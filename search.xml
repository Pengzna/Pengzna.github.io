<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>About &amp; 博客维护日志</title>
      <link href="/article/Blog-building-log/"/>
      <url>/article/Blog-building-log/</url>
      
        <content type="html"><![CDATA[<p>彭俊植，本科毕业于南京大学，清华大学软件学院研究生在读。对分布式数据系统、工具&amp;代码&amp;体系结构层面的性能优化比较感兴趣，Apache IoTDB Committer、Apache HugeGraph Committer。</p><div align="center"><img src=https://img12.360buyimg.com/ddimg/jfs/t1/205592/38/11526/1148329/616c41eaEa542980b/a42d6ab6bb99f65b.jpg width="90%" height="auto" align="center"/></div><div align="center" style="font-size: 30px; font-weight: bold; margin-top: 30px"></div><h2 id="2023-11-16"><a href="#2023-11-16" class="headerlink" title="2023.11.16"></a>2023.11.16</h2><p>参考<a href="https://zhuanlan.zhihu.com/p/113433230">这篇文章</a>，将网站托管在 <a href="https://link.zhihu.com/?target=https://zeit.co/">zeit.co</a> 上。好处有两个：</p><ol><li><a href="https://link.zhihu.com/?target=https://zeit.co/">zeit.co</a> 在亚洲美洲都有 cdn，加快网站访问速度</li><li>解决百度爬虫无法爬取 github 的问题，让百度也能搜到博客</li></ol><p>按照步骤，首先在 Vercel 部署网站，随后按要求修改 cdn</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116180542764.png" alt="image-20231116180542764"></p><p>修改后 Vercel 会自动部署并解析，完成重定向</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116180459803.png" alt="image-20231116180459803"></p><p>注意设置 Vercel 提供的二级域名重定向到自定义域名，避免分散 SEO 权重问题。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116183306643.png" alt="image-20231116183306643"></p><p>完成部署后如图所示，可以正常访问 <a href="https://www.pengzna.top/">https://www.pengzna.top</a></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116181512845.png" alt="image-20231116181512845"></p><p>部署成功后验证下：百度站长平台上，博客能够被百度爬虫抓取了</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116201033122.png" alt="image-20231116201033122"></p><h2 id="2023-11-15"><a href="#2023-11-15" class="headerlink" title="2023.11.15"></a>2023.11.15</h2><p>❗️重大更新</p><p>🐦了两年的博客终于更新了！由于个人审美的变化、前端水平的长进，以前的主题不再适合我，因此我决定另起炉灶。</p><p><strong>我的需求：</strong></p><ol><li>简洁，不要花里胡哨的</li><li>良好支持 markdown</li><li>文章流阅读体验良好</li><li>代码可读性高，遵循软件工程规范，方便我魔改🫣</li></ol><p>精挑细选，最终决定使用 <a href="https://github.com/leedom92/hexo-theme-leedom">leedom</a> 作为新主题，<strong>理由有四</strong></p><ol><li>简洁</li><li>js、css 代码完善，可定制化空间大</li><li>markdown 渲染效果令人满意</li><li><a href="https://blog.evanyou.me/">尤雨溪</a>同款😝</li></ol><p>同时，为了满足个人需求，<strong>我做了如下改进</strong>：</p><ol><li><p>将字体改为 <a href="https://tonyxu.io/blog/recommending-lxgw-font/">霞飞文楷</a>。这也是我目前 typora 所在用的字体，非常舒服。</p></li><li><p>调整了首页标题、footer、右侧搜索栏的位置&#x2F;大小等 css。</p></li></ol><p>博客也有<strong>美中不足</strong>：</p><ol><li>markdown 缺少目录</li><li>缺少 About 页面，因此我只能在博文里介绍自己</li></ol><p>不过总体瑕不掩瑜～ 后续有空琢磨琢磨怎么魔改🤕</p><h2 id="2021-10-14"><a href="#2021-10-14" class="headerlink" title="2021.10.14"></a>2021.10.14</h2><blockquote><p>现在看到这，只想说： <strong>典。</strong></p></blockquote><ul><li>多次尝试配置基于 gitment 的评论功能，失败<ul><li>卡在无法登录 GitHub 账号进行初始化操作</li><li>Error: Bad credentials</li></ul></li><li>头大</li></ul><div align="center"><img src=https://img12.360buyimg.com/ddimg/jfs/t1/204649/38/11208/214683/6167fdd3E46302051/0af3c7b67f672e8d.png /></div><h2 id="2021-10-13"><a href="#2021-10-13" class="headerlink" title="2021.10.13"></a>2021.10.13</h2><ul><li>修改网站图标</li></ul><h2 id="2021-10-10"><a href="#2021-10-10" class="headerlink" title="2021.10.10"></a>2021.10.10</h2><ul><li><p>完成“随笔”、“生活”标签栏配置</p><ul><li>要用 hexo new page &lt;&gt; 命令来创建新 menu 单</li><li>在 yilia-plus 主题里，新 menu 单并不是一个独立的页面，而是通过博客的 tag 完成自动分类配置</li></ul></li><li><p>添加 Nanyi 友链</p></li><li><p>购买域名 <a href="http://www.pengzna.top/">www.pengzna.top</a> ，并将其绑定到 GitHub Page 上</p></li><li><div align="center"><img src="https://img13.360buyimg.com/ddimg/jfs/t1/196861/13/12355/1365619/6162c9f6Effa90e15/97b35eeeb602b55f.png" alt="图片替换文本" width="90%" height="auto" align="center" /></div></li></ul><h2 id="2021-10-09"><a href="#2021-10-09" class="headerlink" title="2021.10.09"></a>2021.10.09</h2><ul><li>最终决定采用 yilia-plus 主题</li><li>完成头像、关于我、GitHub&#x2F;知乎&#x2F;bilibili 等配置</li><li>踩了个坑，在 blog 根目录修改 _config.yilia-plus.yml 配置文件虽然会生效，但是会和 themes 目录下的 _config.yml 配置文件冲突</li><li>又踩了个坑，直接修改 html、css 文件在 hexo g 是没用的，因为 hexo g 会自动生成静态网页代码覆盖原有修改</li><li>博客大体搭建完成</li></ul><h2 id="2021-08-29-2021-09-13"><a href="#2021-08-29-2021-09-13" class="headerlink" title="2021.08.29 - 2021.09.13"></a>2021.08.29 - 2021.09.13</h2><ul><li>尝试搭配主题（下按时间顺序列出）<ul><li>fluid</li><li>yilia</li><li>butterfly</li><li>yilia-plus</li></ul></li></ul><h2 id="2021-08-28"><a href="#2021-08-28" class="headerlink" title="2021.08.28"></a>2021.08.28</h2><ul><li>参考教程和大佬博客，配置 hexo</li><li>将 hexo 博客部署到 [GitHub Page](<a href="https://github.com/Pengzna/Pengzna.github.io">Pengzna&#x2F;Pengzna.github.io: My personal blog</a>) 上</li><li>发表第一篇博客《Peng’s Hello World!》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 维护日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memory-management</title>
      <link href="/article/memory-management/"/>
      <url>/article/memory-management/</url>
      
        <content type="html"><![CDATA[<p>笔者在 2024 年有幸参与了 Apache HugeGraph 的内存管理工作，从 0 到 1 搭建了 Apache HugeGraph 对于 Query 的内存管控。</p><p>对于一个 Java base 的系统，堆内存全部是由 JVM 以及 GC 进行管控。本项目的难点和亮点在于，在 JVM 的框架下对内存进行灵活的分配、去配以及监控管理，实现更加个性化、精细化的内存调控。</p><p>具体来说，Apache HugeGraph 的 Query 链路可能有极大的负载，导致某些时间窗口内，内存使用压力极大。</p><ul><li>如果使用堆内存，依赖 JVM 进行管控的话极易因为 Full GC 造成不可控的 stw 从而影响所有链路的业务。<ul><li>我们希望减少 Full GC 的影响，并且即使内存不足，也不要 stw 影响全部链路的业务。可以通过暂时 hang 某一条链路从而保证其他业务的正常进行。</li></ul></li><li>使用 JVM 原生的内存管控框架无法实现细粒度的内存调控<ul><li>我们希望对于各种细粒度的内存分配、去配都能白盒管理，并辅助对全局业务流进行调配，从而保证系统的稳步运行而不是卡死。</li></ul></li></ul><p>为了解决上述问题，我基于堆外内存、零拷贝序列化、树形层次式内存管理架构等角度提出了解决方案，并合入了 Apache HugeGraph 的主分支。</p><p>本文档为中文版，原版文档可以参考：<a href="https://github.com/apache/incubator-hugegraph/wiki/%5BMemory-Management%5D-GSoC-2024-Final-Report">https://github.com/apache/incubator-hugegraph/wiki/%5BMemory-Management%5D-GSoC-2024-Final-Report</a></p><h2 id="Project-Overview"><a href="#Project-Overview" class="headerlink" title="Project Overview"></a>Project Overview</h2><p>To reduce request latency and response time jitter, the hugegraph-server graph query，engine has already used off-heap memory in most OLTP algorithms. However, at present, hugegraph cannot control memory based on a single request Query, so a Query may exhaust the memory of the entire process and cause OOM, or even cause the service to be unable to respond to other requests. Need to implement a memory management module based on a single Query.</p><p>Key goals includes:</p><ul><li>Implement a <strong>unified memory manager</strong>, independently manage JVM off-heap memory, and adapt the memory allocation methods of various native collections, so that the memory mainly used by the algorithm comes from the unified memory pool, and it is returned to the memory pool after release.</li><li>Each request corresponds to a unified memory manager, and the memory usage of a request can be controlled by counting the memory usage of a request.</li><li>Complete related <strong>unit tests UT</strong> and basic documentation.</li></ul><h2 id="Feature-Implemented"><a href="#Feature-Implemented" class="headerlink" title="Feature Implemented"></a>Feature Implemented</h2><h3 id="Feature1-Hierarchical-Memory-Allocation"><a href="#Feature1-Hierarchical-Memory-Allocation" class="headerlink" title="Feature1: Hierarchical Memory Allocation"></a>Feature1: Hierarchical Memory Allocation</h3><h4 id="Design："><a href="#Design：" class="headerlink" title="Design："></a>Design：</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20241030174412113.png" alt="image-20241030174412113"></p><ul><li><p>如上图所示，对于不同层次的执行组件，我们分配不同层次的 MemoryPool(MemoryContext)，分别对应管理。</p><ul><li><p><strong>每个</strong> <strong>Query</strong> 对应一个 <strong>QueryMemoryPool</strong></p></li><li><p>一个 Query 派生出的<strong>每个 Task（每个线程）</strong>，对应一个 <strong>TaskMemoryPool</strong></p></li><li><p>一个 Task 使用的<strong>每个 Operator（如 HG 中的各种迭代器）</strong>，对应一个 <strong>OperatorMemoryPool</strong></p></li><li><p>MemoryManager 管理所有的 MemoryPool</p></li><li><p><strong>生命周期相近</strong>的对象尽量放在一个 MemoryContext 里，访问的时候不跨物理内存，释放时一起释放</p></li></ul></li></ul><p>通过这种方式，我们可以实现对每个查询任务的内存实际使用量的精细追踪，精确到运算符级别。这样，对于全局的内存使用和控制便能达到最佳效果。</p><p>以上三种 MemoryPool 可以组成一个 MemoryPool<strong>Tree</strong>，根节点是 MemoryManager，叶子节点是 OperatorPool</p><ul><li><p>真正需要使用内存的是<strong>叶子节点</strong> <strong>OperatorPool</strong></p></li><li><p>上层的 TaskPool 和 QueryPool 本质上不申请使用内存，它们作为<strong>聚合池</strong>，把底层叶子节点的使用情况聚合起来。并且作为管理子池的生命周期。</p></li></ul><p>内存池的<strong>生命周期</strong>：</p><ul><li><p>QueryMemoryPool：每个 query 请求入口处创建，如 http query 请求。query 结束时 release，并释放对应内存</p></li><li><p>TaskMemoryPool：每当 Submit 一个新线程任务时创建，如 Executor.submit(() -&gt; doSomething())。线程任务结束时 release，并释放对应内存</p></li><li><p>OperatorMemoryPool：每当创建一个 Iterator 时创建，不主动 release，只有当上层的 TaskMemoryPool release 时触发自己的释放。</p></li></ul><h4 id="Effect："><a href="#Effect：" class="headerlink" title="Effect："></a>Effect：</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20241031205631529.png" alt="image-20241031205631529"></p><h3 id="Feature2：按需内存分配"><a href="#Feature2：按需内存分配" class="headerlink" title="Feature2：按需内存分配"></a>Feature2：按需内存分配</h3><h4 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h4><p>所有的内存分配请求都由叶子节点 OperatorPool 发起，向上传递使用量，<strong>自底向上</strong>传递到 QueryMemoryPool</p><ol><li>由 QueryMemoryPool 处统一消耗 MemoryManager 的内存。</li><li>QueryMemoryPool 有容量限制，如果容量不够，会向 MemoryManager 申请内存</li><li>先进行逻辑申请内存 requestMemory 操作，再进行真实物理分配 allocate。request 逻辑完成后，MemoryManager 和 Pool 中的各统计信息就会发生改变。</li></ol><p>如果 QueryMemoryPool 的内存足够，会返回分配结果，分配结果<strong>自顶向下</strong>逐层返回到叶子结点</p><ol><li><p>如果 QueryMemoryPool 的内存不够，会向根节点 MemoryManager 请求一次内存仲裁</p></li><li><p>每次分配的内存采用「预留」策略，借助量化机制，减少申请次数。如果申请的 size：</p><ol><li><p>&lt; 16MB，按照 1MB 的粒度向上取整</p></li><li><p>&lt; 64MB，按照 4MB 的粒度向上取整</p></li><li><p>&gt;&#x3D; 64MB，按照 8MB 的粒度向上取整</p></li></ol></li></ol><p>在每个 MemoryPool 中，都有一个容量（capacity）的概念，即每个池的最大容量是多少，当前已申请的容量是多少，以及当前所有的叶子节点在根池中获取的保留容量是多少。</p><ol><li>例如，某个 leaf pool 需要申请新的内存，它将从绿色部分的容量中获取。若此容量不足，则需增长其容量以向右移。如果此时全局内存容量还是不够，会触发内存仲裁</li></ol><p>   <img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20241030174738768.png"></p><p>   内存仲裁的主要职责是管理所有 query 的可用容量，并在查询间进行仲裁。</p><ul><li>决定将哪个查询，或查询中的哪个算子闲置的容量归还于该查询或算子</li><li>又或是通过 spill 技术，将bi操作符中使用的容量，使用的状态数据进行溢出处理后，将溢出的容量还回给查询。</li></ul><p>一次内存仲裁是由某次内存分配请求触发的</p><ul><li>如果内存分配请求到达 QueryPool 时发现内存不足，MemoryManager 会触发一次内存仲裁</li><li>内存仲裁<strong>本质上是一次内存回收，它将决定回收哪些查询的内存，以及怎么回收</strong></li><li>假设已经选定了回收某个 Query 的内存，内存回收请求会<strong>自顶向下</strong>传递，直到叶子节点</li></ul><ol><li>LocalArbitration</li></ol><p>假设 QueryA 的 OperatorA 触发了一次仲裁，Local 策略只会回收 QueryA 内部的其他 Operator 闲置内存。</p><p>如 QueryA 下面的 OperatorA 需要内存，则会把 QueryA 内除了 OperatorA 的 free 内存都回收掉，分配给 OperatorA</p><ol start="2"><li>GlobalArbitration</li></ol><p>假设 QueryA 触发了一次仲裁，Local 策略会尝试回收其他 Query 的闲置内存</p><ul><li>过程同上</li><li>选择除了 QueryA 之外的某次 Query、比如 QueryB 进行回收<ul><li>选择策略：Query 根据 free 内存大小进行排序，会选择 free 内存最大的 Query 进行回收</li><li>默认回收策略：只回收 free 部分的内存</li></ul></li></ul><h3 id="Feature3：-并发安全与-OOM-Handle-Strategy"><a href="#Feature3：-并发安全与-OOM-Handle-Strategy" class="headerlink" title="Feature3： 并发安全与 OOM Handle Strategy"></a>Feature3： 并发安全与 OOM Handle Strategy</h3><h4 id="Design：-1"><a href="#Design：-1" class="headerlink" title="Design："></a>Design：</h4><p>如果某次 Operator 请求分配内存，<strong>经过一次内存仲裁之后仍然内存不够，抛出</strong> <strong>OOM</strong> <strong>异常（自己定制的），中断本次查询任务（Abort 自己）</strong>，释放所有内存。</p><p><strong>要求：对于同一个 pool，内存仲裁、内存分配、内存去配三者都是串行，不允许两两并行。</strong></p><ul><li>内存仲裁时不允许分配或去配内存，因为内存仲裁的过程中要保证 Pool 的<strong>内存状态不可变</strong>。即内存仲裁时需要<strong>暂停</strong> <strong>Query</strong>（不允许分配内存、去配内存）<ul><li>该“暂停”不需要真正的暂停，因为我们只需要内存状态不变即可，不需要执行状态不变。</li><li>通过打标志位实现，发生仲裁后打上标记。</li><li>该 pool 如果后续在申请内存、释放内存时发现打上了标记，会在 condition wait（如此能实现 query 任务“暂停”的效果）。直到仲裁结束后唤醒（signal）</li></ul></li><li>申请内存时，和内存仲裁共享一把锁，以保证内存仲裁和内存分配是串行的（不会并发）</li><li>内存池释放时，不允许和其他过程并发（分配、仲裁）<ul><li>去配内存时，打上 closed 标记。不允许其他过程与 release 并发进行</li></ul></li></ul><h4 id="Effect：-1"><a href="#Effect：-1" class="headerlink" title="Effect："></a>Effect：</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20241031210033733.png" alt="image-20241031210033733"></p><h3 id="Feature4：-核心数据结构堆外改造"><a href="#Feature4：-核心数据结构堆外改造" class="headerlink" title="Feature4： 核心数据结构堆外改造"></a>Feature4： 核心数据结构堆外改造</h3><h4 id="Design：-2"><a href="#Design：-2" class="headerlink" title="Design："></a>Design：</h4><p>   <strong>启发：</strong>观察了 dump 出来的文件，发现 90%以上的查询内存占用在：label、property、edge 和 vertex 上。查询过程的<strong>内存占用集中在少数、不可变、拥有大量实例的 class 上</strong></p><p>   内容：不把数据结构对象全改造成堆外的，还是让数据结构对象保持在堆内，只把其中内存占用大、不可变的某些成员变量，比如 label（本质上是个 int）存在堆外，然后内存管理框架管理这部分堆外内存</p><ul><li>这些不可变的成员变量用堆外管理方便实现<strong>零拷贝读写</strong></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20241031210243918.png" alt="image-20241031210243918"></p><ol><li>找出所有可以改造的【内存占用大】且【不可变】对象，提供从堆外直接访问读取的 <strong>API</strong></li></ol><ul><li>Object[]：主要内存占用来自于 HugeEdge 的 List，只要解决 HugeEdge 的改造即可</li><li>HugeVertex：主要内存占用来自于 HugeEdge 的 List，只要解决 HugeEdge 的改造即可</li><li>HugeEdge：<ul><li>一部分来自于 id 的内存占用<ul><li>IdGenerator.Id：已完成改造</li></ul></li><li>一部分来自于 IntObjectMap，该部分为可变的，无法改造</li></ul></li><li>label：本质上就是 Id，只要完成了 Id 的改造即可</li><li>HugeProperty：本质上是 value，将 value 存到堆外即可</li></ul><p>   <strong>实现：</strong> <a href="https://github.com/apache/incubator-hugegraph/pull/2649/files#diff-50dacfc16cd10c17e66ac7254d7464b9c43218cd3a63f0b9a8782b149222c357">https://github.com/apache/incubator-hugegraph/pull/2649/files#diff-50dacfc16cd10c17e66ac7254d7464b9c43218cd3a63f0b9a8782b149222c357</a></p><ul><li>实现了 Factory，使用 Factory 替换所有 new 上述对象的地方。</li><li>Factory 的接口和原来 new 保持一致。</li><li>Factory 内部根据用户设置的 memory_mode，选择构造原来的堆内版本对象还是构造堆外对象。</li></ul><h4 id="Effect：-2"><a href="#Effect：-2" class="headerlink" title="Effect：   "></a>Effect：   <img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20241030175040503.png" alt="image-20241030175040503"></h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Raft + RocksDB 架构及其在 Apache Hugegraph 分布式存储中的运用</title>
      <link href="/article/raft-rocksdb-in-hg/"/>
      <url>/article/raft-rocksdb-in-hg/</url>
      
        <content type="html"><![CDATA[<blockquote><p> RAFT 加 RocksDB 已经逐渐成为分布式 KV 领域的一种普适性架构，通过整合 RAFT log 还有rocksdb 的 WAL 可以在一定程度上降低数据的写放大问题。目前该部署方式的应用场景也比较广泛，耳熟能详的比如 TiKV、NebulaGraph 还有美团的 Cellar，在部署方式的选择上主要是基于 share nothing 架构，其中 RocksDB 充当了 RAFT 状态机的角色。</p></blockquote><p>Apache Hugegraph 今年也在构建分布式架构，其中 store 存储模块基于 Raft + RocksDB 向 Hugegraph Server 提供分布式存储服务，以达到存算分离的目的。</p><p>近期笔者在 Apache Hugegraph 社区做了一次相关分享，以下为脱敏后的内容。</p><h1 id="知识背景"><a href="#知识背景" class="headerlink" title="知识背景"></a>知识背景</h1><h2 id="RocksDB"><a href="#RocksDB" class="headerlink" title="RocksDB"></a>RocksDB</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li><a href="https://github.com/facebook/rocksdb">RocksDB</a> 是 Facebook 开发的一款高性能 C++ KV 存储引擎，底层基于 LSM Tree<strong>，其键值均允许使用二进制流。</strong><ol><li>它的前身是重写自 <a href="https://github.com/google/leveldb">LevelDB</a> (也就是大名鼎鼎的 Google 技术元老 Jeff Dean 在发布 GFS&#x2F;BigTale 后的 C++ 实现)</li><li>Rocksdb <a href="https://github.com/facebook/rocksdb/wiki">官方 WIK</a>I 算是最好的参考资料之一, 对核心特性都有比较好的解读</li></ol></li><li><a href="https://github.com/facebook/rocksdb/wiki/RocksJava-Basics">RocksJava</a> 是为了给 RocksDB 构建一个高性能，但是易用的 java 驱动的工程, 它由 3 层构成：<ol><li>org.rocksdb 包里面的 Java 类，构成 RocksJava API。Java 用户只会直接接触到这一层。</li><li>C++ 的 JNI 代码，提供 Java API 和 RocksDB 之间的链接。</li><li>C++ 层的 RocksDB 本身，并且编译成了一个 native 库，被 JNI 层使用。</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.rocksdb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocksdbjni<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>RocksJava 生成的文件</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164704333.png" alt="image-20240401164704333"></p><ul><li>xxx.log：(日志) WAL 文件</li><li>xxx.sst：数据文件</li><li>CURRENT：是一个特殊的文件，用于声明最新的manifest日志文件</li><li>IDENTITY：id</li><li>LOCK：无内容，open 时创建，表示一个 db 在一个进程中只能被 open 一次，多线程共用此实例</li><li>LOG：(主)统计日志</li><li>MANIFEST：指一个独立的日志文件，它包含 RocksDB 的状态快照&#x2F;版本</li><li>OPTIONS：配置信息</li></ul><h3 id="经典术语"><a href="#经典术语" class="headerlink" title="经典术语"></a>经典术语</h3><blockquote><p>理解经典定义不只是帮我们理解 LSM 的设计, 更是帮我们理解从内存 -&gt; 磁盘, 从逻辑-&gt;物理视图上, 为何要引入这些概念, 更好的理解和传统 B-Tree 的区别</p></blockquote><ol><li><strong>Column Family（列族）</strong></li></ol><p>在 RocksDB 3.0，增加了 Column Families 的支持。可以简单理解为：<strong>CF 约等于我们熟悉的 Table</strong></p><p>RocksDB 的每个键值对都与唯一一个列族（column family）结合。如果没有指定 Column Family，<strong>键值对将会结合到“default” 列族。</strong>RocksDB 在开启 WAL 的时候保证即使crash，列族的数据也能保持一致性。通过 WriteBatch API，还可以实现跨列族的原子操作。</p><p>列族提供了一种从逻辑上给数据库分片的方法。它的一些有趣的特性包括：</p><ul><li>支持跨列族原子写。意味着你可以原子执行Write({cf1, key1, value1}, {cf2, key2, value2})。</li><li>跨列族的一致性视图。</li><li>允许对不同的列族进行不同的配置</li><li>即时添加／删除列族。两个操作都是非常快的。</li></ul><p>简单的说，不同的列族是共享 WAL 的（从而保证跨列族原子写），但是 memtable 和 SSTable 是隔离的。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164714015.png" alt="image-20240401164714015"></p><ol start="2"><li><strong>Column (列)</strong></li></ol><ul><li>传统的「列存」和「行存」<ul><li>行存（常用于 OLTP）对应左边，列存（常用于 OLAP）对应右边</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164728893.png" alt="image-20240401164728893"></p><ul><li>以 Hbase 为例，虽然它的官网写着：<em>HBase is a</em> column-oriented <em>database management system。</em>但是 RocksDB&#x2F;Hbase 其实不是上述的「列存」，以 Hbase 为例：</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164739729.png" alt="image-20240401164739729"></p><p>假如有这么一张 HBase 表，它的底层存储大概是这样的：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164749235.png" alt="image-20240401164749235"></p><p>从上图可以看出：</p><ul><li>不同的列族存在不同的文件中（上面两个表格代表不同的 HFile）；</li><li>整个数据是按照 Rowkey 进行字典排序的；</li><li>每一列数据在底层 HFile 中是以 KV 形式存储的；</li><li>相同的一行数据中，如果列族也一样，那么这些数据是顺序放在一起的。</li></ul><p>到这里大家应该可以看到，<strong>HBase 其实不是列式数据库</strong>，因为同一行数据，如果列族也一样，这些数据是存储在相邻位置的；这和上面的列式存储不太一样。所以说，HBase 既不像行式存储，又不像列式存储。它其实更像是面向列族的存储数据库，因为不同行相同的列族数据是相邻存储的；而同一行不同列族的数据是存储在不同位置的。</p><p><strong>RocksDB 同理，我们可以直接看 RocksDB 底层的 SSTable 结构：</strong>（SSTable 的概念可以参考 ddia 第三章：<a href="https://vonng.gitbooks.io/ddia-cn/content/ch3.html%EF%BC%89">https://vonng.gitbooks.io/ddia-cn/content/ch3.html）</a></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164802092.png" alt="image-20240401164802092"></p><p>重点看一下 Data Block：data block <strong>顺序存储</strong> key&#x2F;value，对于单个 block 会保存5个数值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">  varint sharedKeyLength;</span><br><span class="line">  varint unsharedKeyLength;</span><br><span class="line">  varint valueLength;</span><br><span class="line">  byte[] unsharedKeyContent;</span><br><span class="line">  byte[] valueContent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataBlock</span> &#123;</span><br><span class="line">  Entry[] entries;</span><br><span class="line">  int32 [] restartPointOffsets;</span><br><span class="line">  int32 restartPointCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一部分 Entry 用来存储 key-value 数据。由于 sstable 中所有的 key-value 对都是<strong>严格按序存储</strong>的，用了节省存储空间，并不会为每一对 key-value 对都存储完整的 key 值，而是存储与上一个 key 非共享的部分，避免了 key 重复内容的存储。比如  “the car” 和 “the color” 相同的部分 “the“，为了节省空间，那么 key+1 开始，只记录key 不同的部分，例如：”olor”</li><li><a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/d6ce3593a69e">一个Entry分为5部分内容：</a><ul><li>与前一条记录 key 共享部分的长度，为 0 则表示该 Entry 是一个重启点；</li><li>与前一条记录 key 不共享部分的长度；</li><li>value 长度；</li><li>与前一条记录 key 非共享的内容；</li><li>value 内容</li></ul></li></ul><p>可以看出 RocksDB 也是以 key 为基准进行有序存储的 KV 引擎，至于「列族」概念，只是逻辑上的划分，并不意味着它们真的是列存数据库。</p><ol start="3"><li><strong>Snapshot（快照）</strong></li></ol><p>一个快照会捕获在创建的时间点的 DB 的一致性视图。快照在 DB 重启之后将消失。</p><ol start="4"><li><strong>Iterator（迭代器）</strong></li></ol><p>RocksDB 迭代器允许用户以一个排序好的顺序向后或者向前遍历 db。它还拥有查找 DB 中的一个特定 key 的功能，为此，迭代器需要以一个排序好的流来访问 DB。</p><ul><li>而 RocksDB 数据库中的所有数据都是逻辑上排好序的。应用可以指定一种键值压缩算法来对键值排序。</li></ul><p>如果 ReadOptions.snapshot 被给出，那么迭代器会从一个快照里面返回数据。如果这是一个nullptr，迭代器隐式创建一个迭代器创建的时间节点的快照。该隐式快照会通过<a href="https://wanghenshui.github.io/rocksdb-doc-cn/doc/Iterator.html">固定资源</a>来提供数据。隐式快照无法转换为显式快照。</p><ol start="5"><li><strong>Compaction（压缩）&amp;&amp; flush</strong></li></ol><p>Compaction 是将一些 SST 文件合并成另外一些 SST 文件的后台任务。</p><p>Flush 是将 memtable 的数据写入 SST 文件的后台任务。</p><ul><li>可以手动调用；compaction 是较重的操作，在某些负载较重的场景，会提前 compaction，减轻负载<ul><li>比如业务低峰期，会集中 compaction</li><li>进阶：Remote compaction，存算分离</li></ul></li></ul><h3 id="典型-API"><a href="#典型-API" class="headerlink" title="典型 API"></a>典型 API</h3><p>键值对的数据都是按照二进制处理的。键值都没有长度的限制。</p><ul><li><code>Put</code> 可以将一个键值对写入数据库。如果该键值已经存在于数据库内，之前的数据会被覆盖。</li><li><code>WriteBatch</code> 可以将多个操作原子地写入数据库。<ul><li>比如 hg 中利用 writeBatch 的原子性，封装为 <code>SessionOperatorImpl.commit</code></li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164836771.png" alt="image-20240401164836771"></p><ul><li><code>Get</code>允许应用从数据库里面提取一个键值对的数据。</li><li><code>MultiGet</code> 允许应用一次从数据库获取一批数据。使用<code>MultiGet</code>获取的所有数据保证相互之间的一致性（版本相同）。</li><li><code>Iterator</code> API 允许对 database 做 RangeScan。Iterator 可以指定一个 key，然后应用程序就可以从这个 key 开始做扫描。Iterator API 还可以用来对数据库内已有的 key 生成一个预留的迭代器。一个在指定时间的一致性的数据库视图会在 Iterator 创建的时候被生成。所以，通过 Iterator 返回的所有键值都是来自一个一致的数据库视图的。</li><li><code>Snapshot</code> API 允许应用创建一个指定时间的数据库视图。<code>Get</code>，<code>Iterator</code>接口可以用于读取一个指定snapshot 数据。当然，<code>Snapshot</code>和<code>Iterator</code>都提供一个指定时间的数据库视图，但是他们的内部实现不同。<code>Snapshot</code>在数据库重启过程不能保持存在：reload RocksDB 会释放所有之前创建好的 snapshot。</li></ul><h3 id="有趣的事实"><a href="#有趣的事实" class="headerlink" title="有趣的事实"></a>有趣的事实</h3><blockquote><p>RocksDB 从使用层的角度来说，难点在于：open 时要传入的 option 对象可配置的太多了，就连 rocksdb 开发者都没有给出一个完美的调优方案，只是给出了一系列调优参考值，建议的是在不同的应用场景中通过压测来进行参数调优。github上的调优参考链接如下：<a href="https://github.com/facebook/rocksdb/wiki/RocksDB-Tuning-Guide">https://github.com/facebook/rocksdb/wiki/RocksDB-Tuning-Guide</a></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164846804.png" alt="image-20240401164846804"></p><p>此图为上面链接的文档中最后一段，可见 rocksdb 调优是多么复杂的一件事。</p></blockquote><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>此处进行了本地演示，大体为展示 multiGet、put、writeBatch 等 API</p><h2 id="Raft-JRaft"><a href="#Raft-JRaft" class="headerlink" title="Raft&#x2F;JRaft"></a>Raft&#x2F;JRaft</h2><p>详细了解 Raft 机制可以参考 <a href="https://raft.github.io/raft.pdf">Raft 论文</a></p><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Raft 是一个强一致性的共识算法，用于分布式系统中保持副本间的一致性，核心是日志复制和 leader 选举。</p><p>Client 向复制状态机发送一系列能够在状态机上执行的命令，共识算法负责将这些命令以 Log 的形式复制给其他的状态机，这样不同的状态机只要按照完全一样的顺序来执行这些命令，就能得到一样的输出结果。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164854770.png" alt="image-20240401164854770"></p><p>SOFA-JRaft 是一个基于 <a href="https://link.zhihu.com/?target=https://raft.github.io/">Raft</a> 一致性算法的生产级高性能 Java 实现，支持 MULTI-RAFT-GROUP，适用于高负载低延迟的场景。 (也可以理解为一个 <a href="https://github.com/brpc/braft">braft</a> 的 Java 实现 - 见官方 README)</p><p>上述状态机模型应用到 JRaft，大致架构如下：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164905202.png" alt="image-20240401164905202"></p><p>因为 Raft 中，通常选举或写入需要半数以上副本同意，所以 RaftGroup 只允许半数以下的副本故障，也就是说 5 副本允许 2 个故障，6 个副本也是允许 2 个故障，可见 5 个和 6 个节点的容灾能力是一样的，所以一般来说建议用户配置的副本数量为奇数。</p><p>而对于大部分生产环境，共识组一般就是 3 副本。因此上述架构图可拓展如下：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164922384.png" alt="image-20240401164922384"></p><p>具体可以参考：<a href="https://zhuanlan.zhihu.com/p/59385865">https://zhuanlan.zhihu.com/p/59385865</a></p><h3 id="Multi-Raft"><a href="#Multi-Raft" class="headerlink" title="Multi-Raft"></a>Multi-Raft</h3><p>这里引用 Cockroach ( MultiRaft 的先驱，出来的比 TiDB 早 )对 MultiRaft 的定义：</p><blockquote><p>In <a href="https://github.com/cockroachdb/cockroach">CockroachDB</a>, we use the <a href="https://raftconsensus.github.io/">Raft consensus algorithm</a> to ensure that your data remains consistent even when machines fail. In most systems that use Raft, such as <a href="https://github.com/coreos/etcd">etcd</a> and <a href="https://www.consul.io/">Consul</a>, the entire system is one Raft consensus group. In CockroachDB, however, the data is divided into ranges, each with its own consensus group. This means that each node may be participating in hundreds of thousands of consensus groups. This presents some unique challenges, which we have addressed by introducing a layer on top of Raft that we call <a href="https://github.com/cockroachdb/cockroach/tree/master/multiraft">MultiRaft</a>.</p></blockquote><p>在 CockroachDB 中，我们使用 Raft 一致性算法来确保在机器发生故障时数据也能保持一致。在大多数使用 Raft 的系统中，如 etcd 和 Consul，整个系统只有一个 Raft 共识组。然而，在 CockroachDB 中，数据被分成不同的范围，每个范围都有自己的共识组。这意味着每个节点都可能参与成千上万个共识组。这就提出了一些独特的挑战，我们通过在 Raft 之上引入一层 MultiRaft 来解决这些问题。</p><p>简单来说，MultiRaft 是在整个系统中，把所管理的数据按照一定的方式切片，每一个切片的数据都有自己的副本，这些副本之间的数据使用 Raft 来保证数据的一致性，在全局来看整个系统中同时存在多个 Raft-Group，就像这个样子：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164934312.png" alt="image-20240401164934312"></p><p>单个 Raft group 是无法解决大流量的读写瓶颈的，通过 Multi-Raft 来拓展读写性能是分布式系统的常见做法，JRaft 支持 Multi-Raft 架构，Hg 也采用了 Multi-Raft 架构。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164943032.png" alt="image-20240401164943032"></p><h1 id="HG-分布式存储模型"><a href="#HG-分布式存储模型" class="headerlink" title="HG 分布式存储模型"></a>HG 分布式存储模型</h1><p>从图中可以看到 RaftGroup 和 patition 是一一对应的，patition 是逻辑上的概念，是多个 PartGraph 的集合。</p><p>因为 RaftGroup 是横跨多个服务器节点的，每一个节点就是一个数据分片，也就是 shard，所以 partition 和 shard 是一对多的关系，partition 有几个副本就对应几个 shard。因为一台服务器会有多个 RaftGroup，也就是有多个 shard，而一个图实例对应的是一个 rocksdb 实例，所以 shard 和 store 是多对一的关系。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401165034362.png" alt="image-20240401165034362"></p><p>在代码里面：假设某个 store 实例有 n 个 shard，分别属于 n 个 RaftGroup</p><ul><li>那么该 store 实例将持有 n 个 PartitionEngine（Map&lt;String, PartitionEngine&gt;）</li><li>每个 PartitionEngine 持有该 store 实例，对应 shard 的 RaftNode 引用，同时持有该 Partition 的所有 peer 信息<ul><li>对应 JRaft 的 raftGroupService.start</li></ul></li></ul><p>具体分区哈希算法：详情参考 <a href="https://github.com/apache/incubator-hugegraph/pull/1696">feat(hbase): support hash rowkey struct &amp; pre-init tables (#1696) 035a03e1</a></p><h1 id="Store-模块交互流程概览"><a href="#Store-模块交互流程概览" class="headerlink" title="Store 模块交互流程概览"></a>Store 模块交互流程概览</h1><ol><li>集群整体架构：</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401165043323.png" alt="image-20240401165043323"></p><ul><li>Server 和 store 类似存算分离</li></ul><ol start="2"><li>Store 内部的 request flow</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401145506418.png" alt="image-20240401145506418"></p><h1 id="HG-在-RocksDB-的存储数据结构"><a href="#HG-在-RocksDB-的存储数据结构" class="headerlink" title="HG 在 RocksDB 的存储数据结构"></a>HG 在 RocksDB 的存储数据结构</h1><p>某个 graph 在 RocksDB 的数据存在下列 table（CF-列族）中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Integer&gt; tables = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;() &#123;&#123;</span><br><span class="line">    put(<span class="string">&quot;unknown&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    put(<span class="string">&quot;g+v&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    put(<span class="string">&quot;g+oe&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    put(<span class="string">&quot;g+ie&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    put(<span class="string">&quot;g+index&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    put(<span class="string">&quot;g+task&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    put(<span class="string">&quot;g+olap&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    put(<span class="string">&quot;g+server&quot;</span>, <span class="number">7</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure><p>参考 <code>org.apache.hugegraph.backend.serializer.BinarySerializer</code> ，可以看出 HG 的边点等属性是如何序列化成 RocksDB 的 kv</p><p>以边为例：</p><ul><li>以 partition_Id（基于 id hash 算出来的） + id 作为 key，以边&#x2F;点的具体 lable、properties 作为 value</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以边为例，写 kv 的方法</span></span><br><span class="line"><span class="keyword">public</span> BackendEntry <span class="title function_">writeVertex</span><span class="params">(HugeVertex vertex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (vertex.olap()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.writeOlapVertex(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BinaryBackendEntry</span> <span class="variable">entry</span> <span class="operator">=</span> newBackendEntry(vertex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vertex.removed()) &#123;</span><br><span class="line">        <span class="keyword">return</span> entry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">propsCount</span> <span class="operator">=</span> vertex.sizeOfProperties();</span><br><span class="line">    <span class="type">BytesBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> BytesBuffer.allocate(<span class="number">8</span> + <span class="number">16</span> * propsCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write vertex label</span></span><br><span class="line">    buffer.writeId(vertex.schemaLabel().id());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write all properties of the vertex</span></span><br><span class="line">    <span class="built_in">this</span>.formatProperties(vertex.getProperties(), buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write vertex expired time if needed</span></span><br><span class="line">    <span class="keyword">if</span> (vertex.hasTtl()) &#123;</span><br><span class="line">        entry.ttl(vertex.ttl());</span><br><span class="line">        <span class="built_in">this</span>.formatExpiredTime(vertex.expiredTime(), buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key</span></span><br><span class="line">    <span class="type">byte</span>[] name = <span class="built_in">this</span>.keyWithIdPrefix ?</span><br><span class="line">                  entry.id().asBytes() : BytesBuffer.BYTES_EMPTY;</span><br><span class="line">    <span class="comment">// value</span></span><br><span class="line">    entry.column(name, buffer.bytes());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写 key 的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writePartitionedId</span><span class="params">(HugeType type, Id id, BytesBuffer buffer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.enablePartition) &#123;</span><br><span class="line">        buffer.writeShort(getPartition(type, id));</span><br><span class="line">        buffer.writeId(id);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer.writeId(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="宏观设计"><a href="#宏观设计" class="headerlink" title="宏观设计"></a>宏观设计</h1><h2 id="Iterator-pattern"><a href="#Iterator-pattern" class="headerlink" title="Iterator pattern"></a>Iterator pattern</h2><p>对于 pd-store 架构，Hg 采用各种 Iterator 来进行数据读取</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401165100005.png" alt="image-20240401165100005"></p><p>理解有两层原因：</p><ol><li>RocksDB 底层后端提供 Iterator 读方式，因此顺水推舟在整个架构中都用 Iterator</li><li>采用 Iterator wrap Iterator 的方式，层层调用，<strong>可以实现类似火山模型的效果</strong> <strong>(向量化&#x2F;批处理模型可算是它的优化版, 也是 HG 之后可在部分查询上改进的思路之一)</strong></li></ol><blockquote><p>火山模型是数据库界已经很成熟的解释计算模型，该计算模型将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树，从根节点到叶子结点自上而下地递归调用 next() 函数。每个 next() 函数处理一个 tuple。</p><p>例如 SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Id, Name, Age, (Age <span class="operator">-</span> <span class="number">30</span>) <span class="operator">*</span> <span class="number">50</span> <span class="keyword">AS</span> BonusFROM PeopleWHERE Age  <span class="number">30</span></span><br></pre></td></tr></table></figure><p>对应火山模型如下：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401165115173.png" alt="image-20240401165115173"></p></blockquote><h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>用于广播、执行类似 AOP 的逻辑，实现一些切面动作</p><ol><li>Store 的状态：当 store 上线时，进行启动动作</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401165125425.png" alt="image-20240401165125425"></p><ol start="2"><li>RaftGroup 的状态</li></ol><p>RaftStateListener：监听 RaftGroup 的 leader change 等信息</p><ol start="3"><li>Replicator（JRaft 用于复制日志的组件）的状态</li></ol><p>ReplicatorStateListener：在状态改变时检查是否有 changeShard 任务</p><ol start="4"><li>RocksDB 的状态</li></ol><p>RocksDBChangeListener：compaction 等动作</p><ol start="5"><li>Partition 的状态</li></ol><p>PartitionChangedListener：用于在 change 的时候由 leader 通知其他 follower</p><h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h2><p>类似闭包，实际用起来像 go defer 或 AOP，定义在结束某个活动时执行的动作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">engine.addRaftTask(request.getGraphName(), request.getPartitionId(),</span><br><span class="line">                   RaftOperation.create(op, request), <span class="keyword">new</span> <span class="title class_">RaftClosure</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(com.alipay.sofa.jraft.Status status)</span> &#123;</span><br><span class="line">                <span class="type">Status</span> <span class="variable">responseStatus</span> <span class="operator">=</span> Status.UNKNOWN;</span><br><span class="line">                <span class="keyword">switch</span> (HgRaftError.forNumber(status.getCode())) &#123;</span><br><span class="line">                    <span class="keyword">case</span> OK:</span><br><span class="line">                        responseStatus = Status.OK;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NOT_LEADER:</span><br><span class="line">                        responseStatus = Status.LEADER_REDIRECT;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NOT_LOCAL:</span><br><span class="line">                        responseStatus = Status.NO_PARTITION;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> WAIT_LEADER_TIMEOUT:</span><br><span class="line">                        responseStatus = Status.WAIT_LEADER_TIMEOUT;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        responseStatus.setMsg(status.getErrorMsg());</span><br><span class="line">                &#125;</span><br><span class="line">                response.setStatus(responseStatus);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLeaderChanged</span><span class="params">(Integer partId, Long storeId)</span> &#123;</span><br><span class="line">                RaftClosure.<span class="built_in">super</span>.onLeaderChanged(partId, storeId);</span><br><span class="line">                response.addPartitionLeader(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">HgCmdBase</span>.BaseResponse.PartitionLeader(partId, storeId));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>需要注意的是：JRaft 还使用 closure 来标识是否是 leader </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApply</span><span class="params">(Iterator inter)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (inter.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RaftClosureAdapter</span> <span class="variable">done</span> <span class="operator">=</span> (RaftClosureAdapter) inter.done();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (RaftTaskHandler taskHandler : taskHandlers) &#123;</span><br><span class="line">                <span class="keyword">if</span> (done != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Leader分支，本地调用</span></span><br><span class="line">                    <span class="keyword">if</span> (taskHandler.invoke(groupId, done.op.getOp(), done.op.getReq(),</span><br><span class="line">                                           done.closure)) &#123;</span><br><span class="line">                        done.run(Status.OK());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (taskHandler.invoke(groupId, inter.getData().array(), <span class="literal">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;&#123;&#125;&quot;</span>, Base64.getEncoder().encode(inter.getData().array()));</span><br><span class="line">            LOG.error(<span class="string">&quot;StateMachine&#123;&#125; meet critical error: .&quot;</span>, groupId, t);</span><br><span class="line">            <span class="keyword">if</span> (done != <span class="literal">null</span>) &#123;</span><br><span class="line">                LOG.error(<span class="string">&quot;StateMachine meet critical error: op = &#123;&#125; &#123;&#125;.&quot;</span>, done.op.getOp(),</span><br><span class="line">                          done.op.getReq());</span><br><span class="line">                <span class="comment">//    done.run(new Status(RaftError.EINTERNAL, t.getMessage()));</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        committedIndex = inter.getIndex();</span><br><span class="line"></span><br><span class="line">        stateListeners.forEach(listener -&gt; &#123;</span><br><span class="line">            listener.onDataCommitted(committedIndex);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 清理数据</span></span><br><span class="line">        <span class="keyword">if</span> (done != <span class="literal">null</span>) &#123;</span><br><span class="line">            done.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历下一条</span></span><br><span class="line">        inter.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="心跳保活（with-TTL）"><a href="#心跳保活（with-TTL）" class="headerlink" title="心跳保活（with TTL）"></a>心跳保活（with TTL）</h2><p>HgStoreEngine 中，store 实例会定期向 pd 发送心跳。</p><p>Store 的设计中，处处可见状态机思想：store 实例被设定为了四种状态，根据不同的状态，心跳会有不同的动作</p><ul><li>Unknown</li><li>Offline<ul><li>重新向 pd 注册，先拿 id，如果集群 ready，注册之，然后监听 partition 的消息（重启）</li></ul></li><li>Online<ul><li>与 pd 心跳，更新 storeInfo</li><li>根据拿到的 cluster 信息，检查 cluster 是否异常（保活）</li></ul></li><li>Tombstone（死亡）<ul><li>什么也不做</li></ul></li></ul><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><ol><li>分布式架构原生保证一定的容错</li><li>store 定期与 pd 心跳，同步元信息（伴有 TTL 保活），而 Pd 利用 RocksDB 将元信息持久化，保证了重启恢复。</li><li>store 实例之间的副本同步过程，借助 JRaft 组件保证了重启恢复。 </li><li>store 的 meta info（无论是 pd 还是 store）都借助 RocksDB 进行持久化，防止节点宕机信息丢失（存储在专门的图 hgstore-metadata 下）</li></ol><h1 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h1><ol><li>并发执行：不多赘述</li><li>异步任务：如 AsyncRPC</li><li>上下文用 Byte 对象传输，减少序列化开销：如 RaftOperation</li></ol><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ol><li><a href="https://blog.csdn.net/weixin_44607611/article/details/113742388">https://blog.csdn.net/weixin_44607611/article/details/113742388</a></li><li><a href="https://cloud.tencent.com/developer/article/1785028">https://cloud.tencent.com/developer/article/1785028</a></li><li><a href="https://blog.csdn.net/penriver/article/details/117559188">https://blog.csdn.net/penriver/article/details/117559188</a></li><li><a href="https://wanghenshui.github.io/rocksdb-doc-cn/">https://wanghenshui.github.io/rocksdb-doc-cn/</a></li><li><a href="https://github.com/facebook/rocksdb/blob/master/java/samples/src/main/java/RocksDBSample.java">https://github.com/facebook/rocksdb/blob/master/java/samples/src/main/java/RocksDBSample.java</a></li><li><a href="https://zhuanlan.zhihu.com/p/165399524">https://zhuanlan.zhihu.com/p/165399524</a></li><li><a href="https://zhuanlan.zhihu.com/p/340949657">https://zhuanlan.zhihu.com/p/340949657</a></li><li><a href="https://zhuanlan.zhihu.com/p/145551967">https://zhuanlan.zhihu.com/p/145551967</a></li><li><a href="https://zhuanlan.zhihu.com/p/59385865">https://zhuanlan.zhihu.com/p/59385865</a></li><li><a href="https://zhuanlan.zhihu.com/p/61185934">https://zhuanlan.zhihu.com/p/61185934</a></li><li><a href="https://zhuanlan.zhihu.com/p/478705155">https://zhuanlan.zhihu.com/p/478705155</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次由偏向锁引起的性能下降</title>
      <link href="/article/JVM-biased-lock/"/>
      <url>/article/JVM-biased-lock/</url>
      
        <content type="html"><![CDATA[<p>近期，笔者为 Apache IoTDB 新增了 JVM 的若干优化 options，其中一条是 <code>-XX:-UseBiasedLock</code> 关闭偏向锁（因为偏向锁如今作用有限，JDK15 开始默认废弃；而取消偏向锁时会造成 safepoint 等待的 stw 开销）。然而，合入 pr 后发现若干场景发生了性能下降。</p><p>由于偏向锁是过时且有开销的机制，因此将其关闭后，反而是负优化有点反直觉。第一次遇到这类问题，排查和解决下来都挺有意思的。</p><p>偏向锁简介可以参考：<a href="https://juejin.cn/post/6994404508344270878">https://juejin.cn/post/6994404508344270878</a></p><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>合入 <a href="https://github.com/apache/iotdb/pull/12088/files">https://github.com/apache/iotdb/pull/12088/files</a> 后</p><ol><li>合并导出场景耗时增加</li><li>写入 1C1D、3C3D 场景无变化，3C5D 耗时增加</li></ol><h1 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h1><p>首先和社区同学讨论问题范围：</p><ol><li>写入是跨多个 commit 共同测试（可能其他 commit 是罪魁祸首），但导出合并是明确定位到该 <strong><a href="https://github.com/apache/iotdb/pull/12088/files">pr</a><strong>。</strong>因此接下来着重排查</strong> <strong><a href="https://github.com/apache/iotdb/pull/12088/files">pr</a></strong> <strong>对合并的影响</strong></li><li>测试环境是 JDK11</li></ol><h2 id="初步思考"><a href="#初步思考" class="headerlink" title="初步思考"></a>初步思考</h2><p>感觉会影响查询和合并吞吐的，可能是 <code>-XX:SafepointTimeoutDelay=1000</code> <code>-XX:+SafepointTimeout</code>。这两个参数会在某个线程 Safepoint 超时时，将相关信息打印到标准输出里。可能是在某个时刻 Safepoint 超时的线程太多了，导致标准输出变多，影响了吞吐。</p><p><strong>验证结果</strong>：注释掉上述参数，验证发现还是耗时高，说明罪魁祸首不是它们</p><p><strong>补充验证：</strong>还把 IoTDB 启动脚本完全替换回了 <a href="https://github.com/apache/iotdb/pull/12088/files">pr</a> 修改之前的版本，发现无耗时异常，说明罪魁祸首在 <a href="https://github.com/apache/iotdb/pull/12088/files">pr</a> 里</p><h2 id="再次思考"><a href="#再次思考" class="headerlink" title="再次思考"></a>再次思考</h2><p> <a href="https://github.com/apache/iotdb/pull/12088/files">pr</a> 剩下涉及到的修改只有：</p><ul><li><strong>safepoint 相关优化：</strong>有点黑盒，可能造成耗时增加</li><li><strong>取消偏向锁：</strong>偏向锁理论上已经过时， 取消它并无太多不妥，大多数场景多害少益，且有其他高性能锁作为替代，这也是 JDK15 不支持偏向锁的原因。但是由于它较为黑盒，理论上仍有可能造成耗时增加。</li><li>线程内存从 1M -&gt; 512K：不会对性能有影响，除非 OOM</li><li>GC 开启自适应：不会对性能有那么大的影响，且大部分场景是正优化</li></ul><p><strong>再次验证：</strong>注释掉 safepoint 所有优化，并打开了 safepoint 日志，发现问题仍然存在。</p><p>而且 safepoint 日志显示：safepoint 耗时很少，平均毫秒级，总共 safepoint 耗时才 1s，且 GC 耗时也很少。因此应该不是 safepoint 和 GC 导致的问题。</p><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>联想到社区之前测试机器升级到 JDK17 后，也发生了类似的性能下降（当时笔者从 CPU、GC、内存 等角度，使用火焰图、JMH 等手段都没排查出来是哪里的问题），发现当时的耗时就跟本次开源版高耗时的情况差不多</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401154231858.png" alt="image-20240401154231858"></p><p>联想到本次 PR 内容之一是手动取消偏向锁 -XX:-UseBiasedLock（这里有一个背景是 JDK8、11 有偏向锁，JDK17 无偏向锁）</p><p>而正好之前 JDK17 （无偏向锁）的合并耗时也很高，加上之前的几次实验，已经基本排除了 safepoint 等其他参数的影响，只剩下偏向锁取消和线程内存调整没有验证了，而线程内存调整应该不会影响性能，最多只会 OOM。</p><p>因此推测是偏向锁取消导致的这次问题，但是偏向锁理论上已经过时，大多数场景多害少益，且有其他锁作为替代，这也是 JDK17 不支持偏向锁的原因。</p><p><strong>验证结果：注释掉 -XX:-UseBiasedLock 后，耗时下降，问题消失。说明本次耗时增加是由于取消了偏向锁</strong></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401154251514.png" alt="image-20240401154251514"></p><p>实锤了偏向锁的影响后，笔者还在之前 JDK 升级的测试环境进行验证：</p><p><strong>验证结果：在 JDK17 的环境，手动添加偏向锁 -XX:+UseBiasedLock 后，耗时下降，问题消失。说明当时  JDK 升级后性能下降是由于 JDK17 默认废弃了偏向锁</strong></p><h1 id="问题根因"><a href="#问题根因" class="headerlink" title="问题根因"></a>问题根因</h1><p>引入了 -XX:-UseBiasedLock 取消偏向锁，导致某些场景性能下降。</p><p><a href="https://openjdk.org/jeps/374">https://openjdk.org/jeps/374</a></p><p>根据 openjdk 团队的 note，按理说 biased lock 如今已经是多害少益，且有更完善的锁机制进行替代，也因此 JDK 15 之后，biased lock 就默认关闭了。</p><p>然而在合并等场景，关闭偏向锁后观测到性能下降。</p><ul><li><p>可能是由于如下场景较多：某线程长期持有某临界区资源，反复获取锁、释放锁，且临界区资源的锁竞争较少，导致偏向锁不太需要被取消。</p></li><li><p>因此偏向锁带来少 access 锁的收益大于了取消偏向锁 stw 的开销，总体上是正优化。相反，如果取消偏向锁，线程反复 access 锁的开销较大，带来耗时增加。</p></li></ul><p>社区负责 compaction 的同学后续通过查看代码验证，也找到了代码根因：</p><p>compaction 依赖底层 ByteArrayOutputStream 的读写接口，而 BAOS 的读写接口都是 Synchronized 修饰的同步方法。导致大量级的 Synchronized 拿锁放锁，进而放大了偏向锁的影响。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>虽然 openjdk 声明了偏向锁的弊端，并在 jdk15 废弃之，但根据 IoTDB 的实践，取消偏向锁反而会带来负优化。</p><p>由此看来，openjdk 的观点并不能奉为圭臬。真正废弃偏向锁的原因可能不是偏向锁性能差，可能是难以维护 || 机制复杂 || 行为难以预测等等。</p><p>根据社区老师的指导和建议，软件要尽量控制不可控的因素。既然高版本 JDK 已经移除了偏向锁，那我们就不推荐使用（尽管偏向锁能在 IoTDB 的某些场景有一些优化 ）；对于低版本 JDK 默认使用偏向锁，我们也不会手动 disable</p><p>因此，<strong>我们将移除对偏向锁的默认禁用（-XX:-UseBiasedLock)，对于 JDK15 以上已经默认 disable 偏向锁的高版本 JDK，我们也不会显式使用偏向锁</strong>。因为 JDK 未来可能完全废弃偏向锁，从维护软件稳定性的角度来说，我们只能去适应。</p><h1 id="额外思考"><a href="#额外思考" class="headerlink" title="额外思考"></a>额外思考</h1><p>看八股好像记得 ReentrantLock 的性能比 Synchronized 好，思考：在高版本 JDK（默认关闭偏向锁），ReentrantLock 是否可以作为 Synchronized 的替代。</p><p>ReentrantLock 和 Synchronized 的性能比较，使用 JMH 进行基准测试</p><ul><li>测试代码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 3)</span></span><br><span class="line"><span class="meta">@Fork(1)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 3, time = 1)</span></span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span> <span class="comment">// 测试多线程性能</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockBenchmark</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">frequency</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Benchmark</span></span><br><span class="line">  <span class="meta">@Threads(1)</span> <span class="comment">// 指定一个线程，重入 10000 次</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReentrantLockWithoutCompetition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; frequency; i++) &#123;</span><br><span class="line">      doSomethingWithReentrantLock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Benchmark</span></span><br><span class="line">  <span class="meta">@Threads(1)</span> <span class="comment">// 指定一个线程，重入 10000 次</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSynchronizedWithoutCompetition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; frequency; i++) &#123;</span><br><span class="line">      doSomethingWithSynchronized();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Benchmark</span></span><br><span class="line">  <span class="meta">@Threads(10)</span> <span class="comment">// 指定十个线程</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReentrantLockWithCompetition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (frequency / <span class="number">1000</span>); i++) &#123;</span><br><span class="line">      doSomethingWithReentrantLock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Benchmark</span></span><br><span class="line">  <span class="meta">@Threads(10)</span> <span class="comment">// 指定十个线程</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSynchronizedWithCompetition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (frequency / <span class="number">1000</span>); i++) &#123;</span><br><span class="line">      doSomethingWithSynchronized();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSomethingWithReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    reentrantLock.lock();</span><br><span class="line">    cnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">      cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomethingWithSynchronized</span><span class="params">()</span> &#123;</span><br><span class="line">    cnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">      cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>().include(LockBenchmark.class.getSimpleName()).build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Runner</span>(options).run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果：JDK 1.8 M2 pro 带偏向锁</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Benchmark                                          Mode  Cnt      Score       Error  Units</span><br><span class="line">LockBenchmark.testReentrantLockWithCompetition     avgt    <span class="number">3</span>   <span class="number">1466.112</span> ±  <span class="number">2447.627</span>  ns<span class="operator">/</span>op</span><br><span class="line">LockBenchmark.testReentrantLockWithoutCompetition  avgt    <span class="number">3</span>  <span class="number">84707.382</span> ±  <span class="number">4476.439</span>  ns<span class="operator">/</span>op</span><br><span class="line">LockBenchmark.testSynchronizedWithCompetition      avgt    <span class="number">3</span>   <span class="number">2669.839</span> ±   <span class="number">147.294</span>  ns<span class="operator">/</span>op</span><br><span class="line">LockBenchmark.testSynchronizedWithoutCompetition   avgt    <span class="number">3</span>  <span class="number">52546.483</span> ± <span class="number">37818.714</span>  ns<span class="operator">/</span>op</span><br></pre></td></tr></table></figure><ul><li>结果：JDK 1.8 M2 pro 不带偏向锁</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Benchmark                                          Mode  Cnt      Score      Error  Units</span><br><span class="line">LockBenchmark.testReentrantLockWithCompetition     avgt    <span class="number">3</span>   <span class="number">1421.258</span> ± <span class="number">1710.012</span>  ns<span class="operator">/</span>op</span><br><span class="line">LockBenchmark.testReentrantLockWithoutCompetition  avgt    <span class="number">3</span>  <span class="number">83813.692</span> ± <span class="number">6111.888</span>  ns<span class="operator">/</span>op</span><br><span class="line">LockBenchmark.testSynchronizedWithCompetition      avgt    <span class="number">3</span>   <span class="number">3421.783</span> ± <span class="number">1129.167</span>  ns<span class="operator">/</span>op</span><br><span class="line">LockBenchmark.testSynchronizedWithoutCompetition   avgt    <span class="number">3</span>  <span class="number">50313.866</span> ± <span class="number">1219.218</span>  ns<span class="operator">/</span>op</span><br></pre></td></tr></table></figure><p>结论： 在单线程不断重入，无锁竞争的情况下，Synchronized 无论是否开启偏向锁性能都优于 ReentrantLock。看来八股也不是准的 23333</p><p>后续有时间考虑详细学习一下各类锁的实现，并用 Benchmark 测试性能</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GC 视角下的代码优化——如何写出&quot;GC 友好&quot;的代码</title>
      <link href="/article/GC-prefered-coding/"/>
      <url>/article/GC-prefered-coding/</url>
      
        <content type="html"><![CDATA[<p>广义上的 GC 调优，通常是指通过 JVM options 参数进行调优。然而，除了调参，我们更应该注意结合 GC 的知识，从代码上就写的对 GC 友好，从而”未雨绸缪“，防患于未然。因此，总结一些代码经验十分有必要。</p><p>结合笔者前期对 GC 的系统调研，以及笔者和 Apache IoTDB 社区同学的代码实践，参考网络大神资料，总结一些 ”GC 友好“代码 tips。</p><h2 id="复用对象：池化"><a href="#复用对象：池化" class="headerlink" title="复用对象：池化"></a>复用对象：池化</h2><p>为了减少对象分配开销，提高性能、同时尽量减少对象的创建销毁，减小 GC 压力，可以采取对象池的方式来缓存对象集合，作为复用的手段。</p><p><strong>但是无脑池化，可能效果有限，因为：</strong></p><ol><li>对于对象本身：</li></ol><blockquote><p>如果对象很小，那么分配的开销本来就小，对象池只会增加代码复杂度。</p><p>如果对象比较大，那么晋升到 Old Generation 后，对 GC 的压力就更大了。</p></blockquote><ol><li>从线程安全的角度考虑，通常池都是会被并发访问的，那么同步带来的开销，未必比重新创建一个对象小。（除非池本身的实现很优秀，比如通过 CAS 等手段尽可能减小了同步开销）</li><li>对象池中的对象由于在运行期长期存活，大部分会晋升到 Old Generation，因此无法通过 YoungGC 回收。</li></ol><p><strong>因此对于池化，需要注意两点：</strong></p><ol><li>合适的场景才池化：即<strong>当池中的每个对象的创建、回收开销较大</strong>时，缓存复用才有意义，例如每次 new 都会创建一个连接，或是依赖一次 RPC。<ol><li>如线程池、RPC client 池、TCP 连接池、数据库 session 池等</li></ol></li><li>最好引入定时对象清理（KeepAliveTime）机制：清理池子中长时间不用的长活对象，释放资源。否则可能导致老年代空间被堆积占用。</li></ol><blockquote><p>IoTDB 在 clientManager 已经对池化对象的定时清理有过实践：使用 <code>org.apache.commons.pool2</code> 的 <code>KeyedObjectPool</code>，并设置定时驱逐参数即可。</p><p>JDK 原生的线程池之所以引入 KeepLiveTime 定时清理闲置线程也是同样的道理。</p></blockquote><p><strong>案例</strong>：IoTDB 社区同学对大 Text 写入场景的 Byte[] 对象进行了池化，获得了较好的收益。</p><h2 id="善用各类引用"><a href="#善用各类引用" class="headerlink" title="善用各类引用"></a>善用各类引用</h2><p><code>java.lang.ref.Reference</code>有几个子类，用于处理和 GC 相关的引用。JVM 的引用类型简单来说有几种：</p><ul><li><p><strong>Strong Reference</strong>，只要强引用存在，GC 将永远不会回收被引用的对象，哪怕内存不足时，JVM 也会直接抛出 <code>OutOfMemoryError</code>，不会去回收。如果想中断强引用与对象之间的联系，可以显式的将强引用赋值为 null。</p></li><li><p><strong>Soft Reference</strong>，在内存足够的时候，软引用对象不会被回收，只当临近 OOM 时，系统才会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出OutOfMemoryError。<strong>这种特性常常被用来实现缓存</strong>。</p></li><li><p><strong>Weak Reference</strong>，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。</p></li></ul><blockquote><p>在 Java 集合中有一种特殊的 Map 类型：WeakHashMap， 在这种 Map 中存放了键对象的弱引用，当一个键对象被垃圾回收，那么相应的值对象的引用会从 Map 中删除。WeakHashMap 能够节约存储空间，可用来缓存那些非必须存在的数据。</p><p>当实现缓存时，可以考虑优先使用<code>WeakHashMap</code>，而不是<code>HashMap</code>，当然，更好的选择是使用框架，例如 Guava Cache。</p></blockquote><ul><li><strong>Phantom Reference</strong>，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。主要用于识别对象被 GC 的时机，通常用于做一些清理工作，实际代码开发用的不多</li></ul><p>以上的这些未必可以对代码有多少性能上的提升，但是熟悉这些方法，是为了帮助我们写出更卓越的代码，和 GC 更好地合作。</p><h2 id="指定容器初始化大小"><a href="#指定容器初始化大小" class="headerlink" title="指定容器初始化大小"></a>指定容器初始化大小</h2><p>Java 容器的一个特点就是可以动态扩展，所以通常我们都不会去考虑初始大小的设置，容器会自动扩容。</p><p>但是扩容意味着代价，例如一些基于数组的数据结构：<code>StringBuilder</code>、<code>StringBuffer</code>、<code>ArrayList</code>、<code>HashMap</code>等，在扩容的时候都需要做 ArrayCopy，对于不断增长的结构来说，经过若干次扩容，会存在大量无用的老数组，而回收这些数组的压力，全都会加在 GC 身上。</p><p>这些容器的构造函数中通常都有一个可以指定大小的参数，<strong>如果对于某些大小可以预估的容器，建议加上这个参数。</strong></p><blockquote><p>如果采用默认无参构造函数，创建一个 ArrayList，不断增加元素直到 OOM，那么在此过程中会导致：</p><ul><li>多次数组扩容，重新分配更大空间的数组</li><li>多次数组拷贝</li><li>内存碎片（压力会最终给到 GC）</li></ul></blockquote><h2 id="手动把对象置-null？"><a href="#手动把对象置-null？" class="headerlink" title="手动把对象置 null？"></a>手动把对象置 null？</h2><p><strong>大部分情况下没有作用</strong>，JVM 会帮我们分析出不可达的对象并自动回收，JIT Compiler 会自动分析 local 变量的生命周期。此举使得代码的可读性下降了不少。</p><p><strong>以下几种有限的情况可能需要手动处理：</strong></p><ol><li>某个巨大的常驻内存的集合缓存对象，里面某些数据在业务完成后必须要手动释放，否则该集合对象可能会越来越大。</li><li>某个对象生命周期较长，比如它在一个巨大的方法体内，或它横跨了多个方法的调用栈，被一直引用，在业务不需要的时候将其引用及时置为 null，可以帮助 GC 提前释放掉该对象的内存。在内存占用达到瓶颈时可以优化 GC。</li></ol><p><strong>案例：</strong>在 IoTDB 的 InsertRecord 接口里，对 request 里业务不需要的序列化数据提前置 null，让 GC 提前释放这部分内存，有助于降低内存占用的峰值，在内存比较紧张的极端瓶颈场景下（GC time 占比 30%+）有效减轻了 GC 压力</p><h2 id="异常时在-cath-或-finally-回收资源"><a href="#异常时在-cath-或-finally-回收资源" class="headerlink" title="异常时在 cath{} 或 finally{} 回收资源"></a>异常时在 cath{} 或 finally{} 回收资源</h2><p>异常处理的 catch 模块或者 finally 模块中资源释放的代码是必须的，如果异常时没有在 catch{} 或 finally{} 中释放某些资源（如 close 文件等），可能会造成对象资源的长期占用。</p><h2 id="不要手动挡：System-gc-以及-finalize"><a href="#不要手动挡：System-gc-以及-finalize" class="headerlink" title="不要手动挡：System.gc() 以及 finalize()"></a>不要手动挡：System.gc() 以及 finalize()</h2><p>在某些高级组件的高级功能中可能会调用这两个方法，平时我们的编码中基本上用不上，所以还是让 JVM 自己去处理吧。</p><ol><li>System.gc() 会触发 FGC，相当于自杀。</li><li>重写 finalize() 的对象不会被  GC 回收，直到 finalize() 被执行，即使它已经成为「垃圾对象」。因此 finalize() 不善用的话容易产生对象堆积。</li></ol><blockquote><p>NOTE：除非是在对代码非常熟悉的情况下，手动 System.gc 来释放堆外内存，否则平时不建议手动 System.gc</p></blockquote><h2 id="缩小对象作用域"><a href="#缩小对象作用域" class="headerlink" title="缩小对象作用域"></a>缩小对象作用域</h2><p>尽可能缩小对象的作用域，即生命周期。</p><blockquote><p>如果可以在方法内声明的局部变量，就不要声明为实例变量。</p><p>除非你的对象是单例的或不变的，否则尽可能少地声明 static 变量。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM GC 调优方法论与系统总结</title>
      <link href="/article/JVM-GC-Tuning/"/>
      <url>/article/JVM-GC-Tuning/</url>
      
        <content type="html"><![CDATA[<p>此文是笔者对于 GC 系列调研的收尾。本次工作全面总结了 PS、G1 等常见 GC 的工作原理、可调参数，解析了 GC 日志读法、可观测手段，还从延迟、吞吐两个角度分别总结了调优方法论。内容覆盖从 GC 基本知识、观测手段、日志解析到调优方法，完成了 GC 诊断、定位、调优的全链路调研解析。</p><p>文章大量参考互联网资料，感谢！</p><h1 id="基本原理与介绍"><a href="#基本原理与介绍" class="headerlink" title="基本原理与介绍"></a>基本原理与介绍</h1><p><strong>基础知识1：</strong>对于 GC，无论其具体实现和策略，都有标记-清除、复制、标记-整理等<strong>基本算法，</strong>只是不同的 GC 使用不同的基本算法。此处不再赘述，详细可以参考往期博客</p><p><strong>基础知识2：</strong>对于大部分 GC，都会对堆内存进行分代划分，可以参考往期博客。对于更详细的 java 内存划分概念，同样可以参考往期博客</p><p><strong>基础知识3：</strong>对于 GC，在 footprint（内存占用）、throughout（吞吐）、latency（延迟）三者不可能同时满足。<strong>最多三者满足其二</strong>。（类似 CAP 定理）</p><blockquote><p>吞吐量跟低延时是无法兼得的，低延时意味着GC工作会更加频繁，相对的，会占用应用的资源，吞吐量降低。需要大吞吐量，那么GC工作就会减少，相对的，每次回收的垃圾就会多，暂停时间就会增加，延时就会增加。</p></blockquote><p>我们经常遇到的情况是高吞吐的 GC 单次 stw 时间较长；而 stw 优秀的 GC 往往 GC 频率高、占用线程资源多，导致吞吐低。因此我们调优需要<strong>有的放矢，</strong>一般是针对吞吐和延迟分别调优，而不是同时追求吞吐和延迟。</p><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p>在 jdk 7 才推出，9 中正式作为默认 GC ，注重停顿时间。</p><p>本文主要从 <a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html">oracle 官网文档</a>和<a href="https://dl.acm.org/doi/pdf/10.1145/1029873.1029879"> G1 的论文</a>进行宏观上的调研。</p><h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><p><strong>【摘自官网】</strong></p><p>G1 垃圾收集器是一个服务端的垃圾收集器，它针对的是<strong>拥有较大内存</strong>的<strong>多处理器</strong>的机器。</p><ul><li>它既满足了暂停时间比较短的高性能，又满足吞吐量比较高的目标。</li></ul><p>G1 垃圾收集器是在 Oracle 的 JDK7 update 4 及以后的版本得到了完全的支持。G1 垃圾收集器是针对这样的应用来进行设计的：</p><ul><li>能够像 CMS 收集器一样跟应用线程并发的去执行。【CMS 本身就是一个并发的收集器，也就是GC线程与应用线程可以同时间执行】</li><li>可以压缩可用的空间，而不会让 GC 引起暂停时间过长。</li><li>需要更多的可预测的 GC 暂停的间隔。【也就是说 GC 暂停的时间会尽量往我们设置的暂时时间来靠】</li><li>不想牺牲大量吞吐性能。</li><li>不想需要大量 Java 的堆空间。</li></ul><p>Oracle 官方说明：如果应用程序具有以下一个或多个特征，则当前使用 CMS 或 PS 运行的应用程序将有利于切换到 G1：</p><ul><li>Full GC 持续时间太长或太频繁。</li><li>对象分配率或提升率波动很大。</li><li>不需要的长时间垃圾收集或压缩暂停（超过 0.5 到 1 秒）</li></ul><p><strong>【笔者经验总结】</strong></p><p>也就是说，G1 是一款相对通用，在 footprint（内存占用）、throughout（吞吐）、latency（延迟）三者达成一个较好平衡的回收器，<strong>相对更侧重</strong> <strong>latency（延迟，或者我们常说的暂停时间）的优化。相比于</strong> <strong>PS，G1 的 FGC 将显著减少。</strong></p><p>因此 G1 不经过调优，实测在 IoTDB 的某些场景下，吞吐等指标不如 PS 等侧重优化吞吐的 GC </p><blockquote><p>补充：CMS 被废弃的原因有部分原因是源于 G1 更可控、更易于维护、在大多数场景下有更好的表现。</p><p>参考：<a href="https://openjdk.org/jeps/291">https://openjdk.org/jeps/291</a></p></blockquote><blockquote><p><a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html">Oracle 官网</a>专门提到：G1 的吞吐量目标是 90% 应用 + 10% GC，而 PS 是 99% 应用 + 1% GC。因此 G1 的吞吐肯定是不如 PS 的，但是 G1 的 stw 表现比 PS 更优秀。</p></blockquote><h3 id="G1-内存模型"><a href="#G1-内存模型" class="headerlink" title="G1 内存模型"></a>G1 内存模型</h3><p>一般的 GC （像 serial、PS、CMS）采用分代内存模型，如下图：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401161844376.png" alt="image-20240401161844376"></p><p>G1 <strong>在内存空间的划分上：</strong>堆被划分了一组相等大小堆区域（region），区域之间可能是<strong>离散</strong>的，但每一个区域都是<strong>连续</strong>虚拟内存的地址空间， 这就提供了内存使用当中最大的灵活性。区域大小由<code>-XX:G1HeapRegionSize</code>决定。一般来说，JVM 大约划分 2000 个 regions，它们的大小范围为 [1, 32] MB</p><p>但是<strong>在概念上</strong>仍采取分代内存的思想，即这些 regions 会分别映射到 eden、survivor、old。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401161859543.png" alt="image-20240401161859543"></p><p>此外，还有一种上图没标出的 region，称为巨型区域（huge region）。 这些区域用于容纳尺寸为标准区域 50% 或更大的对象，它们存储为一组连续的区域。 </p><h3 id="G1-的-GC-过程"><a href="#G1-的-GC-过程" class="headerlink" title="G1 的 GC 过程"></a>G1 的 GC 过程</h3><h4 id="年轻代收集"><a href="#年轻代收集" class="headerlink" title="年轻代收集"></a>年轻代收集</h4><p>在 YGC（Young GC） 中，live objects 被搬运（evacuated，即复制或移动）到一个或多个 survivor 区域。 如果满足老化阈值，则某些对象将被提升到老一代区域。YGC 将 stw 。</p><ul><li>注意 Eden 大小和 Survivor 大小是为下一次 YGC 计算的。 相关信息会被保留以帮助计算大小。 诸如暂停时间目标（<code>-XX:MaxGCPauseMillis</code>）之类的事情都会被考虑在内。这种方法可以根据需要放大或缩小 Eden 和 Survivor 的大小。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401161917881.png" alt="image-20240401161917881"></p><p>在 YGC 的末尾，live objects 已被搬运到幸存者区域或晋升到老年代区域。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401161929260.png" alt="image-20240401161929260"></p><p>综上所述：</p><ul><li>堆是划分为多个区域的单个内存空间。</li><li>年轻代内存由一组不连续的区域组成。<strong>这使得在需要时可以轻松调整大小</strong>。</li><li>YGC 是 stw 的事件。 所有应用程序线程都会因该操作而停止。</li><li>YGC 使用多个线程并行完成。</li><li>活动对象被复制到新的幸存者或老一代区域。</li></ul><h4 id="老年代收集"><a href="#老年代收集" class="headerlink" title="老年代收集"></a>老年代收集</h4><p>G1 收集器在堆的老年代执行以下阶段。 </p><ul><li>请注意，某些阶段是 YGC 的一部分（因为 G1 的实现里面，由 YGC 触发 mixed GC &#x2F; full GC）</li><li>Mixed GC 是 G1 特有的回收策略，在回收年轻代之余，还会回收部分收益较高的老年代区域</li></ul><table><thead><tr><th><strong>阶段</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>(1) Initial Mark <em>(Stop the World Event)</em></td><td>这是一个 stw 事件。 对于 G1，它搭载在正常的 YGC 上。 标记可能引用老年代区域对象的 survivor 区域（根区域）。</td></tr><tr><td>(2) Root Region Scanning</td><td>扫描 survivor 区域以获取对老年代的引用。当应用程序继续运行时会发生这种情况。该阶段必须在 YGC 之前完成。</td></tr><tr><td>(3) Concurrent Marking</td><td>在整个堆上查找 live objects。 这发生在应用程序运行时。此阶段可能会被 YGC 中断。</td></tr><tr><td>(4) Remark <em>(Stop the World Event)</em></td><td>完成堆中存 live objects 的标记。使用称为开始快照 (SATB) 的算法，该算法比 CMS 收集器中使用的算法快得多。</td></tr><tr><td>(5) Cleanup <em>(Stop the World Event and</em> <em>Concurrent</em><em>)</em></td><td>（stw）对 live objects 和完全空闲的 region 执行 accounting（这个词不知道咋翻译）（stw）刷洗 remembered sets。 （concurrent）重置空 region 并将它们返回到 freelist。</td></tr><tr><td>(*) Copying <em>(Stop the World Event)</em></td><td>该阶段将 stw 以搬运或将活动对象复制到新的未使用 regions。 这可以通过日志记录为<code>[GC pause (young)]</code>的年轻代区域，或者记录为<code>[GC Pause (mixed)]</code>的年轻代和老年代区域来完成。</td></tr></tbody></table><p>接下来看看这些 phase 是如何和 G1 的老年代交互的</p><ol><li><strong>Initial Marking Phase</strong></li></ol><p>活动对象的初始标记是在 YGC 的基础上进行的。 在日志中，这被标记为 <code>GC pause (young)(inital-mark).</code></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401162004224.png" alt="image-20240401162004224"></p><ol start="2"><li><strong>Concurrent</strong> <strong>Marking Phase</strong></li></ol><p>如果发现空区域（如“X”所示），则在 marking 阶段立即将其删除。 此外，还计算确定 liveness 的“accounting”信息。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401162019150.png" alt="image-20240401162019150"></p><ol start="3"><li><strong>Remark Phase</strong></li></ol><p>空区域被删除并回收。 所有区域的 liveness 将被计算</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401162032792.png" alt="image-20240401162032792"></p><ol start="4"><li><strong>Copying&#x2F;Cleanup Phase</strong></li></ol><p>G1 选择“liveness”最低的区域，即可以最快收集的区域。 然后这些区域会与 YGC 同时收集。 这在日志中表示为  [GC pause (mixed)]。 所以年轻代和老年代都会同时被收集。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401162043900.png" alt="image-20240401162043900"></p><ol start="5"><li><strong>After Copying&#x2F;Cleanup Phase</strong></li></ol><p>所选区域已被收集并压缩为图中所示的深蓝色区域和深绿色区域。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401162055015.png" alt="image-20240401162055015"></p><p>综上所述，关于老年代的 G1 垃圾回收：</p><ul><li>Concurrent Marking Phase<ul><li>Liveness 信息是在应用程序运行时同时计算的。</li><li>此 liveness 信息可识别在疏散暂停期间最适合回收的区域。</li><li>没有像 CMS 那样的清理阶段。</li></ul></li><li>Remark Phase<ul><li>使用<strong>开始快照 (SATB)</strong> 算法，该算法比 CMS 所使用的算法（增量更新）快得多。<ul><li><strong>详细介绍：</strong>对于对象关系的扫描处理（GC root 扫描），JVM 使用「三色标记算法」。然而，对于该算法，在用户线程和 GC 线程并发的情况下，存在漏标情况。CMS 和 G1 分别对漏标问题有不同的解决方案。<ul><li>CMS 对增加引用环节进行处理（Increment Update），G1 则对删除引用环节进行处理 (SATB）</li></ul></li><li>SATB 算法的机制是：在三色扫描时，如果用户线程断开灰色对象 A 到白色对象B 的引用，会通过写屏障机制记录当前对象状态的快照。然后在 Remark phase 中将 B 改为灰色，重新扫描一遍<ul><li>由于 RSet 的存在，且对象 B 在对象引用链中的深度一般较大，遍历链的扫描开销较小</li></ul></li><li>CMS 的增量更新机制是：当黑色对象要增加指向灰色或白色对象的引用关系时，将发出引用的黑色对象改为灰色，重新扫描一遍<ul><li>由于黑色对象在对象引用链中的深度较小，遍历链的深度扫描开销大，所以比 G1 的 SATB 慢</li></ul></li></ul></li><li>完全空的区域被回收。</li></ul></li><li>Copying&#x2F;Cleanup Phase<ul><li>年轻代和老年代同时被回收。</li><li>老年代区域是根据其活跃度来选择的。</li></ul></li></ul><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>JDK 8 的默认 GC，又叫 throughout GC，注重吞吐</p><p>中英文互联网都没搜到特别详实的、原理层次的解析。因此这里主要参考国内 system 领域著名实验室 <a href="https://ipads.se.sjtu.edu.cn/zh/publications/">iPads</a> 的论文中关于 PS 原理的论述。感兴趣的读者也可以直接阅读论文原文：</p><ul><li><a href="https://ipads.se.sjtu.edu.cn/_media/publications/scissorgc-vee2019.pdf">https://ipads.se.sjtu.edu.cn/_media/publications/scissorgc-vee2019.pdf</a></li><li><a href="https://ipads.se.sjtu.edu.cn/_media/publications/yuvee.pdf">https://ipads.se.sjtu.edu.cn/_media/publications/yuvee.pdf</a></li><li><a href="https://ipads.se.sjtu.edu.cn/_media/publications/wuatc20.pdf">https://ipads.se.sjtu.edu.cn/_media/publications/wuatc20.pdf</a></li></ul><h3 id="PS-的-GC-过程"><a href="#PS-的-GC-过程" class="headerlink" title="PS 的 GC 过程"></a>PS 的 GC 过程</h3><p>对于 YGC，PS 基于标记-复制算法（copy-based），论文没有做详细的描述。</p><blockquote><p>大多数对象一开始分配在 eden 区（一些大对象是例外，会直接分配到 old 区）。当 YGC 后，一些对象被移动到 survivor 区，同时一些其他年老的对象被晋升到老年代。</p></blockquote><p>对于 FGC，PS 基于标记-整理算法（compaction-based）</p><p>PS 的 FGC 实现分为三个阶段，包括 marking phase, summary phase, 和 compacting phase。 这三个阶段都是 region-based: PS 将 JVM 堆<strong>划分为相等大小的连续 regions</strong>（默认大小为 512KB），并将相同 region 内的 live objects 一同整理（compact）</p><ul><li>论文给出的 region 代码是：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Region</span> &#123; </span><br><span class="line">    <span class="comment">// Fields in vanilla PSGC</span></span><br><span class="line">    <span class="type">int</span> dcount;</span><br><span class="line">    <span class="type">int</span> live_obj_size;</span><br><span class="line">    <span class="type">char</span>* dest_addr;</span><br><span class="line">    Region*[] src_regions;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>去 <a href="https://github.com/openjdk/jdk8u">openjdk 源码</a>求证了一下，<strong>论文给出的源码应该是简化过的，并不是完整、标准的源码。</strong></p><ul><li>实际对比后，论文的 <code>class Region</code> 应该对应：<a href="https://github.com/openjdk/jdk8u/blob/9c9d6b267c41e4c713cacc41befb66007cdb2601/hotspot/src/share/vm/gc_implementation/parallelScavenge/psParallelCompact.hpp#L236">openjdk - RegionData</a></li></ul></blockquote><p>PS 的 FGC 可以划分为以下三阶段：</p><ol><li><strong>Marking phase：</strong>GC 线程将从已知根（GC roots），例如堆栈引用和静态变量，搜索活动对象。 所有从 GC roots 可达的对象将被标记为活着，并且它们的大小将被添加到特定 region 的 <code>live_obj_size</code> 中。</li><li><strong>Summary phase：</strong>marking phase 结束后，PS 会为所有 region 分别根据它们的 <code>live_obj_size</code> 计算出一个 heap summary。<ol><li>Heap summary 会生成一个 source region 到 destination region 的映射，这样每个 source region 都会有 1~2 个 destination region 用于后续的对象拷贝。这些映射被保存在 <code>src_regions</code> 中。</li><li>Summary phase 也会生成 per-region indices，即 <code>dest_addr</code>，GC 线程可以用它来得到 region 内 live objects的目标地址。</li></ol></li><li><strong>Compacting phase：</strong>Live objects 直到该阶段才会被移动或修改。该阶段是 overhead 最大的，一般占了70% 以上的 FGC 开销。 <ol><li>Compacting phase 仍然是 region-based，每个 destination regions 即代表一个 task，GC 线程将并行地从相应的 source regions 中 fetch live objects 去填充这些 destination regions。在 copy 对象的过程中，引用关系也将被更新。</li><li>由于 destination regions 自身可能也是其他 region 的 source regions（即一个 region 可能既是 destination 又是 source，既要把自己的 live objects 拷贝到其他 region 那里，也要接受其他 region 拷贝过来的 live objects），因此 GC 线程必须等 destination regions 内的所有 live objects 都被搬运（evacuated）到它们的 destinations 后才能开始处理它们。<ul><li><p>该 process order 通过维护一个名为 <code>dcount</code> 或者下图所示 <code>destination_count</code> 的变量来保持。该变量记录了该 region 作为 source，有多少 destination regions。Summary phase 会计算该变量的值。</p></li><li><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401162140442.png" alt="image-20240401162140442"></p></li><li><p>在 Compacting phase，一旦某个 GC 线程 fills up 了一个 destination region，它将相应 update 该 destination region 关联的所有 source region 的 <code>dcount</code>（减1）。当某个 region 的 <code>dcount</code> 减为 0 时，意味着它作为 source region 的职责结束，可以 serve as a destination region 了。该 region 会被 push 到 GC 线程的 working stack 中，并准备好接受其他 source regions 中的 live objects。</p></li></ul></li></ol></li></ol><h3 id="Compact-详细算法"><a href="#Compact-详细算法" class="headerlink" title="Compact 详细算法"></a>Compact 详细算法</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401162113697.png" alt="image-20240401162113697"></p><p>论文提供了 Figure 2 来帮助理解，下面详细解说：</p><ol><li>假设有 6 个 region，从 0 编号到 5；假设有 2 个 GC 线程，从 0 编号到 1</li><li>在 Summary phase。由于 region 0 和 region 2 不包含 live objects，所以它们的 <code>dcount</code> 是 0（因为它们不需要将自己的 live objects 拷贝出去）。而其他 region 都有相应的 destination regions</li><li>当 Compacting phase 开始时，region 0 和 region 2（<code>dcount</code> 为 0 的 regions）会被分配到 GC thread 0、1 的 working stack 中（如 Figure 2.a 所示）</li><li>两个 GC 线程会根据 Summary phase 生成的 per-region indices 将其他 regions 中的 live objects 拷贝到 stack 中对应的 regions（如 Figure 2.a 所示）</li><li>当 region 0 被 thread 0 处理后，region1 的 dcount 会减为 0，这意味着 region1 可以作为 destination region 入栈被 GC 线程处理了。</li><li>由于 region 1 一开始依赖 region 0，并是 region 3、4 的 destination regions。因此它会被 push 到 thread 0 的栈中（如 Figure 2.b 所示）</li><li>相反，当 thread 1 完成 region 2 的处理后，region 5 并不会被 push 到 GC 线程的栈中，因为没有 region 依赖它。</li><li>相似地，当 region 1 的 task 完成后，region 3、4 不会被 push 到 GC 线程的栈中。此时所有的 live objects 都被整理完毕，compacting phase 结束。</li></ol><h2 id="GC-对性能的影响"><a href="#GC-对性能的影响" class="headerlink" title="GC 对性能的影响"></a>GC 对性能的影响</h2><p><strong>受GC影响请求占比&#x3D;(接口响应时间+GC时间)×N&#x2F;T</strong></p><p>举例：假设单位时间T内发生一次持续25ms的GC，接口平均响应时间为50ms，且请求均匀到达，根据下图所示：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401162150663.png" alt="image-20240401162150663"></p><p>那么有 (50ms+25ms)&#x2F;T 比例的请求会受GC影响，其中GC前的 50ms 内到达的请求都会增加 25ms，GC期间的25ms 内到达的请求，会增加 0-25ms 不等，如果时间 T 内发生 N 次GC，<strong>受GC影响请求占比&#x3D;(接口响应时间+GC时间)×N&#x2F;T</strong> 。可见无论降低单次 GC 时间还是降低 GC 次数 N 都可以有效减少 GC 对响应时间的影响。</p><h1 id="JVM-调优参数"><a href="#JVM-调优参数" class="headerlink" title="JVM 调优参数"></a>JVM 调优参数</h1><p>以下参数均来自 oracle JDK 8、11、17 官方文档 GC VM options 板块，本文档实现了对 oracle 官网的全覆盖。</p><p>很多参数背后都有 trade-off。所以 JDK 团队已经为我们选取了最合适的 default 值，大多数情况不需要修改。</p><ul><li>比如说：<code>-XX:InitiatingHeapOccupancyPercent</code>，如果该值过小，比如 Mixed GC 周期结束后老年代使用率还是超过 IHOP，那么会再次触发全局并发标记过程，这样就会导致频繁的老年代 GC，影响应用吞吐量。如果此值太高，会导致老年代回收不及时（容易导致年轻代晋升失败而触发 Full GC） + 老年代一次回收的任务量较重（造成尖刺）</li></ul><h2 id="G1-1"><a href="#G1-1" class="headerlink" title="G1"></a>G1</h2><table><thead><tr><th><strong>JVM</strong> <strong>选项</strong></th><th><strong>类别</strong> （控制哪方面）</th><th><strong>描述</strong></th><th><strong>调优建议</strong></th><th><strong>支持的</strong> <strong>LTS</strong> <strong>version</strong></th></tr></thead><tbody><tr><td>-XX:+UseG1GC</td><td>-</td><td>指定使用 G1 GC</td><td>无</td><td>8、11、17</td></tr><tr><td>-XX:MaxGCPauseMillis（越低延迟越低）</td><td>自适应</td><td>指定最大的 GC pause time。指定的 target 是一个软目标（soft goal），JVM 会用一些机制尽最大努力来达到它。对于 G1，默认值为 200（0.2 秒）</td><td>这是一个软性目标，G1 会尽量达成，如果达不成，会逐渐做自我调整。<strong>该参数是停顿时间和吞吐量的取舍</strong>对于 Young GC 来说，会逐渐减少 Eden 区个数，减少 Eden 空间那么 Young GC 的处理时间就会相应减少；对于 Mixed GC，G1 会调整每次 Choose Cset 的比例，默认最大值是 10%，当然每次选择的 Cset 少了，所要经历的 Mixed GC 的次数会相应增加。同时减少 Eden 的总空间时，就会更加频繁的触发 Young GC，也就是会加快 Mixed GC 的执行频率，因为 Mixed GC 是由Young GC 触发的，或者说借机同时执行的。频繁 GC 会对应用的吞吐量造成影响，每次 Mixed GC 回收时间太短，回收的垃圾量太少，可能最后 GC 的垃圾清理速度赶不上应用产生的速度，那么可能会造成串行的 Full GC，这是要极力避免的。所以暂停时间肯定不是设置的越小越好，当然也不能设置的偏大，转而指望 G1 自己会尽快的处理，这样可能会导致一次全部并发标记后触发的 Mixed GC 次数变少，但每次的时间变长， STW 时间变长，对应用的影响更加明显。该参数与 JVM GC 的自适应调优（<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#ergonomics">GC ergonomics</a>）相关</td><td>8、11、17</td></tr><tr><td>-XX:GCTimeRatio（越高吞吐越高）</td><td>自适应</td><td>参数的值应当是一个大于 0 且小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。<strong>如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1 &#x2F;（1+19））</strong>G1 的默认值为 12，就是允许最大大约 8%（ 1 &#x2F;（1+12））的垃圾收集时间。</td><td>根据需求妥善设置，如果该值设置的过高，那么可能会导致 heap 一直在 minimum 的 size。该参数与 JVM GC 的自适应调优（<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#ergonomics">GC ergonomics</a>）相关</td><td></td></tr><tr><td>-XX:NewRatio</td><td>内存</td><td>young&#x2F;old generation 大小的比例。默认值是 2</td><td>G1 不建议手动设置，原因参考 <a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html">oracle 官网文章</a></td><td>8、11、17</td></tr><tr><td>-XX:SurvivorRatio</td><td>内存</td><td>eden&#x2F;survivor 区大小的比例，默认值是 8</td><td>G1 不建议手动设置，原因参考 <a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html">oracle 官网文章</a></td><td>8、11、17</td></tr><tr><td>-XX:G1ReservePercent</td><td>内存</td><td>G1 会将堆中的某一部分空间预先保留作为虚天花板（false ceiling）来减少晋升失败的情况（晋升失败会导致 FGC），默认值是 10补注：比如默认情况下，老年代会预留 10% 的空间来给新生代的对象晋升，如果经常发生新生代晋升失败而导致 FGC，那么可以适当调高此阈值。但是调高此值同时也意味着降低了老年代的实际可用空间</td><td>如果经常发生新生代晋升失败而导致Full GC，那么可以适当调高此阈值。但是调高此值同时也意味着降低了老年代的实际可用空间官方文档特别提醒：如果增加或减少该参数比例，最好确保同步调整整个 Java heap 的大小</td><td>8、11、17</td></tr><tr><td>-XX:G1HeapRegionSize</td><td>内存</td><td>G1 的内存模型是把 heap 分成一个个 region，该参数指定了 region 的大小。默认值根据 heap size 决定，最小值是 1M，最大值是 32M</td><td>Region的大小主要是关系到Humongous Object的判定，当一个对象超过Region大小的一半时，则为巨型对象，那么其会至少独占一个Region，如果一个放不下，会占用连续的多个Region。当一个Humongous Region放入了一个巨型对象，可能还有不少剩余空间，但是不能用于存放其他对象，这些空间就浪费了。所以如果应用里有很多大小差不多的巨型对象，可以适当调整Region的大小，尽量让他们以普通对象的形式分配，合理利用Region空间。</td><td>8、11、17</td></tr><tr><td>-XX:G1NewSizePercent</td><td>内存</td><td>Young generation 内存大小的下限（以占堆大小的百分比来表示）。默认值是 5%。This is an experimental flag. See “<a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html#Unlock">How to unlock experimental VM flags</a>“ for an example. This setting replaces the <code>-XX:DefaultMinNewGenPercent</code> setting.</td><td>新生代比例有两个数值指定，下限：-XX:G1NewSizePercent，默认值 5%，上限：-XX:G1MaxNewSizePercent，默认值 60%。G1 会根据实际的 GC 情况（主要是暂停时间）来动态的调整新生代的大小，主要是 Eden Region 的个数。最好是 Eden 的空间大一点，毕竟 Young GC 的频率更大，大的 Eden 空间能够降低 Young GC 的发生次数。但是 Mixed GC 是伴随着 Young GC 一起的，如果暂停时间短，那么需要更加频繁的 Young GC，同时也需要平衡好 Mixed GC 中新生代和老年代的 Region，因为新生代的所有 Region 都会被回收，如果 Eden 很大，那么留给老年代回收空间就不多了，最后可能会导致 Full GC。</td><td>11、17</td></tr><tr><td>-XX:G1MaxNewSizePercent</td><td>内存</td><td>Young generation 内存大小的上限（以占堆大小的百分比来表示）。默认值是 60%。This is an experimental flag. See “<a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html#Unlock">How to unlock experimental VM flags</a>“ for an example. This setting replaces the <code>-XX:DefaultMaxNewGenPercent</code> setting. This setting is not available in Java HotSpot VM, build 23.</td><td>见上</td><td>11、17</td></tr><tr><td>-XX:ParallelGCThreads</td><td>效率</td><td>stop-the-world (STW) worker 线程数。该参数将被用作设置 logical processors 数。默认值取决于宿主机 CPU 的核数。</td><td>当 GC 时间过长时，可以尝试调大 GC 工作线程数，但是这也意味着此期间应用所占的线程数减少，会对吞吐量有一定影响。</td><td>8、11、17</td></tr><tr><td>-XX:ConcGCThreads</td><td>效率</td><td>concurrent GC 阶段（即非 STW 阶段）所用到的线程数。根据官方文档，推荐设置为<code>-XX:ParellelGCThreads</code>的四分之一</td><td>该值同样是吞吐和停顿时间的取舍，需要根据实际需求测试调整。</td><td>8、11、17</td></tr><tr><td>-XX:InitiatingHeapOccupancyPercent</td><td>行为&#x2F;时机</td><td>当老年代占用的<strong>整个</strong> heap 的比例达到该值时，开启一个 concurrent GC cycle。默认值是 45%如果为 0，意味着 G1 将不停进行并发 GC，直到 G1 adaptively set this value（17 特性，8、11 没有该特性）</td><td>如果该值过小，比如 Mixed GC 周期结束后老年代使用率还是超过 45%，那么会再次触发全局并发标记过程，这样就会导致频繁的老年代 GC，影响应用吞吐量如果老年代空间不大，Mixed GC 回收的空间偏少。可以适当调高 IHOP 的值如果此值太高，很容易导致年轻代晋升失败而触发 Full GC，所以需要多次调整测试进行取舍</td><td>8、11、17</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>行为&#x2F;时机</td><td>Tenuring 的阈值（补注：一般新生对象经过 15 次 Young GC 会晋升到老年代，巨型对象会直接分配在老年代），除了 CMS 默认值是 6，其他默认值是 15，最大值也是 15</td><td>一般这个值不需要额外调整，但如果观察到对象在达到某个年龄 n 后，不怎么晋升，直到15岁，那么可以适当调小 MaxTenuringThreshold 到 n，以减少 ygc 中复制对象的开销。</td><td>8、11、17</td></tr><tr><td>-XX:G1HeapWastePercent</td><td>行为&#x2F;时机</td><td>开发者可接受浪费的 heap percentage。当可回收（reclaimable）的比例小于该值时，JVM 将不会触发 Mixed GC。默认值是 5%</td><td>在全局标记结束后能够统计出所有 Cset 内可被回收的垃圾占整对的比例值，如果超过 5%，那么就会触发之后的多轮 Mixed GC，如果不超过，那么会在之后的某次 Young GC 中重新执行全局并发标记。可以尝试适当的调高此阈值，能够适当的降低 Mixed GC 的频率。</td><td>11、17</td></tr><tr><td>-XX:G1MixedGCLiveThresholdPercent</td><td>行为&#x2F;时机</td><td>Mixed GC 选择回收 old region 的 occupancy 阈值。在全局并发标记阶段，如果一个 Region 的 live objects 的空间占比低于此值，则会被纳入 Cset。此值直接影响到 Mixed GC 选择回收的区域。11 和 17 的默认值是 85This is an experimental flag. See “<a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html#Unlock">How to unlock experimental VM flags</a>“ for an example. This setting replaces the <code>-XX:G1OldCSetRegionLiveThresholdPercent</code> setting.</td><td>当发现 GC 时间较长时，可以尝试调低此阈值，尽量优先选择回收垃圾占比高的Region，但此举也可能导致垃圾回收的不够彻底，最终触发 Full GC。</td><td>11、17</td></tr><tr><td>-XX:G1OldCSetRegionThresholdPercent</td><td>行为&#x2F;时机</td><td>每轮 Mixed GC 回收的 Region 最大比例。默认值是 10%</td><td>一般这个值不需要额外调整。</td><td>11、17</td></tr><tr><td>-XX:G1MixedGCCountTarget</td><td>行为&#x2F;时机</td><td>回收超过<code>G1MixedGCLIveThresholdPercent</code>的老年代时，最多进行的 mixed gc 次数。默认值是 8，mixed gc 的目标是要控制在此目标次数以内</td><td>在一次全局并发标记后，最多接着 8 次 Mixed GC，即会把全局并发标记阶段生成的 Cset 里的 Region 拆分为最多 8 部分，然后在每轮 Mixed GC 里收集一部分。这个值要和上一个参数配合使用，8*10%&#x3D;80%，应该来说会大于每次标记阶段的 Cset 集合了。一般此参数也不需额外调整。</td><td>11、17</td></tr></tbody></table><h2 id="PS-1"><a href="#PS-1" class="headerlink" title="PS"></a>PS</h2><table><thead><tr><th><strong>JVM</strong> <strong>选项</strong></th><th><strong>类别</strong> （控制哪方面）</th><th><strong>描述</strong></th><th><strong>调优建议</strong></th><th><strong>支持的</strong> <strong>LTS</strong> <strong>version</strong></th></tr></thead><tbody><tr><td>-XX:+UseParallelGC</td><td>-</td><td>使用 PS，JDK 默认使用该参数，use Parallel Scavenge + Parallel Old as a combination.</td><td>无</td><td>8，11，17</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>自适应</td><td>指定最大的 GC pause time。指定的 target 是一个软目标（soft goal），JVM 会用一些机制尽最大努力来达到它。默认不使用它，值为 18446744073709551615可以通过设置来使用它</td><td>同上</td><td>8，11，17</td></tr><tr><td>-XX:GCTimeRatio</td><td>自适应</td><td>参数的值应当是一个大于 0 且小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。<strong>如果把此参数设置为 19，那允许的最大</strong> <strong>GC</strong> <strong>时间就占总时间的 5%（即 1 &#x2F;（1+19））</strong>PS 的默认值为 99，就是允许最大 1%（即 1 &#x2F;（1+99））的垃圾收集时间。</td><td>根据需求妥善设置，如果该值设置的过高，那么可能会导致 heap 一直在 minimum 的 size。该参数与 JVM GC 的自适应调优（<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#ergonomics">GC ergonomics</a>）相关</td><td>8，11，17</td></tr><tr><td>-XX:+UseAdaptiveSizePolicy</td><td>自适应</td><td>一个开关参数，<strong>默认打开</strong>。当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略（<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#ergonomics">GC ergonomics</a>）。</td><td>如果对于收集器运作原来不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx 设置最大堆），然后使用 MaxGCPauseMillis 参数（更关注最大停顿时间）或 GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。</td><td>8，11，17</td></tr><tr><td>-XX:SurvivorRatio</td><td>内存</td><td>Eden 区和 survivor 区大小的比值，默认为 8</td><td>如果大量对象都在一次 YoungGC 后就会回收清理，那么新生代 Eden：From：To 为默认的 8：1：1 就比较合适。如果说很大部分对象的年龄都超过1，即需要在Survivor 的 From, To 中来回转换几次之后才能被回收，那么此时可以适当增大一下 Survivor 区的空间，并且可以将 Survivor 的空间使用率增大，避免对象年龄增长过快，从而被移动到老年代，造成 FullGC</td><td>8，11，17</td></tr><tr><td>-XX:NewRatio</td><td>内存</td><td>young&#x2F;old generation 大小的比例。默认值是 2</td><td>如果 old 区有空余，可以增大 young 区的比例，减少 ygc 的次数，减缓对象晋升的速度。</td><td>8，11，17</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>内存</td><td>直接进入老年代的对象的大小阈值，大于这个值的对象将直接在老年代分配没在 8、11、17 的官方文档上找到该参数的说明，所以没找到默认值是多少。但是实测 8、11、17 均支持该参数</td><td>暂时没搜到相关资料</td><td>8，11，17</td></tr><tr><td>-XX:ParallelGCThreads</td><td>效率</td><td>stop-the-world (STW) worker 线程数。该参数将被用作设置 logical processors 数。默认值取决于宿主机 CPU 的核数。</td><td>当 GC 时间过长时，可以尝试调大 GC 工作线程数，但是这也意味着此期间应用所占的线程数减少，会对吞吐量有一定影响。</td><td>8，11，17</td></tr><tr><td>-XX:+UseNUMA</td><td>效率</td><td>通过增加应用程序对低延迟内存的使用，可以优化具有 NUMA 的计算机上的应用程序的性能。 默认情况下，该选项处于禁用状态，并且不会对 NUMA 进行优化。 该选项仅在使用 PS （-XX:+UseParallelGC）时可用。</td><td>支持 NUMA 可以打开</td><td>8，11，17</td></tr><tr><td>-XX:TargetSurvivorRatio</td><td>行为&#x2F;时机</td><td>该参数设置了 YGC 后，期望 survivor used space 占比多少。根据这篇 <a href="https://www.herongyang.com/Java-GC/Serial-TargetSurvivorRatio-Second-Tenuring-Condition.html">blog</a> 的实验结果，如果 survivor space 的 usage 占比超过了该参数，那么某些 live objects 会被直接晋升到 tenured generation，即使他们的 age 可能还没到 MaxTenuringThreshold。这种现象叫做 premature tenuring (or premature promotion)默认值为 50%</td><td>该参数一定程度上决定了对象的晋升。</td><td>8，11，17</td></tr></tbody></table><h1 id="调优建议"><a href="#调优建议" class="headerlink" title="调优建议"></a>调优建议</h1><p>我们调优的时候，通常从以下事实出发：</p><ol><li><strong>调优目标：</strong></li></ol><ul><li>降低停顿时间（减少 fgc）（常用）</li><li>提高吞吐（减少 gc 次数）（常用）</li><li>降低 footprint 占用</li></ul><ol start="2"><li><strong>根据业务需求进行调优：</strong></li></ol><ul><li>比如对于高并发场景，大多数对象是朝生夕死的，也就是说大部分对象在新生代创建后，还没来得及晋升到老年代就死亡了。这种情况下就需要提高新生代内存，减少 fgc。</li></ul><ol start="3"><li><strong>调优策略</strong></li></ol><p>我们的终极目标是</p><ol><li>减少 ygc、fgc 的次数</li><li>降低 ygc、fgc 的耗时</li></ol><p>首先对于<strong>减少次数</strong>：我们从 GC 的成因拆解。</p><ul><li><strong>ygc</strong> 的成因是新生代的空间不足以容纳对象大小 —— 因此减少 ygc 的次数可以通过增加新生代空间大小实现。常见的做法是分析 old 和 young 的空间大小，如果 old 有盈余，可以适当减少 old，增加 young</li><li><strong>Fgc</strong> 的成因是<ul><li>当新生代的 Eden 区、Survivor 区无法容纳新的对象时，会触发 ygc。如果在 ygc 后仍然没有足够的内存空间分配对象，则会触发 fgc —— 因此这里还是新生代空间大小的问题，可以通过增大新生代空间解决</li><li>当老年代无法容纳新的对象时，会触发 Major GC（老年代垃圾回收）。如果在 Major GC 后仍然没有足够的内存空间分配对象，则会触发 fgc —— 1. 如果是老生代空间大小的问题，可以通过增大老生代空间解决；2. 如果是对象晋升过快的问题，可以调大 survivor 区大小，减缓对象在 from 和 to 区复制转移的速度；或者直接增大新生代空间，以减缓年龄晋升速度；3. 调整代码，尽量减少大对象和对象频繁创建行为</li><li>当元空间的类加载信息、常量池等元数据无法容纳新的数据时，会触发 fgc —— 因此这里是 metapsace 空间大小的问题，可以通过增大 metaspace 空间解决</li></ul></li></ul><p>其次对于<strong>减少耗时</strong>，这里要复杂很多，我们仍然从成因分析：</p><ul><li>Ygc 的一个常见耗时场景：对于 PS、G1 这种标记复制算法的 gc，大多数对象需要在 survivor 区的 from 和 to 复制多次，直到晋升 —— 所以为了减少复制成本，<code>MaxTenuringThreshold</code> 要尽量合理，不能设置太大，否则有些长寿对象在每次 GC 时都会在两个 Survivor 区之间来回复制，无疑是增加了复制阶段的耗时</li><li>GC log 里经常会看到 safe-point  —— 遇到锁竞争时，取消锁的过程需要等待全局安全点（safe point），会导致所有线程暂停，即会发生Stop-The-World。所以在锁竞争激烈的场景下，最好提前关闭掉偏向锁。</li><li>GC 的某个阶段耗时过长（可以从日志看出） —— 1. 调整并行线程、并发线程等参数，增加并行度，优化性能；2. 优化代码，减少大对象创建等；3. 根据实际情况减少该阶段的耗时</li></ul><ol start="4"><li><strong>内存参数基本策略</strong></li></ol><p>各分区的大小对 GC 的性能影响很大。如何将各分区调整到合适的大小，分析活跃数据的大小是很好的切入点。</p><p><strong>活跃数据的大小</strong>是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是 Full GC 后堆中老年代占用空间的大小。可以通过 GC 日志中 Full GC 之后老年代数据大小得出，比较准确的方法是在程序稳定后，多次获取 GC 数据，通过取平均值的方式计算活跃数据的大小。活跃数据和各分区之间的比例关系如下：</p><table><thead><tr><th><strong>内存区域</strong></th><th><strong>推荐设置大小</strong></th></tr></thead><tbody><tr><td>总大小</td><td>3-4 倍活跃数据的大小</td></tr><tr><td>新生代</td><td>1-1.5 活跃数据的大小</td></tr><tr><td>老年代</td><td>2-3 倍活跃数据的大小</td></tr><tr><td>永久代</td><td>1.2-1.5 倍Full GC后的永久代空间占用</td></tr></tbody></table><p>例如，根据GC日志获得老年代的活跃数据大小为300M，那么各分区大小可以设为：</p><p>总堆：1200MB &#x3D; 300MB × 4</p><p>新生代：450MB &#x3D; 300MB × 1.5</p><p>老年代： 750MB &#x3D; 1200MB - 450MB</p><p>这部分设置仅仅是堆大小的初始值，后面的优化中，可能会调整这些值，具体情况取决于应用程序的特性和需求。</p><h2 id="PS-2"><a href="#PS-2" class="headerlink" title="PS"></a>PS</h2><p>Parallel GC会尽量去满足如下目标：（优先级由高到低）</p><ul><li>最大停顿时间目标</li><li>吞吐量目标</li><li>最小移动目标</li></ul><p>对 ParallelGC 的调优，其目标应尽可能避免 Full GC, 这就需要优化对象老年化的频率，</p><p>使用 ParallelGC 时，垃圾收集的资源开销应小于 5%，如果已经减少到 1% 甚至更少，基本上已经达到极限了。</p><h3 id="吞吐优先"><a href="#吞吐优先" class="headerlink" title="吞吐优先"></a>吞吐优先</h3><ol><li><strong>JVM 自适应调优：</strong>宏观目标：<code>-XX:GCTimeRatio=99</code> 。其值为1-100的整数，表示吞吐量，默认值是99，表示允许1%的垃圾回收时间占比。暂停时间越长，那么垃圾回收占用的时间比越大，可能会超过前面的设定比例。</li><li><strong>降低线程资源占用：</strong>根据实际情况适当调小<code>-XX:ParallelGCThreads</code> ，给用户线程让出更多的 CPU 资源</li><li><strong>想方设法降低 GC 频率</strong>（这样可能会导致每次 GC 的 stw 时间变长）：包括调高<code>-XX:MaxGCPauseMills</code>等<ol><li>如果 ygc 频率过高，可以从两个角度考虑：<ol><li>尝试调高 young 区大小，推迟对象堆积的时机</li><li>根据日志：尝试调整晋升年龄，将大部分对象及时晋升，减少在 s 区来回 copy 的开销并占据 young 区</li></ol></li><li>如果 fgc 频率过高，建议根据日志从以下角度考虑调优<ol><li>是否 old 区内存增长速度过快——减缓对象晋升速度<ol><li>可以调整 young 区<ol><li>直接调大 size：<code>-Xmn</code></li><li>调整 young 和 old 的比例 ：<code>-XX:NewRatio</code></li><li>可以调大 survivor 区，减缓对象晋升速度：<code>-XX:SurvivorRatio</code></li></ol></li></ol></li><li>是否 young 区过小，ygc 后仍然没有足够空间——调大 young 区<ol><li>直接调大 size：<code>-Xmn</code></li><li>调整 young 和 old 的比例 ：<code>-XX:NewRatio</code></li></ol></li><li>Meta 区是否过小——调大 Meta 区</li></ol></li></ol></li></ol><h3 id="延迟优先"><a href="#延迟优先" class="headerlink" title="延迟优先"></a>延迟优先</h3><ol><li>宏观目标：<code>-XX:MaxGCPauseMills=&lt;N&gt;</code> ，值大于0的毫秒数。</li><li>新生代（Ygc）调优： 如果发现 GC 频率过高，整体新生代又太小，可以增大新生代的大小，从而降低 YGC 的频率和占用时间。ParallelGC 可以自动调整 Survivor 空间，大部分的程序使用自动调整可以满足要求，个别应用在需要的情况下可以关闭自动调整，进行手动调整。<ol><li><code>-Xmn</code>（设置新生代大小） 、<code>-XX:-UseAdaptiveSizePolicy</code>（关闭自适应调整）</li><li>一般情况下 Eden 区的大小比 Survivor 大很多，如果大量对象都在一次 YoungGC 后就会回收清理，那么新生代 Eden：From：To 为8：1：1就比较合适。如果说很大部分对象的年龄都超过 1，即需要在 Survivor 的 From，To 中来回转换几次之后才能被回收，那么此时可以调小 SurvivorRatio 的值，在整个新生代不变的情况下，会增大 Survivor 区的大小（From 和 To 同时增大）。将 Survivor 的空间使用率增大，避免对象年龄增长过快，从而被移动到老年代，造成 FullGC。<ol><li><code>-XX:SurvivorRatio</code> 可以调整新生代中 Survivor 与 Eden 区的比例，例如 <code>-XX:SurvivorRatio=6</code> 表示S(From) : S(To) : Eden &#x3D; 1: 1: 6 。其默认值为8</li></ol></li></ol></li><li>老年代调优</li><li>并行线程的优化：<code>-XX:ParallelGCThreads=&lt;N&gt;</code>。此参数设置年轻代并行收集器的线程数，一般与 CPU数量相等，过多的线程数量会影响垃圾回收以及整个程序的性能。</li></ol><h2 id="G1-2"><a href="#G1-2" class="headerlink" title="G1"></a>G1</h2><p>无论以延迟还是吞吐为目标，Oracle 官网<strong>不建议</strong>我们<strong>显式</strong>通过<code>-Xmn</code><strong>设置新生代区域大小</strong>（仅管前面 PS 我们提到过这种做法），因为这与 G1 的默认表现相悖：</p><ul><li>设置新生代大小会让 G1 的停顿目标失效</li><li>设置新生代大小会让 G1 失去动态扩缩容新生代的能力</li></ul><h3 id="吞吐优先-1"><a href="#吞吐优先-1" class="headerlink" title="吞吐优先"></a>吞吐优先</h3><p>想达到吞吐目标，建议优先考虑 PS。</p><p>如果想使用 G1 的同时优化吞吐，建议：</p><ol><li><strong>降低线程资源占用：</strong>根据实际情况适当调小<code> -XX:ParallelGCThreads</code> 和<code> -XX:ConcGCThreads</code>，给用户线程让出更多的 CPU 资源</li><li><strong>想方设法降低 GC 频率</strong>（这样可能会导致每次 GC 的 stw 时间变长）：包括调高<code>XX:MaxGCPauseMillis</code>等方法<ol><li>可以参考上文 PS 片段中提到的方法</li><li>此外还可以根据日志观察程序是否有规律大小的大对象。如有，可针对性设置 regionSize，增大内存利用率。</li><li>如果上述方法都效果不大，尤其是在 space-reclaimation 阶段，根据 <a href="https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-70E3F150-B68E-4787-BBF1-F91315AC9AB9">oracle 官网</a>，建议调高 young 区的最小 size<code> -XX:G1NewSizePercent</code> 并调高 young 区的上限 size <code>-XX:G1MaxNewSizePercent</code></li><li>如果 fgc 频率过高，对于 G1，可以适当提高 mixed gc 频率。调整 <code>-XX:G1HeapWastePercent</code>。也可以调整 <code>-XX:InitiatingHeapOccupancyPercent</code>，来提前开启并发标记，用更多的小代价 mixed gc 换取更少的高代价 fgc</li></ol></li><li><strong>降低 concurrent work 的频率</strong>：根据 <a href="https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-70E3F150-B68E-4787-BBF1-F91315AC9AB9">oracle 官网</a>，并发很消耗 cpu 资源。可以调高 <code>-XX:G1RSetUpdatingPauseTimePercent</code>，将并发工作移到 gc pause 中。</li><li><strong>内存调优：</strong><code>-XX:+AlwaysPreTouch</code>，将 <code>-Xmx</code> 和 <code>-Xms</code> 设置为同样的值以禁止堆自动扩缩容</li></ol><h3 id="延迟优先-1"><a href="#延迟优先-1" class="headerlink" title="延迟优先"></a>延迟优先</h3><ol><li><p>根据 oracle 官网的建议，对于延迟我们主要关注 <code>XX:MaxGCPauseMillis=&lt;N&gt;</code>参数，考虑将<code>XX:MaxGCPauseMillis</code> 设置为能满足 90% 场景需求的值。也就是说，90% 的 gc 停顿不超过 <code>XX:MaxGCPauseMillis</code></p></li><li><p>如果我们在日志中看到很多 <strong>Evacuation Failure</strong>，那么可以考虑下面一些方案：</p><ol><li><blockquote><p><strong>What is an Evacuation Failure?</strong></p><p>A promotion failure that happens when a JVM runs out of heap regions during the GC for either survivors and promoted objects. The heap can’t expand because it is already at max. This is indicated in the GC logs when using <code>-XX:+PrintGCDetails</code> by <strong><code>to-space overflow</code></strong>. This is expensive!</p><ul><li>GC still has to continue, so space has to be freed up.</li><li>Unsuccessfully copied objects have to be tenured in place.</li><li>Any updates to RSets of regions in the CSet have to be regenerated.</li><li>All of these steps are expensive.</li></ul></blockquote></li><li><p>增加 heap size</p><ol><li>此时最好同步增加**<code>-XX:G1ReservePercent=n</code>**, 默认值是 10。这样会流出更多的空间来供晋升</li></ol></li><li><p>更早开启 marking cycle，调低 <strong><code>-XX:InitiatingHeapOccupancyPercent</code><strong>（提前开启 mixed GC）</strong>。</strong> Evacuation Failure 的代价比多执行一些 marking cycle 周期高很多。</p></li><li><p>增加 marking 阶段的线程，设置 <strong><code>-XX:ConcGCThreads</code></strong></p></li></ol></li><li><p>优化 ygc 时间。</p><ol><li>观察大部分对象的晋升年龄和目前程序设置的 tenure threshold，将二者调为一致，保证对象在该晋升时就晋升，减少新生代 from 和 to 区来回复制的开销</li></ol></li><li><p>优化 mixed gc 时间（此段参考 <a href="https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-D2B6ADCE-6766-4FF8-AA9D-B7F4F3D0F469">oracle 官网</a>）</p><ol><li>通过增加 <code>-XX:G1MixedGCCountTarget</code> 将老年代区域回收分散到更多垃圾回收中。</li><li>降低 <code>-XX:G1MixedGCLiveThresholdPercent</code> ，不将花费大量时间的区域放入候选收集集中，可以避免收集这些区域。 在许多情况下，高度占用的区域需要花费大量时间来收集。</li><li>可以增加 <code>-XX:G1HeapWastePercent</code>，尽早停止老年代的空间回收，这样 G1 就不会收集那么多高度占用的区域。</li></ol></li></ol><h1 id="观测-GC-的方式"><a href="#观测-GC-的方式" class="headerlink" title="观测 GC 的方式"></a>观测 GC 的方式</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="开启日志参数"><a href="#开启日志参数" class="headerlink" title="开启日志参数"></a>开启日志参数</h3><p>JDK8</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xloggc:<span class="variable">$&#123;IOTDB_HOME&#125;</span>/logs/gc.log  </span><br><span class="line">-XX:+PrintGCDateStamps </span><br><span class="line">-XX:+PrintGCDetails </span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line">-XX:+PrintReferenceGC </span><br><span class="line">-XX:+PrintSafepointStatistics</span><br><span class="line">-XX:PrintSafepointStatisticsCount=1  </span><br><span class="line">-XX:+PrintTenuringDistribution </span><br><span class="line">-XX:+PrintGCApplicationStoppedTime </span><br><span class="line">-XX:+PrintPromotionFailure </span><br><span class="line">-XX:+UseGCLogFileRotation </span><br><span class="line">-XX:NumberOfGCLogFiles=10</span><br><span class="line">-XX:GCLogFileSize=100M</span><br></pre></td></tr></table></figure><p>JDK9 及以上 JVM 重构了日志框架。大大简化了日志参数，下面的参数基本与上面等价：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xlog:</span><br><span class="line">gc*=debug,</span><br><span class="line">heap*=debug,</span><br><span class="line">age*=trace,</span><br><span class="line">metaspace*=info,</span><br><span class="line">safepoint*=debug,</span><br><span class="line">promotion*=info:</span><br><span class="line">file=<span class="variable">$&#123;IOTDB_HOME&#125;</span>/logs/gc.log:time,<span class="built_in">uptime</span>,pid,tid,level,tags:filecount=10,filesize=100M</span><br></pre></td></tr></table></figure><h3 id="如何读日志"><a href="#如何读日志" class="headerlink" title="如何读日志"></a>如何读日志</h3><p>默认的 JVM 日志包括：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[启动经过时间][日志级别][日志标签，可能包含多个] 日志内容</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">14</span>:<span class="number">32.025</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">278.288</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,alloc,region   ] GC(<span class="number">418</span>) Mutator Allocation stats, regions: <span class="number">136</span>, wasted size: <span class="number">2952</span>B ( <span class="number">0.0</span><span class="operator">%</span>)</span><br></pre></td></tr></table></figure><p>其中一行日志，可能包含多个标签。如上面的例子里标签就有 gc、alloc、region。之后关于 JVM 日志相关的配置，也是围绕着这些标签进行配置。</p><p>gc 日志有很多标签与组合，大部分以 gc 标签为开始，混合搭配其他一些标签。一般，有如下几个标签我们会经常用到：</p><ol><li><strong>标签<code>gc</code></strong></li></ol><p>gc 总体描述日志，一般设置 info 级别查看 gc 的发生时间，消耗时间还有内存大小。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">14</span>:<span class="number">32.112</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">278.375</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][info ][gc                ] GC(<span class="number">418</span>) Pause Young (Normal) (G1 Evacuation Pause) <span class="number">20934</span>M<span class="operator">-</span><span class="operator">&gt;</span><span class="number">20078</span>M(<span class="number">25088</span>M) <span class="number">86.631</span>ms</span><br></pre></td></tr></table></figure><p>包含了 gc 类型，gc 原因，收集内存大小，持续时间等信息</p><blockquote><p>目前 System 面板较好的集成了该项日志信息，也推荐直接看 System 面板。</p></blockquote><ol start="2"><li><strong>标签<code>gc,age</code></strong></li></ol><p>gc 中 age 相关信息，age 比较高的对象会进入老年代。debug 级别只会输出最高级别的 age 以及期望大小。如果是 trace 级别，会输出:</p><ul><li>每一个 age 的所有对象占用总大小</li><li>不大于这个 age 的所有 age 的大小。</li></ul><p>例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">14</span>:<span class="number">44.595</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">290.858</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][trace][gc,age            ] GC(<span class="number">441</span>) Age <span class="keyword">table</span> <span class="keyword">with</span> threshold <span class="number">15</span> (max threshold <span class="number">15</span>)</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">14</span>:<span class="number">44.595</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">290.858</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][trace][gc,age            ] GC(<span class="number">441</span>) <span class="operator">-</span> age   <span class="number">1</span>:  <span class="number">164913704</span> bytes,  <span class="number">164913704</span> total</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">14</span>:<span class="number">44.595</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">290.858</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][trace][gc,age            ] GC(<span class="number">441</span>) <span class="operator">-</span> age   <span class="number">2</span>:   <span class="number">36313680</span> bytes,  <span class="number">201227384</span> total</span><br></pre></td></tr></table></figure><p>这个标签可以有效分析对象的晋升年龄情况，从而调整 <code>-XX:MaxTenuringThreshold</code>等选项</p><ol start="3"><li><strong>标签<code>gc,alloc</code>，<code>gc,alloc,region</code></strong></li></ol><p>这两个参数仅对 G1 gc 有效 <code>gc,alloc</code> 在 gc 完成的时候，打印 trace 级别日志记录触发 gc 的线程是哪一个以及返回的 gc 结果地址，一般是在 debug 调试 gc 的时候才需要看这个日志，平时开到 debug 级别即可。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="number">2020</span><span class="number">-02</span><span class="number">-28</span>T02:<span class="number">14</span>:<span class="number">02.694</span><span class="operator">+</span><span class="number">0000</span>][trace][gc,alloc                    ] sdk<span class="number">-27692</span><span class="number">-2</span><span class="operator">-</span>amqp<span class="operator">-</span>t<span class="number">-4</span>: Successfully scheduled collection returning <span class="number">0x00000007ffc00000</span></span><br></pre></td></tr></table></figure><p><code>gc,alloc,region</code> 统计每次 gc 的 Regions 信息，打印 debug 级别日志。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">14</span>:<span class="number">46.431</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">292.694</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,alloc,region   ] GC(<span class="number">445</span>) Mutator Allocation stats, regions: <span class="number">136</span>, wasted size: <span class="number">536</span>B ( <span class="number">0.0</span><span class="operator">%</span>)</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>标签<code>gc,cpu</code></strong> 这个是大多数 gc 问题定位需要查看的日志，info 级别打印每次gc真正耗时：</li></ol><p>注意到日志中时间分为了三块：<code>user</code>， <code>sys</code>，和 <code>real</code>，三者的区别和含义如下：</p><ul><li><code>real</code>：指的是在此次 GC 事件中 CPU 实际所花费的时间，跟钟表上的时间是一致的（wall clock time）；</li><li><code>user</code>：指的是 CPU 工作在用户态所花费的时间；</li><li><code>sys</code>：指的是 CPU 工作在内核态所花费的时间。</li></ul><p><code>User</code> + <code>sys</code> 就是 CPU 花费的实际时间，注意这个值统计了所有CPU上的时间。如果 CPU 是多核的，<code>User</code> + <code>sys</code> 可能会比自然流逝的绝对时间大</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">39.132</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">825.395</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][info ][gc,cpu            ] GC(<span class="number">1449</span>) <span class="keyword">User</span><span class="operator">=</span><span class="number">1.41</span>s Sys<span class="operator">=</span><span class="number">0.00</span>s <span class="type">Real</span><span class="operator">=</span><span class="number">0.11</span>s</span><br></pre></td></tr></table></figure><p>一般来说，如果看到 <code>real</code> 所显示的时间 远 大于 <code>User</code> + <code>sys</code>，表明 GC 过程存在某些问题（等待计算资源），原因可能是下面这两种：</p><ul><li>频繁的 IO 操作（让 GC 延迟）</li><li>缺乏 CPU 资源（GC 分配不到 CPU cycles）</li></ul><p>如果 <code>sys</code> 特别高，说明虚拟机没有得到足够的 CPU，主机的负载可能太高了。可能是 io、内存分配等方面出了问题；</p><ol start="5"><li><strong>标签<code>gc,ergo</code>，<code>gc,ergo,cset</code>，<code>gc,ergo,ihop</code>，<code>gc,ergo,refine</code></strong></li></ol><p>这是 GC 自适应调节（ergonomics）相关的日志，记录了 GC 是如何自适应调节相关参数的。一般的 debug 级别信息就够了</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">39.439</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">825.702</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,ergo           ] GC(<span class="number">1450</span>) <span class="keyword">Running</span> G1 Clear Card <span class="keyword">Table</span> Task <span class="keyword">using</span> <span class="number">9</span> workers <span class="keyword">for</span> <span class="number">9</span> units <span class="keyword">of</span> work <span class="keyword">for</span> <span class="number">538</span> regions.</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">39.343</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">825.606</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,ergo,cset      ] GC(<span class="number">1450</span>) Finish choosing CSet. <span class="keyword">old</span>: <span class="number">0</span> regions, predicted <span class="keyword">old</span> region <span class="type">time</span>: <span class="number">0.00</span>ms, <span class="type">time</span> remaining: <span class="number">68.65</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.240</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">788.503</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,ergo,ihop      ] GC(<span class="number">1378</span>) Request concurrent <span class="keyword">cycle</span> initiation (occupancy higher than threshold) occupancy: <span class="number">12398362624</span>B allocation request: <span class="number">0</span>B threshold: <span class="number">11838003609</span>B (<span class="number">45.00</span>) source: <span class="keyword">end</span> <span class="keyword">of</span> GC</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.240</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">788.503</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,ergo,refine    ] GC(<span class="number">1378</span>) Updated Refinement Zones: green: <span class="number">82</span>, yellow: <span class="number">246</span>, red: <span class="number">410</span></span><br></pre></td></tr></table></figure><ol start="6"><li><strong>标签<code>gc,heap</code>，<code>gc,heap,region</code></strong></li></ol><p><code>gc,heap</code>的 debug 级别会显示 gc 的时候堆的概况，对于 g1 gc <code>gc,heap,region</code>的 trace 级别，会打印每一个 region 的详细情况，这个一般供 gc 调试使用。</p><p>我们一般只需要关心<code>gc,heap</code>的日志就行了：关注年轻代和年老代堆回收前后的情况，观察 GC 效率、堆空间增长速度等。</p><blockquote><p>目前 System 面板较好的集成了该项日志信息，也推荐直接看 System 面板。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.240</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">788.503</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][info ][gc,heap           ] GC(<span class="number">1378</span>) Eden regions: <span class="number">251</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">0</span>(<span class="number">229</span>)</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.240</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">788.503</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][info ][gc,heap           ] GC(<span class="number">1378</span>) Survivor regions: <span class="number">32</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">35</span>(<span class="number">35</span>)</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.240</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">788.503</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][info ][gc,heap           ] GC(<span class="number">1378</span>) <span class="keyword">Old</span> regions: <span class="number">1040</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">1148</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.240</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">788.503</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][info ][gc,heap           ] GC(<span class="number">1378</span>) Humongous regions: <span class="number">334</span><span class="operator">-</span><span class="operator">&gt;</span><span class="number">330</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.240</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">788.503</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,heap           ] GC(<span class="number">1378</span>) Heap after GC invocations<span class="operator">=</span><span class="number">1343</span> (<span class="keyword">full</span> <span class="number">36</span>): garbage<span class="operator">-</span><span class="keyword">first</span> heap   total <span class="number">25690112</span>K, used <span class="number">12333688</span>K [<span class="number">0x00000001e0000000</span>, <span class="number">0x0000000800000000</span>)</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.240</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">788.503</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,heap           ] GC(<span class="number">1378</span>)   region size <span class="number">8192</span>K, <span class="number">35</span> young (<span class="number">286720</span>K), <span class="number">35</span> survivors (<span class="number">286720</span>K)</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.240</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">788.503</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,heap           ] GC(<span class="number">1378</span>)  Metaspace       used <span class="number">66936</span>K, capacity <span class="number">68918</span>K, committed <span class="number">69760</span>K, reserved <span class="number">1110016</span>K</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.240</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">788.503</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,heap           ] GC(<span class="number">1378</span>)   class space    used <span class="number">7554</span>K, capacity <span class="number">8389</span>K, committed <span class="number">8780</span>K, reserved <span class="number">1048576</span>K</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>标签<code>gc,humongous</code></strong></li></ol><p>如果使用的是 G1 gc，并且经常出现 Evacuation Failure 或者 Humongous Allocation ，并且不知道是什么原因的话，可以考虑看看这个标签相关的日志：</p><p>记载了大对象的分配情况和大对象 size。至于后面被哪个 remset 标记，在哪个 code root，如果不是调试 gc 的话一般不用关注</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.748</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">789.011</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,humongous      ] GC(<span class="number">1379</span>) Live humongous region <span class="number">0</span> object size <span class="number">22420064</span> <span class="keyword">start</span> <span class="number">0x00000001e0000000</span>  <span class="keyword">with</span> remset <span class="number">0</span> code roots <span class="number">0</span> <span class="keyword">is</span> marked <span class="number">0</span> reclaim candidate <span class="number">0</span> type <span class="keyword">array</span> <span class="number">1</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.748</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">789.011</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,humongous      ] GC(<span class="number">1379</span>) Live humongous region <span class="number">1052</span> object size <span class="number">22420064</span> <span class="keyword">start</span> <span class="number">0x00000003ee000000</span>  <span class="keyword">with</span> remset <span class="number">1</span> code roots <span class="number">0</span> <span class="keyword">is</span> marked <span class="number">0</span> reclaim candidate <span class="number">0</span> type <span class="keyword">array</span> <span class="number">1</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.748</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">789.011</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,humongous      ] GC(<span class="number">1379</span>) Live humongous region <span class="number">1057</span> object size <span class="number">22420064</span> <span class="keyword">start</span> <span class="number">0x00000003f0800000</span>  <span class="keyword">with</span> remset <span class="number">0</span> code roots <span class="number">0</span> <span class="keyword">is</span> marked <span class="number">0</span> reclaim candidate <span class="number">0</span> type <span class="keyword">array</span> <span class="number">1</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.748</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">789.011</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,humongous      ] GC(<span class="number">1379</span>) Live humongous region <span class="number">1065</span> object size <span class="number">22420064</span> <span class="keyword">start</span> <span class="number">0x00000003f4800000</span>  <span class="keyword">with</span> remset <span class="number">0</span> code roots <span class="number">0</span> <span class="keyword">is</span> marked <span class="number">0</span> reclaim candidate <span class="number">0</span> type <span class="keyword">array</span> <span class="number">1</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">02.748</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">789.011</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,humongous      ] GC(<span class="number">1379</span>) Live humongous region <span class="number">1070</span> object size <span class="number">8968208</span> <span class="keyword">start</span> <span class="number">0x00000003f7000000</span>  <span class="keyword">with</span> remset <span class="number">0</span> code roots <span class="number">0</span> <span class="keyword">is</span> marked <span class="number">0</span> reclaim candidate <span class="number">0</span> type <span class="keyword">array</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ol start="8"><li><strong>标签<code>gc,metaspace</code></strong></li></ol><p>查看 metaspace 相关的 gc 日志，<code>gc,metaspace</code>的 info 级别会输出每次 gc 涉及的 metaspace 内存变化。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">03.645</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">789.908</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][info ][gc,metaspace      ] GC(<span class="number">1381</span>) Metaspace: <span class="number">66936</span>K(<span class="number">69760</span>K)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">66936</span>K(<span class="number">69760</span>K) NonClass: <span class="number">59381</span>K(<span class="number">60980</span>K)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">59381</span>K(<span class="number">60980</span>K) Class: <span class="number">7554</span>K(<span class="number">8780</span>K)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">7554</span>K(<span class="number">8780</span>K)</span><br></pre></td></tr></table></figure><ol><li><strong>标签<code>gc,phases</code>，<code>gc,phases,ref</code>，<code>gc,phases,task</code>，<code>gc,ref</code>，<code>gc,start</code>,<code>gc,ref,start</code>，<code>gc,task</code></strong> <strong>等</strong></li></ol><p>这些标签与 gc 步骤相关，详细记录了 GC 每步的耗时、软&#x2F;弱等各类引用处理等信息。可以查看这些标签的日志，来了解 gc 的步骤以及原理。</p><p><strong>一般可以通过该类日志查看 GC 在哪步耗时显著大，从而针对性优化。</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][info ][gc,phases         ] GC(<span class="number">1382</span>)   Pre Evacuate Collection <span class="keyword">Set</span>: <span class="number">0.1</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     <span class="keyword">Prepare</span> TLABs: <span class="number">0.0</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Choose Collection <span class="keyword">Set</span>: <span class="number">0.0</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Humongous Register: <span class="number">0.1</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][info ][gc,phases         ] GC(<span class="number">1382</span>)   Evacuate Collection <span class="keyword">Set</span>: <span class="number">144.4</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Ext Root Scanning (ms):   Min:  <span class="number">0.3</span>, Avg:  <span class="number">0.3</span>, Max:  <span class="number">0.5</span>, Diff:  <span class="number">0.3</span>, Sum:  <span class="number">4.3</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     <span class="keyword">Update</span> RS (ms):           Min:  <span class="number">4.0</span>, Avg: <span class="number">16.6</span>, Max: <span class="number">56.5</span>, Diff: <span class="number">52.5</span>, Sum: <span class="number">215.4</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)       Processed Buffers:        Min: <span class="number">3</span>, Avg: <span class="number">12.4</span>, Max: <span class="number">24</span>, Diff: <span class="number">21</span>, Sum: <span class="number">161</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)       Scanned Cards:            Min: <span class="number">767</span>, Avg: <span class="number">2468.7</span>, Max: <span class="number">4190</span>, Diff: <span class="number">3423</span>, Sum: <span class="number">32093</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)       Skipped Cards:            Min: <span class="number">0</span>, Avg:  <span class="number">0.4</span>, Max: <span class="number">1</span>, Diff: <span class="number">1</span>, Sum: <span class="number">5</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Scan RS (ms):             Min:  <span class="number">7.2</span>, Avg: <span class="number">34.5</span>, Max: <span class="number">62.1</span>, Diff: <span class="number">54.9</span>, Sum: <span class="number">448.7</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)       Scanned Cards:            Min: <span class="number">1501</span>, Avg: <span class="number">11120.2</span>, Max: <span class="number">21225</span>, Diff: <span class="number">19724</span>, Sum: <span class="number">144563</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)       Claimed Cards:            Min: <span class="number">1792</span>, Avg: <span class="number">13903.3</span>, Max: <span class="number">30483</span>, Diff: <span class="number">28691</span>, Sum: <span class="number">180743</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)       Skipped Cards:            Min: <span class="number">43974</span>, Avg: <span class="number">105456.0</span>, Max: <span class="number">143149</span>, Diff: <span class="number">99175</span>, Sum: <span class="number">1370928</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Code Root Scanning (ms):  Min:  <span class="number">0.0</span>, Avg:  <span class="number">0.0</span>, Max:  <span class="number">0.0</span>, Diff:  <span class="number">0.0</span>, Sum:  <span class="number">0.0</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     AOT Root Scanning (ms):   skipped</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Object <span class="keyword">Copy</span> (ms):         Min: <span class="number">71.7</span>, Avg: <span class="number">92.3</span>, Max: <span class="number">129.0</span>, Diff: <span class="number">57.3</span>, Sum: <span class="number">1199.7</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Termination (ms):         Min:  <span class="number">0.0</span>, Avg:  <span class="number">0.0</span>, Max:  <span class="number">0.0</span>, Diff:  <span class="number">0.0</span>, Sum:  <span class="number">0.0</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)       Termination Attempts:     Min: <span class="number">1</span>, Avg:  <span class="number">1.0</span>, Max: <span class="number">1</span>, Diff: <span class="number">0</span>, Sum: <span class="number">13</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     GC Worker Other (ms):     Min:  <span class="number">0.1</span>, Avg:  <span class="number">0.3</span>, Max:  <span class="number">0.6</span>, Diff:  <span class="number">0.6</span>, Sum:  <span class="number">4.5</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     GC Worker Total (ms):     Min: <span class="number">143.8</span>, Avg: <span class="number">144.1</span>, Max: <span class="number">144.3</span>, Diff:  <span class="number">0.5</span>, Sum: <span class="number">1873.1</span>, Workers: <span class="number">13</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][info ][gc,phases         ] GC(<span class="number">1382</span>)   Post Evacuate Collection <span class="keyword">Set</span>: <span class="number">1.4</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Code Roots Fixup: <span class="number">0.0</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Clear Card <span class="keyword">Table</span>: <span class="number">0.3</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Reference Processing: <span class="number">0.1</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)       Reconsider SoftReferences: <span class="number">0.0</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         SoftRef (ms):             skipped</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)       Notify Soft<span class="operator">/</span>WeakReferences: <span class="number">0.0</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.366</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         SoftRef (ms):             skipped</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         WeakRef (ms):             skipped</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         FinalRef (ms):            skipped</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         Total (ms):               skipped</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)       Notify <span class="keyword">and</span> keep alive finalizable: <span class="number">0.0</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         FinalRef (ms):            skipped</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)       Notify PhantomReferences: <span class="number">0.0</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         PhantomRef (ms):          Min:  <span class="number">0.0</span>, Avg:  <span class="number">0.0</span>, Max:  <span class="number">0.0</span>, Diff:  <span class="number">0.0</span>, Sum:  <span class="number">0.0</span>, Workers: <span class="number">1</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)       SoftReference:</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         Discovered: <span class="number">0</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         Cleared: <span class="number">0</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)       WeakReference:</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         Discovered: <span class="number">0</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         Cleared: <span class="number">0</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)       FinalReference:</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         Discovered: <span class="number">0</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         Cleared: <span class="number">0</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)       PhantomReference:</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         Discovered: <span class="number">2</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases,<span class="keyword">ref</span>     ] GC(<span class="number">1382</span>)         Cleared: <span class="number">2</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Weak Processing: <span class="number">0.1</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     <span class="keyword">Merge</span> <span class="keyword">Per</span><span class="operator">-</span>Thread State: <span class="number">0.0</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Code Roots Purge: <span class="number">0.0</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Redirty Cards: <span class="number">0.1</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     DerivedPointerTable <span class="keyword">Update</span>: <span class="number">0.0</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     <span class="keyword">Free</span> Collection <span class="keyword">Set</span>: <span class="number">0.3</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Humongous Reclaim: <span class="number">0.6</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     <span class="keyword">Start</span> <span class="keyword">New</span> Collection <span class="keyword">Set</span>: <span class="number">0.0</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Resize TLABs: <span class="number">0.0</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,phases         ] GC(<span class="number">1382</span>)     Expand Heap After Collection: <span class="number">0.0</span>ms</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">04.104</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">790.367</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][info ][gc,phases         ] GC(<span class="number">1382</span>)   Other: <span class="number">0.3</span>ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">08.433</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">794.696</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][info ][gc,<span class="keyword">start</span>          ] GC(<span class="number">1389</span>) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">08.433</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">794.696</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][info ][gc,task           ] GC(<span class="number">1389</span>) <span class="keyword">Using</span> <span class="number">13</span> workers <span class="keyword">of</span> <span class="number">13</span> <span class="keyword">for</span> evacuation</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">08.433</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">794.696</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,tlab           ] GC(<span class="number">1389</span>) TLAB totals: thrds: <span class="number">47</span>  refills: <span class="number">1704</span> max: <span class="number">181</span> slow allocs: <span class="number">56</span> max <span class="number">29</span> waste:  <span class="number">1.1</span><span class="operator">%</span> gc: <span class="number">15548672</span>B max: <span class="number">1563232</span>B slow: <span class="number">1233720</span>B max: <span class="number">197560</span>B fast: <span class="number">0</span>B max: <span class="number">0</span>B</span><br><span class="line">[<span class="number">2024</span><span class="number">-01</span><span class="number">-15</span>T15:<span class="number">23</span>:<span class="number">08.433</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">794.696</span>s][<span class="number">3381829</span>][<span class="number">3381900</span>][debug][gc,alloc,region   ] GC(<span class="number">1389</span>) Mutator Allocation stats, regions: <span class="number">180</span>, wasted size: <span class="number">0</span>B ( <span class="number">0.0</span><span class="operator">%</span>)</span><br></pre></td></tr></table></figure><ol start="9"><li><strong>标签<code>safepoint</code></strong></li></ol><p>我们知道只有到达 safepoint，我们才可以进行 gc，如果我们对这些 safepoint 感兴趣，可以查看这个标签的 debug 级别的日志。</p><p>关于 safepoint 的解析、日志观测、调优，感兴趣的同学可以参考这篇文章：</p><p><a href="https://zhuanlan.zhihu.com/p/161710652?spm=a2c6h.12873639.article-detail.15.7a8b1da3Hy4DoP">https://zhuanlan.zhihu.com/p/161710652?spm=a2c6h.12873639.article-detail.15.7a8b1da3Hy4DoP</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-12</span>T17:<span class="number">57</span>:<span class="number">57.360</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1388.942</span>s][<span class="number">558968</span>][<span class="number">559235</span>][info ][safepoint,stats  ] G1CollectForAllocation       [           <span class="number">1542</span>               <span class="number">3</span> ][           <span class="number">578703</span>     <span class="number">173202</span> <span class="number">13655482720</span> <span class="number">13656234625</span> ]               <span class="number">6</span></span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-12</span>T17:<span class="number">57</span>:<span class="number">57.360</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1388.942</span>s][<span class="number">558968</span>][<span class="number">559235</span>][info ][safepoint        ] Safepoint &quot;G1CollectForAllocation&quot;, <span class="type">Time</span> since <span class="keyword">last</span>: <span class="number">153683087494</span> ns, Reaching safepoint: <span class="number">578703</span> ns, Cleanup: <span class="number">173202</span> ns, <span class="keyword">At</span> safepoint: <span class="number">13655482720</span> ns, Total: <span class="number">13656234625</span> ns</span><br><span class="line"></span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.558</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ] # SafepointSynchronize::<span class="keyword">begin</span>: Timeout detected:</span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.558</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ] # SafepointSynchronize::<span class="keyword">begin</span>: Timed <span class="keyword">out</span> while spinning <span class="keyword">to</span> reach a safepoint.</span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.558</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ] # SafepointSynchronize::<span class="keyword">begin</span>: Threads which did <span class="keyword">not</span> reach the safepoint:</span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.558</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ] # &quot;Pipe-Async-Connector-Client-Pool-selector-299&quot; #<span class="number">299</span> daemon prio<span class="operator">=</span><span class="number">5</span> os_prio<span class="operator">=</span><span class="number">0</span> cpu<span class="operator">=</span><span class="number">24998.13</span>ms elapsed<span class="operator">=</span><span class="number">1435.09</span>s tid<span class="operator">=</span><span class="number">0x00007e63dc2e1d00</span> nid<span class="operator">=</span><span class="number">0x1deb7</span> runnable  [<span class="number">0x0000000000000000</span>]</span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.559</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ]    java.lang.Thread.State: RUNNABLE</span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.559</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ] </span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.559</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ] # &quot;pool-29-IoTDB-Pipe-Connector-Executor-Pool-69&quot; #<span class="number">1476</span> prio<span class="operator">=</span><span class="number">5</span> os_prio<span class="operator">=</span><span class="number">0</span> cpu<span class="operator">=</span><span class="number">18305.09</span>ms elapsed<span class="operator">=</span><span class="number">1320.80</span>s tid<span class="operator">=</span><span class="number">0x00007e63fc376ee0</span> nid<span class="operator">=</span><span class="number">0x1e842</span> runnable  [<span class="number">0x0000000000000000</span>]</span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.559</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ]    java.lang.Thread.State: RUNNABLE</span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.559</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ] </span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.559</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ] # &quot;pool-29-IoTDB-Pipe-Connector-Executor-Pool-81&quot; #<span class="number">1488</span> prio<span class="operator">=</span><span class="number">5</span> os_prio<span class="operator">=</span><span class="number">0</span> cpu<span class="operator">=</span><span class="number">17034.13</span>ms elapsed<span class="operator">=</span><span class="number">1320.80</span>s tid<span class="operator">=</span><span class="number">0x00007e63fc385400</span> nid<span class="operator">=</span><span class="number">0x1e84e</span> runnable  [<span class="number">0x0000000000000000</span>]</span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.559</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ]    java.lang.Thread.State: RUNNABLE</span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.559</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ] </span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.559</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ] # &quot;pool-26-IoTDB-ClientRPC-Processor-913&quot; #<span class="number">1564</span> prio<span class="operator">=</span><span class="number">5</span> os_prio<span class="operator">=</span><span class="number">0</span> cpu<span class="operator">=</span><span class="number">104459.15</span>ms elapsed<span class="operator">=</span><span class="number">1300.41</span>s tid<span class="operator">=</span><span class="number">0x00007e63e44113c0</span> nid<span class="operator">=</span><span class="number">0x1e8cb</span> runnable  [<span class="number">0x00007e5254478000</span>]</span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.559</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ]    java.lang.Thread.State: RUNNABLE</span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.559</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ] </span><br><span class="line">[<span class="number">2024</span><span class="number">-03</span><span class="number">-08</span>T11:<span class="number">10</span>:<span class="number">51.559</span><span class="operator">+</span><span class="number">0800</span>][<span class="number">1624.879</span>s][<span class="number">121648</span>][<span class="number">121979</span>][warning][safepoint         ] # SafepointSynchronize::<span class="keyword">begin</span>: (<span class="keyword">End</span> <span class="keyword">of</span> list)</span><br></pre></td></tr></table></figure><h3 id="GCEasy"><a href="#GCEasy" class="headerlink" title="GCEasy"></a>GCEasy</h3><p>非常强大的 GC 日志可视化分析报告，强大之处在于自动整合耗时、内存、cause、年龄等各类日志分析，并给出一些调优思路（实测不是特别靠谱，但可以参考）。</p><p>国外原版需收费。下面是国内镜像，实测免费：</p><p><a href="https://gceasy.ycrash.cn/gc-index.jsp">https://gceasy.ycrash.cn/gc-index.jsp</a></p><h1 id="Java-大数据系统-JVM-调优建议"><a href="#Java-大数据系统-JVM-调优建议" class="headerlink" title="Java 大数据系统 JVM 调优建议"></a>Java 大数据系统 JVM 调优建议</h1><p>笔者还调研了 Spark、Hadoop、Alluxio、Hbase、Ratis 等大数据系统的 JVM 默认参数或调优建议，这里贴出提供了相关信息的项目。</p><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>Spark 的目标是确保只有长寿的 RDD 存储在老年代，这样新生代便足以存放短命对象。这将有助于避免 fgc</p><p>Spark 建议：</p><ul><li>查看 GC 日志，如果一次 task 完成前产生了多次 fgc，说明进程内存不够了</li><li>如果 ygc 很多，而 fgc 不是很多，建议调高 eden 区的大小。eden 区的大小可以设置为稍大于每个 task 需要的内存。如果 eden 的大小为 <code>E</code>，那么可以设置 <code>-Xmn=4/3*E</code></li><li>如果观察 GC 日志，发现老年代接近满载，可以尝试从代码层面减少内存使用（<code>spark.memory.fraction</code>，这里不赘述）。此外，还可以减小新生代大小。如果已经减小过 <code>-Xmn</code>，可以试试 <code>NewRatio</code></li><li>如果 GC 成为瓶颈（这里没说是吞吐瓶颈还是延迟瓶颈，根据经验一般 G1 对付延迟瓶颈比较有效），可以尝试 G1。增大 G1 的 region size 可能很有用（<a href="http://www.oracle.com/technetwork/articles/java/g1gc-1984535.html%EF%BC%89">http://www.oracle.com/technetwork/articles/java/g1gc-1984535.html）</a></li></ul><h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h2><p><strong>为了低延迟而调优：</strong></p><ul><li>使用 CMS collector: <code>-XX:+UseConcMarkSweepGC</code></li><li>尽可能调小年轻代大小. Example:<code>-XX:CMSInitiatingOccupancyFraction=70</code></li><li>为低时延而非高吞吐而调优: <code>-Xmn512m</code></li><li>使用并行收集 eden 的 gc: <code>-XX:+UseParNewGC</code></li><li>Avoid collection under pressure: <code>-XX:+UseCMSInitiatingOccupancyOnly</code></li><li>代码层面的调优：Limit per request scanner result sizing so everything fits into survivor space but doesn’t tenure. In <code>hbase-site.xml</code>, set <code>hbase.client.scanner.max.result.size</code> to 1&#x2F;8th of eden space (with -<code>Xmn512m</code> this is ~51MB )</li><li>代码层面的调优：Set <code>max.result.size</code> x <code>handler.count</code> less than survivor space</li></ul><p><strong>OS-Level 调优：</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/267846455">Turn transparent huge pages (THP)</a> off:</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br></pre></td></tr></table></figure><ul><li>Set <code>vm.swappiness = 0</code>（禁用 swap）</li><li>Set <code>vm.min_free_kbytes</code> to at least 1GB (8GB on larger memory systems)（调整内存水位线）</li><li>Disable NUMA zone reclaim with <code>vm.zone_reclaim_mode = 0</code></li></ul><h1 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h1><p>贴出 9 个典型场景，并概述他们的场景、解决方案和效果</p><ol><li><strong>场景：</strong>针对 PS new + CMS 的 YGC 调优（主要是吞吐目标）</li></ol><p><strong>解决方案：</strong>调整 young 区大小、比例（优化 ygc 频率）；调整晋升年龄阈值（优化 ygc 耗时）；优化偏向锁（safepoint）（优化 ygc 耗时）</p><p><strong>效果：</strong>Young GC 的频率减少了大概 1&#x2F;3。GC 的吞量提高了 3.8%，达到了 96.8%</p><p><a href="https://zhuanlan.zhihu.com/p/165382850">https://zhuanlan.zhihu.com/p/165382850</a></p><ol start="2"><li>类似1，是 PS 针对 young 区大小的调优，找到合适的 young 和 old 区比例</li></ol><p><a href="https://blog.csdn.net/hilaryfrank/article/details/109598582">https://blog.csdn.net/hilaryfrank/article/details/109598582</a></p><ol start="3"><li><strong>场景：</strong>Major GC 和 Minor GC 频繁（针对 CMS）</li></ol><p><strong>解决方案：</strong>调整 young 区大小，防止大量临时对象进入 old 区，让 ygc 更彻底。</p><p><strong>效果：</strong>通过扩容新生代为为原来的三倍，单次Minor GC时间增加小于5ms，频率下降了60%，服务响应时间TP90，TP99都下降了10ms+，服务可用性得到提升。</p><ol start="4"><li><strong>场景：</strong>请求高峰期发生GC，导致服务可用性下降（针对 CMS）</li></ol><p><strong>解决方案：</strong>设法让 CMS 在 Remark 前执行一次 ygc，使得新生代的对象数量减少，进而减少 remark 工作量</p><p><strong>效果：</strong>通过扩容新生代为为原来的三倍，单次Minor GC时间增加小于5ms，频率下降了60%，服务响应时间TP90，TP99都下降了10ms+，服务可用性得到提升。</p><ol start="5"><li><strong>场景：</strong>发生 Stop-The-World 的 GC（针对 CMS）</li></ol><p><strong>解决方案：</strong>固定 Perm 区大小，防止 Perm 扩容导致的 fgc</p><p><strong>效果：</strong>调整参数后，服务不再有 Perm 区扩容导致的 STW GC 发生</p><p><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">https://tech.meituan.com/2017/12/29/jvm-optimize.html</a></p><ol start="6"><li><strong>场景：</strong>年轻代对象晋升过早，大部分对象在 1 岁时便晋升，导致 old 区增长速度过快</li></ol><p><strong>解决方案：</strong>通过 <code>-XX:SurvivorRatio</code> 扩容 survivor 区</p><p><strong>效果：</strong>调整参数后，再也没有切量后长暂停的问题了，Young GC 稳定在 30-100ms，成功解决</p><p><a href="https://segmentfault.com/a/1190000044467479">https://segmentfault.com/a/1190000044467479</a></p><ol start="7"><li><strong>场景：</strong>G1 Reference Process 环节中：软引用处理时间过长</li></ol><p><strong>解决方案：</strong>调整参数 <code>-XX:+ParallelRefProcEnabled</code>、<code>-XX:SoftRefLRUPolicyMSPerMB=0</code>，并优化代码减少 Finialize 对象。</p><p><strong>效果：</strong>mixed gc 稳定到 85ms，耗时大幅降低</p><p><a href="https://zhuanlan.zhihu.com/p/463122674">https://zhuanlan.zhihu.com/p/463122674</a></p><ol start="8"><li><strong>场景：</strong>G1 GC 的日志出现 to-space exhausted 问题</li></ol><p><strong>解决方案：</strong>增大 GC 的速度，使其超过垃圾增长的速度：让G1更早得启动混合式垃圾收集周期，调小 <code>-XX:InitiatingHeapOccupancyPercent</code>；增加每次混合式垃圾收集收集的Old分区数量，调整<code>-XX:G1MixedGCCountTarget</code>；</p><p><a href="https://zhuanlan.zhihu.com/p/79643783">https://zhuanlan.zhihu.com/p/79643783</a></p><ol start="9"><li><strong>场景：</strong>Young GC 耗时一直居高不下，更重要的是 Old 区的最大使用量与日递增</li></ol><p><strong>解决方案：</strong>调大 heapRegionSize</p><p><strong>效果：</strong>将 Region 大小调到 16M 或者 32M 时，GC 情况会有明显的好转</p><p><a href="https://www.jianshu.com/p/0955113a12db">https://www.jianshu.com/p/0955113a12db</a></p><h1 id="补充附录"><a href="#补充附录" class="headerlink" title="补充附录"></a>补充附录</h1><h2 id="GC-VM-参数是否支持热修改？"><a href="#GC-VM-参数是否支持热修改？" class="headerlink" title="GC VM 参数是否支持热修改？"></a>GC VM 参数是否支持热修改？</h2><p><strong>结论：</strong>只有极少部分<strong>【managable】</strong>的参数才可以被热修改。这部分参数大多不是我们 GC 调优常用的，<strong>因此 GC 目前还是依赖冷调优。</strong></p><ol><li>根据 <a href="https://docs.oracle.com/en/java/javase/11/tools/jinfo.html#GUID-69246B58-28C4-477D-B375-278F5F9830A5">oracle </a>官网，<code>jinfo</code> 命令可以实现<strong>部分参数</strong>热修改。且只有被标记为<strong>【managable】</strong>的参数才可以被热修改</li></ol><ul><li>具体语法如下：</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164237934.png" alt="image-20240401164237934"></p><p>比如 JDK8 下，我们可以通过 jinfo 命令热修改 <code>-XX:PrintGC</code> 参数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">jinfo <span class="operator">-</span>flag <span class="operator">+</span>PrintGC pid</span><br></pre></td></tr></table></figure><ol><li><strong>那么哪些参数是 managable 的呢？</strong></li></ol><p>所有的 JVM 中 manageable 的参数可以从 openjdk 源码（<a href="https://github.com/openjdk/jdk/blob/master/src/hotspot/share/runtime/globals.hpp">openjdk .&#x2F;hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;globals.hpp</a>）中获取</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164300666.png" alt="image-20240401164300666"></p><p>也可以通过 console 命令<code>java -XX:+PrintFlagsFinal -version | grep &quot;manageable&quot; </code>获得：</p><p>JDK8：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164311823.png" alt="image-20240401164311823"></p><p>JDK11：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164328950.png" alt="image-20240401164328950"></p><p>JDK17：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20240401164337903.png" alt="image-20240401164337903"></p><h2 id="不同发行商-JDK-的参数效果相同吗？"><a href="#不同发行商-JDK-的参数效果相同吗？" class="headerlink" title="不同发行商 JDK 的参数效果相同吗？"></a>不同发行商 JDK 的参数效果相同吗？</h2><p>所有发行商的 JDK 都是基于开源的 <a href="https://github.com/openjdk/jdk">openjdk</a>  进行修改，因此在 VM options 上都保证了向后兼容，<strong>可以放心使用。</strong></p><blockquote><p>👉 使用 oracle、openjdk、correto 三款最常用的 JDK 进行验证，常用的参数均能 work</p></blockquote><h2 id="设置矛盾效果的-GC-参数，JVM-如何表现？"><a href="#设置矛盾效果的-GC-参数，JVM-如何表现？" class="headerlink" title="设置矛盾效果的 GC 参数，JVM 如何表现？"></a>设置矛盾效果的 GC 参数，JVM 如何表现？</h2><p><strong>结论：</strong>如果 <code>-XX:MaxGCPauseMillis</code> 和 <code>-XX:GCTimeRatio</code> 设置产生的效果发生矛盾，会一定程度影响 GC 的表现</p><p>实验数据敏感，在此省略。</p><h2 id="XX-AlwaysPreTouch-对启动性能的影响"><a href="#XX-AlwaysPreTouch-对启动性能的影响" class="headerlink" title="-XX:+AlwaysPreTouch 对启动性能的影响"></a>-XX:+AlwaysPreTouch 对启动性能的影响</h2><p><strong>AlwaysPreTouch 对 IoTDB 启动性能影响的实验：</strong></p><ol><li>环境：M2 pro 16G JDK 8&#x2F;11</li></ol><ul><li>ConfigNode：1068ms（加 AlwaysPreTouch）</li><li>DataNode：1369ms（加 AlwaysPreTouch）</li><li>ConfigNode：999ms（不加 AlwaysPreTouch）</li><li>DataNode：1374ms（不加 AlwaysPreTouch）</li></ul><ol start="2"><li>环境： 32G JDK 8</li></ol><ul><li>ConfigNode：1044ms（加 AlwaysPreTouch）</li><li>DataNode：1349ms（加 AlwaysPreTouch）</li><li>ConfigNode：1031ms（不加 AlwaysPreTouch）</li><li>DataNode：1430ms（不加 AlwaysPreTouch）</li></ul><ol start="3"><li>环境：Ubuntu 754G JDK11</li></ol><ul><li>DataNode：大约 1-2 s（不加 AlwaysPreTouch）</li><li>DataNode：大约 20+ s（加 AlwaysPreTouch）</li></ul><p><strong>结论：</strong></p><ol><li>AlwaysPreTouch 在常见的小内存场景下对启动的影响不大，但在大内存场景下会显著延长启动时间</li><li>AlwaysPreTouch 主要能提高启动初期的性能，对启动中后期的性能影响不大。因为应用运行初期内存未完全分配，可能会有一些分配内存的开销；但随着应用的运行，当内存已经被 OS 完全分配时，该参数理论上已无优化效果。</li><li><strong>对用户来说，启动时间短比启动期间的性能更重要，且用户可以不感知此参数，因此建议该参数不用默认打开</strong></li></ol><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html</a></p><p><a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html">https://www.oracle.com/technical-resources/articles/java/g1gc.html</a></p><p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html">https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html</a></p><p><a href="https://docs.oracle.com/en/java/javase/17/">https://docs.oracle.com/en/java/javase/17/</a></p><p><a href="https://docs.oracle.com/en/java/javase/11/">https://docs.oracle.com/en/java/javase/11/</a></p><p><a href="https://docs.oracle.com/javase/8/">https://docs.oracle.com/javase/8/</a></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BABFAFAE">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BABFAFAE</a></p><p><a href="https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-379B3888-FE24-4C3F-9E38-26434EB04F89">https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-379B3888-FE24-4C3F-9E38-26434EB04F89</a></p><p><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE__BABFAFAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE__BABFAFAE</a></p><p><a href="https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html#advanced-garbage-collection-options-for-java">https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html#advanced-garbage-collection-options-for-java</a></p><p><a href="https://masteranyfield.com/2021/05/13/gcs-of-jvm-tuning-pspo-vs-cms-vs-g1/">https://masteranyfield.com/2021/05/13/gcs-of-jvm-tuning-pspo-vs-cms-vs-g1/</a></p><p><a href="https://www.oracle.com/technical-resources/articles/javame/garbagecollection2.html">https://www.oracle.com/technical-resources/articles/javame/garbagecollection2.html</a></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html</a></p><p><a href="https://xie.infoq.cn/article/317ccdfabd7694a093925f7fe">https://xie.infoq.cn/article/317ccdfabd7694a093925f7fe</a></p><p><a href="https://sematext.com/blog/java-garbage-collection-tuning/#starting-gc-tuning">https://sematext.com/blog/java-garbage-collection-tuning/#starting-gc-tuning</a></p><p><a href="https://zhuanlan.zhihu.com/p/161710652?spm=a2c6h.12873639.article-detail.15.7a8b1da3cPF1W0">https://zhuanlan.zhihu.com/p/161710652?spm=a2c6h.12873639.article-detail.15.7a8b1da3cPF1W0</a></p><p><a href="https://developer.aliyun.com/article/978505">https://developer.aliyun.com/article/978505</a></p><p><a href="http://www.yishuifengxiao.com/2023/10/12/%E4%BB%8E%E9%9B%B6%E7%90%86%E8%A7%A3java%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/">http://www.yishuifengxiao.com/2023/10/12/%E4%BB%8E%E9%9B%B6%E7%90%86%E8%A7%A3java%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/</a></p><p><a href="https://zhuanlan.zhihu.com/p/111886882">https://zhuanlan.zhihu.com/p/111886882</a></p><p><a href="https://www.cnblogs.com/senlinyang/p/8717611.html">https://www.cnblogs.com/senlinyang/p/8717611.html</a></p><p><a href="https://www.cnblogs.com/lindev/articles/15467748.html">https://www.cnblogs.com/lindev/articles/15467748.html</a></p><p><a href="https://blog.csdn.net/feiyanaffection/article/details/124019544">https://blog.csdn.net/feiyanaffection/article/details/124019544</a></p><p><a href="https://www.cnblogs.com/hongdada/p/14578950.html">https://www.cnblogs.com/hongdada/p/14578950.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/628682897">https://zhuanlan.zhihu.com/p/628682897</a></p><p><a href="https://stackoverflow.com/questions/67232199/how-to-reduce-time-taken-on-threads-reaching-safepoint-sync-state">https://stackoverflow.com/questions/67232199/how-to-reduce-time-taken-on-threads-reaching-safepoint-sync-state</a></p><p><a href="https://juejin.cn/post/7068858769706319879">https://juejin.cn/post/7068858769706319879</a></p><p><a href="https://segmentfault.com/a/1190000039411521">https://segmentfault.com/a/1190000039411521</a></p><p><a href="https://hesey.wang/2018/11/gc-oriented-java-programming.html#comments">https://hesey.wang/2018/11/gc-oriented-java-programming.html#comments</a></p><p><a href="https://juejin.cn/post/7109664057002557470#heading-11">https://juejin.cn/post/7109664057002557470#heading-11</a></p><p><a href="https://zhuanlan.zhihu.com/p/193037071">https://zhuanlan.zhihu.com/p/193037071</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 进程内存占用及可观测性调研&amp;内存异常排查最佳实践</title>
      <link href="/article/Java-Memory/"/>
      <url>/article/Java-Memory/</url>
      
        <content type="html"><![CDATA[<p>在以往实践中 IoTDB 团队对 Java 内存发现了一些问题：</p><ol><li>IoTDB 的实际占用内存超过了我们「以往认知 」的 “堆内存 + <code>MAX_DIRECT_MEMORY_SIZE</code>”</li><li>堆外内存泄漏，亟需堆外内存管理的最佳实践</li></ol><p>本文从上述问题出发，以 Java 进程（JVM）的视角，调研其所占内存。力求把「概念」理清，并探究「监控」手段和「最佳实践」，最终达到「补齐」IoTDB 目前相关板块的目的。</p><p><strong>注：作为调研工作，本文大量参考互联网资料（均放在了结尾的 Reference 里），亦有作者的思考与总结。文档难免有疏忽错误，欢迎大家批评指正！可以通过博客上方的 github、邮箱或微信联系我。</strong></p><h1 id="【概念】Java-进程所用内存"><a href="#【概念】Java-进程所用内存" class="headerlink" title="【概念】Java 进程所用内存"></a>【概念】Java 进程所用内存</h1><p>开门见山，先画出 Java 进程所占内存图：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126224519210.png" alt="image-20231126224519210"></p><p>可以看到：</p><ul><li>JVM 的内存被分为了不同的区域，主要由 Java 堆内存、非堆内存组成，在 Linux 上，JVM 通过 glibc 与 OS 进行内存分配与去配。</li><li>我们分析 Java 进程所占内存，可以从上图的各个板块着手切入。</li></ul><p>我们从 Java 提供的原生内存监控工具 Native Memory Tracking(NMT) 切入，一一介绍上图中所涉及的内存板块。这里贴出一段 NMT 的输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Total: reserved=10575644KB, committed=443024KB</span><br><span class="line">-                 Java Heap (reserved=8323072KB, committed=192512KB)</span><br><span class="line">                            (mmap: reserved=8323072KB, committed=192512KB) </span><br><span class="line"> </span><br><span class="line">-                     Class (reserved=1050202KB, committed=10522KB)</span><br><span class="line">                            (classes <span class="comment">#15409)</span></span><br><span class="line">                            (  instance classes <span class="comment">#14405, array classes #1004)</span></span><br><span class="line">                            (malloc=1626KB <span class="comment">#33495) </span></span><br><span class="line">                            (mmap: reserved=1048576KB, committed=8896KB) </span><br><span class="line">                            (  Metadata:   )</span><br><span class="line">                            (    reserved=57344KB, committed=57216KB)</span><br><span class="line">                            (    used=56968KB)</span><br><span class="line">                            (    waste=248KB =0.43%)</span><br><span class="line">                            (  Class space:)</span><br><span class="line">                            (    reserved=1048576KB, committed=8896KB)</span><br><span class="line">                            (    used=8651KB)</span><br><span class="line">                            (    waste=245KB =2.75%)</span><br><span class="line"> </span><br><span class="line">-                    Thread (reserved=669351KB, committed=41775KB)</span><br><span class="line">                            (thread <span class="comment">#653)</span></span><br><span class="line">                            (stack: reserved=667648KB, committed=40072KB)</span><br><span class="line">                            (malloc=939KB <span class="comment">#3932) </span></span><br><span class="line">                            (arena=764KB <span class="comment">#1304)</span></span><br><span class="line"> </span><br><span class="line">-                      Code (reserved=50742KB, committed=17786KB)</span><br><span class="line">                            (malloc=1206KB <span class="comment">#9495) </span></span><br><span class="line">                            (mmap: reserved=49536KB, committed=16580KB) </span><br><span class="line">.... 后面省略</span><br></pre></td></tr></table></figure><p>可以看到，Java 进程所占内存项有 Java Heap、Class、Thread、Code 等等。</p><p>除了 Native Memory Tracking 记录的内存使用，还有两种内存 <strong>Native Memory Tracking 没有记录</strong>，那就是：</p><ul><li>MMap Buffer：文件映射内存</li><li>JNI 方法里的内存分配</li></ul><p>这些内存项可以分为：「Java 堆内存」和「非（Java）堆内存」。后文将基于这一分类展开，一一进行介绍。</p><h2 id="Java-堆内存"><a href="#Java-堆内存" class="headerlink" title="Java 堆内存"></a>Java 堆内存</h2><p><strong>Java</strong> <strong>堆内存</strong>，所有 Java 对象分配占用内存的来源，由 JVM GC 管理回收。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//堆内存占用，reserve 了 8323072KB，当前 commit 了 192512KB 用于实际使用</span><br><span class="line">Java Heap (reserved=8323072KB, committed=192512KB) </span><br><span class="line">          (mmap: reserved=8323072KB, committed=192512KB)</span><br><span class="line">          //堆内存都是通过 mmap 系统调用方式分配的</span><br></pre></td></tr></table></figure><p>需要注意的是：<strong>堆</strong>这个词可以指代很多，操作系统里有堆；JVM 中有堆；Java 中还有 native 堆（C heap）</p><ul><li>我们一般说的「堆内存」在 Java 开发语境下指的是「Java 堆内存」</li><li>而 C heap 虽然也可以叫「堆内存」，但在 Java 开发语境下实际上习惯被划分到「非堆内存」</li></ul><p>因此为了严谨，本文对于 Java 开发语境下的「堆内存」统一叫为「Java 堆内存」</p><p>JVM 堆内存是分代的，分为 Young、Old Generation。</p><p>我们经常看到的可能是 <code>Xmx</code> 以及 <code>Xms</code> 这两个参数：</p><ul><li><code>Xmx</code>：对应 <strong>最大堆大小</strong> <code>MaxHeapSize</code></li><li><code>Xms</code>：相当于同时设置<strong>最小堆*大小</strong><code>MinHeapSize</code> 和<strong>初始堆大小</strong><code>InitialHeapSize</code></li></ul><p><em>这部分大家经常打交道，都比较熟悉，不多赘述。</em></p><h2 id="非堆内存"><a href="#非堆内存" class="headerlink" title="非堆内存"></a>非堆内存</h2><h3 id="什么是非堆内存-堆外内存？"><a href="#什么是非堆内存-堆外内存？" class="headerlink" title="什么是非堆内存&#x2F;堆外内存？"></a>什么是非堆内存&#x2F;堆外内存？</h3><p>这里要明晰一个概念：</p><p><strong>非<em>堆内存</em>：</strong>是指不受到 Java 堆垃圾回收直接管理的内存。</p><ul><li>从 JVM 内存模型角度来看，甚至方法区也属于非堆内存（即使在主流 JVM 实现中，方法区内部包含堆内存实现），包括 Java 方法栈区内存和 native 内存等都属于非堆内存。</li></ul><p><strong>堆外<em>内存</em>：</strong>理论上语义等同于非堆内存。<strong>但笔者在调研时，发现实际上很多语境下特指 DirectMemory（java.nio.DirectByteBuffer）</strong></p><p>二者有区别！为了明确概念，避免混淆<strong>，</strong>本文中：</p><ol><li>非堆内存是指不受到 Java 托管堆垃圾回收管理的内存</li><li>堆外内存特指 DirectMemory（native heap）</li></ol><h4 id="堆外内存有什么好处？"><a href="#堆外内存有什么好处？" class="headerlink" title="堆外内存有什么好处？"></a>堆外内存有什么好处？</h4><p>使用堆外内存（DirectMemory）的好处主要有以下两个：</p><ul><li>避免堆内内存 Full GC 造成的 stop-the-world 延迟，当然也可以降低 OOM 风险，前提是要妥善管理堆外内存</li><li>绕过用户态到内核态的切换，实现高效数据读写，如<a href="https://www.jianshu.com/p/193cae9cbf07">零拷贝和内存映射</a>。（一般 nio 中它可以减少一次 Java 堆向native 堆做的内存拷贝以及可以直接做 Memory Mapping 以提高速度。）</li></ul><p>因此 Spark、Flink、Kafka 等这些鼎鼎大名的大数据组件都会积极地使用堆外内存，Netty 也有大量使用。</p><p><strong>补充：</strong></p><ol><li><strong>为什么堆外<em>内存</em>能提高</strong> <strong>I&#x2F;O</strong> <strong>效率？</strong></li></ol><ul><li>因为从堆内向磁盘&#x2F;网卡读写数据时，数据会被先复制到堆外内存，然后堆外内存的数据被拷贝到硬件，如下图所示，直接写入堆外内存可避免堆内到堆外的一次数据拷贝。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126224721428.png" alt="image-20231126224721428"></p><ol><li><strong>为什么<em>操作系统</em>一定要将 Java 数据拷贝到堆外<em>内存</em>再进行</strong> <strong>I&#x2F;O</strong> <strong>呢？</strong></li></ol><p>这是由于<code>write、read</code>等函数进行系统调用时，参数传的是内存地址，而 JVM 进行 GC 时，会对 Java 堆进行碎片整理，移动对象在内存中的位置，进而导致内存地址的变化。如果在 I&#x2F;O 操作进行中发生了 GC，内存地址发生变化，I&#x2F;O 操作的数据就全乱套了。而堆外内存是不受 GC 控制的，因此需要把数据拷贝到堆外内存之后再进行 I&#x2F;O 操作。</p><p>（R 大在知乎上有更详细的回答，感兴趣的可以看下）</p><blockquote><p>这里其实是在迁就 OpenJDK 里的 HotSpot VM 的一点实现细节。</p><p>HotSpot VM 里的 GC 除了 CMS 之外都是要移动对象的，是所谓“compacting GC”。</p><p>如果要把一个Java里的 byte[] 对象的引用传给native代码，让native代码直接访问数组的内容的话，就必须要保证native代码在访问的时候这个 byte[] 对象不能被移动，也就是要被“pin”（钉）住。</p><p>可惜 HotSpot VM 出于一些取舍而决定不实现单个对象层面的 object pinning，要 pin 的话就得暂时禁用 GC——也就等于把整个 Java 堆都给 pin 住。</p><p>所以 Oracle&#x2F;Sun JDK &#x2F; OpenJDK 的这个地方就用了点绕弯的做法。它假设把 HeapByteBuffer 背后的 byte[] 里的内容拷贝一次是一个时间开销可以接受的操作，同时假设真正的 I&#x2F;O 可能是一个很慢的操作。</p><p>于是它就先把 HeapByteBuffer 背后的 byte[] 的内容拷贝到一个 DirectByteBuffer 背后的 native memory去，这个拷贝会涉及 sun.misc.Unsafe.copyMemory() 的调用，背后是类似 memcpy() 的实现。<strong>这个操作本质上是会在整个拷贝过程中暂时不允许发生</strong> <strong>GC</strong> <strong>的。</strong></p><p>然后数据被拷贝到 native memory 之后就好办了，就去做真正的 I&#x2F;O，把 DirectByteBuffer 背后的 native memory 地址传给真正做 I&#x2F;O 的函数。这边就不需要再去访问 Java 对象去读写要做 I&#x2F;O 的数据了。</p></blockquote><h3 id="非堆内存有哪些？"><a href="#非堆内存有哪些？" class="headerlink" title="非堆内存有哪些？"></a>非堆内存有哪些？</h3><p>承接上文 NMT 的各项补充展开说明。此处整理各网络资料：</p><ol><li><strong>Java Class</strong>，JVM 将类文件加载到内存中用于后续使用所占用的空间，注意是 JVM C++ 层面的内存占用，主要包括类文件中在 JVM 解析为 C++ 的 Klass 类（Klass 是 JVM 源码中的一个 C++ 类，可以理解为类在 JVM 中的内存形式）以及相关元素，对应的 Java 反射类 Class 还是在堆内存空间中。</li></ol><ul><li><p>包含两部分：</p><ul><li><p>一是 metadata，被<code>-XX:MaxMetaspaceSize</code>限制最大大小。对应我们比较熟悉的 <strong>Metaspace</strong>。</p></li><li><p>二是 class space，被<code>-XX:CompressedClassSpaceSize</code>限制最大大小。对应我们比较熟悉的 <strong>Compressed Class Space。</strong></p></li><li><p>对于 metaspace 和 compressed class space，补充说明：</p></li><li><blockquote><p>元空间保存的数据，目前分为两大类：</p><ul><li><strong>Java 类数据</strong>：即加载的 Java 类对应 JVM 中的 Klass 对象，但是这个 Klass 对象中存储的很多数据都是指针，具体的数据存储属于非 Java 类数据，一般非 Java 类数据远比 Java 类数据占用空间大。</li><li><strong>非 Java 类数据</strong>：即被 Klass 对象引用的一些数据，例如：类中的各种方法，注解，执行采集与统计信息、静态变量等等。</li></ul><p>如果是 64 位的 JVM 虚拟机，并且开启了压缩类指针(-XX:+UseCompressedClassPointers，默认是开启的)，那么元空间会被划分成两部分：</p><ul><li><strong>类元空间</strong>：存储上面说的<strong>Java 类数据</strong>的空间（compressed class space）</li><li><strong>数据元空间</strong>：存储上面说的<strong>非 Java 类数据</strong>的空间（metaspace）</li></ul></blockquote></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reserved、committed、used 含义，后文有详细介绍 ：Java 内存占用分类 &amp; 观测手段 调研</span></span><br><span class="line"><span class="comment">// reserved: 在 Java 进程虚拟地址空间中保留的内存空间，但是没有分配到物理内存中。</span></span><br><span class="line"><span class="comment">// 通过 OS 的 page fault 来实际分配到物理内存（RAM 或 swap space）</span></span><br><span class="line"><span class="comment">// committed: 已经分配并与物理内存关联的内存空间，Java 进程可以被保证并直接使用。</span></span><br><span class="line"><span class="comment">// used: Java 进程实际已经使用的内存，通常 ≤ committed 大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 是类元空间总占用，reserve 了 1050202KB，当前 commit 了 10522KB 用于实际使用</span></span><br><span class="line"><span class="comment">// 总共 reserved 1050202KB = mmap reserved 1048576KB + malloc 1626KB</span></span><br><span class="line"><span class="comment">// 总共 committed 10522KB = mmap committed 8896KB + malloc 1626KB</span></span><br><span class="line"><span class="title class_">Class</span> (reserved=1050202KB, committed=10522KB)</span><br><span class="line">            (classes #<span class="number">15409</span>) <span class="comment">// 一共加载了 15409 个类</span></span><br><span class="line">            (  instance classes #<span class="number">14405</span>, array classes #<span class="number">1004</span>) <span class="comment">// 其中 14405 个实体类，1004 个数组类</span></span><br><span class="line">            (malloc=1626KB #<span class="number">33495</span>) <span class="comment">// 通过 malloc 系统调用方式一共分配了 1626KB，一共调用了 33495 次 malloc</span></span><br><span class="line">            (<span class="attr">mmap</span>: reserved=1048576KB, committed=8896KB) <span class="comment">// 通过 mmap 系统调用方式 reserve 了 1048576KB，当前 commit 了 8896KB 用于实际使用</span></span><br><span class="line">            (  <span class="title class_">Metadata</span>:   )<span class="comment">// 注意，MetaData 这块不属于类元空间，属于数据元空间</span></span><br><span class="line">            (    reserved=57344KB, committed=57216KB) <span class="comment">// 数据元空间当前 reserve 了 57344KB，commit 了 57216KB 用于实际使用</span></span><br><span class="line">            (    used=56968KB) <span class="comment">// 但是实际从 MetaChunk 的角度去看使用，只有 56968KB 用于实际数据的分配，有 248KB 的浪费</span></span><br><span class="line">            (    waste=248KB =<span class="number">0.43</span>%)</span><br><span class="line">            (  <span class="title class_">Class</span> <span class="attr">space</span>:)</span><br><span class="line">            (    reserved=1048576KB, committed=8896KB) <span class="comment">// 类元空间当前 reserve 了 1048576KB，commit 了 8896KB 用于实际使用</span></span><br><span class="line">            (    used=8651KB) <span class="comment">// 但是实际从 MetaChunk 的角度去看使用，只有 8651KB 用于实际数据的分配，有 245KB 的浪费</span></span><br><span class="line">            (    waste=245KB =<span class="number">2.75</span>%)</span><br><span class="line"><span class="title class_">Shared</span> <span class="keyword">class</span> <span class="title class_">space</span> (reserved=12032KB, committed=12032KB) <span class="comment">// 共享类空间，当前 reserve 了 12032KB，commit 了 12032KB 用于实际使用，这块其实属于上面 Class 的一部分</span></span><br><span class="line">            (<span class="attr">mmap</span>: reserved=12032KB, committed=12032KB) </span><br><span class="line"><span class="title class_">Module</span> (reserved=403KB, committed=403KB) <span class="comment">// 加载并记录模块占用空间，当前 reserve 了 403KB，commit 了 403KB 用于实际使用</span></span><br><span class="line">            (malloc=403KB #<span class="number">2919</span>) </span><br><span class="line"><span class="title class_">Metaspace</span> (reserved=57606KB, committed=57478KB) <span class="comment">// 等价于上面 Class 中的 MetaChunk（除了 malloc 的部分），当前 reserve 了 57606KB，commit 了 57478KB 用于实际使用</span></span><br><span class="line">            (malloc=262KB #<span class="number">180</span>) </span><br><span class="line">            (<span class="attr">mmap</span>: reserved=57344KB, committed=57216KB) </span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Symbol：</strong>加载类的时候，有很多字符串信息，不同类的字符串信息可能会重复。所以统一放入符号表复用。 包含 SymbolTable:（存储 names signatures）和 StringTable:（存储 interned strings）。可以通过<code>-XX:+PrintStringTableStatistics</code>打印具体的信息</li></ol><ul><li>StringTable 这个数据结构的大小受<code>-XX:StringTableSize</code>限制，但总内存大小不受限制。</li></ul><blockquote><p>StringTable 是一个本地固定大小的哈希表，其用来保存内部字符串。<code>String.intern()</code> 被调用时会往 StringTable 插入一个 String（若该 String 不存在）</p><p>我们能够通过-XX:StringTableSize 标志配置 StringTable 的大小，-XX:StringTableSize 的含义是：Number of buckets in the interned String table</p><p>该参数主要 trade off 了哈希碰撞概率和哈希表内存大小，参数越大，StringTable 占用内存越大，但插入速度越快。参数越小，StringTable 占用内存越小，但由于哈希碰撞插入速度慢。</p><p>（<a href="https://www.baeldung.com/native-memory-tracking-in-jvm%E3%80%81https://www.baeldung.com/java-string-pool%EF%BC%89">https://www.baeldung.com/native-memory-tracking-in-jvm、https://www.baeldung.com/java-string-pool）</a></p><p>经过经过实测和调研，从 Java 7u40 到 JDK11 <strong>默认大小</strong>是 60013 ，JDK11及其之后是 65536。下图是 JDK 17 的默认大小：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126224803251.png"></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Symbol</span> (reserved=18629KB, committed=18629KB)(malloc=16479KB #<span class="number">445877</span>) <span class="comment">// 通过 malloc 系统调用方式一共分配了 16479KB，一共调用了 445877 次 malloc(arena=2150KB #1) //通过 arena 系统调用方式一共分配了 2150KB，一共调用了 1 次 arena</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>Thread：线程占用*内存</strong>，主要是每个线程的线程栈，一般也主要关注线程栈占用空间，其他的管理线程占用的空间很小，可以忽略不计。</li></ol><blockquote><p>JVM 中比较消耗内存的数据区域之一，它与每个线程同时创建。 线程栈存储局部变量和部分结果，在方法调用中发挥着重要作用。根据 Oracle jdk 官网的说明，默认线程堆栈大小取决于平台，在大多数现代 64位操作系统中（Linux、<em>MacOS</em>），为 <strong>1 MB</strong>（jdk8、11、17 均一致）</p><p>（<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html%E3%80%81https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE%E3%80%81https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html%EF%BC%89">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html、https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE、https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html）</a></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126224803251.png" alt="image-20231126224803251"></p></blockquote><ul><li><p>每个线程栈占用大小受<code>-Xss</code>限制，但是总大小没有限制，当线程数量没有限制时，分配给堆栈的总内存实际上是无限的。</p><ul><li>如果该值设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢出的可能性更大。</li><li>如果该值设置过大，可能会影响系统整体的内存。</li></ul></li><li><p>-Xss 调优：JVM 的默认值一般偏高（1M），意在保证不受线程栈溢出的影响。<strong>可以根据项目情况和经验调小。</strong></p><ul><li>调研网络资料，建议栈深度设置在 3000-5000（调用深度）即 -Xss256K 或 -Xss512K，一般 512K 设置的比较多（<a href="https://zhuanlan.zhihu.com/p/243064867%EF%BC%89">https://zhuanlan.zhihu.com/p/243064867）</a></li><li>实验显示，-Xss512K 时，较简单的函数调研（无参）可以支持 16979 的调用深度（<a href="https://cloud.tencent.com/developer/article/1888586%EF%BC%89">https://cloud.tencent.com/developer/article/1888586）</a></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//总共 reserve 了 669351KB，commit 了 41775KB</span></span><br><span class="line"><span class="title class_">Thread</span> (reserved=669351KB, committed=41775KB)</span><br><span class="line">    (thread #<span class="number">653</span>)<span class="comment">//当前线程数量是 653，每个线程栈大小是 1M，固 reserved 是 653 * 1024 = 667648KB，当前 commit 了 40072KB 用于实际使用</span></span><br><span class="line">    (<span class="attr">stack</span>: reserved=667648KB, committed=40072KB) <span class="comment">//线程栈占用的空间：我们没有指定 Xss，默认是 1MB</span></span><br><span class="line">    (malloc=939KB #<span class="number">3932</span>) <span class="comment">//通过 malloc 系统调用方式一共分配了 939KB，一共调用了 3932 次 malloc</span></span><br><span class="line">    (arena=764KB #<span class="number">1304</span>)  <span class="comment">//通过 JVM 内部 Arena 分配的内存，一共分配了 764KB，一共调用了 1304 次 Arena 分配</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>Code：</strong><a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM1NjY5NQ==&mid=2247484493&idx=1&sn=676fe0aa750dc99c5712aac26b74f933&chksm=fddf4975caa8c063ca69f2ce7a109c7ac15b2becde8811ffb7e7c0b9976c8c77fa30d0cf2edf&token=1373220626&lang=zh_CN#rd">JIT 编译器</a>编译后（<a href="https://zhuanlan.zhihu.com/p/355304828">C1 C2 编译器</a>优化）的代码占用空间</li></ol><ul><li>受<code>-XX:ReservedCodeCacheSize</code>限制，主要对应我们比较熟悉的 <strong>Code Cache</strong></li></ul><blockquote><p>为了在不同的平台上运行 JVM 字节码，JIT 编译器需要将代码编译转换为机器码。</p><p>当 JVM 编译字节码到汇编指令时，它保存这些指令在一个特殊的非堆区域，该区域称为 <em>CodeCache</em>。JVM 可以像管理其他区域一样管理 CodeCache。<code>-XX:InitialCodeCacheSize</code> 和 <code>-XX:ReservedCodeCacheSize</code> 标记决定了CodeCache 的初始值和可能的最大值。</p><ul><li>根据 Oracle jdk 官网说明，initialCodeCacheSize 的默认值取决于平台，但不能比 OS 的 minimal page size 更小。对于 Unix和 windows，默认大小是 500KB</li><li>默认最大 Code Cache 大小为 240 MB； 如果使用选项 -XX:-TieredCompilation 禁用分层编译，则默认大小为 48 MB。 <code>-XX:ReservedCodeCacheSize</code> 的限制为 2 GB， 否则会产生错误。</li><li>如果 Code cache 内存占用超过上限，会停止JIT编译。同时还会收到 “CodeCache is full… The compiler has been disabled” 之类的告警消息</li></ul><p>（<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html%E3%80%81https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html%E3%80%81https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html%EF%BC%89">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html、https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html、https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html）</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Code</span> (reserved=50742KB, committed=17786KB)</span><br><span class="line">(malloc=1206KB #<span class="number">9495</span>) </span><br><span class="line">(<span class="attr">mmap</span>: reserved=49536KB, committed=16580KB) </span><br></pre></td></tr></table></figure><ol start="5"><li><strong>Compiler：</strong>JIT 编译器(C1 C2 编译器)本身占用的空间和标记占用的内存，不受限制，一般比较小。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Compiler</span> (reserved=159KB, committed=159KB)</span><br><span class="line">(malloc=29KB #<span class="number">813</span>) </span><br><span class="line">(arena=131KB #<span class="number">3</span>)   </span><br></pre></td></tr></table></figure><ol start="6"><li><strong>Arena 数据结构占用空间</strong>，所有通过 <a href="https://www.zhihu.com/question/439269671">arena </a>方式分配的内存。我们看到 Native Memory Tracking 中有很多通过 arena 分配的内存，这个就是管理 Arena 数据结构占用空间。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Arena</span> <span class="title class_">Chunk</span> (reserved=187KB, committed=187KB)(malloc=187KB) </span><br></pre></td></tr></table></figure><ol start="7"><li><strong>JVM</strong> <strong>Tracing 占用*内存</strong>，所有采集占用的内存。包括 JVM perf 以及 <a href="https://zhuanlan.zhihu.com/p/122247741">JFR</a> 占用的空间，如果开启了 JFR 则主要是 JFR 占用的内存。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Tracing</span> (reserved=32KB, committed=32KB)(arena=32KB #<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ol start="8"><li><strong>JVM</strong> <strong>GC</strong> <strong>需要的数据结构与记录信息占用的空间</strong>，例如垃圾回收需要的 CardTable，标记数，区域划分记录，还有标记 GC Root 等等。这块内存可能会比较大，尤其是对于那种专注于低延迟的 GC，例如 ZGC。（ZGC 是一种以空间换时间的思路，提高 CPU 消耗与内存占用，但是消灭全局暂停）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GC</span> (reserved=370980KB, committed=69260KB)(malloc=28516KB #<span class="number">8340</span>) </span><br><span class="line">(<span class="attr">mmap</span>: reserved=342464KB, committed=40744KB) </span><br></pre></td></tr></table></figure><ol start="9"><li><strong>Direct Buffer &amp; Other</strong>：直接内存。在 NMT 中表现为 “Other”，意为：其他占用 (不是 JVM 本身而是操作系统的某些系统调用导致额外占的空间)。此项为我们大多数使用的非堆内存，也是「堆外内存」一词通常所指。</li></ol><ul><li>这里说的堆外内存主要针对 <code>java.nio.DirectByteBuffer</code>，这些对象的创建过程会通过 Unsafe 接口直接通过 <code>os::malloc</code> 来分配内存，然后将内存的起始地址和大小存到 <code>java.nio.DirectByteBuffer</code> 对象里，这样就可以直接操作这些内存。这些内存要么在 DirectByteBuffer 回收掉之后才有机会被回收，要么被程序员手动回收。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Other</span> (reserved=12348KB, committed=12348KB)(malloc=12348KB #<span class="number">14</span>) </span><br></pre></td></tr></table></figure><p>还有两项 NMT 没有列出，但非常重要的堆外内存：</p><ol start="10"><li><strong>MMap</strong> <strong>Buffer</strong>：Java 文件映射内存大小，也是我们在 I&#x2F;O 中经常用到的非堆内存，可以通过 JMX 监控</li></ol><blockquote><p>Java 中的内存映射缓存区（Memory-mapped buffer）是一种将文件或文件的一部分直接映射到程序内存中的技术。简单来说，内存映射缓存区允许 Java 程序在处理文件时像处理一个非常大的字节数组一样进行操作，而不用担心过多的 I&#x2F;O 负担或频繁的磁盘访问。</p></blockquote><ol start="11"><li><strong>Native 分配：</strong>即直接调用 malloc 分配的，如 JNI 调用、磁盘与网络 io 操作等，可通过 pmap 命令、malloc_stats 函数观测。</li></ol><p><strong>以下几种堆外<em>内存</em>比较小，我们一般不会关心：</strong></p><ol start="12"><li><p><strong>Logging：</strong>写 JVM 日志占用的内存</p><ol><li>日志是指<code> -Xlog</code> 参数指定的日志输出</li><li>Java 17 之后引入了异步 JVM 日志<code>-Xlog:async</code>（<a href="https://bugs.openjdk.org/browse/JDK-8229517%EF%BC%89">https://bugs.openjdk.org/browse/JDK-8229517）</a></li></ol><ul><li>「异步日志」是指写日志动作与主应用程序是异步的，降低了写日志开销</li><li>异步日志所需的 buffer 也在这里</li></ul></li></ol><blockquote><p>日志用法：<a href="https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html#xlog-usage-examples">https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html#xlog-usage-examples</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Logging</span> (reserved=5KB, committed=5KB)(malloc=5KB #<span class="number">216</span>) </span><br></pre></td></tr></table></figure><ol start="13"><li><strong>Arguments：</strong>JVM 参数占用内存，我们需要保存并处理当前的 JVM 参数以及用户启动 JVM 的是传入的各种参数（有时候称为 flag）。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Arguments</span> (reserved=31KB, committed=31KB)(malloc=31KB #<span class="number">90</span>) </span><br></pre></td></tr></table></figure><ol start="14"><li><strong>Safepoint：</strong>JVM 安全点占用内存，是固定的两页内存（这个页大小与操作系统相关），用于 JVM 安全点的实现，不会随着 JVM 运行时的内存占用而变化。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Safepoint</span> (reserved=8KB, committed=8KB)(<span class="attr">mmap</span>: reserved=8KB, committed=8KB) </span><br></pre></td></tr></table></figure><ol start="15"><li><strong>Synchronization：</strong>Java 同步机制（例如 <code>synchronized</code>，还有 AQS 的基础 <code>LockSupport</code>）底层依赖的 C++ 的数据结构，系统内部的 mutex 等占用的内存。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Synchronization</span> (reserved=56KB, committed=56KB)(malloc=56KB #<span class="number">789</span>)</span><br></pre></td></tr></table></figure><ol start="16"><li><strong>Serviceability：</strong>JVM TI 相关内存。</li></ol><blockquote><p>JVMTI 是 Java 虚拟机工具接口（Java Virtual Machine Tool Interface）的缩写。它是 Java 虚拟机（JVM）的一部分，提供了一组 API，使开发人员可以开发自己的 Java 工具和代理程序，以监视、分析和调试 Java 应用程序。</p><p>JVMTI API 是一组 C&#x2F;C++ 函数，可以通过 JVM TI Agent Library 和 JVM 进行交互。开发人员可以使用 JVMTI API 开发自己的 JVM 代理程序或工具，以监视和操作 Java 应用程序。例如，可以使用 JVMTI API 开发性能分析工具、代码覆盖率工具、内存泄漏<a href="https://cloud.tencent.com/product/tools?from_column=20065&from=20065">检测工具</a>等等。</p></blockquote><ul><li>这里的内存就是调用了 JVMTI API 之后 JVM 为了生成数据占用的内存<strong>。</strong></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Serviceability</span> (reserved=1KB, committed=1KB)(malloc=1KB #<span class="number">18</span>) </span><br></pre></td></tr></table></figure><ol start="17"><li><strong>String Deduplication：</strong>Java 字符串去重占用内存。</li></ol><ul><li>这是一种字符串去重的机制，该机制只有在 G1GC 中才能使用（<a href="https://openjdk.org/jeps/192%EF%BC%89%EF%BC%8C%E6%89%80%E4%BB%A5%E9%BB%98%E8%AE%A4%E6%98%AF%E5%85%B3%E9%97%AD%E7%9A%84%E3%80%82%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87">https://openjdk.org/jeps/192），所以默认是关闭的。可以通过</a> <code>-XX:+UseStringDedupl``ication</code> + <code>-XX:UseG1GC</code>来启用。</li></ul><blockquote><p><strong>String Deduplication 实现</strong>：</p><ul><li>当 G1 工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的 string 对象。</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。当有空闲 CPU 周期可用时，该线程会扫描堆，查找重复的字符串。</li><li>使用一个 hashtable 来记录所有的被 string 对象使用的不重复的 char 数组。当去重的时候，会查这个 hashtable，来看堆上是否已经存在一个一模一样的 char 数组。当找到两个具有相同值的不同 string 时 ，将对它们进行重复数据删除。<ul><li>仅处理在一定的最小 GC 周期数（默认为 3 个）后幸存下来的字符串，以避免在非常短命的对象上浪费精力，从统计上看，这些对象很有可能成为垃圾。</li></ul></li><li>如果存在一模一样的 char 数组，string 对象会被调整为引用那个数组，释放对原来数组的引用，最终被 G1 回收掉。</li><li>如果不存在，char 数组会被插入到 hashtable，这样以后其他相同的字符串可以共享该数组。</li></ul><p><strong>与 string.intern() 的区别</strong></p><ul><li>String Deduplication：如果有 1000 个不同的 String 对象，它们都具有相同的内容“abc”，JVM 可以让它们在内部共享相同的 char[]，但是仍然有 1000 个不同的 String 对象。</li><li>String.intern()：使用 intern()，将只有一个 String 对象。 因此，如果关心节省内存，那么 intern() 会更好。 它将节省空间以及 GC 时间。但缺点是有时需要手动调用 <code>intern()</code></li></ul><p>（<a href="https://stackoverflow.com/questions/32854968/java-8-string-deduplication-vs-string-intern%E3%80%81https://dzone.com/articles/duplicate-strings-how-to-get-rid-of-them-and-save%E3%80%81[JEP">https://stackoverflow.com/questions/32854968/java-8-string-deduplication-vs-string-intern、https://dzone.com/articles/duplicate-strings-how-to-get-rid-of-them-and-save、[JEP</a> 192: String Deduplication in G1](<a href="http://openjdk.java.net/jeps/192)%EF%BC%89">http://openjdk.java.net/jeps/192)）</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span> <span class="title class_">Deduplication</span> (reserved=1KB, committed=1KB)(malloc=1KB #<span class="number">8</span>) </span><br></pre></td></tr></table></figure><ol start="18"><li><strong>Internal：</strong>JVM 内部不属于其他类别的内存占用，不会很大</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Internal</span> (reserved=1373KB, committed=1373KB)(malloc=1309KB #<span class="number">6135</span>) </span><br><span class="line">(<span class="attr">mmap</span>: reserved=64KB, committed=64KB) </span><br></pre></td></tr></table></figure><ol start="19"><li><strong>Native Memory Tracking*：</strong>开启 Native Memory Tracking 本身消耗的内存</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Native</span> <span class="title class_">Memory</span> <span class="title class_">Tracking</span> (reserved=8426KB, committed=8426KB)(malloc=325KB #<span class="number">4777</span>) </span><br><span class="line">(tracking overhead=8102KB)</span><br></pre></td></tr></table></figure><h3 id="非堆内存与-GC"><a href="#非堆内存与-GC" class="headerlink" title="非堆内存与 GC"></a>非堆内存与 GC</h3><p><strong>结论：</strong>理论上非堆内存中，只有 DirectBuffer（堆外内存）可以被 gc 回收。其他部分都直接由操作系统&#x2F; native 库管理。在编程中：</p><ul><li>对于 DirectBuffer ，要注意结合<code>-XX:MaxDirectMemorySize</code>与 full gc 控制内存泄漏问题，必要时手动管理</li><li>对于其他非堆内存，要手动做好内存分配去配（malloc&#x2F;free）管理</li></ul><p>由于 DirectBuffer（堆外内存）可以通过 JVM 的 DirectBuffer 对象管理，<strong>因此</strong> <strong>gc</strong> <strong>可以通过回收 D<em>i</em>rectBuffer 对象来回收其关联的堆外内存</strong>。这也是为什么会有如下现象：</p><blockquote><p>DirectByteBuffer 对象本身其实是很小的，但是它后面可能关联了一个非常大的堆外内存，因此我们通常称之为<strong>『冰山对象』。</strong></p><p>ygc 时会将新生代里的不可达的 DirectByteBuffer 对象及其堆外内存回收，但是无法对 old 里的 DirectByteBuffer 对象及其堆外内存进行回收。因此如果有大量的 DirectByteBuffer 对象移到了 old，但是又一直没有做 full gc，而只进行 ygc，且 -XX:MaxDirectMemory 没有正确设置，那么可能会发生堆外内存泄漏。</p></blockquote><blockquote><p><strong>补充问题：</strong>对于 g1 这种 mixed gc 也可以回收老年代 region 的 gc 算法，是不是这个问题会缓解很多？</p><p><strong>实验：</strong>手动添加 100_000_00 次堆外内存，每次添加 1024B，同时手动添加 10_000 次堆内存以触发 mixed gc&#x2F;full gc，并将堆外内存晋升到老年代。对比 CMS 和 G1 的堆外内存回收情况。</p><p><strong>环境：</strong>-XX:+UseG1GC&#x2F;-XX:+UseConcMarkSweepGC -Xmx4g -XX:MaxDirectMemorySize&#x3D;2g </p><p><strong>结论</strong> (将两种 GC 下，堆外内存 used 情况画成折线图)<strong>：</strong></p><ul><li><strong>在<em>内存</em>低负载情况下（x 轴 1471 之前），G1 对于堆外内存的控制优于</strong> <strong>CMS*。</strong>猜测这是由于此时两种 GC 的 full gc 都不多，而 G1 的 mixed gc 能回收老年代 region，CMS 的 young gc 则不行，因此 G1 表现优于 CMS</li><li><strong>在<em>内存</em>高负载情况下（x 轴 1471 之后），*CMS</strong> <strong>对于堆外内存的控制优于 G1。</strong>猜测这是由于此时负载太高了，CMS 主要进行 full gc。而 G1 在 full gc 之余，优先会 mixed gc，而 mixed gc 对于内存的回收效果显然不如 full gc，因此 CMS 表现优于 G1</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225137581.png" alt="image-20231126225137581"></p></blockquote><p>因此我们认为：对于堆外内存，只有 full gc 或者 System.gc() 才能比较彻底的回收，一旦一直触发不了 fullgc 或 System.gc()，后果会比较严重。</p><p>糟糕的是如果 JVM 分配的堆内存空间很大，以至于很少发生老年代的 GC （或者 Full GC），可能会导致一些 <code>DirectByteBuffer</code> 对象虽然已经处于不可达的状态但是却长时间无法被 GC 掉。然后这些对象会一直持有其指向的堆外内存，直到下面的清理方法被调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((DirectBuffer)buf).cleaner().clean();</span><br></pre></td></tr></table></figure><p>虽然 GC 会销毁 DirectByteBuffer 之前调用该方法，但是，如上所述，它可能为时已晚。</p><p>如果我们对管理堆外内存的代码了如指掌，则可以显式调用上述方法。 否则，防止堆外内存过度使用的方法是减小堆内存的大小从而使得 GC 更加频繁，或者依赖<code>-XX:MaxDirectMemorySize</code>的 OOM 检查进行 System.gc()<strong>。</strong></p><blockquote><p><strong>实验验证：</strong>在机器上指定 G1 GC（JDK 11），不断手动添加堆外内存。通过控制 -Xmx 和 -XX:MaxDirectMemory 来研究堆外内存受 GC 的影响。</p><p><strong>实验代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 通过 JMX 打印内存信息 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMemInfo</span><span class="params">()</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;==================================Mem===================================&quot;</span>);</span><br><span class="line">  ManagementFactory.getPlatformMXBeans(MemoryPoolMXBean.class).stream()</span><br><span class="line">      .forEach(</span><br><span class="line">          e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name: &quot;</span> + e.getName() + <span class="string">&quot; / info: &quot;</span> + e.getUsage());</span><br><span class="line">          &#125;);</span><br><span class="line">  ManagementFactory.getPlatformMXBeans(BufferPoolMXBean.class).stream()</span><br><span class="line">      .forEach(</span><br><span class="line">          e -&gt; &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                <span class="string">&quot;name: &quot;</span></span><br><span class="line">                    + e.getName()</span><br><span class="line">                    + <span class="string">&quot; total: &quot;</span></span><br><span class="line">                    + e.getTotalCapacity()</span><br><span class="line">                    + <span class="string">&quot; used: &quot;</span></span><br><span class="line">                    + e.getMemoryUsed());</span><br><span class="line">          &#125;);</span><br><span class="line">  System.out.println(<span class="string">&quot;==================================GC===================================&quot;</span>);</span><br><span class="line">  ManagementFactory.getPlatformMXBeans(GarbageCollectorMXBean.class).stream()</span><br><span class="line">      .forEach(</span><br><span class="line">          e -&gt; &#123;</span><br><span class="line">            System.out.println(e.getName() + <span class="string">&quot;: &quot;</span> + e.getCollectionTime());</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException, IOException &#123;</span><br><span class="line">  List&lt;<span class="type">byte</span>[]&gt; heapMem = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100_000_00</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 通过增加 heap mem 来触发 full gc 或 mixed gc（G1）</span></span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      heapMem.add(bytes);</span><br><span class="line">      printMemInfo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 手动不断分配堆外内存</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  printMemInfo();</span><br></pre></td></tr></table></figure><p><strong>结果如下：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// 限制最大堆内存 2G，堆外内存 1G</span><br><span class="line">name: CodeHeap <span class="string">&#x27;non-nmethods&#x27;</span> / info: init = <span class="number">2555904</span>(2496K) used = <span class="number">1121280</span>(1095K) committed = <span class="number">2555904</span>(2496K) <span class="built_in">max</span> = <span class="number">5849088</span>(5712K)</span><br><span class="line">name: Metaspace / info: init = <span class="number">0</span>(0K) used = <span class="number">8045576</span>(7857K) committed = <span class="number">8519680</span>(8320K) <span class="built_in">max</span> = -<span class="number">1</span>(-1K)</span><br><span class="line">name: CodeHeap <span class="string">&#x27;profiled nmethods&#x27;</span> / info: init = <span class="number">2555904</span>(2496K) used = <span class="number">1836672</span>(1793K) committed = <span class="number">2555904</span>(2496K) <span class="built_in">max</span> = <span class="number">122896384</span>(120016K)</span><br><span class="line">name: Compressed Class Space / info: init = <span class="number">0</span>(0K) used = <span class="number">747256</span>(729K) committed = <span class="number">917504</span>(896K) <span class="built_in">max</span> = <span class="number">1073741824</span>(1048576K)</span><br><span class="line">name: G1 Eden Space / info: init = <span class="number">27262976</span>(26624K) used = <span class="number">60817408</span>(59392K) committed = <span class="number">247463936</span>(241664K) <span class="built_in">max</span> = -<span class="number">1</span>(-1K)</span><br><span class="line">name: G1 Old Gen / info: init = <span class="number">241172480</span>(235520K) used = <span class="number">251638016</span>(245740K) committed = <span class="number">729808896</span>(712704K) <span class="built_in">max</span> = <span class="number">2147483648</span>(2097152K)</span><br><span class="line">name: G1 Survivor Space / info: init = <span class="number">0</span>(0K) used = <span class="number">34603008</span>(33792K) committed = <span class="number">34603008</span>(33792K) <span class="built_in">max</span> = -<span class="number">1</span>(-1K)</span><br><span class="line">name: CodeHeap <span class="string">&#x27;non-profiled nmethods&#x27;</span> / info: init = <span class="number">2555904</span>(2496K) used = <span class="number">871168</span>(850K) committed = <span class="number">2555904</span>(2496K) <span class="built_in">max</span> = <span class="number">122912768</span>(120032K)</span><br><span class="line">name: mapped total: <span class="number">0</span> used: <span class="number">0</span></span><br><span class="line">name: direct total: <span class="number">659278848</span> used: <span class="number">659278848</span></span><br><span class="line"></span><br><span class="line">// 限制最大堆内存 512M，堆外内存 1G</span><br><span class="line">name: CodeHeap <span class="string">&#x27;non-nmethods&#x27;</span> / info: init = <span class="number">2555904</span>(2496K) used = <span class="number">1120000</span>(1093K) committed = <span class="number">2555904</span>(2496K) <span class="built_in">max</span> = <span class="number">5849088</span>(5712K)</span><br><span class="line">name: Metaspace / info: init = <span class="number">0</span>(0K) used = <span class="number">8051904</span>(7863K) committed = <span class="number">8519680</span>(8320K) <span class="built_in">max</span> = -<span class="number">1</span>(-1K)</span><br><span class="line">name: CodeHeap <span class="string">&#x27;profiled nmethods&#x27;</span> / info: init = <span class="number">2555904</span>(2496K) used = <span class="number">1885056</span>(1840K) committed = <span class="number">2555904</span>(2496K) <span class="built_in">max</span> = <span class="number">122896384</span>(120016K)</span><br><span class="line">name: Compressed Class Space / info: init = <span class="number">0</span>(0K) used = <span class="number">747256</span>(729K) committed = <span class="number">917504</span>(896K) <span class="built_in">max</span> = <span class="number">1073741824</span>(1048576K)</span><br><span class="line">name: G1 Eden Space / info: init = <span class="number">27262976</span>(26624K) used = <span class="number">157286400</span>(153600K) committed = <span class="number">191889408</span>(187392K) <span class="built_in">max</span> = -<span class="number">1</span>(-1K)</span><br><span class="line">name: G1 Old Gen / info: init = <span class="number">241172480</span>(235520K) used = <span class="number">187691464</span>(183292K) committed = <span class="number">319815680</span>(312320K) <span class="built_in">max</span> = <span class="number">536870912</span>(524288K)</span><br><span class="line">name: G1 Survivor Space / info: init = <span class="number">0</span>(0K) used = <span class="number">3145728</span>(3072K) committed = <span class="number">3145728</span>(3072K) <span class="built_in">max</span> = -<span class="number">1</span>(-1K)</span><br><span class="line">name: CodeHeap <span class="string">&#x27;non-profiled nmethods&#x27;</span> / info: init = <span class="number">2555904</span>(2496K) used = <span class="number">840192</span>(820K) committed = <span class="number">2555904</span>(2496K) <span class="built_in">max</span> = <span class="number">122912768</span>(120032K)</span><br><span class="line">name: mapped total: <span class="number">0</span> used: <span class="number">0</span></span><br><span class="line">name: direct total: <span class="number">452782080</span> used: <span class="number">452782080</span></span><br></pre></td></tr></table></figure><p>可以看到：当堆内存阈值变小时，GC 更加频繁，堆外内存得到了更好的回收。但是这是以减小堆内存为代价。</p><p><strong>对于 IoTDB 的启示是：</strong></p><ul><li>在保证堆内存够用的前提下， -Xmx 尽量小对于堆外内存回收是有用的。</li><li>尽管如此，对于堆外内存，手动管理回收是更安全的方式。即在合适的时机（如 close() 方法）调用<code>DirectByteBuffer.getCleaner().clean()</code>，手动清理堆外内存，而不是交给 GC（finalize() 方法）</li></ul></blockquote><p>我们通常通过<code>-XX:MaxDirectMemorySize</code>来指定最大的堆外内存大小，当使用达到了阈值的时候将调用System.gc 来做一次 full gc，以此来回收掉没有被使用的堆外内存。</p><ul><li>因此不要轻易显示关闭 System.gc()</li></ul><h2 id="Java-进程内存占用-“misunderstanding”"><a href="#Java-进程内存占用-“misunderstanding”" class="headerlink" title="Java 进程内存占用 “misunderstanding”"></a>Java 进程内存占用 “misunderstanding”</h2><p>明晰了 Java 内存组成，但实际观测时还是会发现：Java 实际占用内存与认知存在一定差距。这是因为存在一些“misunderstanding”：</p><h3 id="JVM-commit-的内存与实际占用内存的差异"><a href="#JVM-commit-的内存与实际占用内存的差异" class="headerlink" title="JVM commit 的内存与实际占用内存的差异"></a>JVM commit 的内存与实际占用内存的差异</h3><p>首先明确 commit、reserve 等概念，对这些比较熟悉的可以直接跳到下一部分了（<a href="https://stackoverflow.com/questions/31173374/why-does-a-jvm-report-more-committed-memory-than-the-linux-process-resident-set%EF%BC%9B%E7%BF%BB%E8%AF%91%E8%B5%B7%E6%9D%A5%E6%80%BB%E6%84%9F%E8%A7%89%E4%B8%8D%E5%A4%AA%E5%87%86%E7%A1%AE%EF%BC%8C%E5%B0%B1%E7%9B%B4%E6%8E%A5%E8%B4%B4%E8%8B%B1%E6%96%87%E4%BA%86%EF%BC%89">https://stackoverflow.com/questions/31173374/why-does-a-jvm-report-more-committed-memory-than-the-linux-process-resident-set；翻译起来总感觉不太准确，就直接贴英文了）</a></p><ol><li><strong>JVM</strong> <strong>自身监控工具里常见的<em>内存</em>概念：</strong></li></ol><p><strong>Used</strong> <strong>Heap</strong>: the amount of memory occupied by live objects according to the last GC</p><p><strong>Reserved</strong>: The total address range that has been pre-mapped via <code>mmap</code> for a particular memory pool. The <em>reserved</em> memory consists of <code>PROT_NONE</code> mappings, which are guaranteed to not be backed by physical memory</p><blockquote><p>“PROT” 是 Linux 里的概念，意为 protection，表示的是对内存映射区域的保护，包括 PROT_READ（可读），PROT_WRITE（可写）， PROT_EXEC（可执行）和 PROT_NONE，即既不可读也不可写更不可执行</p><p>意思就是说，reserved 是通过 PROT_NONE 分配的内存，即在虚存中分配的空间在 kernel 的 vma structs 有 entries，因此不会被其他 mmap&#x2F;malloc calls 所使用。如果其他进程访问这些 reserved 的内存会造成 page fault（SIGSEGV）</p></blockquote><p><strong>Committed</strong>: Address ranges that have been mapped with something other than PROT_NONE. They may or may not be backed by physical or swap due to lazy allocation and paging. </p><p>Committed-but-not-backed-by-storage memory has been mapped with - for example - <code>PROT_READ | PROT_WRITE</code> but accessing it still causes a page fault. But that page fault is silently handled by the kernel by backing it with actual memory and returning to execution as if nothing happened.</p><ol><li><strong>Linux 监控 Java 进程，常见的<em>内存</em>概念：</strong></li></ol><p><strong>Resident</strong>: Pages which are currently in physical RAM. This means code, stacks, part of the committed memory pools but also portions of mmaped files which have recently been accessed and allocations outside the control of the JVM.（即真实使用的物理内存）</p><p><strong>Virtual</strong>: The sum of all virtual address mappings. Covers committed, reserved memory pools but also mapped files or shared memory. This number is rarely informative since the JVM can reserve very large address ranges in advance or mmap large files.（就是说这个数值没啥参考价值）</p><p>我们经常可以在各种监控工具（JMX、上文提到的 NMT 等）看到 JVM commit 的内存。实际上 JVM commit 的内存与在 Linux OS 上的实际占用内存（RSS）是有差异的：</p><p>JVM 中大块内存，基本都是先 reserve 一大块，之后 commit 其中需要的一小块，然后开始读写处理内存。</p><ol><li>commit 之后，<strong>内存<em>并不是立刻被分配了</em>物理内存*，而是真正往内存中 store 东西（写动作）的时候，才会真正映射物理内存，如果是 load 读取也是可能不映射物理内存的。（所谓 lazy allocation）</strong></li><li>还有的差异，主要来源于在 <strong>uncommit 之后，系统可能还没有来的及将这块<em>物理内存</em>真正回收。</strong></li></ol><p>所以，JVM 认为自己 commit 的内存，与实际系统分配的物理内存，可能是有差异的：可能 JVM 认为自己 commit 的内存比系统分配的物理内存多。</p><h3 id="为什么啥都没干，JVM-启动后内存一直在涨"><a href="#为什么啥都没干，JVM-启动后内存一直在涨" class="headerlink" title="为什么啥都没干，JVM 启动后内存一直在涨"></a>为什么啥都没干，JVM 启动后内存一直在涨</h3><p>有的时候这是正常的，原因正是 1.3.1 所提到的。</p><blockquote><p>比如：如果你使用的是 SerialGC，ParallelGC 或者 CMS GC，老年代的内存在有对象晋升到老年代之前，可能是不会映射物理内存的，虽然这块内存已经被 commit 了。如果你用的是 ZGC，G1GC，或者 ShenandoahGC，那么内存用的会更激进些（主要因为分区算法划分导致内存被写入），这是你在换 GC 之后看到物理内存内存快速上涨的原因之一。</p></blockquote><p>假如 JVM 为堆申请的内存是 4.8G，JVM commit 了 4.8G。但在启动后 JVM 一开始可能实际只使用了 3G 内存，由于前面刚提到的 lazy allocation 机制，导致剩下的 1.8G 是不会映射物理内存的，虽然这块内存已经被 commit 了， Linux 实际只分配了 3G。</p><p>然后在 gc 时，由于会复制存活对象到堆的空闲部分，如果正好复制到了以前未使用过的区域，就又会触发 Linux 进行内存分配，故一段时间内内存占用会越来越多，直到堆的所有区域都被 touch 到。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225202704.png" alt="image-20231126225202704"></p><p>而通过添加JVM参数<code>-XX:+AlwaysPreTouch</code>（默认关闭），可以在 Commit 内存后立刻写入 0 来强制操作系统分配内存，使得堆区域全都被分配物理内存。而由于 Java 进程主要活动在堆内，故后续内存就不会有很大变化了。</p><ul><li>这种优化叫做 <strong>“pre-zeroing”</strong>，即将内存全部预填 0，减少页分配开销，<a href="https://www.cse.iitd.ernet.in/~sbansal/pubs/hawkeye.pdf">这篇论文</a>有详细描述</li></ul><p><strong>无此参数可以提高<em>内存</em>利用度</strong>，<strong>加此参数则会使应用运行得更稳定。</strong></p><blockquote><ul><li>在 jdk9 以前，<strong>理论上</strong> AlwaysPreTouch 打开后会降低项目启动时间1~2个数量级（<a href="https://www.jianshu.com/p/a8356d03ac8f%EF%BC%89%E3%80%82%E5%9C%A8">https://www.jianshu.com/p/a8356d03ac8f）。在</a> jdk9 及之后，由于 jvm 对 preTouch 加入了并行优化（<a href="https://bugs.openjdk.org/browse/JDK-8157952%EF%BC%89%EF%BC%8CAlwaysPreTouch">https://bugs.openjdk.org/browse/JDK-8157952），AlwaysPreTouch</a> 对项目启动时间的影响大幅降低。</li></ul><p><strong>AlwaysPreTouch 对 IoTDB 启动性能影响的实验：</strong></p><ol><li>环境：Mac M2 pro JDK 8&#x2F;11</li></ol><ul><li>ConfigNode：1068ms（加 AlwaysPreTouch）</li><li>DataNode：1369ms（加 AlwaysPreTouch）</li><li>ConfigNode：999ms（不加 AlwaysPreTouch）</li><li>DataNode：1374ms（不加 AlwaysPreTouch）</li></ul><ol><li>环境：fit 服务器 JDK 8</li></ol><ul><li>ConfigNode：1044ms（加 AlwaysPreTouch）</li><li>DataNode：1349ms（加 AlwaysPreTouch）</li><li>ConfigNode：1031ms（不加 AlwaysPreTouch）</li><li>DataNode：1430ms（不加 AlwaysPreTouch）</li></ul><p><strong>结论：</strong>对 IoTDB 的启动几乎没有性能开销影响，对运行时理论没有性能开销。</p></blockquote><h3 id="glibc-内存去配机制对-JVM-的影响"><a href="#glibc-内存去配机制对-JVM-的影响" class="headerlink" title="glibc 内存去配机制对 JVM 的影响"></a>glibc 内存去配机制对 JVM 的影响</h3><p>JVM 等原生应用程序调用的 malloc、free 函数，实际是由基础 C 库 <a href="https://zhuanlan.zhihu.com/p/428216764">glibc</a> 提供的，而 linux 系统则提供了 brk、mmap、munmap 这几个系统调用来分配虚拟内存，所以 libc 的 malloc、free 函数实际是基于这些系统调用实现的。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225215844.png" alt="image-20231126225215844"></p><p>由于系统调用有一定的开销，为减小开销，glibc 实现了一个类似内存池的机制，在 free 函数调用时将内存块缓存起来不归还给 linux，直到缓存内存量到达一定条件才会实际执行归还内存的系统调用。</p><blockquote><p>节选自 glibc 资料：</p><p>用户调用 free 函数释放内存的时候，ptmalloc 并不会立即将其归还操作系统，而是将其放入空闲链表 (bins) 中，这样下次再调用 malloc 函数申请内存的时候，就会从 bins 中取出一块返回，这样就避免了频繁调用系统调用函数，从而降低内存分配的开销。</p></blockquote><p>因此，<strong>Java 进程占用<em>内存</em>有时比<em>理论上</em>要大些，一定程度上是正常的。（这点对于理解 Java 进程在<em>操作系统</em>中的占用内存非常重要）</strong></p><h3 id="glibc-Allocator-的负面影响-RSS-以-64MB-为增量进行递增"><a href="#glibc-Allocator-的负面影响-RSS-以-64MB-为增量进行递增" class="headerlink" title="glibc Allocator 的负面影响: RSS 以 64MB 为增量进行递增"></a>glibc Allocator 的负面影响: RSS 以 64MB 为增量进行递增</h3><p>这是最不容易发现但是可能导致堆外内存不符合预期的情况。在笔者调研时，中英文互联网均有这种 case：pmap 时，发现 java 进程分配了大量 64 MB 大小的内存块。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225229675.png" alt="image-20231126225229675"></p><p>这是由于 Linux 中，glibc 对具有大量并发线程的程序进行了优化，通过避免竞争调高了程序运行速度。而提速是通过为每一个核来维护一个内存池达到的。</p><p>这种优化方式的本质是：操作系统会为给定的进程捕获（抢占）内存，<strong>每个内存块的大小为</strong> <strong>64MB</strong>，这样的内存块被叫做 arena，glibc 再根据应用需要将 arena 切割为小块进行实际分配。当使用 pmap 分析进程内存时，这些清晰可见（如上图）</p><p>每一个 arena 都只能由特定的 CPU-Core 来进行访问，所以在同一时间点至多会有一个线程会进行访问。然后每个 arena 内部通过 malloc 来使用内存空间。每个 CPU-Core 至多可以分配一定数量的 arena，默认是 8 个。</p><p><strong>但是在这些 arena 占用的大量<em>内存</em>中，应用程序真正使用的内存量可能很少</strong>。如果应用程序拥有很多的线程数量，并且执行程序的机器CPU核数也很多，那么通过分配 arena 这种方式占用的内存总量可能非常大。比如在CPU核数为16的机器上，arena 占用的内存量会达到 16 * 8 * 64 MB &#x3D; 8GB。</p><p>映射到 Java 程序上，就是：<strong>JVM</strong> <strong>实际只需要一小部分<em>内存</em>，但是</strong> <strong>RSS</strong> <strong>不断增长的问题就会显现出来。因此会导致 Java 实际使用的内存小于 Linux 系统分配的内存。</strong></p><p>解决：</p><ol><li>可以通过<code>MALLOC_ARENA_MAX</code>环境变量来调整arena的最大数量，加上这个环境变量启动 java 进程。并且可以通过<code>cat /proc/&lt;JVM_PID&gt;/environ</code>来检查是否配置成功。</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Some versions of glibc use an arena memory allocator that causes</span></span><br><span class="line"><span class="comment"># virtual memory usage to explode. Tune the variable down to prevent</span></span><br><span class="line"><span class="comment"># vmem explosion.</span></span><br><span class="line"><span class="built_in">export</span> MALLOC_ARENA_MAX=<span class="variable">$&#123;MALLOC_ARENA_MAX:-4&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>但是 <a href="https://link.juejin.cn/?target=https://bugzilla.redhat.com/show_bug.cgi?id=799327">Linux的一个BUG</a> 表明设置<code>MALLOC_ARENA_MAX</code>可能无法生效。不过这个问题已经在 <code>glibc 2.12</code> 版本进行了修复（参考<a href="https://link.juejin.cn/?target=https://access.redhat.com/errata/RHSA-2012:0058">Linux update release notes mentioning  BZ#769594</a>），如果使用的仍旧是未修复版本，那么需要注意这一点。</p></blockquote><ol><li>替换 glibc 为碎片整理更友好的 tcmalloc(google) 和 jemalloc(facebook)</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 用法：</span><br><span class="line">LD_PRELOAD=/usr/local/lib/libtcmalloc.so java -jar xxx</span><br></pre></td></tr></table></figure><ul><li>Redis 使用了 tcmalloc 和 jemalloc 作为内存管理库的 option，在 zmalloc.c 源码中可以看到 redis 用二者覆盖了 glibc（<a href="https://blog.csdn.net/u010144805/article/details/80353851%EF%BC%89">https://blog.csdn.net/u010144805/article/details/80353851）</a></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225246701.png" alt="image-20231126225246701"></p><ul><li>甚至 Redis 直接内置了 jemalloc 的源码，作为 deps 来覆盖 glibc。虽然 Redis 默认用 glibc，但从 Redis 源码的注释中可以看到，Redis 团队是鼓励使用 jemalloc 的</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225304091.png" alt="image-20231126225304091"></p><p>调研时，也发现互联网不乏喊 glibc 坑爹的声音，关于 tcmalloc、jemalloc 与 glibc 的性能对比测试比比皆是（<a href="https://www.zhihu.com/question/54823155%EF%BC%89%EF%BC%8C%E5%9F%BA%E6%9C%AC%E5%9D%87%E8%A1%A8%E6%98%8E">https://www.zhihu.com/question/54823155），基本均表明</a> tcmalloc、jemalloc 不仅碎片整理比 glibc 优越，性能也有优势😳。</p><p>以下两点比较少见，主要贴出来供参考学习，感兴趣的可以看看</p><h3 id="DirectByteBuffer-的-capacity-之和大于-MaxDirectMemorySize"><a href="#DirectByteBuffer-的-capacity-之和大于-MaxDirectMemorySize" class="headerlink" title="DirectByteBuffer 的 capacity 之和大于 MaxDirectMemorySize"></a>DirectByteBuffer 的 capacity 之和大于 MaxDirectMemorySize</h3><p>有时我们设置了<code>-XX:MaxDirectMemorySize</code>，但是统计时将所有 DirectByteBuffer 对象的 capacity 加起来发现大于了<code>-XX:MaxDirectMemorySize</code>。</p><p>关注 DirectByteBuffer 里的这两个函数：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225318178.png" alt="image-20231126225318178"></p><p><code>slice</code>是从一块已知的内存里取出剩下的一部分，用一个新的 DirectByteBuffer 对象指向它，而 <code>duplicate</code> 就是创建一个现有 DirectByteBuffer 的全新副本，各种指针都一样。</p><ul><li><strong>这两个函数 IoTDB 都有用到</strong></li></ul><p>从这两个函数创建出来的 DirectByteBuffer 实际上指向的是已存在的堆外内存（相当于复用）。所以如果我们做统计的时候如果仅仅将所有 DirectByteBuffer 对象的 capacity 加起来，那可能会导致算出来的结果偏大不少。</p><p><strong>因此我们统计的时候可以注意这点，不要简单 add 所有DirectByteBuffer 对象的</strong> <strong>capacity*。</strong></p><h3 id="MaxDirectMemorySize-与-RealDirectMemoryBufferSize"><a href="#MaxDirectMemorySize-与-RealDirectMemoryBufferSize" class="headerlink" title="MaxDirectMemorySize 与 RealDirectMemoryBufferSize"></a>MaxDirectMemorySize 与 RealDirectMemoryBufferSize</h3><p>首先明确：<code>-XX:MaxDirectMemorySize</code>是如何限制 DirectMemory 的？</p><p>我们从 java 层面创建 DirectByteBuffer 对象，一般都是通过 ByteBuffer 的 allocateDirect 方法</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225331048.png" alt="image-20231126225331048"></p><p>这个方法会调用该构造函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap));</span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个构造函数里的<code>Bits.reserveMemory(size, cap)</code>方法会做堆外内存的阈值 check</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// These methods should be called whenever direct memory is allocated or</span></span><br><span class="line"><span class="comment">// freed.  They allow the user to control the amount of direct memory</span></span><br><span class="line"><span class="comment">// which a process may access.  All sizes are specified in bytes.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reserveMemory</span><span class="params">(<span class="type">long</span> size, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!memoryLimitSet &amp;&amp; VM.isBooted()) &#123;</span><br><span class="line">        maxMemory = VM.maxDirectMemory();</span><br><span class="line">        memoryLimitSet = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// optimist!</span></span><br><span class="line">    <span class="keyword">if</span> (tryReserveMemory(size, cap)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">JavaLangRefAccess</span> <span class="variable">jlra</span> <span class="operator">=</span> SharedSecrets.getJavaLangRefAccess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retry while helping enqueue pending Reference objects</span></span><br><span class="line">    <span class="comment">// which includes executing pending Cleaner(s) which includes</span></span><br><span class="line">    <span class="comment">// Cleaner(s) that free direct buffer memory</span></span><br><span class="line">    <span class="keyword">while</span> (jlra.tryHandlePendingReference()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReserveMemory(size, cap)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger VM&#x27;s Reference processing</span></span><br><span class="line">    System.gc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a retry loop with exponential back-off delays</span></span><br><span class="line">    <span class="comment">// (this gives VM some time to do it&#x27;s job)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sleepTime</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sleeps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tryReserveMemory(size, cap)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sleeps &gt;= MAX_SLEEPS) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!jlra.tryHandlePendingReference()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(sleepTime);</span><br><span class="line">                    sleepTime &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                    sleeps++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// no luck</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>(<span class="string">&quot;Direct buffer memory&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">            <span class="comment">// don&#x27;t swallow interrupts</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会检查已经分配的内存是否超过阈值，如是，会触发一次 gc 动作，并重新做一次分配，如果还是超过阈值，那将会抛出 OOM，因此分配动作会失败。</p><p><strong>结论</strong>：只有通过 <code>DirectByteBuffer(int cap)</code> 构造函数分配的堆外内存，会被检查并受<code>MaxDirectMemorySize</code>限制。</p><p>那么如果通过其他构造函数分配堆外内存，显然就不会受<code>MaxDirectMemorySize</code>的限制，比如：</p><p>在 jvm 里可以通过 jni 方法回调 DirectByteBuffer 的构造函数，这个构造函数是</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225345248.png" alt="image-20231126225345248"></p><p>而调用这个构造函数的 jni 方法是<code>NewDirectByteBuffer</code></p><p>想象这么种情况，我们写了一个 native 方法，里面分配了一块内存，同时通过上面这个方法和一个 DirectByteBuffer 对象关联起来，那从 java 层面来看这个 DirectByteBuffer 确实是一个有效的占有不少 native 内存的对象，但是这个对象后面关联的内存完全绕过了<code>MaxDirectMemorySize</code> 的 check。所以造成：明明设置了<code>MaxDirectMemorySize</code>，但是发现 DirectByteBuffer 关联的堆外内存其实是大于它的。</p><ul><li>IoTDB 的依赖 [zstd-jni](<a href="https://github.com/search?q=repo:luben/zstd-jni">https://github.com/search?q=repo%3Aluben%2Fzstd-jni</a> newDirectByteBuffer&amp;type&#x3D;code) 有声明该 jni 方法，不过 IoTDB 并未调用。这里贴出来主要参考学习~</li></ul><h1 id="【监控】如何监控？"><a href="#【监控】如何监控？" class="headerlink" title="【监控】如何监控？"></a>【监控】如何监控？</h1><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225358955.png" alt="image-20231126225358955"></p><h2 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h2><ol><li>使用 MemoryPoolMXBean 监控分代堆内存 + Code Cache + Metaspace</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225411976.png" alt="image-20231126225411976"></p><ol start="2"><li>使用BufferPoolMXBean 监控 Direct + mmap</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225424076.png" alt="image-20231126225424076"></p><ol start="3"><li><strong>缺点：</strong>对于非堆内存的监控不全，只覆盖了 code cache、metaspace、direct、mapped。</li></ol><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ol><li>直接读取 <code>java.nio.Bits</code> 来监控 direct 的 <code>TOTAL_CAPACITY</code>与<code>RESERVE_MEMORY</code>。<strong>实测跟</strong> <strong>JMX</strong> <strong>的</strong> <code>total</code>、<code>used</code> <strong>效果一致</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Class&lt;?&gt; c = Class.forName(<span class="string">&quot;java.nio.Bits&quot;</span>);</span><br><span class="line">  <span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;RESERVED_MEMORY&quot;</span>);</span><br><span class="line">  field1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;TOTAL_CAPACITY&quot;</span>);</span><br><span class="line">  field2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (c) &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">total</span> <span class="operator">=</span> ((AtomicLong) field2.get(<span class="literal">null</span>)).get();</span><br><span class="line">    <span class="type">long</span> <span class="variable">reserve</span> <span class="operator">=</span> ((AtomicLong) field1.get(<span class="literal">null</span>)).get();</span><br><span class="line">    System.out.println(total + <span class="string">&quot; &quot;</span> + reserve);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="Java-工具"><a href="#Java-工具" class="headerlink" title="Java 工具"></a>Java 工具</h3><h4 id="Jmap"><a href="#Jmap" class="headerlink" title="Jmap"></a>Jmap</h4><p>互联网上有非常丰富的资料，可以自行参考</p><ul><li><strong>优点：</strong>随时使用；没有性能损耗；适合监控堆内存，还可以监控类加载情况等，功能强大，可以找出 OOM 瓶颈</li><li><strong>缺点：</strong>对非堆内存的监控有欠缺，只能看到 Metaspace 的内存情况</li></ul><h4 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h4><p>互联网上有非常丰富的资料，可以自行参考</p><ul><li><strong>优点：</strong>功能强大，可以找出 OOM 到底在哪个类发生</li><li><strong>缺点：</strong>对 native 等非堆内存的监控有欠缺</li></ul><h4 id="Jcmd"><a href="#Jcmd" class="headerlink" title="Jcmd"></a>Jcmd</h4><ol><li>监控堆内存使用信息（G1 GC）和 Metaspace</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225520870.png" alt="image-20231126225520870"></p><ol start="2"><li>监控 Code Cache</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225533541.png" alt="image-20231126225533541"></p><ol start="3"><li>查看堆使用情况的统计信息</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225548347.png" alt="image-20231126225548347"></p><ol start="4"><li>打印 native memory（非堆内存）信息，即使用 NMT，见下节。</li></ol><ul><li><strong>优点：</strong>各种命令高低搭配，堆内非堆都能很好的监控到</li><li><strong>缺点：</strong>非堆内存的详细监控需要开启 NMT，会带来性能损失且不支持热加载</li></ul><h4 id="Native-Memory-Tracking（NMT）"><a href="#Native-Memory-Tracking（NMT）" class="headerlink" title="Native Memory Tracking（NMT）"></a>Native Memory Tracking（NMT）</h4><ol><li><strong>开启：</strong>使用 <code>-XX:NativeMemoryTracking=``summary</code> 可以用于开启 NMT，其中该值默认为 off，可以设置为 summary 或者 detail 来开启；<strong>开启的话，大概会增加 5%-10% 的性能消耗</strong></li><li><strong>使用：</strong>使用<code>jcmd pid VM.native_memory</code> 可以查看，后面可以加 summary 或者 detail，如果是开启 summary 的，就只能使用 summary；其中 scale 参数可以指定展示的单位，可以为 KB 或者 MB 或者 GB</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jcmd &lt;pid&gt; VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># summary: 分类内存使用情况.</span></span><br><span class="line"><span class="comment"># detail: 详细内存使用情况，除了summary信息之外还包含了虚拟内存使用情况。</span></span><br><span class="line"><span class="comment"># baseline: 创建内存使用快照，方便和后面做对比</span></span><br><span class="line"><span class="comment"># summary.diff: 和上一次baseline的summary对比</span></span><br><span class="line"><span class="comment"># detail.diff: 和上一次baseline的detail对比</span></span><br><span class="line"><span class="comment"># shutdown: 关闭NMT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例：</span></span><br><span class="line">jcmd 1 VM.native_memory summary</span><br><span class="line">jcmd 1 VM.native_memory summary scale=MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 baseline</span></span><br><span class="line">jcmd 1 VM.native_memory baseline</span><br><span class="line">Baseline succeeded</span><br><span class="line"></span><br><span class="line"><span class="comment"># diff 对比 baseline</span></span><br><span class="line">jcmd 1 VM.native_memory summary.diff</span><br></pre></td></tr></table></figure><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225607661.png" alt="image-20231126225607661"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225618197.png" alt="image-20231126225618197"></p><ul><li><strong>优点：</strong>非常全，各项都能很好的监控到；能监控到 memory map，拿到内存地址。</li><li><strong>缺点：</strong>必须在 JVM 启动时添加参数开启，不支持热加载；有 5-10% 的性能损失</li></ul><h4 id="Verbose"><a href="#Verbose" class="headerlink" title="Verbose"></a>Verbose</h4><p>在调试程序时，有时需要查看程序加载的类、内存回收情况、调用的本地接口等。这时候就需要 <code>-verbose</code> 命令。</p><ol><li>直接在 VM 参数添加</li><li>也可以在命令行输入 <code>java -verbose:xxx</code>来查看</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-verbose:class 查看类加载情况</span><br><span class="line">-verbose:gc 查看虚拟机中内存回收情况</span><br><span class="line">-verbose:jni 查看本地方法调用的情况</span><br></pre></td></tr></table></figure><p>作用：可以用来排查异常类加载情况、本地接口异常调用等（这些通常是内存泄漏、内存异常的凶手）</p><p>例：对 configNode 使用 -verbose:class：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225632258.png" alt="image-20231126225632258"></p><h3 id="系统工具（Linux）"><a href="#系统工具（Linux）" class="headerlink" title="系统工具（Linux）"></a>系统工具（Linux）</h3><p>对于 native 层面的内存分配和排查，Java 层面的工具已经不适合。此时需要 Linux 系统层面的工具进行排查。</p><p>以下提到的工具都可以结合起来使用。有一个真实案例，将下列工具组合运用，非常牛逼丝滑：</p><p><a href="https://heapdump.cn/article/2640702">https://heapdump.cn/article/2640702</a></p><h4 id="pmap"><a href="#pmap" class="headerlink" title="pmap"></a>pmap</h4><p>用法：<code>pmap &lt;选项&gt; pid</code></p><ol><li>快速检查占用较大的内存</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pmap -x 1 | sort -nrk3 | less </span><br></pre></td></tr></table></figure><ol><li>检查一段时间后新增了哪些内存段，或哪些变大了。在不同的时间点多次保存 pmap 命令的输出，然后通过文本对比工具查看两个时间点内存段分布的差异。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pmap -x 1 &gt; pmap-`date +%F-%H-%M-%S`.log</span><br></pre></td></tr></table></figure><p>pmap 的输出如下：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225657607.png" alt="image-20231126225657607"></p><p>可以发现，进程申请的所有虚拟内存段，都在pmap中能够找到，相关字段解释如下：</p><ul><li>Address：表示此内存段的起始地址</li><li>Kbytes：表示此内存段的大小(ps：这是虚拟内存)</li><li>RSS：表示此内存段实际分配的物理内存，这是由于Linux是延迟分配内存的，进程调用malloc时Linux只是分配了一段虚拟内存块，直到进程实际读写此内存块中部分时，Linux会通过缺页中断真正分配物理内存。</li><li>Dirty：此内存段中被修改过的内存大小，使用mmap系统调用申请虚拟内存时，可以关联到某个文件，也可不关联，当关联了文件的内存段被访问时，会自动读取此文件的数据到内存中，若此段某一页内存数据后被更改，即为Dirty，而对于非文件映射的匿名内存段(anon)，此列与RSS相等。</li><li>Mode：内存段是否可读(r)可写(w)可执行(x)</li><li>Mapping：内存段映射的文件，匿名内存段显示为anon，非匿名内存段显示文件名(加-p可显示全路径)。</li></ul><p>pmap 的作用通常是：<strong>查看<em>内存</em>分配情况，找出异常内存；根据内存地址，比对 strace 内存请求的具体申请额度；根据内存地址，比对</strong> <strong>NMT</strong> <strong>中的内存地址，找出异常内存。</strong></p><h4 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h4><p>作用1：<strong>已知异常内存地址的情况下，查看异常内存内容</strong></p><ol><li><code>gdp -pid pid</code> 进入GDB</li><li>使用命令<code>dump memory mem.bin startAddress endAddress</code> dump内存，其中 startAddress 和 endAddress 可以从 &#x2F;proc&#x2F;pid&#x2F;**aps 中查找。</li><li>使用<code>strings mem.bin</code>查看 dump 的内容。</li></ol><p>作用2：<strong>检查被</strong> <strong>glibc</strong> <strong>内存*分配器缓存的内存</strong> </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看glibc内存分配情况，会输出到进程标准错误中</span></span><br><span class="line">gdb -q -batch -ex <span class="string">&#x27;call malloc_stats()&#x27;</span> -p pid</span><br></pre></td></tr></table></figure><p>glibc 实现了 malloc_trim 函数，通过 brk 或 madvise 系统调用，归还被 glibc 缓存的内存，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回收glibc缓存的内存</span></span><br><span class="line">gdb -q -batch -ex <span class="string">&#x27;call malloc_trim(0)&#x27;</span> -p pid </span><br></pre></td></tr></table></figure><h4 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h4><p>向 os 追踪申请内存请求（系统调用），常见用法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace -f -e &quot;brk,mmap,munmap&quot; -p pid</span><br></pre></td></tr></table></figure><p>作用：<strong>查到异常申请<em>内存</em>请求的</strong> <strong>pid*，从而通过</strong> <strong>jstack</strong> <strong>等分析工具，具体分析该 id 线程的<em>调用栈</em>等行为</strong></p><p>缺点：必须在项目启动时 strace 才能达到比较好的追踪效果</p><h1 id="【最佳实践】如何控制-Java-进程所占内存"><a href="#【最佳实践】如何控制-Java-进程所占内存" class="headerlink" title="【最佳实践】如何控制 Java 进程所占内存"></a>【最佳实践】如何控制 Java 进程所占内存</h1><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p><strong>使用</strong> <strong>JVM</strong> <strong>参数控制</strong></p><ul><li><code>Xmx</code>：对应 <strong>最大堆大小</strong> <code>MaxHeapSize</code></li><li><code>Xms</code>：相当于同时设置<strong>最小堆*大小</strong><code>MinHeapSize</code> 和<strong>初始堆大小</strong><code>InitialHeapSize</code></li><li><code>-XX:+AlwaysPreTouch</code>：对于只运行 IoTDB 的机器，内存本来就都是给 IoTDB 用的，建议加上此参数，避免 Linux touch 内存的开销，让内存更稳定。</li></ul><h2 id="非堆内存-1"><a href="#非堆内存-1" class="headerlink" title="非堆内存"></a>非堆内存</h2><ol><li><strong>使用</strong> <strong>JVM</strong> <strong>参数控制</strong></li></ol><ul><li><code>-Xss</code>：每个线程 stack 的大小</li><li><code>-XX:MaxDirectMemorySize</code>：控制直接内存大小</li><li><code>-XX:MaxMetaspaceSize</code>：控制数据元信息区大小</li><li><code>-XX:CompressedClassSpaceSize</code>：控制类元信息区大小</li><li><code>-XX:ReservedCodeCacheSize</code>：Code cache 区最大内存</li><li><code>-Djdk.nio.maxCachedBufferSize</code>：限制每个线程缓存 <code>DirectByteBuffer</code> 的 size</li><li>避免使用<code>-XX:+DisableExplicitGC</code>：JVM 实现中：<code>-XX:MaxMetaspaceSize</code>的阈值检查依赖 System.gc()。禁用 System.gc() 会导致更容易 OOM。</li></ul><ol><li><strong>native 代码分配上妥善处理</strong></li></ol><ul><li>主要指使用 Unsafe 类或者 NIO 相关类直接管理内存时，需要妥善做好内存的分配去配，防止内存泄漏<ul><li>常见的实现是结合 try-with-resource，在 close 函数中释放内存，达到类似 C++ RAII 的效果<ul><li>在合适的时机（close）调用 <code>DirectByteBuffer.getCleaner().clean()</code>，手动清理堆外内存，而不是交给 GC（finalize）</li></ul></li><li>在堆外内存使用频繁的场合，不要擅自开启 <code>-XX:+DisableExplicitGC</code> 开关进行“优化”。</li></ul></li></ul><ol><li><strong>冰山对象</strong> <strong>GC</strong></li></ol><ul><li>主要指 DirectByteBuffer</li></ul><h1 id="【总结】本调研旨在解决的问题"><a href="#【总结】本调研旨在解决的问题" class="headerlink" title="【总结】本调研旨在解决的问题"></a>【总结】本调研旨在解决的问题</h1><h2 id="为什么设置-Xmx6g，但是-java-进程内存占用达到-8g？（数字随便举的）"><a href="#为什么设置-Xmx6g，但是-java-进程内存占用达到-8g？（数字随便举的）" class="headerlink" title="为什么设置-Xmx6g，但是 java 进程内存占用达到 8g？（数字随便举的）"></a>为什么设置-Xmx6g，但是 java 进程内存占用达到 8g？（数字随便举的）</h2><blockquote><p>镜像问题：为什么 MAX_DIRECT_MEMORY_SIZE + 堆内内存 比实际进程占用内存大？</p></blockquote><ol><li>因为有非堆内存，且非堆内存除了 Direct buffer 还包括 Code Cache，MetaSpace 等。</li></ol><p>​      Java 进程内存占用 &#x3D; 堆内存 + 非堆内存（DirectMemory + Metaspace + … )</p><ol><li>由于 glibc 内存去配机制，Java 实际占用内存会比理论上大些</li><li>由于 glibc 内存分配机制，Java 实际分配到的物理内存会比真实使用的内存大些</li></ol><h2 id="非堆内存如何管理？"><a href="#非堆内存如何管理？" class="headerlink" title="非堆内存如何管理？"></a>非堆内存如何管理？</h2><p>可参考前文</p><h2 id="堆内存如何管理？"><a href="#堆内存如何管理？" class="headerlink" title="堆内存如何管理？"></a>堆内存如何管理？</h2><p>可参考前文</p><h1 id="排查-Java-内存相关最佳实践"><a href="#排查-Java-内存相关最佳实践" class="headerlink" title="排查 Java 内存相关最佳实践"></a>排查 Java 内存相关最佳实践</h1><h2 id="如何排查-Java-应用在线上到底占用了多少内存？"><a href="#如何排查-Java-应用在线上到底占用了多少内存？" class="headerlink" title="如何排查 Java 应用在线上到底占用了多少内存？"></a>如何排查 Java 应用在线上到底占用了多少内存？</h2><ol><li><strong>查看 IoTDB 占用的*物理内存</strong><ol><li>top 等命令</li><li>System 面板</li></ol></li><li><strong>查看 IoTDB 进程各模块占用内存</strong><ol><li>堆内存：jmap、jcmd、System 面板等</li><li>非堆内存：<ol><li>推荐：<strong>NMT</strong>（查看绝大部分） + <strong>System 面板</strong>（查看 mapped memory）+ <strong>pmap</strong>（查看 native 内存）+ <strong>gdb</strong>（查看 glibc 缓存内存），以上组合拳可以覆盖本文提到的所有相关内存。</li></ol></li></ol></li></ol><h2 id="内存异常（OOM-RSS-远超预期等），如何定位哪部分内存是凶手？"><a href="#内存异常（OOM-RSS-远超预期等），如何定位哪部分内存是凶手？" class="headerlink" title="内存异常（OOM&#x2F;RSS 远超预期等），如何定位哪部分内存是凶手？"></a>内存异常（OOM&#x2F;RSS 远超预期等），如何定位哪部分内存是凶手？</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225726087.png" alt="image-20231126225726087"></p><ol><li><strong>首先结合异常信息看 System 面板</strong>，定位是不是<strong>堆内存*的问题</strong><ol><li><strong>如果是</strong> <strong>OOM*：</strong>报错 OutOfMemoryError: Direct Buffer Memory：是 Direct Memory 泄漏，跳到第三步。OutOfMemoryError: GC limit、OutOfMemoryError: Heap size 等是堆内存泄漏，跳到第二步</li><li><strong>如果是 Java 进程</strong> <strong>RSS</strong> <strong>远大于理论<em>内存</em>：</strong>一般不是堆内存的问题。根据经验，一般是：<ul><li>某些自定义的 native 代码造成了内存泄漏，对应第四步。</li><li><code>DirectByteBuffer</code> 的问题，对应第三步。<ul><li>这些对象实例可能是由应用程序显示的创建（例如通过某些第三方库）</li><li>也可能是由 JDK 内部使用<code>HeapByteBuffer</code> 的 I&#x2F;O 线程自动创建和缓存在 threadlocal 里，如果创造了很多通过这样的线程， 并且每个线程使用的 buffer 很大，那么最终 Java 进程可能占用大量的堆外内存，看起来就像发生了内存泄漏一样</li></ul></li><li>操作系统存在问题，对应第五步。<ul><li>如果是操作系统的原因的话，那么在通过<code>pmap</code>工具输出的日志中应该会存在众多大小为 64MB 的内存块分配，如果 64M 问题不是很显然，那么就需要检查自定义的本地代码（nmt 等手段）</li></ul></li></ul></li><li>System 面板看各 memory 是否符合预期，可以定位是否为堆内存的问题。</li></ol></li><li><strong>如果是<em>堆内存</em>的问题</strong><ol><li>使用 jmap、jprofiler 等手段 dump 内存，进一步查看到底是哪些对象积压</li><li>使用 jmap、GC log 等手段查看 gc 情况，看看是不是 full gc 不及时等问题。如是，需要调整 GC 的相关 VM options</li></ol></li><li><strong>如果是 DirectMemory</strong><ol><li>查看 MaxDirectMemorySize 是不是设置妥当</li><li>如 MaxDirectMemorySize 设好了，查看 heap 中 DirectByteBuffer 对象的积压&#x2F;创建情况，可以通过 dump heap、verbose 等手段实现。有可能是 DirectByteBuffer 没有被及时 clean 导致 DirectMemory 增大</li></ol></li><li><strong>如果不是</strong> <strong>heap</strong> <strong>也不是 DirectMemory</strong><ol><li>建议加上 nmt，复现 OOM 场景，进一步查看到底是哪块区域内存异常<ul><li>Metaspace、code cache 等，如果它们异常了，重新设置对应的 VM options 即可</li></ul></li></ol></li><li><strong>如果</strong> <strong>nmt</strong> <strong>各项都正常</strong><ol><li>可能是 native 或者 glibc 等 JVM 不能控制的部分在搞鬼，这时候需要使用 linux 的工具了</li><li>先 pmap，查看是不是 glibc 64M 内存的问题。<ul><li>一般来说，64M 问题不会导致 OOM 这么严重的 exception，只会让 Java 进程超额申请它所需要的内存。也就是说，64M 可能只是压死骆驼的最后一根稻草，但并不是 OOM 真正的罪魁祸首。如果想解决 64M 问题的话，可以参考前文的解决方案</li></ul></li><li><code>pmap -x 1 | sort -nrk3 | less</code> ，依次排查较大的内存块。<ul><li>尝试用 gdb 等工具 dump 这些内存，看看里面是什么内容，往往能找到异常类的信息<ul><li>可以参考 <a href="https://juejin.cn/post/7176056215074504762%E3%80%81https://heapdump.cn/article/4044805">https://juejin.cn/post/7176056215074504762、https://heapdump.cn/article/4044805</a></li></ul></li><li>结合 strace 等工具深度跟踪内存分配轨迹，揪出凶手<ul><li>可以参考 <a href="https://heapdump.cn/article/2640702">https://heapdump.cn/article/2640702</a></li></ul></li></ul></li><li>最后查看 glibc 内存分配情况，<code>gdb -q -batch -ex &#39;call malloc_stats()&#39; -p pid</code> ，看看是不是 glibc 缓存未归还操作系统的问题。<ul><li>如是，调用<code>gdb -q -batch -ex &#39;call malloc_trim(0)&#39; -p pid</code>归还 glibc 的缓存<ul><li>malloc_trim 有概率会导致 JVM Crash，使用的时候需要小心</li><li>可以参考 <a href="https://zhuanlan.zhihu.com/p/652545321">https://zhuanlan.zhihu.com/p/652545321</a></li></ul></li></ul></li></ol></li></ol><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ol><li><a href="http://lovestblog.cn/blog/2016/08/29/oom/">http://lovestblog.cn/blog/2016/08/29/oom/</a></li><li><a href="http://lovestblog.cn/blog/2016/10/29/metaspace/">http://lovestblog.cn/blog/2016/10/29/metaspace/</a></li><li><a href="http://lovestblog.cn/blog/2016/06/29/ooc-offheap/">http://lovestblog.cn/blog/2016/06/29/ooc-offheap/</a></li><li><a href="http://lovestblog.cn/blog/2015/05/12/direct-buffer/">http://lovestblog.cn/blog/2015/05/12/direct-buffer/</a></li><li><a href="https://cloud.tencent.com/developer/article/1666640">https://cloud.tencent.com/developer/article/1666640</a></li><li><a href="https://cloud.tencent.com/developer/article/1408384">https://cloud.tencent.com/developer/article/1408384</a></li><li><a href="https://cloud.tencent.com/developer/article/2315755">https://cloud.tencent.com/developer/article/2315755</a></li><li><a href="https://cloud.tencent.com/developer/article/2277333?areaId=106001">https://cloud.tencent.com/developer/article/2277333?areaId=106001</a></li><li><a href="https://juejin.cn/post/7225875600644407357">https://juejin.cn/post/7225875600644407357</a></li><li><a href="https://juejin.cn/post/7225874698906615864">https://juejin.cn/post/7225874698906615864</a></li><li><a href="https://juejin.cn/post/7225879698952486972">https://juejin.cn/post/7225879698952486972</a></li><li><a href="https://juejin.cn/post/6844904168549777421">https://juejin.cn/post/6844904168549777421</a></li><li><a href="https://juejin.cn/post/7067170332917923854">https://juejin.cn/post/7067170332917923854</a></li><li><a href="https://juejin.cn/post/6854573220733911048">https://juejin.cn/post/6854573220733911048</a></li><li><a href="https://juejin.cn/post/7078624931826794503">https://juejin.cn/post/7078624931826794503</a></li><li><a href="https://juejin.cn/post/7176056215074504762">https://juejin.cn/post/7176056215074504762</a></li><li><a href="https://zhuanlan.zhihu.com/p/342770702">https://zhuanlan.zhihu.com/p/342770702</a></li><li><a href="https://zhuanlan.zhihu.com/p/652545321">https://zhuanlan.zhihu.com/p/652545321</a></li><li><a href="https://zhuanlan.zhihu.com/p/428216764">https://zhuanlan.zhihu.com/p/428216764</a></li><li><a href="https://zhuanlan.zhihu.com/p/432258798">https://zhuanlan.zhihu.com/p/432258798</a></li><li><a href="https://www.zhihu.com/question/55529827">https://www.zhihu.com/question/55529827</a></li><li><a href="https://www.zhihu.com/question/58943470">https://www.zhihu.com/question/58943470</a></li><li><a href="https://heapdump.cn/article/2906673">https://heapdump.cn/article/2906673</a></li><li><a href="https://heapdump.cn/article/2614172">https://heapdump.cn/article/2614172</a></li><li><a href="https://heapdump.cn/article/2640702">https://heapdump.cn/article/2640702</a></li><li><a href="https://blog.csdn.net/pingnanlee/article/details/51984058">https://blog.csdn.net/pingnanlee/article/details/51984058</a></li><li><a href="https://blog.csdn.net/renfufei/article/details/115165919">https://blog.csdn.net/renfufei/article/details/115165919</a></li><li><a href="https://learn.skyofit.com/archives/478">https://learn.skyofit.com/archives/478</a></li><li><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</a></li><li><a href="https://haslab.org/2020/12/06/hawkeye.html">https://haslab.org/2020/12/06/hawkeye.html</a></li><li><a href="https://dzone.com/articles/troubleshooting-problems-with-native-off-heap-memo">https://dzone.com/articles/troubleshooting-problems-with-native-off-heap-memo</a></li><li><a href="https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf</a></li><li><a href="https://stackoverflow.com/questions/31173374/why-does-a-jvm-report-more-committed-memory-than-the-linux-process-resident-set">https://stackoverflow.com/questions/31173374/why-does-a-jvm-report-more-committed-memory-than-the-linux-process-resident-set</a></li><li><a href="https://stackoverflow.com/questions/41468670/difference-in-used-committed-and-max-heap-memory">https://stackoverflow.com/questions/41468670/difference-in-used-committed-and-max-heap-memory</a></li><li><a href="https://stackoverflow.com/questions/2440434/whats-the-difference-between-reserved-and-committed-memory">https://stackoverflow.com/questions/2440434/whats-the-difference-between-reserved-and-committed-memory</a></li><li><a href="https://stackoverflow.com/questions/71366522/how-does-java-guarateee-reserved-memory">https://stackoverflow.com/questions/71366522/how-does-java-guarateee-reserved-memory</a></li><li><a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></li><li><a href="https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html">https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>开源 Metric 框架调研与 IoTDB Metric 系统性能优化</title>
      <link href="/article/Metric-System/"/>
      <url>/article/Metric-System/</url>
      
        <content type="html"><![CDATA[<p>DropWizard-Metric 和 MicroMeter 项目是 IoTDB Metric 系统的两大 baseline 之一。目前 IoTDB 在启动时分别提供基于 DropWizard-Metric 和 MicroMeter 实现的监控系统供用户选择。</p><p>本文基于 DropWizard-Metric 和 MicroMeter 的系统实现，对比二者实现性能优劣，期望能整合实现出 IoTDB 内部的最优监控系统，对于用户屏蔽算法库选择的参数，探究 IoTDB Metric 性能优化的可能。</p><h1 id="1-系统设计"><a href="#1-系统设计" class="headerlink" title="1. 系统设计"></a>1. 系统设计</h1><ul><li>DropWizard</li></ul><p>DropWizard 组件类型不复杂，核心组件类图如下。后文会对其一一解析。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115143242599.png" alt="image-20231115143242599"></p><ul><li>Micrometer</li></ul><p>在 Micrometer 中，所有监控指标都继承名为<code>Meter</code>的接口。Micrometer 有一组包含各种监控系统实现的模块，其中的每一种实现被称为<code>registry</code>。</p><ol><li>Micrometer提供了与供应商无关的接口，包括 <strong>timers（计时器）</strong>， <strong>gauges（量规）</strong>， <strong>counters（计数器）</strong>， <strong>distribution summaries（分布式摘要）</strong>， <strong>long task timers（长任务定时器）</strong>。它具有维度数据模型，当与维度监视系统结合使用时，可以高效地访问特定的命名度量，并能够跨维度深入研究。</li><li>可以看到，Micrometer 的核心组件、概念等与 DropWizard 类似。但是 Micrometer 组件非常丰富（提供了很多实现），因此类图过于复杂，此处不作赘述，后文将展开分析。</li></ol><h2 id="1-1-核心组件"><a href="#1-1-核心组件" class="headerlink" title="1.1. 核心组件"></a>1.1. 核心组件</h2><h3 id="1-1-1-MetricsRegistry-MeterRegistry"><a href="#1-1-1-MetricsRegistry-MeterRegistry" class="headerlink" title="1.1.1. MetricsRegistry &#x2F; MeterRegistry"></a>1.1.1. MetricsRegistry &#x2F; MeterRegistry</h3><h4 id="DropWizard"><a href="#DropWizard" class="headerlink" title="DropWizard"></a>DropWizard</h4><p>维护所有 Metric 的集合，在 DropWizard 中表现为 <code>MetricSet</code>。</p><p>核心是使用了 <code>private final ConcurrentMap&lt;String, Metric&gt; metrics</code> 维护所有的 Metric，key 是 metric 的 tag 或者 name</p><ol><li>提供了 <code>MetricRegistryListener</code>，目的是为了在子 registry 增加注册 metric 时，通知父 registry，同步添加到 registry 的 <code>ConcurrentHashMap</code> 中</li></ol><blockquote><p>特别设计：所有类型的 metric 共同放在一个 map 里。在 get 具体类型的 map 时，用到了 klass 进行类型判断，同时使用 MetricFilter 封装 name 匹配操作</p></blockquote><ol start="2"><li><p>提供对下面所有 Metric 的增删改查接口；类似 IoTDB 的 MetricService</p></li><li><p>提供了一些 Util 内部类，比如 MetricBuilder、MetricFilter，用来满足面向对象设计，与性能优化关系不大，暂时按下不表。</p></li><li><p>通常，每个应用程序只需要一个 MetricRegistry 实例，但如果想在特定报告组中组织指标，则可以选择使用更多实例。</p></li></ol><h4 id="Micrometer"><a href="#Micrometer" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>Meter 是收集应用的一系列指标的接口。Meter 是由 MeterRegistry 创建的。每个支持的监控系统都必须实现MeterRegistry。 </p><p>Micrometer 中包含一个 <code>SimpleMeterRegistry</code>，它在内存中维护每个 meter 的最新值，并且不将数据导出到任何地方。这是 Micrometer 最简单的注册表形式。 </p><p>但是，在大多数情况下，Micrometer 有专门为各种监控系统设计的 MeterRegistry：如对于 Promethus 来说，它是 <code>PromethusMeterRegistry</code>。</p><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115143317005.png" alt="image-20231115143317005" style="zoom: 25%;" align="center" /></div><p>甚至，我们可以自行继承 MeterRegistry 接口，定制我们需要的 Registry。定制主要出于以下几点考虑：</p><ol><li>重写创建指标组件（Gauge 等）的方法，对于不同的监控场景，自定义创建我们需要的指标组件类型。</li><li>与 Reporter 集成。这样启动 Registry 的同时自动 report，用户无需再特地使用 Report，符合面向对象行为和状态结合的思想。<ol><li>对 IoTDB 意义不大。因为 IoTDB 本来就是单独启动 Reporter 的，并且 IoTDB 的 Reporter 和 Registry 解耦。</li></ol></li></ol><p>Micrometer 还提供一种 <code>CompositeMeterRegistry</code> ，允许添加多个注册表。 它提供了一种将应用程序指标同时发布到各种受支持的监控系统的解决方案。</p><p>IoTDB 原本用的是 <code>globalRegistry</code>（本质上是一个<code>CompositeMeterRegistry</code>），里面套用 <code>SimpleMeterRegistry</code>。实际上可以认为 IoTDB 用的就是 <code>SimpleMeterRegistry</code>。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181326889.png" alt="image-20231115181326889"></p><p>但是由于 globalRegistry 本质上是 CompositeMeterRegistry，它创建具体的指标项时都是创建 CompositeXXX，CompositeXXX 在具体 api 调用时存在额外的调用开销。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181336375.png" alt="image-20231115181336375"></p><p>咨询 IoTDB Metric 系统的负责大佬 hy 后，得知 IoTDB 使用 CompositeRegistry 的初衷是保留后续为不同 MetricSet 分配不同 Registry 的可能，以提高并发度。</p><p>对于这个问题，考虑到 Registry 的功能仅作为 create 具体的指标项，create 动作本身不具有较高的并发，因此认为可以只有一个 Registry。而将不同 MetricSet 进行存储维度上的不同分配可以通过对 Map 进行更细划分实现。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181345900.png" alt="image-20231115181345900"></p><p>因此，考虑将 IoTDB 的 MetricRegistry 简化成 SimpleRegistry，减少每次记录指标时多出来的函数调用开销。</p><p><strong>此外，也可以考虑直接删除对 Micrometer Registry 的依赖</strong>（需要重写 JMX Reporter），因为 IoTDB 已经有一套 metrics 的增删改查和命名系统，与 Registry 的功能重复。删掉 Registry 后能对每个 metric 都避免重复的存储动作，节省一倍内存。代码可读性、可维护性也更好。</p><ul><li><strong>最终采用此种方案，详细实施可见后文</strong></li></ul><h3 id="1-1-2-Gauges"><a href="#1-1-2-Gauges" class="headerlink" title="1.1.2. Gauges"></a>1.1.2. Gauges</h3><h4 id="DropWizard-1"><a href="#DropWizard-1" class="headerlink" title="DropWizard"></a>DropWizard</h4><p>DropWizard 中的 gauge 的默认实现使用：<code>DefaultSettableGauge</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MetricBuilder&lt;Gauge&gt; GAUGES = <span class="keyword">new</span> <span class="title class_">MetricBuilder</span>&lt;Gauge&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Gauge <span class="title function_">newMetric</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSettableGauge</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInstance</span><span class="params">(Metric metric)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Gauge.class.isInstance(metric);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其他类型的 gauge 主要需要关注 <code>CachedGauge</code>，它缓存了 Gauge 中的值，并设置了过期时间。只有当值过期时，才会 reload 值。</p><p>其他的 Gauge 基本都是存取某个对象计算值的方法引用，其效率取决于具体的<code>getValue()</code>方法。</p><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181356236.png" alt="image-20231115181356236" style="zoom:50%;" /></div><h4 id="Micrometer-1"><a href="#Micrometer-1" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>种类比较多，主要用到的是 <code>DefaultGauge</code> 和 <code>CompositeGauge</code></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181423309.png" alt="image-20231115181423309"></p><p>Micrometer 的 gauge 不是将值的计算委托给具体的对象，而是将<strong>获取具体对象和计算值的方法解耦</strong>。如此，gauge 寄存的值不局限于某个对象的某个方法，对象和方法可以解耦，增强了可拓展性。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181433511.png" alt="image-20231115181433511"></p><p><strong>至于性能上</strong>，由于 Micrometer 没有提供缓存版 gauge，因此在涉及读密集且重计算的场景时会有性能问题，预期不如 Dropwizard。<strong>考虑在 IoTDB 实现时加一层缓存进行优化。</strong></p><h3 id="1-1-3-Rate"><a href="#1-1-3-Rate" class="headerlink" title="1.1.3. Rate"></a>1.1.3. Rate</h3><h4 id="DropWizard-2"><a href="#DropWizard-2" class="headerlink" title="DropWizard"></a>DropWizard</h4><p>相当于 Meter，用于度量事件响应的平均速率，它表示的是应用程序整个运行生命周期内的总速率（总请求响应量&#x2F;处理请求的总毫秒数，即每秒请求数）。</p><p>除此之外，Meter 还提供了1分钟、5分钟以及15分钟的动态平均响应速率。</p><p>其实现借助了 <code>MovingAverage</code>。</p><h4 id="Micrometer-2"><a href="#Micrometer-2" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>没有找到 Rate 语义的实现。</p><h3 id="1-1-4-Counter"><a href="#1-1-4-Counter" class="headerlink" title="1.1.4. Counter"></a>1.1.4. Counter</h3><p>Counter 是一个常规计数器，用于对某项指标值进行累加或者递减操作。</p><h4 id="DropWizard-3"><a href="#DropWizard-3" class="headerlink" title="DropWizard"></a>DropWizard</h4><p>Counter 本质是一个 <code>java.util.concurrent.atomic.LongAdder</code>，在多线程同时更新计数器的场景下，当并发量较大时，LongAdder 比 AtomicLong 具有更高的吞吐量，当然空间资源消耗也更大一些。</p><h4 id="Micrometer-3"><a href="#Micrometer-3" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>Micrometer 提供了更多种类的 Counter，基本功能都类似 <code>CumulativeCounter</code>，其他 Counter 的主要区别是拓展了一些和监控系统相关的功能，具体使用哪种与 Registry 有关。IoTDB 目前使用的 <code>SimpleMeterRegistry</code> 使 用 <code>CumulativeCounter</code>。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181503300.png" alt="image-20231115181503300"></p><p>其与 DropWizard 的实现大同小异，**唯一区别是前者使用 <code>DoubleAdder</code>，后者使用 <code>LongAdder</code>**。但是前者最终接口是 long，因此涉及一些转化开销，double 本身的运算开销也较大。因此 DropWizard 性能更好。</p><p><strong>考虑使用</strong> <strong><code>LongAdder</code></strong> <strong>实现 Counter。</strong></p><h3 id="1-1-5-Histogram-DistributionSummary"><a href="#1-1-5-Histogram-DistributionSummary" class="headerlink" title="1.1.5. Histogram &#x2F; DistributionSummary"></a>1.1.5. Histogram &#x2F; DistributionSummary</h3><h4 id="DropWizard-4"><a href="#DropWizard-4" class="headerlink" title="DropWizard"></a>DropWizard</h4><p>Histogram 反应的是数据流中的值的分布情况。包含最小值、最大值、平均值、中位数、p75、p90、p95、p98、p99以及p999数据分布情况。</p><blockquote><p>节选自参考资料：</p><p>传统 Histogram 计算分位数的方法是先对整个数据集进行排序，然后取排序后的数据集中特定位置的值（比如p99就是取倒序1%位置的值）。这种方式适合于小数据集或者批处理系统，不适用于要求高吞吐量、低延时的服务。</p><p>但这样方式保留全部数据后 sort 的方式明显对内存和运算不友好。因此 Dropwizard 使用了另外的随机性算法。</p></blockquote><p>对于数据量较大，系统对吞吐量、时延要求较大的场景，我们可以采用抽样的方式获取数据。（大意是通过保证概率相等的情况下，仅保留一定量的数据）</p><p>上述这种通过动态地抽取程序运行过程中的能够代表系统真实运行情况的一小部分数据来实现对整个系统运行指标的近似度量，这种方法叫做**<a href="https://zhuanlan.zhihu.com/p/29178293">蓄水池算法（reservoir sampling）</a>**。</p><p>DropWizard 中有三种 reservoir，分别简单介绍下：</p><ol><li><strong>UniformReservoir</strong></li></ol><p>内部为<code>DEFAULT_SIZE = 1028</code>的一个数组</p><p>超过大小了则随机丢弃或者不加入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">long</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> count.incrementAndGet();</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= values.length()) &#123;</span><br><span class="line">        values.set((<span class="type">int</span>) c - <span class="number">1</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> ThreadLocalRandom.current().nextLong(c);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; values.length()) &#123;</span><br><span class="line">            values.set((<span class="type">int</span>) r, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来源于这篇论文：**<a href="http://www.cs.umd.edu/~samir/498/vitter.pdf">Vitter’s R</a>**</p><ol start="2"><li><strong>SlidingWindowReservoir</strong></li></ol><p>保留最近的 N 个值，N 可以在构造函数指定</p><p>简单的滑动窗口逻辑，可以理解为用一个 ring buffer 来存储数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">long</span> value)</span> &#123;</span><br><span class="line">    measurements[(<span class="type">int</span>) (count++ % measurements.length)] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>SlidingTimeWindowReservoir</strong></li></ol><p>保留最近 N 秒的数据，N 可以在构造函数指定</p><p>用时间而不是长度来作为滑动窗口的 window size</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">long</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count.incrementAndGet() % TRIM_THRESHOLD == <span class="number">0</span>) &#123;</span><br><span class="line">        trim();</span><br><span class="line">    &#125;</span><br><span class="line">    measurements.put(getTick(), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点是如果瞬间流量很大，该数据结构内存不可控（因为短时间内存入大量数据，且这些数据都在 window 内，短期内不会被丢弃），因此还提供了<code>SlidingTimeWindowArrayReservoir</code>这个替代的基础结构。</p><ol start="4"><li><strong>ExponentiallyDecayingReservoir</strong></li></ol><p><code>MetericRegistry::histogram</code>默认创建为该类型，内部为<code>DEFAULT_SIZE = 1028</code>的一个跳表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MetricBuilder&lt;Histogram&gt; HISTOGRAMS = <span class="keyword">new</span> <span class="title class_">MetricBuilder</span>&lt;Histogram&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Histogram <span class="title function_">newMetric</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Histogram</span>(<span class="keyword">new</span> <span class="title class_">ExponentiallyDecayingReservoir</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInstance</span><span class="params">(Metric metric)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Histogram.class.isInstance(metric);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它基于指数级别的抽样算法，根据更新时间与开始时间的差值转化为权重值，权重越大数据被保留的几率越大。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds an old value with a fixed timestamp to the reservoir.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value     the value to be added</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp the epoch timestamp of &#123;<span class="doctag">@code</span> value&#125; in seconds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">long</span> value, <span class="type">long</span> timestamp)</span> &#123;</span><br><span class="line">        rescaleIfNeeded();</span><br><span class="line">        lockForRegularUsage();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">double</span> <span class="variable">itemWeight</span> <span class="operator">=</span> weight(timestamp - startTime);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">WeightedSample</span> <span class="variable">sample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeightedSample</span>(value, itemWeight);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">double</span> <span class="variable">priority</span> <span class="operator">=</span> itemWeight / ThreadLocalRandom.current().nextDouble();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">newCount</span> <span class="operator">=</span> count.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (newCount &lt;= size || values.isEmpty()) &#123;</span><br><span class="line">                values.put(priority, sample);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Double</span> <span class="variable">first</span> <span class="operator">=</span> values.firstKey();</span><br><span class="line">                <span class="keyword">if</span> (first &lt; priority &amp;&amp; values.putIfAbsent(priority, sample) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// ensure we always remove an item</span></span><br><span class="line">                    <span class="keyword">while</span> (values.remove(first) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        first = values.firstKey();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlockForRegularUsage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体来说，<code>ExponentiallyDecayingReservoir</code> 会定期执行重定标（rescale）操作，以清理旧数据并降低数据的权重，从而达到淘汰数据的目的。</p><p>Rescale 的大致过程是：基于指数衰减公式 <code>exp(-alpha * (startTime - oldStartTime))</code>计算缩放因子，如果缩放因子等于零，说明时间差距太大，直接清空所有的样本数据；否则，遍历所有样本数据，根据缩放因子将每个样本的权重进行缩放，然后将缩放后的样本数据重新插入到数据结构中。</p><p>来源于这篇论文：**<a href="http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf">forward-decaying priority reservoir</a>**</p><h4 id="Micrometer-4"><a href="#Micrometer-4" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>Micrometer 拥有 Histogram 类，然而 IoTDB 使用的是 Micrometer 的 DistributionSummary。</p><ol><li><strong>Histogram 和 DistributionSummary 有什么功能区别？</strong></li></ol><p>实际代码可以看出：Histogram 在 Micrometer 中是作为一种基础组件，而不是一种监控指标。DistributionSummary 集成了 Histogram</p><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181523661.png" alt="image-20231115181523661" style="zoom:50%;"/></div><p>因此使用 DistributionSummary 即可。</p><ol start="2"><li><strong>DistributionSummary 是怎么实现的？</strong></li></ol><p>根据官网我们知道：DistributionSummary 跟 Timer 的实现结构几乎完全一样，只不过记录的不是 time unit 的值。因此可以参考本文 1.2.5 节。</p><p>值得一提的是，Micrometer 的实现借助了 <a href="https://github.com/HdrHistogram/HdrHistogram">HdrHistogram</a> 这款开源 histogram 库，后文会详细介绍。</p><h4 id="HdrHistogram"><a href="#HdrHistogram" class="headerlink" title="HdrHistogram"></a>HdrHistogram</h4><p>HdrHistogram 是一款高性能、高精度 histogram 库。在 Micrometer 的 Histogram 中使用了 HdrHistogram 作为 baseline。</p><h5 id="1-Micrometer-是怎么使用-HdrHistogram-的？"><a href="#1-Micrometer-是怎么使用-HdrHistogram-的？" class="headerlink" title="1.  Micrometer 是怎么使用 HdrHistogram 的？"></a>1.  Micrometer 是怎么使用 HdrHistogram 的？</h5><p>Micrometer 的 Histogram 分为 Abstract 基类和实现类。基类实现了写路径、淘汰旧数据等基本逻辑；实现类实现了读、记录新数据等 api。</p><ul><li>实现类：实际上就是 wrap 了 HdrHistogram 的 DoubleHistogram，在读路径中用到，作为暴露给外界的结果变量使用。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181543798.png" alt="image-20231115181543798"></p><ul><li>基类：有一个 ringBuffer，ringBuffer 的每一项都是一个 Histogram。写路径更新 ringBuffer（下一节将详细描述）， 有一个函数在 takeSnapshot 时把 <code>ringBuffer[currentBucket]</code> 的值 copy 给实现类的 <code>intervalHistogram</code>（见上图），并做后续处理。</li></ul><h5 id="2-Micrometer-是如何结合-HdrHistogram-实现淘汰旧数据的？"><a href="#2-Micrometer-是如何结合-HdrHistogram-实现淘汰旧数据的？" class="headerlink" title="2. Micrometer 是如何结合 HdrHistogram 实现淘汰旧数据的？"></a>2. Micrometer 是如何结合 HdrHistogram 实现淘汰旧数据的？</h5><ul><li>首先，Micrometer 用一个 ringBuffer 来存储数据。ringBuffer 的每一项就是一个 HdrHistogram（<code>org.HdrHistogram.DoubleRecorder</code>）</li><li>当导出 Snapshot 的时候，用到的是 <code>currrentBucket</code> 指针指向的 buffer。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181608771.png" alt="image-20231115181608771"></p><ul><li>Micrometer 每次插入数据的时候，会往 ringBuffer 中的所有 buffer 插入数据（后文会解释「为什么要向所有的 buffer 插入数据」）</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181619688.png" alt="image-20231115181619688"></p><ul><li>Micrometer 在每次插入新数据前，会调用 <code>rotate()</code> 方法。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181630199.png" alt="image-20231115181630199"></p><ul><li><p><strong>rotate() 方法实现了淘汰旧数据</strong>。逻辑如下：</p></li><li><p>如果上一次淘汰数据到现在的累积时间超过了阈值（该阈值可以通过 config 设置，即 IoTDB metric core 代码里设置的 expiry，默认 1 分钟），那么即实行淘汰策略：reset（清空）  <code>currrentBucket</code> 指向的 buffer，并将 buffer 指针（ <code>currrentBucket</code> ）后移。</p></li><li><p>之后新数据到来时，Micrometer 会向 ringBuffer 中的所有 buffer 插入新数据。但由于某些 buffer 已经被清空过了，因此它们就会只保存后面插入的新数据</p></li><li><p>由于 Micrometer 真正用到的 histogram 是 <code>currrentBucket</code> 指针指向的 buffer，而每次 rotate 会将 <code>currrentBucket</code> 指针后移，因此相当于不断给予保存新数据 buffer 更高的权重。</p></li><li><p>综上，如此就巧妙的达到了淘汰旧数据的目标。可以看出：相比于 DropWizard 每次淘汰旧数据时对跳表的复杂操作，Micrometer 的 rotate 开销不大，再配合 HdrHistogram 本身静态分桶的高写入速度（后文会提到），Micrometer 就实现了比 DropWizard 更好的（写）性能。</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181650099.png" alt="image-20231115181650099"></p><ul><li><strong>可优化点思考：</strong>从前面分析可以看到，Micrometer 在每次写入数据时，对 ringBuffer 的所有 bucket 都进行了写入操作。那么是否可以通过缩小 ringBuffer 的 size，从而减少写 bucket 次数，来提高 Micrometer Histogram 的写入效率？需要研究下 ringBuffer.length 的设置原理。<ul><li>ringBuffer.length 默认设置为 3。根据上文，只要保证 ringBuffer.length 大于 1 既能保证淘汰旧数据的目的。因此考虑将 ringBuffer.length 设为 2（<strong>PR</strong>: <a href="https://github.com/apache/iotdb/pull/11500%EF%BC%89">https://github.com/apache/iotdb/pull/11500）</a></li></ul></li></ul><h5 id="3-HdrHistogram-的设计思路和算法有哪些？"><a href="#3-HdrHistogram-的设计思路和算法有哪些？" class="headerlink" title="3. HdrHistogram 的设计思路和算法有哪些？"></a>3. HdrHistogram 的设计思路和算法有哪些？</h5><p>不同于前文提到 DropWizard 使用的随机性算法实现（淘汰旧数据），HdrHistogram 使用的是<strong>确定性算法</strong>。</p><p>确定性算法本质上就是静态分桶，有点类似压缩存储的思想。<strong>用容器将所有遇到的数据全部保存起来</strong>，<strong>实际上不需要将每个值都存下来，但结果也不是精确解。</strong>以达到 Histogram 所需要的计算分位数等功能。但 HdrHistogram 不是一个数字一个桶，而是一个区间一个桶。该区间的范围可以是线性增长，也可指数增长。<strong>通过一个区间分一个桶</strong>的方式， 就能通过牺牲一小部分精度，从而达到减小空间占用，并且数据大致准确的结果。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181702444.png" alt="image-20231115181702444"></p><h5 id="4-HdrHistogram-具体是如何分割区间的？"><a href="#4-HdrHistogram-具体是如何分割区间的？" class="headerlink" title="4. HdrHistogram 具体是如何分割区间的？"></a>4. HdrHistogram 具体是如何分割区间的？</h5><p>前面提到，HdrHistogram 不是一个数字一个桶，而是一个区间一个桶。该区间的范围可以是线性增长，也可指数增长。现在假设有值域为 [0..R] 的区间</p><ul><li>对于线性分桶：也就是对于 0..R 如果用 B 分隔， 那么总共可以分隔 R&#x2F;B 个格子，数组的size也是 R&#x2F;B</li><li>对于指数分桶，也就是基于指数分隔（2 的幂次），第一个桶有 2^0 个数，第二个桶有 2^1 个数… 第 n 个桶有 2^(n-1) 个数。</li></ul><p>举个例子，比如 10w 个数字：</p><p>采用线性的分桶方法，假设每个 bucket 可以表示100个值，那么需要 1000 个 buckets, : <code>[1..100][101..200]...[99,901..100,000]</code></p><p>采用指数的分桶方式，只需要 17 个 buckets， <code>[2^K..(2^(K+1)-1)]</code> e.g. <code>[1..1][2..3][4..7]...[65,536..131,071]</code></p><p>这里 HdrHistogram 用了一个 trick：</p><p>对于分隔 buckets，HdrHistogram 同时采用了线性和指数，HdrHistogram 内部有2个 index，<code>bucketsIdx</code> 和 <code>subBucketIndex</code>. 前者是指数的，后者是线性的。可以根据业务精度需求控制后面的线性的大小。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181715521.png" alt="image-20231115181715521"></p><p>首先，所谓「分桶」就是一个 long 数组。数组的每一项就是一个桶，其意义是：统计某个区间内数据出现的次数。分桶策略决定了数组的每一项统计的区间范围是多少。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181730237.png" alt="image-20231115181730237"></p><p>具体来说，HdrHistogram 的分桶策略是<strong>指数和线性结合</strong>：</p><p>HdrHistogram 先将需要统计的总区间通过 2 的幂次指数分成 n 个桶<em>（如果区间长度为 l，即保证 2^(n-1) &gt;&#x3D; l）</em>，此时标识这些桶的 index 就叫 <code>bucketIndex</code>。而每个桶又分为 <code>subBucketCount</code> 个子桶（<code>subBucketCount</code> 是可间接配置的），这些子桶的下标就叫做 <code>subBucketIndex</code>。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181756401.png" alt="image-20231115181756401"></p><p><strong>举个例子，</strong>每个桶有 <code>subBucketCount</code> 个子桶，这里假设为 2048 ，那么第 1 个桶可以以 2^0 的精度表示 2^0 * 0 ~ 2^0 * 2048，即第 1 个桶可以覆盖区间 [0, 2048]，且每个子桶可以覆盖 1 个值（精度是 2^0 &#x3D; 1）。</p><p>这里就有一个<strong>「桶重叠」(bucket overlap)</strong> 的问题。首先我们给出结论：</p><ul><li>第 0 个桶以 2^0 &#x3D; 1 的精度覆盖 0…2047，使用所有 2048 个子桶</li><li>第 1 个桶以 2^1 &#x3D; 2 的精度，理论上能覆盖 0… 4095，但仅使用顶部 1024 个子桶，实际上覆盖 2048..4095</li><li>第 2 个桶以 2^2 &#x3D; 4 的精度，理论上能覆盖 0… 8191，但仅使用顶部 1024 个子桶，实际上覆盖 4096..8191</li></ul><p>为什么 Bucket 0 是唯一使用 2048 个子桶的，而其余桶都只使用 1024 个子桶呢？</p><ul><li>因为它们的下半部分与前面所有的存储桶重叠并且已经被覆盖：<ul><li>举个例子，第 k 个桶可以以 2^k 精度表示 2048 个子桶，覆盖区间为 0 * 2^k 到 2048 * 2^k</li><li>但是第 k 个桶的中点：1024 * 2^k &#x3D; 2048 * 2^(k-1) &#x3D; 第 k-1 个存储桶的末尾，因此我们将使用前一个存储桶（第 k-1 个桶）来存储第 k 个桶起点 ～ 第 k 个桶中点的值，<strong>因为它具有更好的精度（即子桶存储的区间范围更小）</strong>。</li></ul></li></ul><p>那么当一个数据被插入，实际计算其下标时，就是结合上述分桶原理，计算它所在的桶（bucketIndex）和子桶（subBucketIndex），二者经过一些简单组合运算后得到最终下标，可以参考代码：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181812492.png" alt="image-20231115181812492"></p><p><strong>这样分桶的好处是：</strong></p><ul><li>如果纯线性分桶，那么显然空间占用过大；如果纯指数分桶，又会有精度的问题。二者结合，可以较好的解决线性分桶空间占用的问题，一定程度上优化指数分桶精度的问题。整个分桶思想有点类似压缩存储，将所有数据保存起来，但是不保存具体的值。在舍弃一点精度的情况下省下大量内存。</li><li>前文提到，<code>subBucketCount</code> 是可配置的。因此我们可以根据业务精度需求，控制线性分桶的精度大小，比较灵活。（线性分桶数越大，精度越大，所占内存越大）<ul><li>这也就是 Histogram 构造函数第二个参数的含义：它与 <code>subBucketCount</code> 有关。<ul><li><p>该参数与 <code>subBucketCount</code> 的转换逻辑如下</p></li><li><pre><code class="Java">static int numberOfSubBuckets(final int numberOfSignificantValueDigits) &#123;    final long largestValueWithSingleUnitResolution = 2 * (long) Math.pow(10, numberOfSignificantValueDigits);    // We need to maintain power-of-two subBucketCount (for clean direct indexing) that is large enough to    // provide unit resolution to at least largestValueWithSingleUnitResolution. So figure out    // largestValueWithSingleUnitResolution&#39;s nearest power-of-two (rounded up), and use that:    int subBucketCountMagnitude = (int) Math.ceil(Math.log(largestValueWithSingleUnitResolution)/Math.log(2));    int subBucketCount = (int) Math.pow(2, subBucketCountMagnitude);    return subBucketCount;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 该参数值域为 0-5，分别对应 `subBucketCount` 为：</span><br><span class="line">- ```Plain</span><br><span class="line">  0 - 2</span><br><span class="line">  1 - 32</span><br><span class="line">  2 - 256</span><br><span class="line">  3 - 2048</span><br><span class="line">  4 - 32768</span><br><span class="line">  5 - 262144</span><br></pre></td></tr></table></figure></code></pre></li><li><p>该参数 IoTDB metric core 里默认配置的是 1（值域为 0 - 5，数字越大，<code>subBucketCount</code> 越大），最终会导致 <code>subBucketCount</code> 为 32</p></li></ul></li><li><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181825941.png" alt="image-20231115181825941"></li></ul></li></ul><h5 id="5-HdrHistogram-的-resize-机制"><a href="#5-HdrHistogram-的-resize-机制" class="headerlink" title="5. HdrHistogram 的 resize 机制"></a>5. HdrHistogram 的 resize 机制</h5><p>当然以上都有个缺点，需要一个可预估的最大值（可以理解为 HdrHistogram 统计区间的最大值）。如果有超过最大值的数字（即数据大小超过了 HdrHistogram 的统计区间）</p><ol><li>如果没有设置 <code>autoResize</code>，将抛出异常，存入失败。</li><li>如果设置了 <code>autoResize</code>，将 resize 区间（重新设置区间范围并重新分桶）</li><li>默认 <code>autoSize</code> 为 true</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181836431-20231115181956661.png"></p><ul><li><code>autoResize</code> 是 Histogram 类里面的一个可设置参数</li></ul><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182017944.png" alt="image-20231115182017944" style="zoom: 33%;" /><h5 id="6-HdrHistogram-如何确定统计区间的上下界？"><a href="#6-HdrHistogram-如何确定统计区间的上下界？" class="headerlink" title="6. HdrHistogram 如何确定统计区间的上下界？"></a>6. HdrHistogram 如何确定统计区间的上下界？</h5><p>答案：通过构造函数设定。</p><p>可以清晰的看到 Histogram 类的构造函数参数含义</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182041701.png" alt="image-20231115182041701"></p><p>但 Micrometer（IoTDB）中不是直接调用该构造函数，跟进发现调用的构造函数是：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182051030.png" alt="image-20231115182051030"></p><p>其中，<code>highestToLowestValueRatio</code> 和 <code>numberOfSignificantValueDigits</code> 共同确定了 hdrHistogram 的上下界。跟进发现最终上下界为 <strong>[1, 127]</strong></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182059931.png" alt="image-20231115182059931"></p><ul><li><strong>可优化点思考：</strong>从前面分析可以看到，当数据超过 hdrHistogram 范围时，会发生 resize，该操作有时间开销。目前的上下界 [1, 127] 显然范围有点小了，在大值数据场景下显然要 resize，甚至多次 resize。我们是否可以对每一个 timer&#x2F;histogram 的使用场景预估数据区间，为每一个 timer&#x2F;histogram 定制数据上下界，尽量避免 resize 操作。<ul><li>由于 Micrometer 没有暴露定制化 hdrHistogram 区间范围的 API，该改动阻塞。已向他们提 issue（<a href="https://github.com/micrometer-metrics/micrometer/issues/4327%EF%BC%89">https://github.com/micrometer-metrics/micrometer/issues/4327）</a></li></ul></li></ul><h5 id="7-HdrHistogram-和-DropWizard-优劣分析"><a href="#7-HdrHistogram-和-DropWizard-优劣分析" class="headerlink" title="7. HdrHistogram 和 DropWizard 优劣分析"></a>7. HdrHistogram 和 DropWizard 优劣分析</h5><ul><li>写入速度：Hdr 远优于 DropWizard<ul><li>正是因为 HdrHistogram 是静态分桶实现，所以写入友好（不需要淘汰旧数据），在 record 性能测试中比 DropWizard 表现要好。</li><li>HdrHistogram 底层是数组，而 DropWizard 底层是跳表，数组肯定比跳表写入快。</li><li>DropWizard 默认设置是每隔一段时间要 rescale 一下，而 rescale 是要锁写的。</li></ul></li><li>读取速度：二者差不多<ul><li>因为都是给定了分位数，相当于给定数组下标&#x2F;跳表 key 了，直接读取基本都是 O(1)</li></ul></li><li>空间占用：需要具体分析。因为 HdrHistogram 可以通过指数分桶减少空间占用，而 DropWizard 的空间占用也和用户指定的容器大小有关，所以直观上不太好说谁空间占用更好，需要结合具体场景分析。</li></ul><h3 id="1-1-6-Timer"><a href="#1-1-6-Timer" class="headerlink" title="1.1.6. Timer"></a>1.1.6. Timer</h3><h4 id="DropWizard-5"><a href="#DropWizard-5" class="headerlink" title="DropWizard"></a>DropWizard</h4><p>Timer 相当于 Meter + Histogram（默认使用 <code>ExponentiallyDecayingReservoir</code>）。可以统计接口请求速率和响应时长。会度量服务的响应速率，同时也会统计服务响应时长的分布情况。</p><blockquote><p>可以说，Timer 能兼容 Meter + Histogram 的所有接口。</p></blockquote><p>因此 Timer 底层的 update 主要也就是更新 Histogram 和 Meter。</p><h4 id="Micrometer-5"><a href="#Micrometer-5" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>Timer 用于度量短时间内的事件时延和响应频率。所有的 Timer 实现都记录了事件响应总耗时和事件总数。Timer 不支持负数，此外如果使用它来记录大批量、长时延事件的话，容易导致指标值数据越界（超过<code>Long.MAX_VALUE</code>）。</p><p>同样，Micrometer 为每种监控系统设计了不同的 Timer，主要用的是 <code>CumulativeTimer</code>。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182117259.png" alt="image-20231115182117259"></p><p>Micrometer 的 Timer 相当于 Histogram + 自己实现的计时器（用 AtomicLong 累计 nanoTime 等）。每次 Record 时会更新 Histogram 并更新自己实现的计时器。</p><h2 id="1-2-Reporter"><a href="#1-2-Reporter" class="headerlink" title="1.2. Reporter"></a>1.2. Reporter</h2><p>用于将 metric 指标数据导出到具体的某个介质。</p><p>IoTDB 主要使用了 IoTDBReporter、PrometheusReporter、JMXReporter 三种。因此本文主要探究 DropWizard 中对应的 InfluxDBReporter、GraphiteReporter、JMXReporter 三种 Reporter</p><h3 id="1-2-1-InfluxDBReporter"><a href="#1-2-1-InfluxDBReporter" class="headerlink" title="1.2.1. InfluxDBReporter"></a>1.2.1. InfluxDBReporter</h3><ul><li><strong>设计思想：</strong> InfluxDB 报告器的设计思想是将度量数据发送到 InfluxDB，以便进行高性能的存储和查询。</li><li><strong>具体实现：</strong> InfluxDB 报告器使用 HTTP 协议将度量数据发送到 InfluxDB 服务器。它将度量名称、值和标签（tags）映射到 InfluxDB 中的数据点，并将其存储在数据库中。</li></ul><h3 id="1-2-2-GraphiteReporter"><a href="#1-2-2-GraphiteReporter" class="headerlink" title="1.2.2. GraphiteReporter"></a>1.2.2. GraphiteReporter</h3><ul><li><strong>设计思想：</strong> Graphite报告器的设计思想是将度量数据发送到Graphite，一个可扩展的度量数据存储和可视化工具，以便长期存储和绘制度量图表。</li><li><strong>具体实现：</strong> Graphite报告器使用TCP或UDP协议将度量数据发送到Graphite服务器。它将度量名称和值映射到Graphite中的度量路径，并定期将数据发送到服务器。</li></ul><h3 id="1-2-3-JMXReporter"><a href="#1-2-3-JMXReporter" class="headerlink" title="1.2.3. JMXReporter"></a>1.2.3. JMXReporter</h3><ul><li><strong>设计思想：</strong> 将 Metric 注册为 MBean，随后将度量数据以Java管理扩展（JMX）的方式导出，以便通过JMX客户端监视和管理应用程序。</li><li><strong>具体实现：</strong> 将度量数据注册到JMX服务器中，然后可以使用JMX客户端连接到服务器，查看和管理度量数据。实现了 JMXListener（本质上也是个 MetricRegistry，监听主 Registry）<ul><li>每次 registry 创建了一个 metric 对象后，在 JMX 中深 clone 一份 JMXMetric，并将其注册为 MBean</li></ul></li></ul><h1 id="2-性能测试"><a href="#2-性能测试" class="headerlink" title="2. 性能测试"></a>2. 性能测试</h1><p>本节主要目的是全面测试对比 Micrometer 和 DropWizard 的性能优劣，从而在算法库参数上做出取舍。</p><p>By JMH benchmark</p><h2 id="2-1-Counter"><a href="#2-1-Counter" class="headerlink" title="2.1. Counter"></a>2.1. Counter</h2><p><strong>测试代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.codahale.metrics.MetricRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.Counter;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.MeterRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.dropwizard.DropwizardCounter;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.prometheus.PrometheusConfig;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.prometheus.PrometheusMeterRegistry;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 Benchmark，测试多线程性能</span></span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterBenchmark</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">            .include(CounterBenchmark.class.getSimpleName())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MeterRegistry micrometerRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MetricRegistry dropwizardRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Counter micrometerCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> com.codahale.metrics.Counter dropwizardCounter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        micrometerRegistry = <span class="keyword">new</span> <span class="title class_">SimpleMeterRegistry</span>();;</span><br><span class="line">        micrometerCounter = micrometerRegistry.counter(<span class="string">&quot;micrometerCounter&quot;</span>);</span><br><span class="line"></span><br><span class="line">        dropwizardRegistry = <span class="keyword">new</span> <span class="title class_">MetricRegistry</span>();</span><br><span class="line">        dropwizardCounter = dropwizardRegistry.counter(<span class="string">&quot;dropwizardCounter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dropwizardCountSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            dropwizardCounter.inc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">micrometerCountSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            micrometerCounter.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; Task :micrometer-benchmarks-core:CounterBenchmark.main()</span><br><span class="line"><span class="comment"># JMH version: 1.37</span></span><br><span class="line"><span class="comment"># VM version: JDK 17.0.8.1, OpenJDK 64-Bit Server VM, 17.0.8.1+8-LTS</span></span><br><span class="line"><span class="comment"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-17.0.8.1/Contents/Home/bin/java</span></span><br><span class="line"><span class="comment"># VM options: -Dfile.encoding=UTF-8 -Duser.country=CN -Duser.language=zh -Duser.variant</span></span><br><span class="line"><span class="comment"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)</span></span><br><span class="line"><span class="comment"># Warmup: 1 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Measurement: 2 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Timeout: 10 min per iteration</span></span><br><span class="line"><span class="comment"># Threads: 1 thread, will synchronize iterations</span></span><br><span class="line"><span class="comment"># Benchmark mode: Average time, time/op</span></span><br><span class="line"><span class="comment"># Benchmark: io.micrometer.benchmark.core.CounterBenchmark.dropwizardCountSum</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 0.00% complete, ETA 00:05:00</span></span><br><span class="line"><span class="comment"># Fork: 1 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 504.794 ns/op</span></span><br><span class="line">Iteration   1: 506.459 ns/op</span><br><span class="line">Iteration   2: 506.261 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 10.00% complete, ETA 00:04:31</span></span><br><span class="line"><span class="comment"># Fork: 2 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 506.972 ns/op</span></span><br><span class="line">Iteration   1: 505.873 ns/op</span><br><span class="line">Iteration   2: 498.922 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 20.00% complete, ETA 00:04:01</span></span><br><span class="line"><span class="comment"># Fork: 3 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 506.325 ns/op</span></span><br><span class="line">Iteration   1: 506.829 ns/op</span><br><span class="line">Iteration   2: 504.362 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 30.00% complete, ETA 00:03:32</span></span><br><span class="line"><span class="comment"># Fork: 4 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 503.179 ns/op</span></span><br><span class="line">Iteration   1: 503.631 ns/op</span><br><span class="line">Iteration   2: 518.545 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 40.00% complete, ETA 00:03:01</span></span><br><span class="line"><span class="comment"># Fork: 5 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 509.092 ns/op</span></span><br><span class="line">Iteration   1: 509.741 ns/op</span><br><span class="line">Iteration   2: 505.743 ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.CounterBenchmark.dropwizardCountSum&quot;</span>:</span><br><span class="line">  506.637 ±(99.9%) 7.589 ns/op [Average]</span><br><span class="line">  (min, avg, max) = (498.922, 506.637, 518.545), stdev = 5.020</span><br><span class="line">  CI (99.9%): [499.048, 514.225] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># JMH version: 1.37</span></span><br><span class="line"><span class="comment"># VM version: JDK 17.0.8.1, OpenJDK 64-Bit Server VM, 17.0.8.1+8-LTS</span></span><br><span class="line"><span class="comment"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-17.0.8.1/Contents/Home/bin/java</span></span><br><span class="line"><span class="comment"># VM options: -Dfile.encoding=UTF-8 -Duser.country=CN -Duser.language=zh -Duser.variant</span></span><br><span class="line"><span class="comment"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)</span></span><br><span class="line"><span class="comment"># Warmup: 1 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Measurement: 2 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Timeout: 10 min per iteration</span></span><br><span class="line"><span class="comment"># Threads: 1 thread, will synchronize iterations</span></span><br><span class="line"><span class="comment"># Benchmark mode: Average time, time/op</span></span><br><span class="line"><span class="comment"># Benchmark: io.micrometer.benchmark.core.CounterBenchmark.micrometerCountSum</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 50.00% complete, ETA 00:02:31</span></span><br><span class="line"><span class="comment"># Fork: 1 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 761.443 ns/op</span></span><br><span class="line">Iteration   1: 750.091 ns/op</span><br><span class="line">Iteration   2: 717.163 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 60.00% complete, ETA 00:02:01</span></span><br><span class="line"><span class="comment"># Fork: 2 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 730.985 ns/op</span></span><br><span class="line">Iteration   1: 786.655 ns/op</span><br><span class="line">Iteration   2: 583.315 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 70.00% complete, ETA 00:01:30</span></span><br><span class="line"><span class="comment"># Fork: 3 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 564.985 ns/op</span></span><br><span class="line">Iteration   1: 567.606 ns/op</span><br><span class="line">Iteration   2: 675.625 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 80.00% complete, ETA 00:01:00</span></span><br><span class="line"><span class="comment"># Fork: 4 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 626.955 ns/op</span></span><br><span class="line">Iteration   1: 560.499 ns/op</span><br><span class="line">Iteration   2: 692.164 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 90.00% complete, ETA 00:00:30</span></span><br><span class="line"><span class="comment"># Fork: 5 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 720.045 ns/op</span></span><br><span class="line">Iteration   1: 733.850 ns/op</span><br><span class="line">Iteration   2: 753.365 ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.CounterBenchmark.micrometerCountSum&quot;</span>:</span><br><span class="line">  682.033 ±(99.9%) 125.825 ns/op [Average]</span><br><span class="line">  (min, avg, max) = (560.499, 682.033, 786.655), stdev = 83.225</span><br><span class="line">  CI (99.9%): [556.208, 807.858] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run complete. Total time: 00:05:02</span></span><br><span class="line"></span><br><span class="line">REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on</span><br><span class="line">why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial</span><br><span class="line">experiments, perform baseline and negative tests that provide experimental control, make sure</span><br><span class="line">the benchmarking environment is safe on JVM/OS/HW level, ask <span class="keyword">for</span> reviews from the domain experts.</span><br><span class="line">Do not assume the numbers tell you what you want them to tell.</span><br><span class="line"></span><br><span class="line">NOTE: Current JVM experimentally supports Compiler Blackholes, and they are <span class="keyword">in</span> use. Please exercise</span><br><span class="line">extra caution when trusting the results, look into the generated code to check the benchmark still</span><br><span class="line">works, and <span class="built_in">factor</span> <span class="keyword">in</span> a small probability of new VM bugs. Additionally, <span class="keyword">while</span> comparisons between</span><br><span class="line">different JVMs are already problematic, the performance difference caused by different Blackhole</span><br><span class="line">modes can be very significant. Please make sure you use the consistent Blackhole mode <span class="keyword">for</span> comparisons.</span><br><span class="line"></span><br><span class="line">Benchmark                            Mode  Cnt    Score     Error  Units</span><br><span class="line">CounterBenchmark.dropwizardCountSum  avgt   10  506.637 ±   7.589  ns/op</span><br><span class="line">CounterBenchmark.micrometerCountSum  avgt   10  682.033 ± 125.825  ns/op</span><br></pre></td></tr></table></figure><p>结论：Dropwizard 性能优于 Micrometer，比例约为20%</p><h2 id="2-2-Gauge"><a href="#2-2-Gauge" class="headerlink" title="2.2. Gauge"></a>2.2. Gauge</h2><p>二者都是寄存某个对象值，在需要取的时候进行更新。其性能取决于具体的 <code>get()</code> 函数，故此处不做测试。</p><p>PS：DropWizard 使用了 CachedGauge，在计算密集的场景下会拥有更好的性能</p><h2 id="2-3-Histogram"><a href="#2-3-Histogram" class="headerlink" title="2.3. Histogram"></a>2.3. Histogram</h2><p><strong>测试代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.codahale.metrics.Histogram;</span><br><span class="line"><span class="keyword">import</span> com.codahale.metrics.MetricRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.DistributionSummary;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.MeterRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.Tag;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.Tags;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.simple.SimpleMeterRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.prometheus.PrometheusConfig;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.prometheus.PrometheusMeterRegistry;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 Benchmark，测试多线程性能</span></span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HistogramBenchmark</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">            .include(HistogramBenchmark.class.getSimpleName())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MeterRegistry micrometerRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MetricRegistry dropwizardRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Histogram dropwizardHistogram;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DistributionSummary micrometerHistogram;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Tags</span> <span class="variable">tags</span> <span class="operator">=</span> Tags.of(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>, <span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>, <span class="string">&quot;key5&quot;</span>, <span class="string">&quot;value5&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        micrometerRegistry = <span class="keyword">new</span> <span class="title class_">SimpleMeterRegistry</span>();</span><br><span class="line">        micrometerHistogram =</span><br><span class="line">            io.micrometer.core.instrument.DistributionSummary.builder(<span class="string">&quot;micrometerHistogram&quot;</span>)</span><br><span class="line">                .tags(tags)</span><br><span class="line">                .publishPercentiles(<span class="number">0.5</span>, <span class="number">0.99</span>)</span><br><span class="line">                .register(micrometerRegistry);</span><br><span class="line"></span><br><span class="line">        dropwizardRegistry = <span class="keyword">new</span> <span class="title class_">MetricRegistry</span>();</span><br><span class="line">        dropwizardHistogram = dropwizardRegistry.histogram(<span class="string">&quot;dropwizardHistogram&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dropwizardRecord</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            dropwizardHistogram.update(i);</span><br><span class="line">            dropwizardHistogram.getCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">micrometerRecord</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            micrometerHistogram.record(i);</span><br><span class="line">            micrometerHistogram.count();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># JMH version: 1.37</span></span><br><span class="line"><span class="comment"># VM version: JDK 17.0.8.1, OpenJDK 64-Bit Server VM, 17.0.8.1+8-LTS</span></span><br><span class="line"><span class="comment"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-17.0.8.1/Contents/Home/bin/java</span></span><br><span class="line"><span class="comment"># VM options: -Dfile.encoding=UTF-8 -Duser.country=CN -Duser.language=zh -Duser.variant</span></span><br><span class="line"><span class="comment"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)</span></span><br><span class="line"><span class="comment"># Warmup: 1 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Measurement: 2 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Timeout: 10 min per iteration</span></span><br><span class="line"><span class="comment"># Threads: 1 thread, will synchronize iterations</span></span><br><span class="line"><span class="comment"># Benchmark mode: Average time, time/op</span></span><br><span class="line"><span class="comment"># Benchmark: io.micrometer.benchmark.core.HistogramBenchmark.dropwizardRecord</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 0.00% complete, ETA 00:05:00</span></span><br><span class="line"><span class="comment"># Fork: 1 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:22:52.331 [io.micrometer.benchmark.core.HistogramBenchmark.dropwizardRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">10174.613 ns/op</span><br><span class="line">Iteration   1: 9998.056 ns/op</span><br><span class="line">Iteration   2: 10828.580 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 10.00% complete, ETA 00:04:32</span></span><br><span class="line"><span class="comment"># Fork: 2 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:23:22.545 [io.micrometer.benchmark.core.HistogramBenchmark.dropwizardRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">10024.374 ns/op</span><br><span class="line">Iteration   1: 9990.595 ns/op</span><br><span class="line">Iteration   2: 10488.892 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 20.00% complete, ETA 00:04:01</span></span><br><span class="line"><span class="comment"># Fork: 3 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:23:52.910 [io.micrometer.benchmark.core.HistogramBenchmark.dropwizardRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">10204.101 ns/op</span><br><span class="line">Iteration   1: 10101.247 ns/op</span><br><span class="line">Iteration   2: 10982.767 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 30.00% complete, ETA 00:03:31</span></span><br><span class="line"><span class="comment"># Fork: 4 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:24:23.120 [io.micrometer.benchmark.core.HistogramBenchmark.dropwizardRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">9942.547 ns/op</span><br><span class="line">Iteration   1: 10305.283 ns/op</span><br><span class="line">Iteration   2: 10703.590 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 40.00% complete, ETA 00:03:01</span></span><br><span class="line"><span class="comment"># Fork: 5 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:24:53.335 [io.micrometer.benchmark.core.HistogramBenchmark.dropwizardRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">9863.582 ns/op</span><br><span class="line">Iteration   1: 9955.748 ns/op</span><br><span class="line">Iteration   2: 10482.406 ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.HistogramBenchmark.dropwizardRecord&quot;</span>:</span><br><span class="line">  10383.716 ±(99.9%) 563.945 ns/op [Average]</span><br><span class="line">  (min, avg, max) = (9955.748, 10383.716, 10982.767), stdev = 373.015</span><br><span class="line">  CI (99.9%): [9819.771, 10947.662] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># JMH version: 1.37</span></span><br><span class="line"><span class="comment"># VM version: JDK 17.0.8.1, OpenJDK 64-Bit Server VM, 17.0.8.1+8-LTS</span></span><br><span class="line"><span class="comment"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-17.0.8.1/Contents/Home/bin/java</span></span><br><span class="line"><span class="comment"># VM options: -Dfile.encoding=UTF-8 -Duser.country=CN -Duser.language=zh -Duser.variant</span></span><br><span class="line"><span class="comment"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)</span></span><br><span class="line"><span class="comment"># Warmup: 1 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Measurement: 2 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Timeout: 10 min per iteration</span></span><br><span class="line"><span class="comment"># Threads: 1 thread, will synchronize iterations</span></span><br><span class="line"><span class="comment"># Benchmark mode: Average time, time/op</span></span><br><span class="line"><span class="comment"># Benchmark: io.micrometer.benchmark.core.HistogramBenchmark.micrometerRecord</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 50.00% complete, ETA 00:02:31</span></span><br><span class="line"><span class="comment"># Fork: 1 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:25:23.556 [io.micrometer.benchmark.core.HistogramBenchmark.micrometerRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">6960.654 ns/op</span><br><span class="line">Iteration   1: 6775.768 ns/op</span><br><span class="line">Iteration   2: 6614.436 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 60.00% complete, ETA 00:02:00</span></span><br><span class="line"><span class="comment"># Fork: 2 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:25:53.835 [io.micrometer.benchmark.core.HistogramBenchmark.micrometerRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">6919.224 ns/op</span><br><span class="line">Iteration   1: 6918.534 ns/op</span><br><span class="line">Iteration   2: 6843.185 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 70.00% complete, ETA 00:01:30</span></span><br><span class="line"><span class="comment"># Fork: 3 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:26:24.055 [io.micrometer.benchmark.core.HistogramBenchmark.micrometerRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">6957.126 ns/op</span><br><span class="line">Iteration   1: 6853.690 ns/op</span><br><span class="line">Iteration   2: 6840.857 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 80.00% complete, ETA 00:01:00</span></span><br><span class="line"><span class="comment"># Fork: 4 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:26:54.287 [io.micrometer.benchmark.core.HistogramBenchmark.micrometerRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">6924.513 ns/op</span><br><span class="line">Iteration   1: 6958.296 ns/op</span><br><span class="line">Iteration   2: 6813.379 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 90.00% complete, ETA 00:00:30</span></span><br><span class="line"><span class="comment"># Fork: 5 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:27:24.499 [io.micrometer.benchmark.core.HistogramBenchmark.micrometerRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">7021.623 ns/op</span><br><span class="line">Iteration   1: 6887.827 ns/op</span><br><span class="line">Iteration   2: 6698.237 ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.HistogramBenchmark.micrometerRecord&quot;</span>:</span><br><span class="line">  6820.421 ±(99.9%) 155.021 ns/op [Average]</span><br><span class="line">  (min, avg, max) = (6614.436, 6820.421, 6958.296), stdev = 102.537</span><br><span class="line">  CI (99.9%): [6665.400, 6975.442] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run complete. Total time: 00:05:02</span></span><br><span class="line"></span><br><span class="line">REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on</span><br><span class="line">why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial</span><br><span class="line">experiments, perform baseline and negative tests that provide experimental control, make sure</span><br><span class="line">the benchmarking environment is safe on JVM/OS/HW level, ask <span class="keyword">for</span> reviews from the domain experts.</span><br><span class="line">Do not assume the numbers tell you what you want them to tell.</span><br><span class="line"></span><br><span class="line">NOTE: Current JVM experimentally supports Compiler Blackholes, and they are <span class="keyword">in</span> use. Please exercise</span><br><span class="line">extra caution when trusting the results, look into the generated code to check the benchmark still</span><br><span class="line">works, and <span class="built_in">factor</span> <span class="keyword">in</span> a small probability of new VM bugs. Additionally, <span class="keyword">while</span> comparisons between</span><br><span class="line">different JVMs are already problematic, the performance difference caused by different Blackhole</span><br><span class="line">modes can be very significant. Please make sure you use the consistent Blackhole mode <span class="keyword">for</span> comparisons.</span><br><span class="line"></span><br><span class="line">Benchmark                            Mode  Cnt      Score     Error  Units</span><br><span class="line">HistogramBenchmark.dropwizardRecord  avgt   10  10383.716 ± 563.945  ns/op</span><br><span class="line">HistogramBenchmark.micrometerRecord  avgt   10   6820.421 ± 155.021  ns/op</span><br><span class="line"></span><br><span class="line">Deprecated Gradle features were used <span class="keyword">in</span> this build, making it incompatible with Gradle 9.0.</span><br><span class="line"></span><br><span class="line">You can use <span class="string">&#x27;--warning-mode all&#x27;</span> to show the individual deprecation warnings and determine <span class="keyword">if</span> they come from your own scripts or plugins.</span><br><span class="line"></span><br><span class="line">For more on this, please refer to https://docs.gradle.org/8.3/userguide/command_line_interface.html<span class="comment">#sec:command_line_warnings in the Gradle documentation.</span></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> 5m 6s</span><br><span class="line">23 actionable tasks: 2 executed, 21 up-to-date</span><br><span class="line">15:27:54: Execution finished <span class="string">&#x27;:micrometer-benchmarks-core:HistogramBenchmark.main()&#x27;</span>.</span><br></pre></td></tr></table></figure><p><strong>结论：</strong>MicroMeter 优于 DropWizard，大约比例为 40%</p><h2 id="2-4-Timer"><a href="#2-4-Timer" class="headerlink" title="2.4. Timer"></a>2.4. Timer</h2><p>测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.codahale.metrics.MetricRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.MeterRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.Timer;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.simple.SimpleMeterRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.prometheus.PrometheusConfig;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.prometheus.PrometheusMeterRegistry;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 Benchmark，测试多线程性能</span></span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerBenchmark</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">            .include(TimerBenchmark.class.getSimpleName())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MeterRegistry micrometerRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MetricRegistry dropwizardRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Timer micrometerTimer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> com.codahale.metrics.Timer dropwizardTimer;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">923</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        micrometerRegistry = <span class="keyword">new</span> <span class="title class_">SimpleMeterRegistry</span>();</span><br><span class="line">        micrometerTimer = micrometerRegistry.timer(<span class="string">&quot;micrometerTimer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        dropwizardRegistry = <span class="keyword">new</span> <span class="title class_">MetricRegistry</span>();</span><br><span class="line">        dropwizardTimer = dropwizardRegistry.timer(<span class="string">&quot;dropwizardTimer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">micrometerSumTimedWithSupplier</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            micrometerTimer.record(x + y, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dropwizardSumTimedWithSupplier</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            dropwizardTimer.update(x + y, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">micrometerSumTimedWithSample</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Timer.<span class="type">Sample</span> <span class="variable">sample</span> <span class="operator">=</span> Timer.start(micrometerRegistry);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sum();</span><br><span class="line">            sample.stop(micrometerTimer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dropwizardSumTimedWithSample</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            dropwizardTimer.time(<span class="built_in">this</span>::sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; Task :micrometer-benchmarks-core:TimerBenchmark.main()</span><br><span class="line"># JMH version: <span class="number">1.37</span></span><br><span class="line"># VM version: JDK <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>, OpenJDK <span class="number">64</span>-Bit Server VM, <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>+<span class="number">8</span>-LTS</span><br><span class="line"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-<span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>/Contents/Home/bin/java</span><br><span class="line"># VM options: -Dfile.encoding=UTF-<span class="number">8</span> -Duser.country=CN -Duser.language=zh -Duser.variant</span><br><span class="line"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=<span class="literal">false</span> to disable)</span><br><span class="line"># Warmup: <span class="number">1</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Measurement: <span class="number">2</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Timeout: <span class="number">10</span> min per iteration</span><br><span class="line"># Threads: <span class="number">1</span> thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Average time, time/op</span><br><span class="line"># Benchmark: io.micrometer.benchmark.core.TimerBenchmark.dropwizardSumTimedWithSample</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">0.00</span>% complete, ETA <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span></span><br><span class="line"># Fork: <span class="number">1</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">1516.590</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">1530.353</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">1605.669</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">5.00</span>% complete, ETA <span class="number">00</span>:09:<span class="number">33</span></span><br><span class="line"># Fork: <span class="number">2</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">1507.719</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">1488.804</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">1576.604</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">10.00</span>% complete, ETA <span class="number">00</span>:09:<span class="number">03</span></span><br><span class="line"># Fork: <span class="number">3</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">1502.103</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">1497.555</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">1555.023</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">15.00</span>% complete, ETA <span class="number">00</span>:08:<span class="number">32</span></span><br><span class="line"># Fork: <span class="number">4</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">1556.940</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">1458.053</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">1505.888</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">20.00</span>% complete, ETA <span class="number">00</span>:08:<span class="number">02</span></span><br><span class="line"># Fork: <span class="number">5</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">1505.264</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">1516.316</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">1580.754</span> ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.TimerBenchmark.dropwizardSumTimedWithSample&quot;</span>:</span><br><span class="line">  <span class="number">1531.502</span> ±(<span class="number">99.9</span>%) <span class="number">70.863</span> ns/op [Average]</span><br><span class="line">  (min, avg, max) = (<span class="number">1458.053</span>, <span class="number">1531.502</span>, <span class="number">1605.669</span>), stdev = <span class="number">46.871</span></span><br><span class="line">  CI (<span class="number">99.9</span>%): [<span class="number">1460.639</span>, <span class="number">1602.365</span>] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># JMH version: <span class="number">1.37</span></span><br><span class="line"># VM version: JDK <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>, OpenJDK <span class="number">64</span>-Bit Server VM, <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>+<span class="number">8</span>-LTS</span><br><span class="line"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-<span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>/Contents/Home/bin/java</span><br><span class="line"># VM options: -Dfile.encoding=UTF-<span class="number">8</span> -Duser.country=CN -Duser.language=zh -Duser.variant</span><br><span class="line"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=<span class="literal">false</span> to disable)</span><br><span class="line"># Warmup: <span class="number">1</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Measurement: <span class="number">2</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Timeout: <span class="number">10</span> min per iteration</span><br><span class="line"># Threads: <span class="number">1</span> thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Average time, time/op</span><br><span class="line"># Benchmark: io.micrometer.benchmark.core.TimerBenchmark.dropwizardSumTimedWithSupplier</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">25.00</span>% complete, ETA <span class="number">00</span>:<span class="number">07</span>:<span class="number">32</span></span><br><span class="line"># Fork: <span class="number">1</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">12358.755</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">12309.136</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">12922.583</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">30.00</span>% complete, ETA <span class="number">00</span>:<span class="number">07</span>:<span class="number">02</span></span><br><span class="line"># Fork: <span class="number">2</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">12072.889</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">11971.788</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">12708.188</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">35.00</span>% complete, ETA <span class="number">00</span>:<span class="number">06</span>:<span class="number">32</span></span><br><span class="line"># Fork: <span class="number">3</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">12240.725</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">12189.390</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">12794.850</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">40.00</span>% complete, ETA <span class="number">00</span>:<span class="number">06</span>:<span class="number">02</span></span><br><span class="line"># Fork: <span class="number">4</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">11909.155</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">12186.550</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">13181.730</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">45.00</span>% complete, ETA <span class="number">00</span>:<span class="number">05</span>:<span class="number">31</span></span><br><span class="line"># Fork: <span class="number">5</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">12192.867</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">12209.921</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">12930.563</span> ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.TimerBenchmark.dropwizardSumTimedWithSupplier&quot;</span>:</span><br><span class="line">  <span class="number">12540.470</span> ±(<span class="number">99.9</span>%) <span class="number">624.765</span> ns/op [Average]</span><br><span class="line">  (min, avg, max) = (<span class="number">11971.788</span>, <span class="number">12540.470</span>, <span class="number">13181.730</span>), stdev = <span class="number">413.243</span></span><br><span class="line">  CI (<span class="number">99.9</span>%): [<span class="number">11915.705</span>, <span class="number">13165.235</span>] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># JMH version: <span class="number">1.37</span></span><br><span class="line"># VM version: JDK <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>, OpenJDK <span class="number">64</span>-Bit Server VM, <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>+<span class="number">8</span>-LTS</span><br><span class="line"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-<span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>/Contents/Home/bin/java</span><br><span class="line"># VM options: -Dfile.encoding=UTF-<span class="number">8</span> -Duser.country=CN -Duser.language=zh -Duser.variant</span><br><span class="line"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=<span class="literal">false</span> to disable)</span><br><span class="line"># Warmup: <span class="number">1</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Measurement: <span class="number">2</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Timeout: <span class="number">10</span> min per iteration</span><br><span class="line"># Threads: <span class="number">1</span> thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Average time, time/op</span><br><span class="line"># Benchmark: io.micrometer.benchmark.core.TimerBenchmark.micrometerSumTimedWithSample</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">50.00</span>% complete, ETA <span class="number">00</span>:<span class="number">05</span>:<span class="number">01</span></span><br><span class="line"># Fork: <span class="number">1</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">520.268</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">520.347</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">515.323</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">55.00</span>% complete, ETA <span class="number">00</span>:<span class="number">04</span>:<span class="number">31</span></span><br><span class="line"># Fork: <span class="number">2</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">516.566</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">520.164</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">509.640</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">60.00</span>% complete, ETA <span class="number">00</span>:<span class="number">04</span>:<span class="number">01</span></span><br><span class="line"># Fork: <span class="number">3</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">509.843</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">507.147</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">506.309</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">65.00</span>% complete, ETA <span class="number">00</span>:<span class="number">03</span>:<span class="number">31</span></span><br><span class="line"># Fork: <span class="number">4</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">510.824</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">504.709</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">505.124</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">70.00</span>% complete, ETA <span class="number">00</span>:<span class="number">03</span>:<span class="number">00</span></span><br><span class="line"># Fork: <span class="number">5</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">509.629</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">516.369</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">501.427</span> ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.TimerBenchmark.micrometerSumTimedWithSample&quot;</span>:</span><br><span class="line">  <span class="number">510.656</span> ±(<span class="number">99.9</span>%) <span class="number">10.354</span> ns/op [Average]</span><br><span class="line">  (min, avg, max) = (<span class="number">501.427</span>, <span class="number">510.656</span>, <span class="number">520.347</span>), stdev = <span class="number">6.849</span></span><br><span class="line">  CI (<span class="number">99.9</span>%): [<span class="number">500.302</span>, <span class="number">521.010</span>] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># JMH version: <span class="number">1.37</span></span><br><span class="line"># VM version: JDK <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>, OpenJDK <span class="number">64</span>-Bit Server VM, <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>+<span class="number">8</span>-LTS</span><br><span class="line"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-<span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>/Contents/Home/bin/java</span><br><span class="line"># VM options: -Dfile.encoding=UTF-<span class="number">8</span> -Duser.country=CN -Duser.language=zh -Duser.variant</span><br><span class="line"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=<span class="literal">false</span> to disable)</span><br><span class="line"># Warmup: <span class="number">1</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Measurement: <span class="number">2</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Timeout: <span class="number">10</span> min per iteration</span><br><span class="line"># Threads: <span class="number">1</span> thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Average time, time/op</span><br><span class="line"># Benchmark: io.micrometer.benchmark.core.TimerBenchmark.micrometerSumTimedWithSupplier</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">75.00</span>% complete, ETA <span class="number">00</span>:<span class="number">02</span>:<span class="number">30</span></span><br><span class="line"># Fork: <span class="number">1</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">2741.534</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">2716.235</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">2762.197</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">80.00</span>% complete, ETA <span class="number">00</span>:<span class="number">02</span>:<span class="number">00</span></span><br><span class="line"># Fork: <span class="number">2</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">2764.662</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">2788.028</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">2801.328</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">85.00</span>% complete, ETA <span class="number">00</span>:<span class="number">01</span>:<span class="number">30</span></span><br><span class="line"># Fork: <span class="number">3</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">2775.788</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">2794.196</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">2833.326</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">90.00</span>% complete, ETA <span class="number">00</span>:<span class="number">01</span>:<span class="number">00</span></span><br><span class="line"># Fork: <span class="number">4</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">2793.570</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">2774.927</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">2818.794</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">95.00</span>% complete, ETA <span class="number">00</span>:<span class="number">00</span>:<span class="number">30</span></span><br><span class="line"># Fork: <span class="number">5</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">2773.815</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">2752.855</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">2816.498</span> ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.TimerBenchmark.micrometerSumTimedWithSupplier&quot;</span>:</span><br><span class="line">  <span class="number">2785.839</span> ±(<span class="number">99.9</span>%) <span class="number">53.348</span> ns/op [Average]</span><br><span class="line">  (min, avg, max) = (<span class="number">2716.235</span>, <span class="number">2785.839</span>, <span class="number">2833.326</span>), stdev = <span class="number">35.287</span></span><br><span class="line">  CI (<span class="number">99.9</span>%): [<span class="number">2732.490</span>, <span class="number">2839.187</span>] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Run complete. Total time: <span class="number">00</span>:<span class="number">10</span>:<span class="number">03</span></span><br><span class="line"></span><br><span class="line">REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on</span><br><span class="line">why the numbers are the way they are. Use <span class="title function_">profilers</span> <span class="params">(see -prof, -lprof)</span>, design factorial</span><br><span class="line">experiments, perform baseline and negative tests that provide experimental control, make sure</span><br><span class="line">the benchmarking environment is safe on JVM/OS/HW level, ask <span class="keyword">for</span> reviews from the domain experts.</span><br><span class="line">Do not assume the numbers tell you what you want them to tell.</span><br><span class="line"></span><br><span class="line">NOTE: Current JVM experimentally supports Compiler Blackholes, and they are in use. Please exercise</span><br><span class="line">extra caution when trusting the results, look into the generated code to check the benchmark still</span><br><span class="line">works, and factor in a small probability of <span class="keyword">new</span> <span class="title class_">VM</span> bugs. Additionally, <span class="keyword">while</span> comparisons between</span><br><span class="line">different JVMs are already problematic, the performance difference caused by different Blackhole</span><br><span class="line">modes can be very significant. Please make sure you use the consistent Blackhole mode <span class="keyword">for</span> comparisons.</span><br><span class="line"></span><br><span class="line">Benchmark                                      Mode  Cnt      Score     Error  Units</span><br><span class="line">TimerBenchmark.dropwizardSumTimedWithSample    avgt   <span class="number">10</span>   <span class="number">1531.502</span> ±  <span class="number">70.863</span>  ns/op</span><br><span class="line">TimerBenchmark.dropwizardSumTimedWithSupplier  avgt   <span class="number">10</span>  <span class="number">12540.470</span> ± <span class="number">624.765</span>  ns/op</span><br><span class="line">TimerBenchmark.micrometerSumTimedWithSample    avgt   <span class="number">10</span>    <span class="number">510.656</span> ±  <span class="number">10.354</span>  ns/op</span><br><span class="line">TimerBenchmark.micrometerSumTimedWithSupplier  avgt   <span class="number">10</span>   <span class="number">2785.839</span> ±  <span class="number">53.348</span>  ns/op</span><br></pre></td></tr></table></figure><p>结论：无论是直接更新抑或是通过 Sample 记录时间更新，Micrometer 均明显优于 DropWizard，大约比例为 300%；</p><h2 id="2-5-Rate"><a href="#2-5-Rate" class="headerlink" title="2.5. Rate"></a>2.5. Rate</h2><p>MicroMeter 没有提供 Rate 语义的实现，目前 IoTDB 都使用的是 DropWizard base</p><h1 id="3-优化方案"><a href="#3-优化方案" class="headerlink" title="3. 优化方案"></a>3. 优化方案</h1><h2 id="3-1-监控项选择参数"><a href="#3-1-监控项选择参数" class="headerlink" title="3.1. 监控项选择参数"></a>3.1. 监控项选择参数</h2><p>经过测试，决定<strong>选择 Micrometer 为 IoTDB Metric 系统的 baseline，在参数上舍弃 DropWizard 。</strong>理由如下<strong>：</strong></p><ol><li><p>Micrometer 在实现时基于 DropWizard ，可以理解为是 DropWizard 的扩展。因此 Micrometer <strong>在功能上</strong>可以完全覆盖 DropWizard，<strong>在可拓展性上</strong>比 DropWizard 更好。</p></li><li><p>经过性能测试，除了 Counter 和 Gauge，IoTDB 现有的 Micrometer base 监控指标<strong>性能均优于</strong> DropWizard base 监控指标（M 比 D 普遍性能优越40%以上）</p><ol><li>而 Micrometer base 的 Counter 和 Gauge 优化项也比较清晰，经过优化后，可以达到 DropWizard base 的性能表现。</li></ol></li><li><p>截止 2023.10.23，无论是 issue 数还是 commit 数 Micrometer 均大于 DropWizard，说明前者<strong>社区更活跃。</strong></p></li></ol><h2 id="3-2-【优化一】MetricType"><a href="#3-2-【优化一】MetricType" class="headerlink" title="3.2. 【优化一】MetricType"></a>3.2. 【优化一】MetricType</h2><h3 id="3-2-1-Gauge"><a href="#3-2-1-Gauge" class="headerlink" title="3.2.1 Gauge"></a>3.2.1 Gauge</h3><ol><li><strong>问题：</strong></li></ol><p>由于 Micrometer 没有提供缓存版 gauge，因此在涉及读密集且重计算的场景时会有性能问题，预期不如 Dropwizard。<strong>考虑在 IoTDB 实现时加一层缓存进行优化。</strong></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182140973.png" alt="image-20231115182140973"></p><ol start="2"><li><strong>优化：</strong></li></ol><p>加一个 cache，在失效时间内，如果反复读 gauge，直接返回 cache 的值。如果超过超时时间，重新调用计算函数 <code>ref.get()</code>，并更新 cache。</p><blockquote><p>组内大佬 review：由于主要调用是 promethus，15s 一次，并发性不高。该优化意义不是特别大，考虑作为写个新类，作为用户的 option</p></blockquote><h3 id="3-2-2-Rate"><a href="#3-2-2-Rate" class="headerlink" title="3.2.2. Rate"></a>3.2.2. Rate</h3><ol><li><strong>问题：</strong></li></ol><p>原生 Rate 的更新和计算有大量冗余逻辑。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182211527.png" alt="image-20231115182211527"></p><ol start="2"><li><strong>优化：</strong></li></ol><p>考虑从 m1、m5、m15 中删去其二。</p><h3 id="3-2-3-Counter"><a href="#3-2-3-Counter" class="headerlink" title="3.2.3. Counter"></a>3.2.3. Counter</h3><ol><li><strong>问题：</strong></li></ol><p>使用 DoubleAdder 作为 value 的容器<strong>，</strong>但是 IoTDB 的最终接口是 long，而 double 本身的运算开销也较大，因此涉及一些转化和计算开销</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182222612.png" alt="image-20231115182222612"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182231480.png" alt="image-20231115182231480"></p><ol start="2"><li><strong>优化：</strong></li></ol><p><strong>考虑使用 LongAdder 实现 Counter。</strong></p><h3 id="3-2-4-DistributionSummary-IoTDB-Histogram"><a href="#3-2-4-DistributionSummary-IoTDB-Histogram" class="headerlink" title="3.2.4. DistributionSummary &#x2F; IoTDB Histogram"></a>3.2.4. DistributionSummary &#x2F; IoTDB Histogram</h3><ol><li><strong>问题：</strong><ol><li>从前面分析可以看到，Micrometer 在每次写入数据时，对 ringBuffer 的所有 bucket 都进行了写入操作。</li><li>从前面分析可以看到，当数据超过 hdrHistogram 范围时，会发生 resize，该操作有时间开销。目前的上下界 [1, 127] 显然范围有点小了，在大值数据场景下显然要 resize，甚至多次 resize。</li></ol></li><li><strong>优化：</strong><ol><li><strong>可以通过缩小 ringBuffer 的 size，从而减少写 bucket 次数</strong>，来提高 Micrometer Histogram 的写入效率<ol><li>ringBuffer.length 默认设置为 3。根据上文，只要保证 ringBuffer.length 大于 1 既能保证淘汰旧数据的目的。因此考虑将 ringBuffer.length 设为 2（<strong>PR</strong>: <a href="https://github.com/apache/iotdb/pull/11500%EF%BC%89">https://github.com/apache/iotdb/pull/11500）</a></li></ol></li><li>可以对每一个 timer&#x2F;histogram 的使用场景预估数据区间，<strong>提前为每一个 timer&#x2F;histogram 定制数据上下界</strong>，尽量避免 resize 操作。<ol><li>由于 Micrometer 没有暴露定制化 hdrHistogram 区间范围的 API，该改动阻塞。已向他们提 issue（<a href="https://github.com/micrometer-metrics/micrometer/issues/4327%EF%BC%89">https://github.com/micrometer-metrics/micrometer/issues/4327）</a></li></ol></li></ol></li></ol><h3 id="3-2-5-Timer"><a href="#3-2-5-Timer" class="headerlink" title="3.2.5. Timer"></a>3.2.5. Timer</h3><p>从火焰图和上文的分析中可以看出，Timer 主要耗时由 histogram 的更新和自己实现计时器的更新组成。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182245840.png" alt="image-20231115182245840"></p><p>由于 Timer 底层使用 Histogram（前文分析过），因此优化 Histogram 也可以优化 Timer，此处不再赘述。</p><h2 id="3-3-【优化二】架构"><a href="#3-3-【优化二】架构" class="headerlink" title="3.3. 【优化二】架构"></a>3.3. 【优化二】架构</h2><h3 id="3-3-1-IoTDBManager"><a href="#3-3-1-IoTDBManager" class="headerlink" title="3.3.1. IoTDBManager"></a>3.3.1. IoTDBManager</h3><p>完全删去原有的 io.micrometer.core.instrument.simple.SimpleMeterRegistry，将各项 Metric 的创建由 Registry 接管过来。<strong>这样优化的好处如下</strong>：</p><ol><li><p>完全适配 IoTDB 自己的命名系统，舍弃 Micrometer 的命名系统</p></li><li><p>由于不再借助 io.micrometer.core.instrument.simple.SimpleMeterRegistry 创建、管理、存储各项 Metric，使得不用再在 io.micrometer.core.instrument.simple.SimpleMeterRegistry 中创建 MetricMap，<strong>节省一倍内存</strong></p></li><li><p>舍弃原有的 JmxReporter，自己实现一套 JmxReporter，<strong>节省一倍内存</strong>。本文 3.4.2 会详细介绍设计以及优化点）</p></li></ol><h4 id="3-3-1-1-各指标的自主创建流程"><a href="#3-3-1-1-各指标的自主创建流程" class="headerlink" title="3.3.1.1. 各指标的自主创建流程"></a>3.3.1.1. 各指标的自主创建流程</h4><ol><li><strong>Gauge</strong></li></ol><p><code>IoTDBGauge</code> 的核心就是 <code>AtomicLong</code>。由于舍弃了 Micrometer 的命名系统，因此创建 <code>IoTDBGauge</code> 只需<code> new AtomicLong()</code> 即可。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182308733.png" alt="image-20231115182308733"></p><ol start="2"><li><strong>AutoGauge</strong></li></ol><p><code>IoTDBAutoGauge</code> 主要修改了 <code>WeakReference</code> 的引用。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182325099.png" alt="image-20231115182325099"></p><p>在原本实现中传入 <code>WeakReference</code> 的 <code>meterRegistry.gauge(...)</code> 中， <code>meterRegistry.gauge(...)</code> 返回的仅仅就是参数中的 <code>object</code>。因此这里直接将<code>WeakReference</code> 的参数改为了 <code>object</code>。</p><p>至于在 <code>meterRegistry.gauge</code> 中创建的 <code>gauge</code>，<code>IoTDBAutoGauge</code> 并没有用到，原来的实现只是为了在 <code>Micrometer</code> 的命名系统中创建一个同名 <code>gauge</code>。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182339161.png" alt="image-20231115182339161"></p><ol start="3"><li><strong>Counter</strong></li></ol><p>完全舍弃掉 Micrometer 的实现，只保留 <code>LongAdder</code></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182349453.png" alt="image-20231115182349453"></p><ol start="4"><li><strong>Rate</strong></li></ol><p>IoTDB 的实现在 Micrometer 的基础上砍去了 m5、m15 等统计点，因此传入 IoTDB 定制的 <code>IoTDBMovingAverage</code> 即可</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182401836.png" alt="image-20231115182401836"></p><ol start="5"><li><strong>Timer</strong></li></ol><p>参考 SimpleMeterRegistry 的创建流程。经验证，创建后的 CumulativeTimer 与原来的实现属性一致，符合预期。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182414059.png" alt="image-20231115182414059"></p><ol start="6"><li><strong>Histogram</strong></li></ol><p>参考 SimpleMeterRegistry 的创建流程。经验证，创建后的 CumulativeDistributionSummary 与原来的实现属性一致，符合预期。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182423894.png" alt="image-20231115182423894"></p><h3 id="3-3-2-JmxReporter"><a href="#3-3-2-JmxReporter" class="headerlink" title="3.3.2. JmxReporter"></a>3.3.2. JmxReporter</h3><p>舍弃 <code>io.micrometer.jmx.JmxMeterRegistry</code> 的实现，自己实现 <code>JmxReporter</code>。<strong>这样优化的好处主要是节省一倍内存</strong>，原因如下：</p><p><code>io.micrometer.jmx.JmxMeterRegistry</code> 的实现是将 <code>JmxReporter</code> 监听 Registry，每次 Registry 创建新指标项时，<code>JmxReporter</code> 也创建一份实现了 MBean 接口的指标对象，相当于<strong>一个监控项创建了两个对象</strong>。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182434178.png" alt="image-20231115182434178"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182441959.png" alt="image-20231115182441959"></p><p><code>IoTDBJmxReporter</code> 的设计思路是：</p><ol><li>所有指标项天然实现 MBean 接口</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182457114.png" alt="image-20231115182457114"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182508237.png" alt="image-20231115182508237"></p><ol start="2"><li><code>IoTDBJmxReporter</code> 的作用仅为监听 <code>IoTDBMetricManager</code>，当有新指标创建时，将其注册到 JMX 中。当 <code>ReporterType</code> 不为 JMX 时，所有指标项不会被注册到 JMX 中。<ol><li>该实现在不开启 JmxReporter 时不会有额外性能开销；在开启 JmxReporter 时，由于 JmxReporter 只需完成注册操作，相比 Micrometer 的实现少了创建对象的性能开销。</li></ol></li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182518746.png" alt="image-20231115182518746"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182529865.png" alt="image-20231115182529865"></p><p><strong>踩坑：</strong>MBean 的接口需要和实现类在同一个包下，且类名、接口名必须严格对应，且 objectName 必须符合 <a href="https://blog.csdn.net/qq_21383435/article/details/111051784">MBean 规范</a></p><ol start="3"><li><strong>实现效果：</strong></li></ol><p>在 org.apache.iotdb.metrics 下有各指标的 jmx 预览项。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182542803.png" alt="image-20231115182542803"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182553360.png" alt="image-20231115182553360"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182604536.png"></p><h1 id="4-优化效果"><a href="#4-优化效果" class="headerlink" title="4. 优化效果"></a>4. 优化效果</h1><ol><li><strong>环境</strong></li></ol><p>在某环境负载下，1C1D (IoTDB 1 ConfigNode + 1 DataNode） 测试。</p><ul><li>baseline：<a href="https://github.com/apache/iotdb/commit/1dd5a200281aff1f42a9d7abdbde9d172445d4f6">1dd5a200281aff1f42a9d7abdbde9d172445d4f6</a></li><li>对比优化后：<a href="https://github.com/apache/iotdb/commit/a4510266fdb74e95f0cfabec36ad3f16155eaa60">a4510266fdb74e95f0cfabec36ad3f16155eaa60</a></li></ul><ol start="2"><li><strong>火焰图实测</strong></li></ol><p>图中浅紫色高亮的是 metrics 部分的开销</p><ul><li>优化前（1dd5a200281aff1f42a9d7abdbde9d172445d4f6）：metrics 整体占比大约在 <strong>9.79%</strong></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182623578.png" alt="image-20231115182623578"></p><p>优化后（a4510266fdb74e95f0cfabec36ad3f16155eaa60）：metrics 整体占比大约在 **5.81%<strong>，优化了</strong>41%**的性能</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182634791.png" alt="image-20231115182634791"></p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><ol><li><p><strong>CPU 开销</strong>：9.79% -&gt; 5.81%，优化了 41%。</p></li><li><p><strong>空间：</strong>由于架构上的优化，metrics 在空间占用上降低了一倍开销。</p></li><li><p><strong>可用性：</strong>对于用户，去掉了算法库参数的选择；对于开发者，统一了原有的 Micrometer 和 DropWizard 内部实现为 metric-core，形成了 IoTDB 自己的实现方案。</p></li></ol><h1 id="6-心得"><a href="#6-心得" class="headerlink" title="6. 心得"></a>6. 心得</h1><p>本次性能优化的流程是：</p><ol><li>调研 baseline（花了一周）</li><li>对比 iotdb 和 baseline，找出冗余点（花了半周）</li><li>性能测试，对比 baseline（花了半周）</li><li>跑火焰图，分析目标函数瓶颈（花了一天）</li><li>结合上述资料，尝试代码改造。改造的<strong>思路</strong>如下：<ol><li>能不能串行改并行？（no）</li><li>能不能同步改异步？（no）</li><li>有没有冗余逻辑，能不能删掉？（yes）</li><li>有没有计算密集场景，能不能加缓存？（yes）</li><li>其他杂项开销（如 double 和 long 的转化，CompositeMeterRegistry 等）</li><li>补充：批处理；拆锁；</li></ol></li></ol><p>其中在火焰图上有一个 trick 的积累：idea 可以继承 async-profiler 进行火焰图分析，并可以很方便的查看结果、统计各阶段耗时比例、查看调用树等。</p><ol><li><strong>配置</strong></li></ol><p>打开 setting，新增 CPU profiler。options 经个人测试，填写<code>event=cpu,interval=1ms</code>的实际体验比较好</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182705428.png" alt="image-20231115182705428"></p><ol start="2"><li><strong>使用</strong></li></ol><p>在 run 项目时选中 profiler 即可</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182714816.png" alt="image-20231115182714816"></p><ol start="3"><li><strong>查看结果</strong></li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182725287.png" alt="image-20231115182725287"></p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ol><li><a href="https://izualzhy.cn/dropwizard-metrics#14-histograms">https://izualzhy.cn/dropwizard-metrics#14-histograms</a></li><li><a href="https://metrics.dropwizard.io/4.1.1">https://metrics.dropwizard.io/4.1.1</a></li><li><a href="https://www.fortra.com/resources/guides/unix-load-average-part-1-how-it-works">https://www.fortra.com/resources/guides/unix-load-average-part-1-how-it-works</a></li><li><a href="https://www.cnblogs.com/mindforward/p/15792132.html">https://www.cnblogs.com/mindforward/p/15792132.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/29178293">https://zhuanlan.zhihu.com/p/29178293</a></li><li><a href="https://metrics.dropwizard.io/4.2.0/manual/core.html#">https://metrics.dropwizard.io/4.2.0/manual/core.html#</a></li><li><a href="https://micrometer.io/docs/observation">https://micrometer.io/docs/observation</a></li><li><a href="https://www.baeldung.com/dropwizard-metrics">https://www.baeldung.com/dropwizard-metrics</a></li><li><a href="https://caorong.github.io/2020/08/03/quartile-%20algorithm/">https://caorong.github.io/2020/08/03/quartile-%20algorithm/</a></li><li><a href="https://zhuanlan.zhihu.com/p/568777601">https://zhuanlan.zhihu.com/p/568777601</a></li><li><a href="https://cxybb.com/article/superice_/121311005">https://cxybb.com/article/superice_/121311005</a></li><li><a href="https://caorong.github.io/2016/07/31/hdrhistogram/">https://caorong.github.io/2016/07/31/hdrhistogram/</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM GC 调研与 Apache IoTDB GC 可观测性建设</title>
      <link href="/article/JVM-GC/"/>
      <url>/article/JVM-GC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>本文是作者在调研改进 IoTDB JVM GC 监控板块时产出的相关 wiki，主要包含 GC 基本知识、不同 JDK 下的 GC 算法细节，以及设计改进 IoTDB JVM GC 监控板块时的思路等内容。本文旨在优化 IoTDB 现有 GC 监控系统，结合实际生产需要，扩充现有 metric 指标，使其针对不同 JDK 的 GC Collector 能更精准、高效的进行监控。</p><blockquote><ol><li><p>JVM GC 是一个浩瀚的系统领域，本文仅于皮毛处探讨，起抛砖引玉之效。如有错误，敬请指出，欢迎各位大佬通过邮件或微信与我进一步交流！</p></li><li><p>本文引用、整合了大量互联网资料（文字、图片），同时也有自己的探究、实验和思考。感谢所有互联网大佬的无私分享，结尾给出了所有的 Reference 链接。</p></li></ol></blockquote><p>在系统工程设计之外，为了更好地帮助理解，<strong>本文涉及以下相关概念</strong>，读者可提前<strong>按需浏览：</strong></p><ul><li>GC 基本知识，具体可参见【2. GC 基础】</li><li>常见的 GC 收集器以及它们的基本特点，具体可参见【3. GC 收集器、10. 其他】</li><li>如何判断 GC 异常，具体可参见【4. GC 异常的判断】</li></ul><h2 id="2-GC-基础"><a href="#2-GC-基础" class="headerlink" title="2. GC 基础"></a>2. GC 基础</h2><h3 id="2-1-JVM-内存划分"><a href="#2-1-JVM-内存划分" class="headerlink" title="2.1. JVM 内存划分"></a>2.1. JVM 内存划分</h3><p>此部分是后续监控指标设计的依据，因此详细介绍：</p><p>JVM 内存中的对象，大致可以分为两大类：一类对象，他们的生命周期很短暂，比如局部变量、临时对象等。另一类对象则会存活很久，比如用户应用程序中 DB 长连接中的 Connection 对象。为了对这两类对象分别高效回收，JVM 的内存使用<strong>分代思想</strong>进行划分。</p><p>以 Java 8 的内存结构为例：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115174532651.png" alt="image-20231115174532651"></p><p>可以看到，JVM 的内存被分为了不同的区域。GC 主要工作在 Heap 区和 MetaSpace 区（上图蓝色部分），而在 GC 的主要工作区，<strong>内存又被分为了不同的代际</strong>。下面这张表格简单描述了我们主要需要关注的区域：</p><table><thead><tr><th><strong>分代名</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Young Generation（Eden + Survivor）</td><td>新生代主要分为两个部分：<strong>Eden 区</strong>和 <strong>Survivor 区</strong>，其中 Survivor 区又可以分为两个部分，<strong>S0 和S1</strong>。该区域中，相对于老年代空间较小，对象的生存周期短，GC 频繁。</td></tr><tr><td>Old Generation（Tenured）</td><td>老年代整体空间较大，对象的生命周期长，存活率高，回收不频繁。</td></tr><tr><td><em><strong>@Deprecated</strong></em>Permanent</td><td>永久代又称为方法区，存储着类和接口的元信息以及 interned 的字符串信息。在 JDK8 中被元空间取代。</td></tr><tr><td>MetaSpace</td><td>JDK8 以后引入，方法区也存在于元空间。</td></tr></tbody></table><p>在 Java 程序中，常见的垃圾回收器，打印内存区域结果如下：</p><ul><li>G1</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">G1 Eden Space <span class="comment">// young</span></span><br><span class="line">G1 Old Gen <span class="comment">// old</span></span><br><span class="line">G1 Survivor Space <span class="comment">// young</span></span><br></pre></td></tr></table></figure><ul><li>ParNewGC + CMS</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Par Eden Space <span class="comment">// young</span></span><br><span class="line">Par Survivor Space <span class="comment">// young</span></span><br><span class="line">CMS Old Gen <span class="comment">// old</span></span><br></pre></td></tr></table></figure><ul><li>SerialGC</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Tenured Gen <span class="comment">// old</span></span><br><span class="line">Eden Space <span class="comment">// young</span></span><br><span class="line">Survivor Space <span class="comment">// young</span></span><br></pre></td></tr></table></figure><ul><li>ParallelGC + ParallelOldGC</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PS Old Gen <span class="comment">// old</span></span><br><span class="line">PS Survivor Space <span class="comment">// young</span></span><br><span class="line">PS Eden Space <span class="comment">// young</span></span><br></pre></td></tr></table></figure><ul><li>Shenandoah</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shenandoah <span class="comment">// non-generational</span></span><br></pre></td></tr></table></figure><ul><li>ZGC</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ZHeap <span class="comment">// non-generational</span></span><br></pre></td></tr></table></figure><h3 id="2-2-GC-收集过程"><a href="#2-2-GC-收集过程" class="headerlink" title="2.2. GC 收集过程"></a>2.2. GC 收集过程</h3><p>基于上述分代内存，JVM 使用<strong>分代垃圾回收算法</strong>（当然，JDK 11 以后的某些新收集器使用非代际垃圾回收算法，这些会在后文中提到），其大致执行过程如下：</p><ul><li>初始态：对象分配在 Eden 区，S0、S1 区几乎为空。</li><li>随着程序的运行，越来越多的对象被分配在 Eden 区。</li><li>当 Eden 放不下时，就会发生 <strong>MinorGC</strong>（即 YoungGC），此时，会先标识出不可达的垃圾对象，然后将可达的对象移动到 S0 区，并将不可达的对象清理掉。这时候，Eden 区就是空的了。在这个过程中，使用了标记清理算法及复制算法。</li><li>随着 Eden 放不下时，会再次触发 minorGC，和上一步一样，先标记。这个时候，Eden 和 S0 区可能都有垃圾对象了，而 S1 区是空的。这个时候，会直接将 Eden 和 S0 区的对象直接搬到S1区，然后将Eden 与 S0 区的垃圾对象清理掉。经历这一轮的 MinorGC 后，Eden 与 S0 区为空。</li><li>随着程序的运行，Eden 空间会被分配殆尽，这时会重复刚才 MinorGC 的过程，不过此时，S0 区是空的，S0 和 S1 区域会互换，此时存活的对象会从 Eden 和 S1 区，向S0 区移动。然后 Eden 和 S1 区中的垃圾会被清除，这一轮完成之后，这两个区域为空。</li><li>在程序运行过程中，虽然大多数对象都会很快消亡，但仍然存在一些存活时间较长的对象，对于这些对象，<strong>在 S0 和 S1 区中反复移动</strong>，会造成一定的性能开销，降低 GC 的效率。因此引入了对象晋升的行为。</li><li>当对象在新生代的 Eden、S0、S1 区域之间，每次从一个区域移动到另一个区域时，年龄都会加一，在达到一定的阈值后，如果该对象仍然存活，该对象将会晋升到老年代。</li><li>如果老年代也被分配完毕后，就会出现 <strong>MajorGC（即Full GC）</strong>，由于老年代通常对象比较多，因此标记-整理算法的耗时较长，因此会出现 <strong>STW</strong> 现象，因此大多数应用都会尽量减少或者避免出现 Full GC 的原因。</li></ul><p>需要特别说明的是：对于一个新分配的对象，如果 Eden 区放不下，但是老年代可以放下时，该对象会被直接分配到老年代，不会按照上述从新生代晋升到老年代。</p><p>上面提到了一些如<strong>「复制算法」、「不可达」</strong>、<strong>「标记-整理」</strong>等概念，这里引用网络资料进行一一简单介绍：</p><h4 id="2-2-1-识别垃圾"><a href="#2-2-1-识别垃圾" class="headerlink" title="2.2.1. 识别垃圾"></a>2.2.1. 识别垃圾</h4><ul><li><strong>引用计数法（Reference Counting）：</strong> 对每个对象的引用进行计数，每当有一个地方引用它时计数器 +1、引用失效则 -1，引用的计数放到对象头中，大于 0 的对象被认为是存活对象。虽然循环引用的问题可通过 Recycler 算法解决，但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较低，早期的编程语言会采用此算法。</li><li><strong>可达性分析，又称引用链法（Tracing GC）：</strong> 从 GC Root 开始进行对象搜索，可以被搜索到的对象即为可达对象，此时还不足以判断对象是否存活&#x2F;死亡，需要经过多次标记才能更加准确地确定，整个连通图之外的对象便可以作为垃圾被回收掉。目前 Java 中主流的虚拟机均采用此算法。</li></ul><h4 id="2-2-2-收集算法"><a href="#2-2-2-收集算法" class="headerlink" title="2.2.2. 收集算法"></a>2.2.2. 收集算法</h4><p>自从有自动内存管理出现之时就有的一些收集算法，不同的收集器也是在不同场景下进行组合。</p><ul><li><strong>Mark-Sweep（标记-清除）：</strong> 回收过程主要分为两个阶段，第一阶段为追踪（Tracing）阶段，即从 GC Root 开始遍历对象图，并标记（Mark）所遇到的每个对象，第二阶段为清除（Sweep）阶段，即回收器检查堆中每一个对象，并将所有未被标记的对象进行回收，整个过程不会发生对象移动。整个算法在不同的实现中会使用三色抽象（Tricolour Abstraction）、位图标记（BitMap）等技术来提高算法的效率，存活对象较多时较高效。</li></ul><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115174549490.png" alt="image-20231115174549490" style="zoom:33%;" /></div><ul><li><strong>Copying（复制）：</strong> 该算法是为了解决标记-清除算法效率低下、GC 之后空间不连续的问题。该算法将空间分为两个大小相同的 From 和 To 两个半区，同一时间只会使用其中一个，每次进行回收时将一个半区的存活对象通过复制的方式转移到另一个半区。复制算法可以通过碰撞指针的方式进行快速地分配内存，但是也存在着空间利用率不高（只有一半）的缺点，另外就是存活对象比较大时复制的成本比较高。</li></ul><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115174612759.png" alt="image-20231115174612759" style="zoom: 40%;" /></div><ul><li><strong>Mark-Compact （标记-整理）：</strong> 这个算法的主要目的就是解决在非移动式回收器中都会存在的碎片化问题，也分为两个阶段，第一阶段与 Mark-Sweep 类似，标记哪些对象死亡，哪些对象被引用，第二阶段则会对存活对象按照整理顺序（Compaction Order）进行整理。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115180028849.png" alt="image-20231115180028849"></p><p>在 JDK 8 中，默认情况下采用分代垃圾回收策略，其中新生代使用标记-复制算法，老年代使用标记-整理算法。</p><p>这是因为老年代<strong>长生命周期</strong>对象多，如果使用复制算法会十分低效。</p><ul><li>三种算法在是否移动对象、空间和时间方面的一些对比，假设存活对象数量为 <em>L</em>、堆空间大小为 <em>H</em>，则：</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115180015502.png" alt="image-20231115180015502"></p><p>把 mark、sweep、compaction、copying 这几种动作的耗时放在一起看，大致有这样的关系：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115180005979.png" alt="image-20231115180005979"></p><p>虽然 compaction 与 copying 都涉及移动对象，但取决于具体算法，compaction 可能要先计算一次对象的目标地址，然后修正指针，最后再移动对象。copying 则可以把这几件事情合为一体来做，所以可以快一些。另外，<strong>还需要留意</strong> <strong>GC</strong> <strong>带来的开销不能只看 Collector 的耗时，还得看 Allocator</strong> 。如果能保证内存没碎片，分配就可以用 pointer bumping 方式，只需要挪一个指针就完成了分配，非常快。而如果内存有碎片就得用 freelist 之类的方式管理，分配速度通常会慢一些。</p><ul><li><strong>Generational Collection(分代收集)算法</strong></li></ul><p>分代收集算法根据对象的生存周期，将堆分为新生代(<code>Young</code>)和老年代(<code>Tenur</code>)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用<strong>复制算法</strong>。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用<strong>标记-整理</strong>或者<strong>标记-清除</strong>。</p><h2 id="3-GC-收集器"><a href="#3-GC-收集器" class="headerlink" title="3. GC 收集器"></a>3. GC 收集器</h2><p>这里枚举一下各 JDK 版本支持的 GC 收集器，作为快速了解。针对具体常用收集器的调研可参见【10. 其他】</p><p>根据 JDK 版本支持的策略，JDK 8、JDK 11 和 JDK 17 是目前长期支持的版本。目前这3个版本共支持7个垃圾回收器，分别是</p><ol><li><strong>SerialGC</strong></li><li><strong>Parallel</strong> <strong>GC</strong></li><li><strong>CMS</strong></li><li><strong>G1</strong></li><li><strong>Shenandoah</strong> <strong>GC</strong></li><li><strong>ZGC</strong></li><li><strong>Epsilon</strong>（实验特性，仅支持分配不回收，实际场景中不会采用）</li></ol><p>CMS 仅在 JDK 8 和 JDK 11 中支持，ZGC 在 JDK11 中为实验特性，在 JDK 17 中为正式产品，Shenandoah 在JDK 17 中为正式产品，Epsilon 在 JDK 11 和 JDK 17 中为实验特性。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175821783.png" alt="image-20231115175821783"></p><h3 id="3-1-分代收集器"><a href="#3-1-分代收集器" class="headerlink" title="3.1. 分代收集器"></a>3.1. 分代收集器</h3><ul><li><strong>ParNew：</strong> 一款多线程的收集器，采用复制算法，主要工作在 Young 区，可以通过 <code>-XX:ParallelGCThreads</code> 参数来控制收集的线程数，整个过程都是 STW 的，常与 CMS 组合使用。</li><li><strong>CMS</strong>： 以获取最短回收停顿时间为目标，采用「标记-清除」算法，分 4 大步进行垃圾收集，其中初始标记和重新标记会 STW ，多数应用于互联网站或者 B&#x2F;S 系统的服务器端上。虽然在 JDK9 被标记弃用，JDK14 被删除，<strong>但仍经常使用。</strong></li></ul><h3 id="3-2-分区收集器"><a href="#3-2-分区收集器" class="headerlink" title="3.2. 分区收集器"></a>3.2. 分区收集器</h3><ul><li><strong>G1：</strong> 一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能地满足垃圾收集暂停时间的要求。<strong>经常使用。</strong></li><li><strong>ZGC：</strong> JDK11 中推出的一款低延迟垃圾回收器，适用于大内存低延迟服务的内存管理和回收，SPECjbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68 ms，停顿时间远胜于 G1 和 CMS。<strong>近期也经常见到应用。</strong></li><li><strong>Shenandoah：</strong> 由 Red Hat 的一个团队负责开发，与 G1 类似，基于 Region 设计的垃圾收集器，但不需要 Remember Set 或者 Card Table <em>（都是 G1 中的数据结构）</em>来记录跨 Region 引用，停顿时间和堆的大小没有任何关系。停顿时间与 ZGC 接近。</li></ul><h2 id="4-GC-异常的判断"><a href="#4-GC-异常的判断" class="headerlink" title="4. GC 异常的判断"></a>4. GC 异常的判断</h2><h3 id="4-1-评价标准"><a href="#4-1-评价标准" class="headerlink" title="4.1. 评价标准"></a>4.1. 评价标准</h3><p>这里引用美团技术团队的文章，美团在生产实践中发现如下指标比较重要：</p><ul><li><strong>延迟（Latency）：</strong> 也可以理解为最大停顿时间，即垃圾收集过程中一次 STW 的最长时间，越短越好，一定程度上可以接受频次的增大，GC 技术的主要发展方向。</li><li><strong>吞吐量（Throughput）：</strong> 应用系统的生命周期内，由于 GC 线程会占用 Mutator 当前可用的 CPU 时钟周期，吞吐量即为 Mutator 有效花费的时间占系统总运行时间的百分比，例如系统运行了 100 min，GC 耗时 1 min，则系统吞吐量为 99%，吞吐量优先的收集器可以接受较长的停顿。</li></ul><p>目前各大互联网公司的系统基本都更追求低延时，避免一次 GC 停顿的时间过长对用户体验造成损失，衡量指标需要结合一下应用服务的 SLA，主要如下两点来判断：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175939344.png" alt="image-20231115175939344"></p><p>简而言之，即为**一次停顿的时间不超过应用服务的 TP9999，GC的吞吐量不小于 99.99%**。</p><blockquote><p>TP9999: 即 Top Percentile 99.99%，保证 99.99% 的网络服务可用的最低耗时</p></blockquote><p>举个例子，假设某个服务 A 的 TP9999 为 80 ms，平均 GC 停顿为 30 ms，那么该服务的最大停顿时间最好不要超过 80 ms，GC 频次控制在 5 min 以上一次。如果满足不了，那就需要调优或者通过更多资源来进行并联冗余。</p><p>备注：除了这两个指标之外还有 Footprint（资源量大小测量）、反应速度等指标，互联网这种实时系统追求低延迟，而很多嵌入式系统则追求 Footprint。</p><p>个人认为：作为时序数据库，IoTDB 追求低延时、异常可告警的需求和互联网公司系统这方面的需求大致吻合，因此可以将上述指标映射到 IoTDB 的 JVM GC 监控系统中作为参考。</p><h3 id="4-2-GC-Cause"><a href="#4-2-GC-Cause" class="headerlink" title="4.2. GC Cause"></a>4.2. GC Cause</h3><p>个人了解到，IoTDB 目前在某些实际环境有一些异常 GC，<strong>而要分析异常 GC，先要读懂 GC Cause</strong>，即 JVM 什么样的条件下选择进行 GC 操作，具体 Cause 的分类可以参考 Hotspot 源码：src&#x2F;share&#x2F;vm&#x2F;gc&#x2F;shared&#x2F;gcCause.hpp 和 src&#x2F;share&#x2F;vm&#x2F;gc&#x2F;shared&#x2F;gcCause.cpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GCCause::to_string</span><span class="params">(GCCause::Cause cause)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (cause) &#123;</span><br><span class="line">    <span class="keyword">case</span> _java_lang_system_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;System.gc()&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _full_gc_alot:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;FullGCAlot&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _scavenge_alot:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ScavengeAlot&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _allocation_profiler:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Allocation Profiler&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _jvmti_force_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;JvmtiEnv ForceGarbageCollection&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _gc_locker:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;GCLocker Initiated GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _heap_inspection:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Heap Inspection Initiated GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _heap_dump:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Heap Dump Initiated GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _wb_young_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;WhiteBox Initiated Young GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _update_allocation_context_stats_inc:</span><br><span class="line">    <span class="keyword">case</span> _update_allocation_context_stats_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Update Allocation Context Stats&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _no_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;No GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _allocation_failure:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Allocation Failure&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _tenured_generation_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Tenured Generation Full&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _metadata_GC_threshold:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Metadata GC Threshold&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_generation_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Generation Full&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_initial_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Initial Mark&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_final_remark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Final Remark&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_concurrent_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Concurrent Mark&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _old_generation_expanded_on_last_scavenge:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Old Generation Expanded On Last Scavenge&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _old_generation_too_full_to_scavenge:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Old Generation Too Full To Scavenge&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _adaptive_size_policy:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Ergonomics&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _g1_inc_collection_pause:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;G1 Evacuation Pause&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _g1_humongous_allocation:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;G1 Humongous Allocation&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _last_ditch_collection:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Last ditch collection&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _last_gc_cause:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ILLEGAL VALUE - last gc cause - ILLEGAL VALUE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;unknown GCCause&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ShouldNotReachHere</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体每种 Cause 的含义，可以参考：<a href="https://blog.csdn.net/lbh_paopao/article/details/120269135">https://blog.csdn.net/lbh_paopao/article/details/120269135</a></li></ul><p>对于以上 Cause，这里还是引用美团技术团队在业界实践的经验：</p><blockquote><p>重点需要关注的几个GC Cause：</p><ul><li><strong>System.gc()：</strong> 手动触发GC操作。</li><li><strong>CMS（如果使用的是 CMS 收集器的话）：</strong> CMS GC 在执行过程中的一些动作，重点关注 CMS Initial Mark 和 CMS Final Remark 两个 STW 阶段。</li><li><strong>Promotion Failure：</strong> Old 区没有足够的空间分配给 Young 区晋升的对象（即使总可用内存足够大，此处特指  CMS）。</li><li><strong>Concurrent</strong> <strong>Mode Failure（如果使用的是</strong> <strong>CMS</strong> <strong>收集器的话）：</strong> CMS GC 运行期间，Old 区预留的空间不足以分配给新的对象，此时收集器会发生退化，严重影响 GC 性能。</li><li><strong>GCLocker Initiated GC</strong>： 如果线程执行在 JNI 临界区时，刚好需要进行 GC，此时 GC Locker 将会阻止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。</li></ul></blockquote><h2 id="5-启示"><a href="#5-启示" class="headerlink" title="5. 启示"></a>5. 启示</h2><p>通过以上的基础调研，可以对 IoTDB JVM GC 监控系统的设计得出如下启示：</p><ol><li>收纳 <strong>延迟（Latency）和吞吐量（Throughput）</strong>作为 metric（可通过直接收集指标或间接计算得出），可以考虑使用 Timer 对每一个 GC Cause 记录 Duration，将 Cause 和 Duration 绑定起来一起记录，从而对 GC 异常分析有据可循。</li></ol><ul><li>期望大致效果如下：可以看到一段时间内应用 GC Cause 的集合以及 GC Duration 相关信息。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175800875.png" alt="image-20231115175800875"></p><ol><li>由于不同的 GC 收集器对内存的划分不同（对不同区域内存的行为也不同），因此需要针对不同 GC 收集器<strong>定制化 Memory usage 监控指标。</strong></li><li>某些 GC 收集器包含 concurrent phase（具体可以查看【10.其他】）。由于它们的 concurrent phase 并不 stw，导致 JMX 的 <strong>GcInfo.getDuration()</strong> 的<strong>实际值比应用程序的停止时间更长</strong>（因为它们把并发阶段也算进去了）。因此对于某些特殊收集器（如涉及到并行 GC），需要<strong>定制化指标计算方式，防止指标计算失准。</strong></li></ol><h2 id="6-现有监控工具及框架"><a href="#6-现有监控工具及框架" class="headerlink" title="6. 现有监控工具及框架"></a>6. 现有监控工具及框架</h2><p>功能大同小异，主要是使用体验上的差别，此处不赘述，仅罗列以扫盲。</p><h3 id="6-1-框架"><a href="#6-1-框架" class="headerlink" title="6.1. 框架"></a>6.1. 框架</h3><ul><li>集成框架（内置 JVM GC 监控模块）Micormeter、Dropwizard</li></ul><h3 id="6-2-命令行终端"><a href="#6-2-命令行终端" class="headerlink" title="6.2. 命令行终端"></a>6.2. 命令行终端</h3><ul><li>jps、jinfo、jstat、jstack、jmap、jcmd、arthas 等</li></ul><h3 id="6-3-可视化界面"><a href="#6-3-可视化界面" class="headerlink" title="6.3. 可视化界面"></a>6.3. 可视化界面</h3><ul><li>JConsole、GCHisto、GCViewer、JProfiler 等</li></ul><p>本文参考了以上项目关注的指标和设计方法。部分项目在 Github 有源码，感兴趣的读者可自行查阅。</p><h2 id="7-JMX-运行时指标收集工具"><a href="#7-JMX-运行时指标收集工具" class="headerlink" title="7. JMX - 运行时指标收集工具"></a>7. JMX - 运行时指标收集工具</h2><p>在实际的 Java 应用中，常常见到开发者通过添加 VM 参数<code>-XX:+PrintGC</code>、<code>-XX:+PrintHeapAtGC</code>等来获取 GC 相关信息。<strong>那么如何用代码的形式在运行时显式获取这些信息呢？</strong>答案是使用 <strong>JVM 提供的相应 api（JMX）。</strong></p><p>我们可以利用 JMX 提供的一些钩子函数，获得我们想要的信息，<strong>理论上来说，通过 JMX，我们可以自己手搓<code>-XX:+PrintGC</code>等的相关功能</strong>。接下来以 GC Info 为例，详细介绍一下 JMX 的相关概念和快速使用。</p><h3 id="7-1-什么是-JMX？"><a href="#7-1-什么是-JMX？" class="headerlink" title="7.1. 什么是 JMX？"></a>7.1. 什么是 JMX？</h3><blockquote><p>Java Management Extensions（<strong>JMX</strong>）技术是 Java SE 平台的标准功能，提供了一种简单的、标准的监控和管理资源的方式，对于如何定义一个资源给出了明确的结构和设计模式，主要用于监控和管理 Java 应用程序运行状态、设备和资源信息、Java 虚拟机运行情况等信息。 JMX 是可以动态的，所以也可以在资源创建、安装、实现时进行动态监控和管理，JDK 自带的 jconsole 就是使用 JMX 技术实现的监控工具。</p></blockquote><p>使用 JMX 技术时，通过定义一个被称为 <strong>MBean</strong> 或 <strong>MXBean</strong> 的 Java 对象来表示要管理指定的资源，然后可以把资源信息注册到 <strong>MBean Server</strong> 对外提供服务。MBean Server 充当了对外提供服务和对内管理 MBean 资源的代理功能，如此优雅的设计让 MBean 资源管理和 MBean Server 代理完全独立开，使之可以自由的控制 MBean 资源信息。</p><h3 id="7-2-资源管理-MBean"><a href="#7-2-资源管理-MBean" class="headerlink" title="7.2. 资源管理 MBean"></a>7.2. 资源管理 MBean</h3><p>在 JMX 中， 使用 <strong>MBean</strong> 或 <strong>MXBean</strong> 来表示一个资源（下面简称 MBean），访问和管理资源也都是通过 MBean，所以 MBean 往往包含着资源的<strong>属性和操作方法</strong>。</p><p>JMX 已经对 JVM 进行了多维度资源检测，所以可以轻松启动 JMX 代理来访问内置的 JVM 资源检测，从而通过 JMX 技术远程监控和管理 JVM。下表列出了一些 JMX 中的资源接口：</p><table><thead><tr><th><strong>资源接口</strong></th><th><strong>管理的资源</strong></th><th><strong>Object Name</strong></th><th><strong>VM</strong> <strong>中的实例个数</strong></th></tr></thead><tbody><tr><td>ClassLoadingMXBean</td><td>类加载</td><td>java.lang:type&#x3D; ClassLoading</td><td>1个</td></tr><tr><td>CompilationMXBean</td><td>汇编系统</td><td>java.lang:type&#x3D; Compilation</td><td>0 个或1个</td></tr><tr><td><strong>GarbageCollectorMXBean</strong>（本文主要关注的）</td><td><em><strong>垃圾收集</strong></em></td><td><em><strong>java.lang:type&#x3D; GarbageCollector, name&#x3D;collectorName</strong></em></td><td><em><strong>1个或更多</strong></em></td></tr><tr><td>LoggingMXBean</td><td>日志系统</td><td>java.util.logging:type &#x3D;Logging</td><td>1个</td></tr><tr><td><strong>MemoryManagerMXBean</strong></td><td><strong>内存池</strong></td><td><strong>java.lang: typeMemoryManager, name&#x3D;managerName</strong></td><td><strong>1个或更多</strong></td></tr><tr><td><strong>MemoryPoolMXBean</strong></td><td><strong>内存</strong></td><td><strong>java.lang: type&#x3D; MemoryPool, name&#x3D;poolName</strong></td><td><strong>1个或更多</strong></td></tr><tr><td><strong>MemoryMXBean</strong></td><td><strong>内存系统</strong></td><td><strong>java.lang:type&#x3D; Memory</strong></td><td><strong>1个</strong></td></tr><tr><td>OperatingSystemMXBean</td><td>操作系统</td><td>java.lang:type&#x3D; OperatingSystem</td><td>1个</td></tr><tr><td>RuntimeMXBean</td><td>运行时系统</td><td>java.lang:type&#x3D; Runtime</td><td>1个</td></tr><tr><td>hreadMXBean</td><td>线程系统</td><td>java.lang:type&#x3D; Threading</td><td>1个</td></tr></tbody></table><h3 id="7-2-JMX-的具体使用"><a href="#7-2-JMX-的具体使用" class="headerlink" title="7.2. JMX 的具体使用"></a>7.2. JMX 的具体使用</h3><ol><li>根据上面的信息，我们可以根据 JMX 内置的 MBean 获取系统信息，<strong>本文的</strong> <strong>JVM</strong> <strong>GC</strong> <strong>监控使用了此方法。</strong></li></ol><p>实例：获得<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">堆内存</a>和非堆内存的大小。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">monitorMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Memory:&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="type">MemoryMXBean</span> <span class="variable">mmbean</span> <span class="operator">=</span> ManagementFactory.getMemoryMXBean();</span><br><span class="line">        <span class="type">MemoryUsage</span> <span class="variable">hmu</span> <span class="operator">=</span> mmbean.getHeapMemoryUsage();</span><br><span class="line">        sb.append(<span class="string">&quot;[HeapMemoryUsage:&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot; Used=&quot;</span> + formatBytes(hmu.getUsed()));</span><br><span class="line">        sb.append(<span class="string">&quot; Committed=&quot;</span> + formatBytes(hmu.getCommitted()));</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">MemoryUsage</span> <span class="variable">nhmu</span> <span class="operator">=</span> mmbean.getNonHeapMemoryUsage();</span><br><span class="line">        sb.append(<span class="string">&quot;[NonHeapMemoryUsage:&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot; Used=&quot;</span> + formatBytes(nhmu.getUsed()));</span><br><span class="line">        sb.append(<span class="string">&quot; Committed=&quot;</span> + formatBytes(nhmu.getCommitted()));</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>我们甚至可以自己按需写一个 MBean 注册到 JMX 中，以供外部使用。<strong>（实际上在 IoTDB 中经常能够见到这样的应用）</strong></li></ul><p>MBean 的编写必须遵守 JMX 的设计规范，MBean 很像一个特殊的 Java Bean，它需要一个接口和一个实现类。MBean 资源接口总是以 MBean 或者 MXBean 结尾，实现类则要以接口去掉 MBean 或 MXBean 之后的名字来命名。</p><p>MBean 资源需要注册到 MBean Server 进行代理才可以暴露给外部进行调用，所以我们想要通过远程管理我们自定义的 MyMemory 资源，需要先进行资源代理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 MBean Server</span></span><br><span class="line"><span class="type">MBeanServer</span> <span class="variable">platformMBeanServer</span> <span class="operator">=</span> ManagementFactory.getPlatformMBeanServer();</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="type">ObjectName</span> <span class="variable">objectName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectName</span>(MBeanName);</span><br><span class="line">platformMBeanServer.registerMBean(your_mbean, objectName);</span><br></pre></td></tr></table></figure><h4 id="7-3-1-监听器模式——Notification"><a href="#7-3-1-监听器模式——Notification" class="headerlink" title="7.3.1. 监听器模式——Notification"></a>7.3.1. 监听器模式——Notification</h4><p>JMX API 定义了一种机制，使得 MBeans 能够生成通知 Notification，比如通知一个状态改变、一个检测到的事件或者问题，系统状态，GC 事件。通知的作用是主动通知远程客户端。例如程序出现异常，CPU使用率过高，出现了死锁等。这时程序能事件触发主动发送给远程客户端，将这些问题记录下来，或者执行一些其他的报警操作。<strong>本文的</strong> <strong>JVM</strong> <strong>GC 监控使用了此方法。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javax.management.Notification</span><br><span class="line">public class NotificationBroadcasterSupport implements NotificationEmitter &#123;</span><br><span class="line">    ...</span><br><span class="line">    public MBeanNotificationInfo[] getNotificationInfo()&#123;...&#125;</span><br><span class="line">    public void sendNotification(Notification notification)&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个 MBean 生成通知必须实现接口 <code>NotificationEmitter</code> 或者扩展 <code>NotificationBroadcasterSupport</code></li><li>Notification 监听器必须实现 <code>NotificationListener</code> 接口</li></ul><p>其中，本文重点关注 GC 相关的 Info，通过阅读源码得知 **<code>GarbageCollectionNotificationInfo</code>**（ notification）的数据结构如下：</p><table><thead><tr><th><strong>属性名</strong></th><th><strong>类型</strong></th><th><strong>注释</strong></th></tr></thead><tbody><tr><td>gcName</td><td>java.lang.String</td><td>如: G1 Old Generation,G1 Young Generation等</td></tr><tr><td>gcAction</td><td>java.lang.String</td><td>标识是哪个 gc 动作，一般为：end of major GC，end of minor GC 等，分别表示老年代和新生代的 gc 结束。</td></tr><tr><td>gcCause</td><td>java.lang.String</td><td>引起 gc 的原因,如：System.gc()，Allocation Failure，G1 Humongous Allocation等</td></tr><tr><td>gcInfo</td><td>javax.management.openmbean.CompositeData</td><td>gc 的详细信息，见下表</td></tr></tbody></table><p>通过阅读 openjdk 官网手册和源码，我们可以得知 <strong><code>GCInfo</code></strong> 详细信息如下：</p><table><thead><tr><th><strong>属性名</strong></th><th><strong>类型</strong></th><th><strong>注释</strong></th></tr></thead><tbody><tr><td>index</td><td>java.lang.Long</td><td>标识这个收集器进行了几次 gc（垃圾回收事件的 ID）</td></tr><tr><td>startTime</td><td>java.lang.Long</td><td>gc 的开始时间</td></tr><tr><td>endTime</td><td>java.lang.Long</td><td>gc 的结束时间</td></tr><tr><td>memoryUsageBeforeGc</td><td>javax.management.openmbean.TabularData</td><td>gc 前内存情况</td></tr><tr><td>memoryUsageAfterGc</td><td>javax.management.openmbean.TabularData</td><td>gc 后内存情况</td></tr></tbody></table><p>以 GC 为例，最简单的 <code>NotificationListener</code> 使用如下：</p><ul><li>该程序实现了：当发生 GC 时，自动读取 GC 时间、GC 原因、相关内存池前后使用情况等相关信息（见 <code>map</code> 变量）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GarbageNotificationListener</span> <span class="keyword">implements</span> <span class="title class_">NotificationListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNotification</span><span class="params">(Notification notification, Object handback)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">notifType</span> <span class="operator">=</span> notification.getType();</span><br><span class="line">        <span class="keyword">if</span> (notifType.equals(GarbageCollectionNotificationInfo.GARBAGE_COLLECTION_NOTIFICATION)) &#123;</span><br><span class="line">            <span class="type">CompositeData</span> <span class="variable">cd</span> <span class="operator">=</span> (CompositeData) notification.getUserData();</span><br><span class="line">            <span class="type">GarbageCollectionNotificationInfo</span> <span class="variable">info</span> <span class="operator">=</span> GarbageCollectionNotificationInfo.from(cd);</span><br><span class="line">            <span class="type">GcInfo</span> <span class="variable">gcInfo</span> <span class="operator">=</span> info.getGcInfo();</span><br><span class="line">            HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;duration&quot;</span>, gcInfo.getDuration());</span><br><span class="line">            map.put(<span class="string">&quot;id&quot;</span>, gcInfo.getId());</span><br><span class="line">            map.put(<span class="string">&quot;UsageAfterGc&quot;</span>, gcInfo.getMemoryUsageAfterGc());</span><br><span class="line">            map.put(<span class="string">&quot;UsageBeforeGc&quot;</span>, gcInfo.getMemoryUsageBeforeGc());</span><br><span class="line">            map.put(<span class="string">&quot;GcAction&quot;</span>, info.getGcAction());</span><br><span class="line">            map.put(<span class="string">&quot;GcCause&quot;</span>, info.getGcCause());</span><br><span class="line">            map.put(<span class="string">&quot;GcName&quot;</span>, info.getGcName());</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-监控方案设计"><a href="#8-监控方案设计" class="headerlink" title="8. 监控方案设计"></a>8. 监控方案设计</h2><h3 id="8-1-push-base"><a href="#8-1-push-base" class="headerlink" title="8.1. push base"></a>8.1. push base</h3><blockquote><p>参考：org.apache.cassandra.service.GCInspector、<em>io.micrometer.core.instrument.binder.jvm.JvmGcMetrics</em></p><p>IoTDB 实现类：</p><ul><li>org.apache.iotdb.metrics.metricsets.jvm.JvmGcMetrics</li></ul></blockquote><p><strong>思路：</strong>利用 JMX 的 notification 机制，实现一个 Listener 对 GC 进行监听。每次 JVM 发生 GC 时，接受 JVM 主动发送的 GcInfo，从中解析出相应的信息（具体查看【9. 监控指标设计】）</p><p><strong>核心方法：</strong>可查看源码，此处不再赘述</p><p><strong>注意点：</strong></p><ul><li>包含并发过程 GC 的 duration 需要采用特别的计算方式，因为 GcInfo.getDuration() 得到的 duration 比实际 stw 的时间长（把并发标记的时间也算上去了）</li><li>一些 GC 如 G1 会在 minor GC 时减小 old gen memory 的 size，需要对其进行追踪</li><li>需要对非代际 GC 和 分代 GC 分别监控</li></ul><p><strong>与 IoTDB 整合的实现效果：</strong></p><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175714192.png" alt="image-20231115175714192" style="zoom:50%;" /></div><h3 id="8-2-pull-base"><a href="#8-2-pull-base" class="headerlink" title="8.2. pull base"></a>8.2. pull base</h3><blockquote><p>参考：org.apache.hadoop.util.GcTimeMonitor</p><p>IoTDB 实现类：</p><ul><li>org.apache.iotdb.commons.service.metric.JvmGcMetrics </li><li>org.apache.iotdb.commons.service.metric.GcTimeAlerter</li></ul></blockquote><p><strong>思路：</strong>在<strong>设定好的频率</strong>下，不断 pull JMX 中的 GC 信息。该 metric 类将监视 JVM 在指定观察窗口（例如1分钟）内的 GC 暂停时间的百分比。用户可以<strong>提供一个钩子</strong>（hook），当这个百分比超过<strong>指定的阈值</strong>（例如 70%）时，将会调用该钩子进行告警、处理等操作。</p><p><strong>核心方法：</strong><code>calculateGCTimePercentageWithinObservedInterval()</code> 在设定好的频率下不停运行。假设调用该方法的时刻是 <code>startTs</code>，那么该方法将计算 [<code>startTs</code> - <code>observerWindowMs</code>，<code>startTs</code>] 时间窗口下的 <code>GcTime</code>、<code>GcCount</code></p><ul><li>方法内部：统计所有 collector 的 <code>GcTime</code> 和 <code>GcCount</code>，并将该次统计信息保存到一个循环缓冲区里，并更新该缓冲区的开始和结束索引以跟踪最早和最新的 GC 暂停时间戳。<ul><li>注意从最早的时间戳开始累加 GcTime 时，需要考虑 <code>startTs</code> - <code>observerWindowMs</code> <strong>之前</strong>发生并延续到[<code>startTs</code> - <code>observerWindowMs</code>，<code>startTs</code>] 时间窗口下的 GC。这时我们只需要统计该时间窗口下的 Gc，<strong>舍弃</strong><code>startTs</code> - <code>observerWindowMs</code> 之前的 GC 时间。</li></ul></li></ul><p><strong>告警处理：</strong>当在指定观察窗口内的 GC 暂停时间百分比超过指定的阈值（例如 70%）时，将会调用<code>org.apache.iotdb.commons.service.metric.GcTimeAlerter</code>进行告警、处理等操作。用户可以在此部分自定义代码，比如打日志、清理内存等。（目前只实现了简单的 <code>logger.warn()</code> 告警功能，如下图）</p><blockquote><p><strong>目前实现的 Alerter 效果：</strong></p><ul><li>打印当前异常时间</li><li>打印当前时间窗口内，GC 时间所占比例（类似吞吐量）</li><li>打印当前时间窗口内，累计 GC 时间</li><li>打印当前时间窗口的起始时间</li><li>打印当前时间窗口的时长（默认为 1 分钟，如果 IoTDB 启动还没满 1 分钟，那么该值为 IoTDB 的累计运行时间）</li></ul></blockquote><p><strong>与 IoTDB 整合的实现效果：</strong></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175656708.png" alt="image-20231115175656708"></p><h3 id="8-3-测试方法"><a href="#8-3-测试方法" class="headerlink" title="8.3. 测试方法"></a>8.3. 测试方法</h3><p>IDEA 3c3d（3个 ConfigNode、3个 DataNode） 环境下，在 IoTDB ConfigNode 和 DataNode 启动时开启一个添加内存的线程，并可以按需 System.gc()。通过观察日志和 <code>curl localhost:9091/metrics</code> 观察指标。以 IoTDB ConfigNode 为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  LOGGER.info(</span><br><span class="line">      <span class="string">&quot;&#123;&#125; environment variables: &#123;&#125;&quot;</span>,</span><br><span class="line">      ConfigNodeConstant.GLOBAL_NAME,</span><br><span class="line">      ConfigNodeConfig.getEnvironmentVariables());</span><br><span class="line">  LOGGER.info(</span><br><span class="line">      <span class="string">&quot;&#123;&#125; default charset is: &#123;&#125;&quot;</span>,</span><br><span class="line">      ConfigNodeConstant.GLOBAL_NAME,</span><br><span class="line">      Charset.defaultCharset().displayName());</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ConfigNodeCommandLine</span>().doMain(args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">          () -&gt; &#123;</span><br><span class="line">            List&lt;<span class="type">byte</span>[]&gt; byteList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">              <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">              byteList.add(bytes);</span><br><span class="line">              <span class="comment">// 可以手动 GC，也可以让系统自动 GC 直至 heap overflow</span></span><br><span class="line"><span class="comment">//              if (i % 10 == 0) &#123;</span></span><br><span class="line"><span class="comment">//                System.gc();</span></span><br><span class="line"><span class="comment">//              &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      .start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-监控指标设计"><a href="#9-监控指标设计" class="headerlink" title="9. 监控指标设计"></a>9. 监控指标设计</h2><h3 id="9-1-push-base"><a href="#9-1-push-base" class="headerlink" title="9.1. push base"></a>9.1. push base</h3><table><thead><tr><th><strong>metric</strong></th><th><strong>Type</strong></th><th><strong>Monitor Approach</strong></th><th><strong>Tips</strong></th></tr></thead><tbody><tr><td>jvm_gc_max_data_size_bytes</td><td>AutoGauge</td><td>JMX</td><td>长生命周期内存池 (old gen &amp; perm gen(Metaspace)  最大内存大小</td></tr><tr><td>jvm_gc_live_data_size_bytes</td><td>AutoGauge</td><td>notification update</td><td>长生命周期内存池已使用大小</td></tr><tr><td>jvm_gc_young_memory_allocated_bytes</td><td>Counter</td><td>notification update</td><td>年轻代内存池已分配对象大小</td></tr><tr><td>jvm_gc_old_memory_allocated_bytes</td><td>Counter</td><td>notification update</td><td>年老代内存池直接分配的对象大小（不包括晋升的对象）</td></tr><tr><td>jvm_gc_non_gen_memory_allocated_bytes</td><td>Counter</td><td>notification update</td><td>非代际内存池已分配的对象大小</td></tr><tr><td>jvm_gc_memory_promoted_bytes</td><td>Counter</td><td>notification update</td><td>移动到 old gen 的对象大小</td></tr><tr><td>jvm_gc_pause</td><td>Timer</td><td>notification update</td><td>具体 GC cause 下的 GC 暂停时间<strong>（将不同</strong> <strong>GC</strong> <strong>的 cause 跟每次 GC 的 duration 绑定，Timer 还可以统计各 cause 的频率）</strong></td></tr><tr><td>jvm_zgc_pauses_count</td><td>Counter</td><td>notification update</td><td><strong>ZGC</strong> pauses 的次数</td></tr><tr><td>jvm_zgc_cycles_count</td><td>Counter</td><td>notification update</td><td><strong>ZGC</strong> circles 的次数</td></tr></tbody></table><h3 id="9-2-pull-base"><a href="#9-2-pull-base" class="headerlink" title="9.2. pull base"></a>9.2. pull base</h3><table><thead><tr><th><strong>metric</strong></th><th><strong>Type</strong></th><th><strong>Monitor Approach</strong></th><th><strong>Tips</strong></th></tr></thead><tbody><tr><td>jvm_gc_accumulated_time</td><td>Alerter 日志打印</td><td>JMX + 累加计算</td><td>在指定时间窗口内，GC 总时间，单位毫秒<strong>，支持 ZGC</strong></td></tr><tr><td>observation_window_start_time</td><td>Alerter 日志打印</td><td>计算</td><td>指定时间窗口的起始时间</td></tr><tr><td>observation_window_end_time</td><td>Alerter 日志打印</td><td>计算</td><td>指定时间窗口的结束时间</td></tr><tr><td>observation_window_time</td><td>Alerter 日志打印</td><td>计算</td><td>指定时间窗口的总时长，默认为 1 min。如果 IoTDB 启动还没满 1 分钟，那么该值为 IoTDB 的累计运行时间</td></tr><tr><td>jvm_gc_accumulated_time_percentage</td><td>AutoGauge</td><td>jvm_gc_accumulated_time &#x2F; total_time</td><td>在指定时间窗口内，GC 时间所占的比例（类似吞吐量的概念）。若超过 threshold，进行告警<strong>（可选）</strong></td></tr></tbody></table><h2 id="10-其他"><a href="#10-其他" class="headerlink" title="10. 其他"></a>10. 其他</h2><p>在实际场景中，<strong>G1 和</strong> <strong>CMS</strong> <strong>使用的较多</strong>，而 <strong>ZGC 作为内存不分代的新型垃圾回收器代表</strong>，也有必要被研究。尽管这些算法的具体执行细节难以监控追踪，但我们仍可以了解它们。这里做一个简单整理，更深入可以阅读资料或者查看 hotspot 源码。</p><h3 id="10-1-CMS-经久不衰的常用回收器"><a href="#10-1-CMS-经久不衰的常用回收器" class="headerlink" title="10.1. CMS - 经久不衰的常用回收器"></a>10.1. CMS - 经久不衰的常用回收器</h3><blockquote><p>CMS（Concurrent Mark Sweep）垃圾回收器是第一个关注 GC 停顿时间的垃圾收集器。 在这之前的垃圾回收器，要么就是串行垃圾回收方式，要么就是关注系统吞吐量。这样的垃圾回收器对于强交互的程序很不友好，而 CMS 垃圾回收器的出现，则打破了这个尴尬的局面。因此，CMS 垃圾回收器诞生之后就受到了大家的欢迎，导致现在还有非常多的应用还在继续使用它。</p></blockquote><p>CMS 垃圾回收器之所以能够实现对 GC 停顿时间的控制，其本质来源于对「根可达算法」的改进，即三色标记算法。在 CMS 垃圾回收器出现之前，无论是 Serious 垃圾回收器，还是 ParNew 垃圾回收器，亦或是 Parallel Scavenge 垃圾回收器，他们在进行垃圾回收的时候都需要 Stop the World，即无法实现垃圾回收线程与用户线程并发执行。而 CMS 垃圾回收器通过<strong>三色标记算法，</strong>实现了垃圾回收线程<strong>与用户线程并发执行</strong>，从而极大地降低了系统响应时间，提高了强交互应用程序的体验。</p><h4 id="10-1-1-三色标记算法"><a href="#10-1-1-三色标记算法" class="headerlink" title="10.1.1. 三色标记算法"></a>10.1.1. 三色标记算法</h4><p>三色标记法将对象的颜色分为了黑、灰、白，三种颜色。</p><p>「白色」：该对象没有被标记过。（对象垃圾）</p><p>「灰色」：该对象已经被标记过了，但该对象下的属性没有全被标记完。（GC 需要从此对象中去寻找垃圾）</p><p>「黑色」：该对象已经被标记过了，且该对象下的属性也全部都被标记过了。（程序所需要的对象）</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175630425.png" alt="image-20231115175630425"></p><h5 id="10-1-2-算法流程"><a href="#10-1-2-算法流程" class="headerlink" title="10.1.2. 算法流程"></a>10.1.2. 算法流程</h5><p>从 GC Root 开始沿着他们的对象向下查找，用黑灰白的规则，标记出所有跟 GC Root 相连接的对象，扫描一遍结束后，一般需要进行一次短暂的 STW，再次进行扫描，此时因为黑色对象的属性都也已经被标记过了，所以只需找出灰色对象并顺着继续往下标记（且因为大部分的标记工作已经在第一次并发的时候发生了，所以灰色对象数量会很少，标记时间也会短很多）, 此时程序继续执行，GC 线程扫描所有的内存，找出扫描之后依旧被标记为白色的对象（垃圾）并清除。具体流程如下</p><ol><li>首先创建三个集合：白、灰、黑。</li><li>将所有对象放入白色集合中。</li><li>然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入灰色集合。</li><li>之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</li><li>重复 4 直到灰色中无任何对象</li><li>通过 write-barrier 检测对象有变化，重复以上操作</li><li>收集所有白色对象（垃圾）</li></ol><h5 id="10-1-3-存在问题"><a href="#10-1-3-存在问题" class="headerlink" title="10.1.3. 存在问题"></a>10.1.3. 存在问题</h5><ol><li><strong>浮动垃圾</strong>：并发标记的过程中，若一个已经被标记成黑色或者灰色的对象，突然变成了垃圾，由于不会再对黑色标记过的对象重新扫描，所以不会被发现，那么这个对象不是白色的但是不会被清除，重新标记也不能从 GC Root 中去找到，所以成为了浮动垃圾，「浮动垃圾对系统的影响不大，留给下一次 GC 进行处理即可」。</li><li><strong>对象漏标问题（需要的对象被回收）</strong>：并发标记的过程中，一个业务线程将一个未被扫描过的白色对象断开引用成为垃圾（删除引用），同时黑色对象引用了该对象（增加引用）（这两部可以不分先后顺序）；因为黑色对象的含义为其属性都已经被标记过了，重新标记也不会从黑色对象中去找，导致该对象被程序所需要，却又要被 GC 回收，此问题会导致系统出现问题，对此「CMS 对增加引用环节进行处理（Increment Update），G1 则对删除引用环节进行处理 (SATB)（这里不做详细介绍，可以自行查阅）」</li></ol><h4 id="10-1-2-与用户线程并发执行-GC"><a href="#10-1-2-与用户线程并发执行-GC" class="headerlink" title="10.1.2. 与用户线程并发执行 GC"></a>10.1.2. 与用户线程并发执行 GC</h4><p><strong>主要</strong>分为4个阶段（注意，该部分在 G1 回收器中也能窥见思想和相似应用）</p><ul><li><strong>初始标记（CMS initial mark）</strong>，指的是寻找所有被 GCRoots 引用的对象，该阶段需要「Stop the World」。 这个步骤仅仅只是标记一下 GC Roots 能直接关联到的对象，并不需要做整个引用的扫描，因此速度很快。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175606653.png" alt="image-20231115175606653"></p><ul><li><strong>并发标记（CMS concurrent mark）</strong>，指的是对「初始标记阶段」标记的对象进行整个引用链的扫描，该阶段不需要「Stop the World」。 对整个引用链做扫描需要花费非常多的时间，因此通过垃圾回收线程与用户线程并发执行，可以降低垃圾回收的时间，从而降低系统响应时间。但这也带来了一些问题，即：并发标记的时候，引用可能发生变化，因此可能发生漏标（本应该被标记的对象，没有被正确地标记颜色，导致不应该回收的对象被回收）和多标（本不该被标记的对象，被错误地标记颜色，导致应该被回收的对象没有被回收）了。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175554390.png" alt="image-20231115175554390"></p><ul><li><strong>重新标记（CMS remark）</strong>，指的是对「并发标记」阶段出现的问题进行校正，该阶段需要「Stop the World」。 正如并发标记阶段说到的，由于垃圾回收算法和用户线程并发执行，虽然能降低响应时间，但是会发生漏标和多标的问题。所以对于 CMS 回收器来说，它需要这个阶段来做一些校验，解决并发标记阶段发生的问题。</li><li><strong>并发清除（CMS concurrent sweep）</strong>，指的是将标记为垃圾的对象进行清除，该阶段不需要「Stop the World」。 在这个阶段，垃圾回收线程与用户线程可以并发执行，因此并不影响用户的响应时间。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175542197.png" alt="image-20231115175542197"></p><p>从上面的描述步骤中我们可以看出：CMS 之所以能极大地降低 GC 停顿时间，本质上是将原本冗长的引用链扫描进行切分。通过 GC 线程与用户线程并发执行，加上重新标记校正的方式，减少了垃圾回收的时间。</p><h3 id="10-2-G1-CMS-的替代者-Java-9-默认回收器"><a href="#10-2-G1-CMS-的替代者-Java-9-默认回收器" class="headerlink" title="10.2. G1 - CMS 的替代者 | Java 9 默认回收器"></a>10.2. G1 - CMS 的替代者 | Java 9 默认回收器</h3><h4 id="10-2-1-内存模型"><a href="#10-2-1-内存模型" class="headerlink" title="10.2.1. 内存模型"></a>10.2.1. 内存模型</h4><p>传统的 GC 收集器将连续的内存空间划分为新生代、老年代和永久代（JDK8 去除了永久代，引入了元空间 Metaspace），这种划分的特点是各代的存储地址（逻辑地址，下同）是连续的。如下图所示：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175528545.png" alt="image-20231115175528545"></p><p>而G1的各代存储地址是<strong>不连续的</strong>，每一代都使用了 n 个不连续的<strong>大小相同</strong>的 Region，每个 Region 占有一块连续的虚拟内存地址（<strong>但内存仍是分代际的，只是分散在不连续的 Region 中</strong>）。如下图所示：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175518344.png" alt="image-20231115175518344"></p><p>这里为了帮助理解，再贴一张 CMS（传统收集器） 和 G1 的内存分布图：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175504522.png" alt="image-20231115175504522"></p><p>在上面的图中，注意到还有一些 Region 标明了 H，它代表 Humongous，这表示这些 Region 存储的是巨大对象（humongous object，H-obj），即大小 ≥ region 一半的对象。H-obj 有如下几个特征：</p><ul><li>H-obj 直接分配到了 old gen，防止了反复拷贝移动。</li><li>H-obj 在 global concurrent marking 阶段的 cleanup 和 full GC 阶段回收。</li><li>在分配 H-obj 之前先检查是否超过 initiating heap occupancy percent 和 the marking threshold（G1 的相关参数，可通过 VM 参数设定）, 如果超过的话，就启动 global concurrent marking，为的是提早回收，防止 evacuation failures 和 full GC。</li></ul><blockquote><p>为了减少连续 H-objs 分配对 GC 的影响，需要把大对象变为普通的对象，建议增大 Region size。</p></blockquote><p>一个 Region 的大小可以通过参数<code> -XX:G1HeapRegionSize</code> 设定，取值范围从 1M 到 32M，且是2的指数。如果不设定，那么 G1 会根据 Heap 大小自动决定</p><p>每一个分配的 Region，都可以分成两个部分，已分配的和未被分配的。它们之间的界限被称为 top。总体上来说，把一个对象分配到 Region 内，只需要简单增加 top 的值。这个做法实际上就是 bump-the-pointer。过程如下：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175448522.png" alt="image-20231115175448522"></p><p>Region 可以说是 G1 回收器一次回收的最小单元。即每一次回收都是回收 N 个 Region。这个 N 是多少，主要受到 G1 回收的效率和用户设置的<strong>软实时目标</strong><em>（用户可以指定<strong>垃圾回收</strong>时间的限时，G1会努力在这个时限内完成垃圾回收，但是G1并不担保每次都能在这个时限内完成垃圾回收。通过设定一个合理的目标，可以让达到90%以上的垃圾回收时间都在这个时限内。）</em>有关。每一次的回收，G1 会选择可能回收最多垃圾的 Region 进行回收。与此同时，G1 回收器会维护一个空间 Region 的链表。每次回收之后的 Region 都会被加入到这个链表中。</p><h4 id="10-2-2-GC-模式"><a href="#10-2-2-GC-模式" class="headerlink" title="10.2.2. GC 模式"></a>10.2.2. GC 模式</h4><p>G1提供了两种GC模式，<strong>Young GC</strong> 和 <strong>Mixed GC</strong>，两种都是完全 Stop The World 的，下面依次简单介绍：</p><blockquote><p>补充论据：为什么 Young GC 和 Mixed GC 都是 stw 的？</p><p><strong>结论：几乎所有收集器的所有回收策略（Young、Mixed、Full）都会 stw，只是停顿时间不同。</strong></p><ol><li>什么情况&#x2F;操作会 STW<ol><li>以 G1 为例。引用《深入理解 Java 虚拟机》，G1 的运行过程有4个步骤：<ul><li>初始标记：标记 GC Roots 的可达对象以及其他一些指针修改操作。<strong>GC Roots 的对象扫描操作是 stw 的，尽管停顿时间很短。</strong>因为如果与用户线程并行，会存在漏扫、错扫等问题</li><li>并发标记，不 stw</li><li>最终标记：<strong>很显然是 stw 的</strong>，因为是为了修正并发标记时可能发生的漏标错标问题，所以必须暂停用户线程以保证正确性。</li><li>筛选回收：负责更新 Region 的统计数据，制定回收计划。可以自由的选择任意多个 Region 构成回收集，然后把决定回收的那部分 Region 复制到空的 Region 中，再清理掉整个旧 Region 的空间（即标记-复制算法）。<strong>由于操作涉及存活对象的移动，必须 stw。</strong></li></ul></li><li>让我们把粒度再变细一点，在 GC 操作中，以下情况会 stw：<ul><li><strong>根节点枚举</strong>。因为必须 Root scan 必须在一个能保障一致性的快照中才能得以进行，否则无法保证正确性，尽管现在可达性分析算法中的查找引用链过程已经能够做到和用户线程并发。</li><li><strong>存活对象的移动</strong>。常发生在标记-复制、标记-整理算法的对象清理过程中</li></ul></li></ol></li><li>Young GC、Mixed GC、Full GC 过程中发生了什么？<ol><li>GC 无论是发生在哪个区域（哪个 region），基本过程都类似，都需要有<strong>扫描和标记的环节（如枚举根节点）</strong>来找出需要被回收&#x2F;复制的对象，如果涉及标记-整理算法，如 Full GC ，还需要整理内存。<strong>这些环节都需要 stw 来保证正确性。</strong>所以我们说所有种类的 GC 都 stw<strong>，</strong>只是 stw 的时间不同。</li></ol></li><li>验证论据<ol><li><p>提出 G1 的论文：<a href="https://dl.acm.org/doi/abs/10.1145/1029873.1029879">Garbage-first garbage collection | Proceedings of the 4th international symposium on Memory manageme</a></p><ul><li>文中 section 3.4 提到：In <strong>fully-young generational mode</strong>, we maintain a dynamic estimate of the number of young-generation regions that <strong>leads to an evacuation pause</strong> that meets the pause time bound, and initiate a pause whenever this number of young regions is allocated. For steady-state applications, this leads to a natural period between evacuation pauses. Note that we can meet the soft real-time goal only if this period exceeds its time slice. <strong>In partially-young mode</strong>, on the other hand, <strong>we do evacuation pauses</strong> as often as the soft real-time goal allows. Doing pauses at the maximum allowed frequency minimizes the number of young regions collected in those pauses, and therefore maximizes the number of non-young regions that may be added to the collection set.</li><li>具体的论述与 GC 的停顿时间预测有关，此处不展开赘述。但我们可以从作者的论述看出：Young GC 和 Mixed GC 都会有 <strong>evacuation pauses。</strong></li><li>那么什么是 evacuation pause 呢？论文的 section 2.4 给出了定义：At appropriate points (described in section 3.4), <strong>we stop the mutator threads and perform an evacuation pause.</strong></li><li>由此可以感性的认知：G1 的 young GC 和 mixed GC 是会 stw 的。</li></ul></li><li><p>源码：G1 触发 Young GC 后，会执行一个叫 do_collection_pause 的方法，方法签名如下：</p></li><li><pre><code class="C++">HeapWord* G1CollectedHeap::do_collection_pause(size_t word_size,                                               unsigned int gc_count_before,                                               bool* succeeded,                                               GCCause::Cause gc_cause) &#123;  // 记录 gc 停顿  g1_policy()-&gt;record_stop_world_start();  // gc 操作任务类,第三个参数表示本次 gc 是不是老年代并发 gc  VM_G1IncCollectionPause op(gc_count_before,                             word_size,                             false, /* should_initiate_conc_mark */                             g1_policy()-&gt;max_pause_time_ms(),                             gc_cause);  // 真正的停顿方法在 VMThread::execute(&amp;op) 中  VMThread::execute(&amp;op);                                                  HeapWord* result = op.result();  bool ret_succeeded = op.prologue_succeeded() &amp;&amp; op.pause_succeeded();                                                  *succeeded = ret_succeeded;                                                  return result;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. do_collection_pause 会在 VMThread::execute(&amp;op) 里会产生停顿，再来看这个方法：</span><br><span class="line">5. ```C++</span><br><span class="line">   void VMThread::execute(VM_Operation* op) &#123;</span><br><span class="line">     Thread* t = Thread::current();</span><br><span class="line">     // 判断当前线程是否是 vm 线程</span><br><span class="line">     if (!t-&gt;is_VM_thread()) &#123;</span><br><span class="line">       // 跳过这里，其实这里的逻辑是当前不是 vm 线程是 java 线程或者 watcher 线程</span><br><span class="line">       // 会先将任务放到一个 queue 中，之后再执行</span><br><span class="line">       ......</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       // 如果是 vm 线程则会进入这里</span><br><span class="line">       ......</span><br><span class="line">       HandleMark hm(t);</span><br><span class="line">       _cur_vm_operation = op;</span><br><span class="line">       // 判断任务是否需要在安全点执行且当前是否在安全点</span><br><span class="line">       if (op-&gt;evaluate_at_safepoint() &amp;&amp; !SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">         // 如果不是安全点,则等待所有线程进入安全点,然后把线程暂时挂起</span><br><span class="line">         // 这个类中有个状态 _state,所有 java 线程转换线程状态时会去判断这个状态然后</span><br><span class="line">         // 决定是否 block</span><br><span class="line">         SafepointSynchronize::begin();</span><br><span class="line">         // 开始任务, op 是刚刚传入的 VM_G1IncCollectionPause 操作任务类</span><br><span class="line">         // evaluate() 方法最后会调用 gc 操作任务类的 doit() 方法</span><br><span class="line">         op-&gt;evaluate();</span><br><span class="line">         // 安全点结束</span><br><span class="line">         SafepointSynchronize::end();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         // 是安全点则直接执行</span><br><span class="line">         op-&gt;evaluate();</span><br><span class="line">       &#125;</span><br><span class="line">                                                   </span><br><span class="line">       if (op-&gt;is_cheap_allocated()) delete op;</span><br><span class="line">                                                   </span><br><span class="line">       _cur_vm_operation = prev_vm_operation;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>该方法会判断线程是否都进入安全区（安全区概念参考：<a href="https://www.zhihu.com/question/371699670%EF%BC%8C%E8%AF%A5%E9%97%AE%E9%A2%98%E9%AB%98%E8%B5%9E%E5%9B%9E%E7%AD%94%E6%AF%94%E8%BE%83%E5%85%A8%E9%9D%A2%E7%9A%84%E9%98%90%E8%BF%B0%E4%BA%86%E5%AE%89%E5%85%A8%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%8C%BA%E5%8F%97%E7%94%A8%E7%9A%84%EF%BC%89%EF%BC%8C%E5%A6%82%E6%98%AF%EF%BC%8C%E6%89%A7%E8%A1%8C">https://www.zhihu.com/question/371699670，该问题高赞回答比较全面的阐述了安全区的概念，挺受用的），如是，执行</a> op-&gt;evaluate() 以 stw。实际上，<strong>SafepointSynchronize::begin() 方法内包括了准备进入安全点到所有 java 线程 Block 的过程，此时 Young</strong> <strong>GC</strong> <strong>的全局停顿开始了</strong>。因此，Young GC 是 stw 的。</p></li><li><p>Mixed GC 和 Full GC 由于涉及到老年代内存对象的回收，需要根节点枚举、对象复制整理等操作，显然是 stw 的，此处不再从源码角度赘述。</p></li></ol></li></ol><ul><li>Reference：<ul><li><a href="https://dl.acm.org/doi/abs/10.1145/1029873.1029879">Garbage-first garbage collection | Proceedings of the 4th international symposium on Memory manageme</a></li><li>深入理解 Java 虚拟机（第三版）</li><li><a href="https://zhuanlan.zhihu.com/p/114293273">JVM源码分析之G1垃圾收集器分析一</a></li><li><a href="https://zhuanlan.zhihu.com/p/528819545">细节炸裂！阿里大佬深入探究G1源码之YoungGC技术</a></li><li><a href="https://blog.csdn.net/a860MHz/article/details/97799282">JVM G1 源码分析(五)- 新生代回收YGC_g1 新生代_860MHz的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/a860MHz/article/details/98062558">JVM G1 源码分析(六)- 混合式GC_g1 混合gc_860MHz的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/a860MHz/article/details/98494732">JVM G1 源码分析(七)- Full GC_jvm g1 full gc 触发参数_860MHz的博客-CSDN博客CSDN博客</a></li></ul></li></ul></blockquote><ul><li>Young GC：选定所有年轻代里的 Region。通过控制年轻代的 region 个数，即年轻代内存大小，来控制 young GC的时间开销。</li><li>Mixed GC：选定所有年轻代里的 Region，外加根据 global concurrent marking 统计得出收集收益高的若干老年代 Region。在用户指定的开销目标范围内尽可能选择收益高的老年代 Region。</li></ul><p>由上面的描述可知，Mixed GC 不是 full GC，它只能回收部分老年代的 Region，如果 mixed GC 实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行 Mixed GC，就会使用 serial old GC（full GC）来收集整个 GC heap。所以我们可以知道，<strong>G1 是不提供 full GC 的</strong>。</p><p>此外，Young GC 和 Mixed GC 都是基于「标记-复制算法」的</p><p>上文中，多次提到了<strong>「global</strong> <strong>concurrent</strong> <strong>marking」</strong>，它的执行过程类似 CMS，但是不同的是，在 G1 GC 中，它主要是为 Mixed GC 提供标记服务的，并不是一次 GC 过程的一个必须环节。global concurrent marking 的执行过程分为四个步骤：</p><ol><li><strong>初始标记（initial mark，STW）</strong>。它标记了从 GC Root 开始直接可达的对象。</li><li><strong>并发标记（Concurrent Marking）</strong>。这个阶段从 GC Root 开始对 heap 中的对象标记，标记线程与应用程序线程并行执行，并且收集各个 Region 的存活对象信息。 </li><li><strong>重新标记（Remark，STW）</strong>。标记那些在并发标记阶段发生变化的对象，将被回收。</li><li><strong>清除垃圾（Cleanup）</strong>。清除空 Region（没有存活对象的），加入到 free list。</li></ol><p>第一阶段 initial mark 是共用了 Young GC 的暂停，这是因为他们可以复用 root scan 操作，所以可以说 global concurrent marking 是伴随 Young GC 而发生的。第四阶段 Cleanup 只是回收了没有存活对象的 Region，所以它并不需要 STW。</p><p>那什么时候发生 Mixed GC 呢？其实是由一些参数控制着的，另外也控制着哪些老年代 Region 会被选入 Collection Set（<em>Collection Set（CSet），记录了 GC 要收集的 Region 集合，集合里的 Region 可以是任意年代的</em>）。</p><ul><li>G1HeapWastePercent：在 global concurrent marking 结束之后，我们可以知道 old gen regions 中有多少空间要被回收，在每次 YGC 之后和再次发生 Mixed GC 之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生Mixed GC。</li><li>G1MixedGCLiveThresholdPercent：old generation region 中的存活对象的占比，只有在此参数之下，才会被选入CSet。</li><li>G1MixedGCCountTarget：一次 global concurrent marking 之后，最多执行 Mixed GC 的次数。</li><li>G1OldCSetRegionThresholdPercent：一次 Mixed GC 中能被选入 CSet 的最多 old generation region 数量。</li></ul><blockquote><p>由于篇幅限制，这里就只整理了对理解 G1 比较重要的 region 概念以及 GC 模式。其实 G1 还有其它的专有算法以及数据结构，比如停顿预测、Remember Set、SATB 等，感兴趣的读者可以自行搜索。</p></blockquote><h3 id="10-3-ZGC-基于非代际内存的最新回收器"><a href="#10-3-ZGC-基于非代际内存的最新回收器" class="headerlink" title="10.3. ZGC - 基于非代际内存的最新回收器"></a>10.3. ZGC - 基于非代际内存的最新回收器</h3><p>ZGC（The Z Garbage Collector）是 JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：</p><ul><li>停顿时间不超过10ms；</li><li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</li><li>支持 8MB~4TB 级别的堆（未来支持 16TB）</li></ul><h4 id="10-3-1-内存模型"><a href="#10-3-1-内存模型" class="headerlink" title="10.3.1. 内存模型"></a>10.3.1. 内存模型</h4><p>ZGC 与传统的 CMS、G1 不同、它没有分代的概念，只有类似 G1 的 Region 概念，ZGC 的 Region 可以具有如下图所示的大中下三类容量：</p><ul><li>小型 Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。</li><li>中型 Region（Medium Region）：容量固定为32MB，用于放置大于256KB但是小于4MB的对象。</li><li>大型 Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型 Region 中会存放一个大对象，这也预示着虽然名字叫“大型 Region”，但它的实际容量完全有可能小于中型 Region，最小容量可低至4MB。大型 Region 在 ZGC 的实现中是不会被重分配的（重分配是ZGC的一种处理动作，用于复制对象的收集器阶段）因为复制大对象的代价非常高。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175430186.png" alt="image-20231115175430186"></p><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用「标记-复制」算法，不过 ZGC 对该算法做了重大改进：ZGC 在标记、转移和重定位阶段几乎都是并发的，这是 ZGC 实现停顿时间小于10ms目标的最关键原因。</p><p>ZGC 垃圾回收周期如下图所示：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175414710.png" alt="image-20231115175414710"></p><p>ZGC只有三个STW阶段：<strong>初始标记</strong>，<strong>再标记</strong>，<strong>初始转移</strong>。其中，初始标记和初始转移分别都只需要扫描所有 GC Roots，其处理时间和 GC Roots 的数量成正比，一般情况耗时非常短；再标记阶段 STW 时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC 几乎所有暂停都只依赖于 GC Roots 集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与 ZGC 对比，G1 的转移阶段完全 STW 的，且停顿时间随存活对象的大小增加而增加。</p><p>Java 实测打印 ZGC 的内存池结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CodeHeap <span class="string">&#x27;non-nmethods&#x27;</span></span><br><span class="line">Metaspace</span><br><span class="line">ZHeap</span><br><span class="line">CodeHeap <span class="string">&#x27;profiled nmethods&#x27;</span></span><br><span class="line">Compressed Class Space</span><br><span class="line">CodeHeap <span class="string">&#x27;non-profiled nmethods&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="10-3-2-关键技术"><a href="#10-3-2-关键技术" class="headerlink" title="10.3.2. 关键技术"></a>10.3.2. 关键技术</h4><p>ZGC 通过<strong>着色指针</strong>和<strong>读屏障技术</strong>，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着 GC 线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在 ZGC 中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM 是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。</p><p><strong>着色指针</strong></p><blockquote><p>着色指针是一种将信息存储在指针中的技术。</p></blockquote><p>ZGC仅支持64位系统，它把64位虚拟地址空间划分为多个子空间，如下图所示：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175350372.png" alt="image-20231115175350372"></p><p>其中，[0~4TB) 对应Java堆，[4TB ~ 8TB) 称为 M0 地址空间，[8TB ~ 12TB) 称为 M1 地址空间，[12TB ~ 16TB) 预留未使用，[16TB ~ 20TB) 称为 Remapped 空间。</p><p>当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址。ZGC 同时会为该对象在 M0、M1 和 Remapped 地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但<strong>这三个空间在同一时间有且只有一个空间有效</strong>。ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低 GC 停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。后面将详细介绍这三个空间的切换过程。</p><p>与上述地址空间划分相对应，ZGC 实际仅使用64位地址空间的第0<del>41位，而第42</del>45位存储元数据，第47~63位固定为0。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175338597.png" alt="image-20231115175338597"></p><p>ZGC将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。</p><p><strong>读屏障</strong></p><blockquote><p>读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。</p></blockquote><p>读屏障示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> obj.FieldA   <span class="comment">// 从堆中读取引用，需要加入屏障</span></span><br><span class="line">&lt;Load barrier&gt;</span><br><span class="line"><span class="type">Object</span> <span class="variable">p</span> <span class="operator">=</span> o  <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line">o.dosomething() <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br></pre></td></tr></table></figure><p>ZGC 中读屏障的代码作用：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。</p><p>接下来详细介绍ZGC一次垃圾回收周期中地址视图的切换过程：</p><ul><li><strong>初始化</strong>：ZGC初始化之后，整个内存空间的地址视图被设置为 Remapped。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。</li><li><strong>并发标记阶段</strong>：第一次进入标记阶段时视图为 M0，如果对象被 GC 标记线程或者应用线程访问过，那么就将对象的地址视图从 Remapped 调整为 M0。所以，在标记阶段结束之后，对象的地址要么是 M0视图，要么是 Remapped。如果对象的地址是 M0 视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。</li><li><strong>并发转移阶段</strong>：标记结束后就进入转移阶段，此时地址视图再次被设置为 Remapped。如果对象被 GC转移线程或者应用线程访问过，那么就将对象的地址视图从 M0 调整为 Remapped。</li></ul><p>其实，在标记阶段存在两个地址视图 M0 和 M1，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了区别前一次标记和当前标记。也即，第二次进入并发标记阶段后，地址视图调整为 M1，而非M0。</p><p>着色指针和读屏障技术不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中；而在 ZGC 中，只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175323045.png" alt="image-20231115175323045"></p><h3 id="10-4-其他分享"><a href="#10-4-其他分享" class="headerlink" title="10.4. 其他分享"></a>10.4. 其他分享</h3><h4 id="10-4-1-如何调试-GC-的-notification-线程？"><a href="#10-4-1-如何调试-GC-的-notification-线程？" class="headerlink" title="10.4.1. 如何调试 GC 的 notification 线程？"></a>10.4.1. 如何调试 GC 的 notification 线程？</h4><p>JDK 8、11 的 notification 是 Service Thread 在做，这个 Thread 不能被 idea 捕获，无法正常调试；</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175301099.png" alt="image-20231115175301099"></p><p>解决：JDK 17 里 notification 的 handle 由 Notification Thread 负责，可以被 idea 捕获，把 JDK 换成 17 之后就可以切换到 Notification Thread 调试 handleNotification </p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175243105.png" alt="image-20231115175243105"></p><h4 id="10-4-2-GC-使用参数"><a href="#10-4-2-GC-使用参数" class="headerlink" title="10.4.2. GC 使用参数"></a>10.4.2. GC 使用参数</h4><table><thead><tr><th>Collector</th><th>Option</th></tr></thead><tbody><tr><td>指定年轻代为Serial收集器</td><td>-XX:+UseSerialGC</td></tr><tr><td>指定老年代为Serial收集器</td><td>‐XX:+UseSerialOldGC</td></tr><tr><td>指定年轻代为ParNew收集器</td><td>‐XX:+UseParNewGC</td></tr><tr><td>指定年轻代为 Parallel 收集器</td><td>‐XX:+UseParallelGC</td></tr><tr><td>指定老年代为 Parallel 收集器</td><td>‐XX:+UseParallelOldGC</td></tr><tr><td>指定老年代为 CMS 收集器</td><td>‐XX:+UseConcMarkSweepGC</td></tr><tr><td>G1</td><td>‐XX:+UseG1GC</td></tr><tr><td>ZGC</td><td>-XX:+UseZGC</td></tr></tbody></table><p>IDEA 使用：在 VM options 添加即可</p><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175206555.png" alt="image-20231115175206555" style="zoom:60%;" /></div><h4 id="10-4-3-JMX-可以监控-G1-的-mixed-GC-吗？"><a href="#10-4-3-JMX-可以监控-G1-的-mixed-GC-吗？" class="headerlink" title="10.4.3. JMX 可以监控 G1 的 mixed GC 吗？"></a>10.4.3. JMX 可以监控 G1 的 mixed GC 吗？</h4><p>不能。实验过程如下：</p><p><strong>可以看到，对于同一次 GC，JVM自带的 GC log 显示是 mixed GC，但 JMX 显示为 minor GC。</strong></p><ul><li>猜测：由于 mixed GC 在 hotspot 源码中是由 YGC 触发，所以 JMX 为了简化将 YGC 和 mixed GC 统一视为 minor GC。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[GC pause (G1 Evacuation Pause) (mixed), <span class="number">0.0237647</span> secs]</span><br><span class="line">   [Parallel <span class="type">Time</span>: <span class="number">22.2</span> ms, GC Workers: <span class="number">9</span>]</span><br><span class="line">      [GC Worker <span class="keyword">Start</span> (ms): Min: <span class="number">10897.2</span>, Avg: <span class="number">10899.3</span>, Max: <span class="number">10900.4</span>, Diff: <span class="number">3.3</span>]</span><br><span class="line">      [Ext Root Scanning (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.1</span>, Max: <span class="number">0.4</span>, Diff: <span class="number">0.3</span>, Sum: <span class="number">0.7</span>]</span><br><span class="line">      [<span class="keyword">Update</span> RS (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">1.1</span>, Max: <span class="number">4.3</span>, Diff: <span class="number">4.3</span>, Sum: <span class="number">9.8</span>]</span><br><span class="line">         [Processed Buffers: Min: <span class="number">0</span>, Avg: <span class="number">1.6</span>, Max: <span class="number">6</span>, Diff: <span class="number">6</span>, Sum: <span class="number">14</span>]</span><br><span class="line">      [Scan RS (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>, Sum: <span class="number">0.1</span>]</span><br><span class="line">      [Code Root Scanning (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>, Sum: <span class="number">0.0</span>]</span><br><span class="line">      [Object <span class="keyword">Copy</span> (ms): Min: <span class="number">7.4</span>, Avg: <span class="number">8.6</span>, Max: <span class="number">8.8</span>, Diff: <span class="number">1.4</span>, Sum: <span class="number">77.2</span>]</span><br><span class="line">      [Termination (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">1.3</span>, Max: <span class="number">10.3</span>, Diff: <span class="number">10.3</span>, Sum: <span class="number">11.8</span>]</span><br><span class="line">         [Termination Attempts: Min: <span class="number">1</span>, Avg: <span class="number">397.3</span>, Max: <span class="number">588</span>, Diff: <span class="number">587</span>, Sum: <span class="number">3576</span>]</span><br><span class="line">      [GC Worker Other (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>, Sum: <span class="number">0.1</span>]</span><br><span class="line">      [GC Worker Total (ms): Min: <span class="number">8.9</span>, Avg: <span class="number">11.1</span>, Max: <span class="number">19.0</span>, Diff: <span class="number">10.2</span>, Sum: <span class="number">99.7</span>]</span><br><span class="line">      [GC Worker <span class="keyword">End</span> (ms): Min: <span class="number">10909.3</span>, Avg: <span class="number">10910.4</span>, Max: <span class="number">10919.3</span>, Diff: <span class="number">10.0</span>]</span><br><span class="line">   [Code Root Fixup: <span class="number">0.0</span> ms]</span><br><span class="line">   [Code Root Purge: <span class="number">0.0</span> ms]</span><br><span class="line">   [Clear CT: <span class="number">0.1</span> ms]</span><br><span class="line">   [Other: <span class="number">1.5</span> ms]</span><br><span class="line">      [Choose CSet: <span class="number">0.0</span> ms]</span><br><span class="line">      [<span class="keyword">Ref</span> Proc: <span class="number">1.2</span> ms]</span><br><span class="line">      [<span class="keyword">Ref</span> Enq: <span class="number">0.0</span> ms]</span><br><span class="line">      [Redirty Cards: <span class="number">0.1</span> ms]</span><br><span class="line">      [Humongous Register: <span class="number">0.1</span> ms]</span><br><span class="line">      [Humongous Reclaim: <span class="number">0.0</span> ms]</span><br><span class="line">      [<span class="keyword">Free</span> CSet: <span class="number">0.0</span> ms]</span><br><span class="line">   [Eden: <span class="number">46080.0</span>K(<span class="number">46080.0</span>K)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">0.0</span>B(<span class="number">48128.0</span>K) Survivors: <span class="number">7168.0</span>K<span class="operator">-</span><span class="operator">&gt;</span><span class="number">7168.0</span>K Heap: <span class="number">1043.1</span>M(<span class="number">1049.0</span>M)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">1044.6</span>M(<span class="number">1098.0</span>M)]</span><br><span class="line"> [Times: <span class="keyword">user</span><span class="operator">=</span><span class="number">0.05</span> sys<span class="operator">=</span><span class="number">0.01</span>, <span class="type">real</span><span class="operator">=</span><span class="number">0.02</span> secs] </span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.446</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> <span class="keyword">end</span> <span class="keyword">of</span> minor GC</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> minor GC: <span class="operator">-</span> <span class="number">45</span> (G1_Evacuation_Pause) <span class="keyword">start</span>: <span class="number">2023</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">58</span>:<span class="number">54.422</span>, <span class="keyword">end</span>: <span class="number">2023</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">58</span>:<span class="number">54.445</span></span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [G1 <span class="keyword">Old</span> Gen] init:<span class="number">235520</span>K; used:<span class="number">24.1</span><span class="operator">%</span>(<span class="number">1014924</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">25.3</span><span class="operator">%</span>(<span class="number">1062540</span>K); committed: <span class="number">24.2</span><span class="operator">%</span>(<span class="number">1017856</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">25.4</span><span class="operator">%</span>(<span class="number">1065984</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [Code Cache] init:<span class="number">2496</span>K; used:<span class="number">1.9</span><span class="operator">%</span>(<span class="number">2586</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1.9</span><span class="operator">%</span>(<span class="number">2586</span>K); committed: <span class="number">2.0</span><span class="operator">%</span>(<span class="number">2624</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">2.0</span><span class="operator">%</span>(<span class="number">2624</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [G1 Survivor Space] init:<span class="number">0</span>K; used:<span class="number">7168</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">7168</span>K); committed: <span class="number">7168</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">7168</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [Compressed Class Space] init:<span class="number">0</span>K; used:<span class="number">0.0</span><span class="operator">%</span>(<span class="number">777</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0.0</span><span class="operator">%</span>(<span class="number">777</span>K); committed: <span class="number">0.0</span><span class="operator">%</span>(<span class="number">896</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0.0</span><span class="operator">%</span>(<span class="number">896</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [Metaspace] init:<span class="number">0</span>K; used:<span class="number">6965</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">6965</span>K); committed: <span class="number">7296</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">7296</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [G1 Eden Space] init:<span class="number">26624</span>K; used:<span class="number">46080</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span>K); committed: <span class="number">49152</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">51200</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> duration:<span class="number">23</span>ms, throughput:<span class="number">96.4</span><span class="operator">%</span></span><br></pre></td></tr></table></figure><p><strong>测试参数：</strong></p><p>这里有一个 trick：由于 G1 的特点，我们希望能平缓的增加内存，使得 G1 「来得及」进行垃圾回收，触发 mixed GC，而不是触发 full GC。因此需要对 JVM 进行调参，同时测试代码中需要延缓内存消耗速度。</p><blockquote><p>-XX:+PrintGCDetails -XX:+UseG1GC -XX:InitiatingHeapOccupancyPercent&#x3D;20 &#x2F;&#x2F; 默认值为 40，是触发 mixed GC 的堆内存占用 threshold，这里调低一点，防止 full GC -XX:G1HeapWastePercent&#x3D;5 &#x2F;&#x2F; 当整个堆可回收的百分比小于该阈值时，Java HotSpot VM不会启动Mixed GC。默认值为10％。这里同理，调低一点防止 full GC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">          <span class="comment">// manually add heap usage</span></span><br><span class="line">          List&lt;<span class="type">byte</span>[]&gt; byteList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">          <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">10000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 为了尽量少的触发 Full GC 而触发 mixed GC，需要减缓内存消耗速度</span></span><br><span class="line">                Thread.sleep(TimeUnit.MILLISECONDS.toMillis(<span class="number">100</span>));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            byteList.add(bytes);</span><br><span class="line">            i++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    .start();</span><br></pre></td></tr></table></figure></blockquote><h4 id="10-4-4-Duration-的计算准确性"><a href="#10-4-4-Duration-的计算准确性" class="headerlink" title="10.4.4. Duration 的计算准确性"></a>10.4.4. Duration 的计算准确性</h4><p>这里贴一个详细的例子来说明：涉及并发 GC 时，JMX notification 提供的 duration 比实际 duration 大。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175146661.png" alt="image-20231115175146661"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[GC pause (G1 Evacuation Pause) (mixed), <span class="number">0.0162640</span> secs]</span><br><span class="line">   [Parallel <span class="type">Time</span>: <span class="number">15.6</span> ms, GC Workers: <span class="number">9</span>]</span><br><span class="line">      [GC Worker <span class="keyword">Start</span> (ms): Min: <span class="number">9212.1</span>, Avg: <span class="number">9214.5</span>, Max: <span class="number">9215.2</span>, Diff: <span class="number">3.1</span>]</span><br><span class="line">      [Ext Root Scanning (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.1</span>, Max: <span class="number">0.6</span>, Diff: <span class="number">0.6</span>, Sum: <span class="number">0.6</span>]</span><br><span class="line">      [<span class="keyword">Update</span> RS (ms): Min: <span class="number">0.9</span>, Avg: <span class="number">2.0</span>, Max: <span class="number">3.2</span>, Diff: <span class="number">2.2</span>, Sum: <span class="number">18.0</span>]</span><br><span class="line">         [Processed Buffers: Min: <span class="number">1</span>, Avg: <span class="number">2.1</span>, Max: <span class="number">4</span>, Diff: <span class="number">3</span>, Sum: <span class="number">19</span>]</span><br><span class="line">      [Scan RS (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.1</span>, Max: <span class="number">0.3</span>, Diff: <span class="number">0.3</span>, Sum: <span class="number">1.1</span>]</span><br><span class="line">      [Code Root Scanning (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>, Sum: <span class="number">0.0</span>]</span><br><span class="line">      [Object <span class="keyword">Copy</span> (ms): Min: <span class="number">9.3</span>, Avg: <span class="number">10.2</span>, Max: <span class="number">10.7</span>, Diff: <span class="number">1.4</span>, Sum: <span class="number">92.0</span>]</span><br><span class="line">      [Termination (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.4</span>, Max: <span class="number">0.5</span>, Diff: <span class="number">0.5</span>, Sum: <span class="number">3.3</span>]</span><br><span class="line">         [Termination Attempts: Min: <span class="number">1</span>, Avg: <span class="number">449.8</span>, Max: <span class="number">606</span>, Diff: <span class="number">605</span>, Sum: <span class="number">4048</span>]</span><br><span class="line">      [GC Worker Other (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.1</span>, Diff: <span class="number">0.1</span>, Sum: <span class="number">0.4</span>]</span><br><span class="line">      [GC Worker Total (ms): Min: <span class="number">12.2</span>, Avg: <span class="number">12.8</span>, Max: <span class="number">15.2</span>, Diff: <span class="number">3.1</span>, Sum: <span class="number">115.4</span>]</span><br><span class="line">      [GC Worker <span class="keyword">End</span> (ms): Min: <span class="number">9227.3</span>, Avg: <span class="number">9227.3</span>, Max: <span class="number">9227.4</span>, Diff: <span class="number">0.1</span>]</span><br><span class="line">   [Code Root Fixup: <span class="number">0.0</span> ms]</span><br><span class="line">   [Code Root Purge: <span class="number">0.0</span> ms]</span><br><span class="line">   [Clear CT: <span class="number">0.1</span> ms]</span><br><span class="line">   [Other: <span class="number">0.5</span> ms]</span><br><span class="line">      [Choose CSet: <span class="number">0.0</span> ms]</span><br><span class="line">      [<span class="keyword">Ref</span> Proc: <span class="number">0.2</span> ms]</span><br><span class="line">      [<span class="keyword">Ref</span> Enq: <span class="number">0.0</span> ms]</span><br><span class="line">      [Redirty Cards: <span class="number">0.1</span> ms]</span><br><span class="line">      [Humongous Register: <span class="number">0.1</span> ms]</span><br><span class="line">      [Humongous Reclaim: <span class="number">0.0</span> ms]</span><br><span class="line">      [<span class="keyword">Free</span> CSet: <span class="number">0.0</span> ms]</span><br><span class="line">   [Eden: <span class="number">38912.0</span>K(<span class="number">38912.0</span>K)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">0.0</span>B(<span class="number">40960.0</span>K) Survivors: <span class="number">6144.0</span>K<span class="operator">-</span><span class="operator">&gt;</span><span class="number">6144.0</span>K Heap: <span class="number">880.2</span>M(<span class="number">886.0</span>M)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">882.2</span>M(<span class="number">928.0</span>M)]</span><br><span class="line"> [Times: <span class="keyword">user</span><span class="operator">=</span><span class="number">0.08</span> sys<span class="operator">=</span><span class="number">0.02</span>, <span class="type">real</span><span class="operator">=</span><span class="number">0.02</span> secs] </span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">58.092</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> <span class="keyword">end</span> <span class="keyword">of</span> minor GC</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">58.092</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> minor GC: <span class="operator">-</span> <span class="number">41</span> (G1_Evacuation_Pause) <span class="keyword">start</span>: <span class="number">2023</span><span class="number">-07</span><span class="number">-26</span> <span class="number">10</span>:<span class="number">48</span>:<span class="number">58.074</span>, <span class="keyword">end</span>: <span class="number">2023</span><span class="number">-07</span><span class="number">-26</span> <span class="number">10</span>:<span class="number">48</span>:<span class="number">58.091</span></span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">58.092</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> duration:<span class="number">17</span>ms, throughput:<span class="number">96.4</span><span class="operator">%</span></span><br></pre></td></tr></table></figure><p>可以看到：这里发生了 mixed GC，有部分 old genertaion 内存被回收。由于 old generation 的回收有一部分 phase 和用户线程并发，这里 JMX notification 提供的 duration 17ms 大于实际的 duration（GC log 打印）16.2ms。</p><blockquote><p>实测这里的误差比较小，在 Millisecond 的粒度，很多时候看不出来误差。然而误差仍然是存在的。</p></blockquote><p>当涉及并发 GC（某些阶段可以和用户线程并发执行，如 G1 old generation）的 duration 时，JMX notification 提供的 duration 实际上比准确的 duration 要大。因此此时需要换一种计算方式：主动向 gcBean 获取总回收时间，通过作差算出现在所需的运算时间。</p><h5 id="10-4-4-1-源码说明"><a href="#10-4-4-1-源码说明" class="headerlink" title="10.4.4.1. 源码说明"></a>10.4.4.1. 源码说明</h5><p><strong>结论</strong>：</p><ul><li>JMX 提供了两种得到 GC duration 的 api，一种是 notification 的 gcInfo，一种是向 GarbageCollectorMXBean 拉取累计 GC 时间，作差算出 duration。前者在涉及并发 GC 的时候 duration 有点不准确。</li><li>GarbageCollectorMXBean 的 getCollectionTime() 方法计算的是 GC pause 的时间，如果 GC 包含与用户线程并发的部分，不会被计算入 getCollectionTime() 中。因此这种方法算出来的 GC duration 是准确的 stw 时间。</li></ul><p>接下来看看为什么 GarbageCollectorMXBean 的 getCollectionTime() 方法获取的是准确的 stw 时间。</p><p>首先来看看 java 上该方法的签名：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175127154.png" alt="image-20231115175127154"></p><p>深入 getCollectionTime()，发现是 native 方法</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175112530.png" alt="image-20231115175112530"></p><p>查看 openjdk 源码，native 方法签名如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jlong JNICALL <span class="title">Java_sun_management_GarbageCollectorImpl_getCollectionTime</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *env, jobject mgr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jmm_interface-&gt;<span class="built_in">GetLongAttribute</span>(env, mgr, JMM_GC_TIME_MS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是返回 JMM_GC_TIME_MS 变量，继续追踪，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">get_gc_attribute</span><span class="params">(GCMemoryManager* mgr, jmmLongAttribute att)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (att) &#123;</span><br><span class="line">  <span class="keyword">case</span> JMM_GC_TIME_MS:</span><br><span class="line">    <span class="keyword">return</span> mgr-&gt;<span class="built_in">gc_time_ms</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> JMM_GC_COUNT:</span><br><span class="line">    <span class="keyword">return</span> mgr-&gt;<span class="built_in">gc_count</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> JMM_GC_EXT_ATTRIBUTE_INFO_SIZE:</span><br><span class="line">    <span class="comment">// current implementation only has 1 ext attribute</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">0</span>, <span class="string">&quot;Unrecognized GC attribute&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该变量通过 mgr-&gt;gc_time_ms() 获取，mgr 是 GCMemoryManager，这个类的签名如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GCMemoryManager</span> : <span class="keyword">public</span> MemoryManager &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> We should unify the GCCounter and GCMemoryManager statistic</span></span><br><span class="line">  <span class="type">size_t</span>       _num_collections;</span><br><span class="line">  elapsedTimer _accumulated_timer;</span><br><span class="line">  GCStatInfo*  _last_gc_stat;</span><br><span class="line">  Mutex*       _last_gc_lock;</span><br><span class="line">  GCStatInfo*  _current_gc_stat;</span><br><span class="line">  <span class="type">int</span>          _num_gc_threads;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">bool</span> _notification_enabled;</span><br><span class="line">  <span class="type">bool</span>         _pool_always_affected_by_gc[MemoryManager::max_num_pools];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">GCMemoryManager</span>(<span class="type">const</span> <span class="type">char</span>* name);</span><br><span class="line">  ~<span class="built_in">GCMemoryManager</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_pool</span><span class="params">(MemoryPool* pool)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_pool</span><span class="params">(MemoryPool* pool, <span class="type">bool</span> always_affected_by_gc)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">pool_always_affected_by_gc</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">num_memory_pools</span>(), <span class="string">&quot;Invalid index&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> _pool_always_affected_by_gc[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span>   <span class="title">initialize_gc_stat_info</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span>   <span class="title">is_gc_memory_manager</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="function">jlong  <span class="title">gc_time_ms</span><span class="params">()</span>                   </span>&#123; <span class="keyword">return</span> _accumulated_timer.<span class="built_in">milliseconds</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">gc_count</span><span class="params">()</span>                     </span>&#123; <span class="keyword">return</span> _num_collections; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span>    <span class="title">num_gc_threads</span><span class="params">()</span>               </span>&#123; <span class="keyword">return</span> _num_gc_threads; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span>   <span class="title">set_num_gc_threads</span><span class="params">(<span class="type">int</span> count)</span>  </span>&#123; _num_gc_threads = count; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span>   <span class="title">gc_begin</span><span class="params">(<span class="type">bool</span> recordGCBeginTime, <span class="type">bool</span> recordPreGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">bool</span> recordAccumulatedGCTime)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span>   <span class="title">gc_end</span><span class="params">(<span class="type">bool</span> recordPostGCUsage, <span class="type">bool</span> recordAccumulatedGCTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">bool</span> recordGCEndTime, <span class="type">bool</span> countCollection, GCCause::Cause cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">bool</span> allMemoryPoolsAffected, <span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span>        <span class="title">reset_gc_stat</span><span class="params">()</span>   </span>&#123; _num_collections = <span class="number">0</span>; _accumulated_timer.<span class="built_in">reset</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy out _last_gc_stat to the given destination, returning</span></span><br><span class="line">  <span class="comment">// the collection count. Zero signifies no gc has taken place.</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">get_last_gc_stat</span><span class="params">(GCStatInfo* dest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_notification_enabled</span><span class="params">(<span class="type">bool</span> enabled)</span> </span>&#123; _notification_enabled = enabled; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_notification_enabled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _notification_enabled; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现，最终 gc_time 是 _accumulated_timer 来记录的。这个 timer 是通过记录 start 和 end 时间，将 end 和 start 时间作差进行计时的。</p><p>那 start 和 end 时间是在哪里记录的呢？继续跟进发现在 gc_begin() 和 gc_end() 方法里。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GCMemoryManager::gc_begin</span><span class="params">(<span class="type">bool</span> recordGCBeginTime, <span class="type">bool</span> recordPreGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">bool</span> recordAccumulatedGCTime)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(_last_gc_stat != <span class="literal">nullptr</span> &amp;&amp; _current_gc_stat != <span class="literal">nullptr</span>, <span class="string">&quot;Just checking&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (recordAccumulatedGCTime) &#123;</span><br><span class="line">    _accumulated_timer.<span class="built_in">start</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// _num_collections now increases in gc_end, to count completed collections</span></span><br><span class="line">  <span class="keyword">if</span> (recordGCBeginTime) &#123;</span><br><span class="line">    _current_gc_stat-&gt;<span class="built_in">set_index</span>(_num_collections+<span class="number">1</span>);</span><br><span class="line">    _current_gc_stat-&gt;<span class="built_in">set_start_time</span>(Management::<span class="built_in">timestamp</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GCMemoryManager::gc_end</span><span class="params">(<span class="type">bool</span> recordPostGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> recordAccumulatedGCTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> recordGCEndTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> countCollection,</span></span></span><br><span class="line"><span class="params"><span class="function">                             GCCause::Cause cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> allMemoryPoolsAffected,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> <span class="type">char</span>* message)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (recordAccumulatedGCTime) &#123;</span><br><span class="line">    _accumulated_timer.<span class="built_in">stop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (recordGCEndTime) &#123;</span><br><span class="line">    _current_gc_stat-&gt;<span class="built_in">set_end_time</span>(Management::<span class="built_in">timestamp</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 gc_begin() 和 gc_end() 方法是何时调用呢？继续跟进，省去一些中间 wrapper，最终可以发现是在 TraceMemoryManagerStats 这个类里调用。该类签名如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TraceMemoryManagerStats::<span class="built_in">TraceMemoryManagerStats</span>(GCMemoryManager* gc_memory_manager,</span><br><span class="line">                                                 GCCause::Cause cause,</span><br><span class="line">                                                 <span class="type">const</span> <span class="type">char</span>* end_message,</span><br><span class="line">                                                 <span class="type">bool</span> allMemoryPoolsAffected,</span><br><span class="line">                                                 <span class="type">bool</span> recordGCBeginTime,</span><br><span class="line">                                                 <span class="type">bool</span> recordPreGCUsage,</span><br><span class="line">                                                 <span class="type">bool</span> recordPeakUsage,</span><br><span class="line">                                                 <span class="type">bool</span> recordPostGCUsage,</span><br><span class="line">                                                 <span class="type">bool</span> recordAccumulatedGCTime,</span><br><span class="line">                                                 <span class="type">bool</span> recordGCEndTime,</span><br><span class="line">                                                 <span class="type">bool</span> countCollection) &#123;</span><br><span class="line">  <span class="built_in">initialize</span>(gc_memory_manager, cause, end_message,</span><br><span class="line">             allMemoryPoolsAffected, recordGCBeginTime, recordPreGCUsage,</span><br><span class="line">             recordPeakUsage, recordPostGCUsage, recordAccumulatedGCTime,</span><br><span class="line">             recordGCEndTime, countCollection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for a subclass to create then initialize an instance before invoking</span></span><br><span class="line"><span class="comment">// the MemoryService</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraceMemoryManagerStats::initialize</span><span class="params">(GCMemoryManager* gc_memory_manager,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         GCCause::Cause cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> <span class="type">char</span>* end_message,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> allMemoryPoolsAffected,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordGCBeginTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordPreGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordPeakUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordPostGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordAccumulatedGCTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordGCEndTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> countCollection)</span> </span>&#123;</span><br><span class="line">  _gc_memory_manager = gc_memory_manager;</span><br><span class="line">  _cause = cause;</span><br><span class="line">  _end_message = end_message;</span><br><span class="line">  _allMemoryPoolsAffected = allMemoryPoolsAffected;</span><br><span class="line">  _recordGCBeginTime = recordGCBeginTime;</span><br><span class="line">  _recordPreGCUsage = recordPreGCUsage;</span><br><span class="line">  _recordPeakUsage = recordPeakUsage;</span><br><span class="line">  _recordPostGCUsage = recordPostGCUsage;</span><br><span class="line">  _recordAccumulatedGCTime = recordAccumulatedGCTime;</span><br><span class="line">  _recordGCEndTime = recordGCEndTime;</span><br><span class="line">  _countCollection = countCollection;</span><br><span class="line"></span><br><span class="line">  MemoryService::<span class="built_in">gc_begin</span>(_gc_memory_manager, _recordGCBeginTime, _recordAccumulatedGCTime,</span><br><span class="line">                          _recordPreGCUsage, _recordPeakUsage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TraceMemoryManagerStats::~<span class="built_in">TraceMemoryManagerStats</span>() &#123;</span><br><span class="line">  MemoryService::<span class="built_in">gc_end</span>(_gc_memory_manager, _recordPostGCUsage, _recordAccumulatedGCTime,</span><br><span class="line">                        _recordGCEndTime, _countCollection, _cause, _allMemoryPoolsAffected,</span><br><span class="line">                        _end_message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重点来了</strong>：TraceMemoryManagerStats 在初始化时调用 gc_begin() 来记录开始时间，在析构时调用 gc_end() 记录结束时间。也就是说，TraceMemoryManagerStats 的生命周期长度等于记录的 <strong>GC 时间。在 JVM 中，在需要记录 GC duration 的地方声明一个 TraceMemoryManagerStats 对象就可以达到记录时间的目的，如果某些 GC phases，如 G1 的并发标记阶段，不需要记录 GC duration，那么就不会声明 TraceMemoryManagerStats 对象。</strong></p><p>接下来追踪该对象在哪里被声明，哪里被析构。继续跟进，发现对于 G1，G1MonitoringScape 类 wrap 了 TraceMemoryManagerStats 对象：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Scope object for java.lang.management support.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">G1MonitoringScope</span> : <span class="keyword">public</span> StackObj &#123;</span><br><span class="line">  G1MonitoringSupport* _monitoring_support;</span><br><span class="line">  TraceCollectorStats _tcs;</span><br><span class="line">  TraceMemoryManagerStats _tms;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">G1MonitoringScope</span>(G1MonitoringSupport* monitoring_support,</span><br><span class="line">                    CollectorCounters* collection_counters,</span><br><span class="line">                    GCMemoryManager* gc_memory_manager,</span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span>* end_message,</span><br><span class="line">                    <span class="type">bool</span> all_memory_pools_affected = <span class="literal">true</span>);</span><br><span class="line">  ~<span class="built_in">G1MonitoringScope</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继续跟进，发现 G1 有三个类记录了 G1MonitoringScope 对象。换句话来说，只要声明了这三个类，就等于声明了 TraceMemoryManagerStats 对象，而后者会随着初始化和析构记录 gc 时间。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">G1YoungGCMonitoringScope::<span class="built_in">G1YoungGCMonitoringScope</span>(G1MonitoringSupport* monitoring_support,</span><br><span class="line">                                                   <span class="type">bool</span> all_memory_pools_affected) :</span><br><span class="line">  <span class="built_in">G1MonitoringScope</span>(monitoring_support,</span><br><span class="line">                    monitoring_support-&gt;_young_collection_counters,</span><br><span class="line">                    &amp;monitoring_support-&gt;_young_gc_memory_manager,</span><br><span class="line">                    <span class="string">&quot;end of minor GC&quot;</span>,</span><br><span class="line">                    all_memory_pools_affected) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">G1FullGCMonitoringScope::<span class="built_in">G1FullGCMonitoringScope</span>(G1MonitoringSupport* monitoring_support) :</span><br><span class="line">  <span class="built_in">G1MonitoringScope</span>(monitoring_support,</span><br><span class="line">                    monitoring_support-&gt;_full_collection_counters,</span><br><span class="line">                    &amp;monitoring_support-&gt;_full_gc_memory_manager,</span><br><span class="line">                    <span class="string">&quot;end of major GC&quot;</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">G1ConcGCMonitoringScope::<span class="built_in">G1ConcGCMonitoringScope</span>(G1MonitoringSupport* monitoring_support) :</span><br><span class="line">  <span class="built_in">G1MonitoringScope</span>(monitoring_support,</span><br><span class="line">                    monitoring_support-&gt;_conc_collection_counters,</span><br><span class="line">                    &amp;monitoring_support-&gt;_conc_gc_memory_manager,</span><br><span class="line">                    <span class="string">&quot;end of concurrent GC pause&quot;</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们重点关注一下 G1ConcGCMonitoringScope，顾名思义，该类主要用于 concurrent G1。继续跟进，发现<strong>只有</strong>在 VM_G1PauseConcurrent::doit() 该类被声明。也就是说，对于 concurrent G1，JVM 只统计了 VM_G1PauseConcurrent::doit() 的耗时。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VM_G1PauseConcurrent::doit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">GCIdMark <span class="title">gc_id_mark</span><span class="params">(_gc_id)</span></span>;</span><br><span class="line">  G1CollectedHeap* g1h = G1CollectedHeap::<span class="built_in">heap</span>();</span><br><span class="line">  <span class="function">GCTraceCPUTime <span class="title">tcpu</span><span class="params">(g1h-&gt;concurrent_mark()-&gt;gc_tracer_cm())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GCTraceTime(...) only supports sub-phases, so a more verbose version</span></span><br><span class="line">  <span class="comment">// is needed when we report the top-level pause phase.</span></span><br><span class="line">  <span class="built_in">GCTraceTimeLogger</span>(Info, gc) <span class="built_in">logger</span>(_message, GCCause::_no_gc, <span class="literal">true</span>);</span><br><span class="line">  <span class="function">GCTraceTimePauseTimer       <span class="title">timer</span><span class="params">(_message, g1h-&gt;concurrent_mark()-&gt;gc_timer_cm())</span></span>;</span><br><span class="line">  <span class="function">GCTraceTimeDriver           <span class="title">t</span><span class="params">(&amp;logger, &amp;timer)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">G1ConcGCMonitoringScope <span class="title">monitoring_scope</span><span class="params">(g1h-&gt;monitoring_support())</span></span>;</span><br><span class="line">  <span class="function">SvcGCMarker <span class="title">sgcm</span><span class="params">(SvcGCMarker::CONCURRENT)</span></span>;</span><br><span class="line">  IsGCActiveMark x;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">work</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下 VM_G1PauseConcurrent::doit() 干了什么。doit() 是 VM_G1PauseConcurrent 的入口方法，而 VM_G1PauseConcurrent 是 concurrent G1 stw 的 operations。这点源码也通过注释解释的很清楚了。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175033983-20231115175047189.png"></p><p>综上，可以看出：JMX 对于 getCollectionTime() 方法只记录了 concurrent G1 的 stw 部分的耗时，因此 getCollectionTime() 的统计耗时是 accumulated stw GC time，更为精确。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《深入理解Java虚拟机（第3版）》 周志明 </p><p><a href="https://openjdk.java.net/projects/jdk/15/">https://openjdk.java.net/projects/jdk/15/</a></p><p><a href="https://aijishu.com/a/1060000000083459">https://aijishu.com/a/1060000000083459</a></p><p><a href="https://www.jianshu.com/p/aef0f4765098">https://www.jianshu.com/p/aef0f4765098</a></p><p><a href="https://blog.csdn.net/lbh_paopao/article/details/120269135">https://blog.csdn.net/lbh_paopao/article/details/120269135</a></p><p><a href="https://zhuanlan.zhihu.com/p/546651403">https://zhuanlan.zhihu.com/p/546651403</a></p><p><a href="https://zhuanlan.zhihu.com/p/431406707">https://zhuanlan.zhihu.com/p/431406707</a></p><p><a href="https://juejin.cn/post/6844903970142421005">https://juejin.cn/post/6844903970142421005</a></p><p><a href="https://stackoverflow.com/questions/19154607/how-actually-card-table-and-writer-barrier-work">https://stackoverflow.com/questions/19154607/how-actually-card-table-and-writer-barrier-work</a></p><p><a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">https://tech.meituan.com/2020/11/12/java-9-cms-gc.html</a></p><p><a href="https://tech.meituan.com/2016/09/23/g1.html">https://tech.meituan.com/2016/09/23/g1.html</a></p><p><a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">https://tech.meituan.com/2020/11/12/java-9-cms-gc.html</a></p><p><a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html</a></p><p><a href="https://blog.csdn.net/wisgood/article/details/79850093">https://blog.csdn.net/wisgood/article/details/79850093</a></p><p><a href="https://juejin.cn/post/7095643412082196511#heading-7">https://juejin.cn/post/7095643412082196511#heading-7</a></p><p><a href="https://blog.csdn.net/weixin_42596455/article/details/81228611">https://blog.csdn.net/weixin_42596455/article/details/81228611</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-Zero-Change Object Transmission (ZCOT)</title>
      <link href="/article/Zero-Change/"/>
      <url>/article/Zero-Change/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.usenix.org/system/files/atc22-wu.pdf">Zero-Change Object Transmission for Distributed Big Data Analytics</a></p><p>本文主要提出了一种零改变（Zero-Change）的跨 JVM 分布式数据传输方法，提高数据交换性能。</p><h1 id="1-Abstract"><a href="#1-Abstract" class="headerlink" title="1. Abstract"></a>1. Abstract</h1><p>分布式大数据分析严重依赖于Java和Scala等高级语言的可靠性和多功能性。</p><p>然而，这些高级语言也为数据交换制造了障碍。要跨托管运行时(如Java虚拟机(jvm))传输数据，对象应该由发送方(序列化)转换为字节数组，并由接收方(反序列化)转换回对象。对象序列化和反序列化(OSD)阶段引入了相当大的性能开销。先前的工作主要集中在OSD的某些阶段的优化，因此对象转换仍然是不可避免的。此外，<strong>它们需要额外的编程工作来与现有的应用程序集成</strong>，并且它们的转换还会导致重复的对象传输。这项工作提出了零改变对象传输(Zero-Change Object Transmission, ZCOT)，其中对象直接在jvm之间复制而不需要任何转换。ZCOT可以在现有的应用程序中使用，而且它基于对象的传输可以用于重复数据删除。对最先进的数据分析框架的评估表明，ZCOT可以大大提高数据交换的性能，从而使应用程序性能提高23.6%。</p><h1 id="2-Introduction"><a href="#2-Introduction" class="headerlink" title="2. Introduction"></a>2. Introduction</h1><p>像Java和Scala这样的高级语言在大数据分析等领域受到欢迎，这要归功于它们可靠且通用的托管运行时环境。然而，托管运行时提供的抽象也会带来性能开销，特别是对于数据交换。由于像Java虚拟机(jvm)这样的托管运行时以不透明的基于对象的格式存储数据，因此它们必须在交换之前将对象转换为可解释的二进制流。</p><p>转换包含两个阶段:序列化阶段将对象转换为字节数组，反序列化阶段将字节数组转换回对象。<strong>对象序列化&#x2F;反序列化(OSD)机制引入了相当大的转换开销，并已成为分布式对象传输的重要性能瓶颈</strong>，特别是对于需要通过网络进行大规模数据交换的应用程序</p><p><strong>先前的工作</strong>已经认识到OSD的性能问题，并提出了不同的方法，包括软件[26,38,39]和硬件[16,32,40,46]，以减轻其影响。</p><p>然而，这些方法主要集中在OSD的特定阶段的优化，<strong>数据转换仍然是不可避免的。</strong>此外，尽管它们可以提高OSD的性能，<strong>但它们中的许多都需要额外的编程工作来注释序列化点或更改原始的jvm间通信模型</strong>。last but not least，<strong>它们将传输的数据视为单个字节数组而不是单个对象，这使得难以识别重复传输并错过优化机会</strong>。</p><p>这项工作的目的不是优化OSD，而是直接消除整个OSD过程。为此，这项工作提出了零改变对象传输(Zero-Change Object Transmission, ZCOT)，它提供了一种理想的数据交换机制，通过直接对象复制在jvm之间传输对象。（provides an ideal data exchange mechanism where objects are transferred among JVMs through <strong>direct object copying</strong>.）当JVM从其他对象接收对象时，它可以直接处理它们而不需要任何修改(Zero-Change)。ZCOT消除了对对象转换的需求，从而提高了数据交换的性能。</p><p>挑战难点及解决方案概述：</p><ul><li>每个JVM都以特定于进程的不透明格式管理对象（each JVM manages objects in a process-specific and opaque format.）<ul><li>ZCOT首先引入了一个名为<strong>交换空间（exchange space）</strong>的全局共享抽象，交换空间是分布式环境中多个jvm可访问的Java堆空间的一部分。ZCOT进一步采用了**分布式类数据共享(DCDS)**机制，该机制提供了统一的对象格式，使交换空间中的对象对所有jvm都是可解释的。</li></ul></li><li>与传统的基于osd的应用程序保持兼容<ul><li>ZCOT提出了一种两级传输机制（two-level transmission mechanism），以弥合基于对象的复制和传统的基于字节的传输之间的差距</li></ul></li><li>相应的，由于提出了全局共享空间，ZCOT 还引入了元数据服务器，此时需要减少元数据服务器和 jvm 之间的流量<ul><li>ZCOT引入了全局共享交换空间，它负责管理多个jvm之间共享的对象。通过引入元数据服务器（metadata server），ZCOT可以<strong>memorizes 对象的存储位置</strong>，并帮助构建jvm之间的数据传输通道（data transmission channels）。由于大数据分析中的对象通常作为一个完整的数据集进行交换，ZCOT支持基于组的对象管理（group-based object management），它将对象分组组织，<strong>并大大减少元数据服务器和jvm之间的流量</strong>。<strong>此外，ZCOT还集成了在单个jvm中触发的垃圾收集(GC)，并减少了GC暂停时间。</strong></li></ul></li></ul><p>ZCOT在传输过程中发送对象而不是字节数组，这使得它具有对象意识（object-conscious），并且更容易识别重复的对象。因此，本文提出了一种重复数据删除机制，进一步优化数据传输。</p><ul><li>ZCOT中的重复数据删除模块利用交换空间抽象来记忆已经发送的对象，避免以后传输不必要的对象。然而，重复数据删除可能会在不同的数据集之间引入引用(或依赖关系)。<ul><li>为此，ZCOT扩展了其分布式内存管理模块，以考虑组间依赖关系。</li></ul></li></ul><h2 id="2-1-contribution"><a href="#2-1-contribution" class="headerlink" title="2.1 contribution"></a>2.1 contribution</h2><ul><li>一个名为交换空间的分布式共享抽象，支持jvm之间的零更改对象传输，同时保持与传统的基于osd的应用程序的兼容性。</li><li>一种在全局共享空间上的内存管理机制，同时与各 JVM 的 GC 集成</li><li>A data deduplication module，识别和删除不必要的数据传输来提升性能</li><li>在通信密集型工作负载上的实验表明ZCOT比现有OSD库的性能有所提高。</li></ul><h1 id="3-Background"><a href="#3-Background" class="headerlink" title="3. Background"></a>3. Background</h1><h2 id="3-1-OSD"><a href="#3-1-OSD" class="headerlink" title="3.1 OSD"></a>3.1 OSD</h2><p>语言运行时为独立于平台的代码执行提供了高级抽象。至于用户对象，运行时以不透明的格式存储它们，这种格式将对象数据与相应的元数据(类型信息、同步、内存管理等)一起维护。以Java为例，jvm为每个对象维护一个头来存储其元数据</p><p>但是，当需要在jvm之间进行数据交换时，对象必须超出运行时范围。例如，对象可能被持久化到磁盘中，以后由其他jvm重用;它们也可以通过网络发送和接收。</p><p>为了支持这些场景，即使在离开jvm时，对象也必须是可解释的。因此，jvm采用对象序列化&#x2F;反序列化(OSD)机制，该机制将Java对象转换为通用数据格式(序列化)，并在jvm中重用时转换回来(反序列化)。Java系统库(JSL)已经为应用程序提供了内置的OSD库。图1显示了JSL OSD的工作流程。<strong>至于序列化部分，对象被转换成一个字节数组，该数组遵循jvm之间一致同意的数据格式。</strong>字节数组将被写入磁盘或通过网络发送。<strong>当另一个JVM接收到字节数组时，它通过反序列化将字节数组转换回对象。</strong></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116164004529.png" alt="image-20231116164004529"></p><p>OSD机制有两个主要优点。首先，该库提供了一种通用的数据格式，这样就可以在不同版本和配置的jvm之间转换Java对象。其次，序列化的数据被压缩，并且在磁盘和网络中产生更小的占用。</p><h2 id="3-2-Limitations-and-opportunities"><a href="#3-2-Limitations-and-opportunities" class="headerlink" title="3.2 Limitations and opportunities"></a>3.2 Limitations and opportunities</h2><p>主要缺点是性能损失</p><ul><li>Transformation overhead：OSD为对象持久化和传输引入了额外的阶段。为了序列化一个对象，OSD应该遍历所有可访问的对象并存储它们的类型信息。对于反序列化，OSD需要扫描序列化后的数据并重构对象。</li><li>Memory footprint（内存占用）：产生很多临时对象，加大内存占用，导致更频繁的 GC</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116164031401.png" alt="image-20231116164031401"></p><ul><li>Duplication transmission：举了 spark 的 page-rank 算法例子，<strong>这里没太理解，需要再看看。</strong><ul><li>大概意思是，第一轮中，传输 url 的网络拓扑关系，第二轮中，迭代的传播每个 URL 的 rank，并组织为键值对后发送。由于所有对象都被转换并合并为字节数组，jvm无法判断以前是否接收过某些对象。它们必须将所有对象作为单个字节数组接收，这导致了不必要的网络传输和OSD阶段。</li></ul></li></ul><blockquote><p>复习：page-rank 算法</p></blockquote><p>另一方面，并不总是需要通用的数据格式。因此，人们提出了许多优化措施来降低OSD的性能开销，包括软件[26,38,39]和硬件[16,32,40,46]。由于基于硬件的方法需要构建定制的硬件加速器来改进OSD，因此本工作主要侧重于使用现成硬件的基于软件的方法。</p><h2 id="3-3-SOTA"><a href="#3-3-SOTA" class="headerlink" title="3.3 SOTA"></a>3.3 SOTA</h2><p>本文基本思想：achieve an <em><strong>agreement</strong></em> on object representation among JVMs. </p><ul><li><p>Kryo：与JSL的OSD相比，Kryo改进了二进制数据格式，以实现更小的序列化数据大小和更好的性能。但是 OSD 的步骤还是一个不少</p></li><li><p>Skyway：提出直接发送 object graph，而不是序列化字节。在Skyway中，序列化阶段几乎被移除，因为对象不再被转换为二进制格式。虽然Skyway在OSD中简化了阶段，但仍然需要修改对象。</p><p>首先，它需要将 header 中的类型信息转换为 globally-agreed 的ID，以便所有jvm都可以识别它。其次，它需要在复制之后修复引用，因为对象已经移动到不同的地址。此外，Skyway还要求程序员手动标记序列化阶段开始的点。</p></li><li><p>Naos：一种网络特有的数据传输机制。与Skyway类似，Naos也采用全球服务来达成类型协议，但它依赖于RDMA技术来实现快速的零复制对象传输。</p><p>然而，Naos仍然需要修改对象头和引用。此外，它只支持基于网络的传输，现有的应用程序需要进行重大修改才能利用Naos（兼容性不好）</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116164054819.png" alt="image-20231116164054819"></p><h3 id="3-4-1-与-SOTA-的对比"><a href="#3-4-1-与-SOTA-的对比" class="headerlink" title="3.4.1 与 SOTA 的对比"></a>3.4.1 与 SOTA 的对比</h3><p>先前的优化提出了不同的解决方案来减少OSD的开销。但是，它们<strong>不能消除整个OSD进程</strong>。尽管像Naos这样的最新工作消除了序列化阶段，但是仍然需要一个反序列化阶段来修复类型信息和引用。</p><p>此外，它们都没有考虑到<strong>重复数据传输的问题</strong>。本文提出了零变化对象传输(Zero-Change Object Transmission，简称ZCOT)，旨在消除数据交换过程中的整个OSD过程。在ZCOT中，对象传输以最直接的方式进行:发送方JVM复制对象，接收方无需任何修改即可直接使用它们。ZCOT还考虑了重复传输问题，提供了重复数据删除模块。</p><p>最后，**ZCOT不绑定到特定的网络技术(如RDMA)**，并为现有的应用程序提供易于集成的接口。</p><h2 id="3-4-goal"><a href="#3-4-goal" class="headerlink" title="3.4 goal"></a>3.4 goal</h2><ul><li>提出一个在 JVMs 之间能够全局适用的 agreement 来表示对象</li><li>兼容已有程序</li></ul><h1 id="4-Design"><a href="#4-Design" class="headerlink" title="4. Design"></a>4. Design</h1><p>ZCOT的核心思想是为运行在不同机器上的jvm构建一个类似分布式共享内存(DSM)的抽象</p><p>在支持zcot的系统中，每个JVM的堆由两部分组成:其私有空间(原始Java堆)和全局共享交换空间。对象最初是在私有空间中管理的。当它们需要通过网络发送或持久化到磁盘时，它们将被复制到交换空间。交换空间是对所有jvm可用的抽象;每个JVM都可以直接访问其中的对象。</p><p>因此，可以通过直接复制到交换空间来实现对象传输，并且可以消除整个OSD过程</p><p>虽然我们的交换空间与DSM有着相似的智慧，<strong>但它只用于数据交换，不需要解决一致性等复杂的问题</strong>。它<strong>还假设交换空间中的对象是不可变的</strong>，这通常适用于Spark和Flink等大数据分析。<strong>如果一个写操作发生在交换空间中的对象上，ZCOT会在JVM的私有堆上为它创建一个副本</strong>。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116164243602.png" alt="image-20231116164243602"></p><blockquote><p>复习：COW 机制</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/136428913">https://zhuanlan.zhihu.com/p/136428913</a></p></blockquote><h2 id="4-1-challenges"><a href="#4-1-challenges" class="headerlink" title="4.1 challenges"></a>4.1 challenges</h2><ul><li>如何 build 一个所有 JVMs 都能 access 的 shared exchange space</li><li>如何利用 exchange-space 来支持 OSD-based applications</li><li>在各 JVMs 的 GC 情况下，如何管理交换区的各对象</li><li>如何解决冗余传输问题</li></ul><h2 id="4-2-DCDS"><a href="#4-2-DCDS" class="headerlink" title="4.2 DCDS"></a>4.2 DCDS</h2><p>DCDS 是 exchange space 的实现基础。</p><p>ZCOT依靠其分布式类数据共享(DCDS)机制来构建一个全局可访问的共享空间。DCDS保证与类相关的元数据将映射到所有jvm的相同虚拟内存地址。这有助于jvm在类元数据上达成一致，因此不需要进行与类型相关的修改(例如，标识符)。</p><blockquote><p>在这种设计中，DCDS机制帮助不同的JVM之间达成对类元数据的一致性，因此不需要对类型进行任何修改，比如标识符的修改。换句话说，不需要在不同JVM之间对类的元数据进行修改或调整。这样做的好处是，不同的JVM可以共享相同的类定义，无论是在对象传输还是在远程方法调用等场景中。</p><p>具体来说，”no type-related modifications (e.g., identifiers)”表示在ZCOT和DCDS的设计中，不需要对类型相关的内容进行修改，例如标识符的修改。这意味着不同的JVM可以共享相同的类定义，而无需在类的元数据上进行任何改动或变化。这有助于确保在分布式系统中的不同节点之间可以共享和使用相同的类定义，以便更好地实现数据传输和方法调用的一致性和可靠性。</p><p><strong>天然保持 JVMs 之间的类数据一致性，而无需额外修改</strong></p></blockquote><p>工作流：</p><ul><li>集群管理者为所有的 JVMs 准备一个共享类 archive 文件（包含在jvm间通信期间共享其对应对象实例的所有类）</li><li>归档文件将在JVM启动期间使用，归档文件中的类将被映射到给定的虚拟地址。（虚拟地址范围被记忆和标记为交换空间的一部分。此步骤确保jvm在类上共享相同的视图）</li><li>虽然DCDS要求提前知道应用程序的数据类型，但主流的大数据分析框架通常通过发送一个fat jar文件来保证这一点。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116164216305.png" alt="image-20231116164216305"></p><p>ZCOT 如何通过网络传输 objects with its DCDS support</p><ul><li>发送方JVM在交换空间中申请一个可用内存块用于对象复制。（这是通过与外部 metadata server 通信实现的）</li><li>发送方JVM将对象复制到块的内存地址。这一步类似于普通Java应用程序中的深度复制。<ul><li>为了检测循环并避免在同一对象上重复复制，我们在每个对象头中添加一个标记字，以便在复制后存储其新地址。</li></ul></li><li>复制的对象保存在发送方机器上，并由接收方<strong>惰性地检索</strong>。<ul><li>只有当接收方需要用到这个对象的时候，才会去真正 retrieve</li></ul></li><li>当接收JVM试图访问这部分数据时(图5b)，它会遇到页面错误。预先注册的页面错误处理程序，会向 metadata server 请求错误页面。 metadata server 跟踪了交换空间中内存地址的 ownership，因此它将请求转发给数据的 owner。</li><li>发送方与接收方建立连接，并将请求的对象放置到所需的地址。现在接收者可以直接访问这些对象进行进一步处理，<strong>既不需要更新元数据，也不需要修改引用(即零更改)。</strong></li></ul><blockquote><p>为什么原有的方案需要更新元数据，修改引用？</p></blockquote><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116164306329.png" alt="image-20231116164306329"></p><h2 id="4-3-兼容-OSD-based-场景"><a href="#4-3-兼容-OSD-based-场景" class="headerlink" title="4.3 兼容 OSD-based 场景"></a>4.3 兼容 OSD-based 场景</h2><h3 id="4-3-1-编程接口"><a href="#4-3-1-编程接口" class="headerlink" title="4.3.1 编程接口"></a>4.3.1 编程接口</h3><p>ZCOT应该提供用户友好的 interfaces，以便与应用程序轻松集成</p><p>JSL为OSD实现提供了基于流的类。<code>ObjectOutputStream</code>类提供了<code>writeObject</code>方法来将对象序列化为流(通常是文件或网络)。类似地，<code>ObjectInputStream</code>类提供了<code>readObject</code>方法来将数据反序列化为对象。</p><p>因此，以前的OSD优化(如Skyway)通过继承这两个类来实现新的序列化器&#x2F;反序列化器，以方便集成。</p><p>ZCOT采用了类似的策略，图6显示了它的基本类:<code>ZCObjectOutputStream</code>和<code>ZCObjectInputStream</code>，它们分别是<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>的子类。与<code>ObjectOutputStream</code>相比，<code>ZCObjectOutputStream</code>略微修改了<code>writeObject</code>的接口，以支持不同的基于osd的场景(稍后讨论)。要使用基于zcot的通信，应用程序只需要用我们的流类替换原来的流类。相比之下，先前的工作要求开发人员<strong>修改原始通信模型或注释序列化点。</strong>（了解一下）</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116164335345.png" alt="image-20231116164335345"></p><h3 id="4-3-2-OSD-compatibility"><a href="#4-3-2-OSD-compatibility" class="headerlink" title="4.3.2 OSD-compatibility"></a>4.3.2 OSD-compatibility</h3><p>为了与OSD接口(<code>writeObject</code>和<code>readObject</code>)保持兼容，ZCOT还应该使用字节数组传输数据。</p><p>为此，ZCOT采用了 two-level transmission mechanism 。如下图所示，ZCOT通过前端和后端传输数据。前端传输兼容OSD接口，但只发送元数据，包括对象的起始地址和数据长度。当<code>ZCObjectInputStream</code>通过<code>readObject</code>接收元数据时，如果触发页面错误，它将直接访问相应的地址，并通过后端传输获取对象(如图5b所示)。ZCOT将在发送方和接收方jvm中启动专用的VM线程来传输请求的对象。</p><blockquote><p>前端 wrap 了一层 OSD base 的字节传输，但只传输元信息，后端仍然使用 ZCOT 的框架进行传输</p></blockquote><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116164358410.png" alt="image-20231116164358410"></p><h3 id="4-3-3-支持不同的-OSD-场景"><a href="#4-3-3-支持不同的-OSD-场景" class="headerlink" title="4.3.3 支持不同的 OSD 场景"></a>4.3.3 支持不同的 OSD 场景</h3><p>在OSD库中，当调用<code>writeObject</code>时，对象被序列化并写入流(例如，图6中第3行定义的out变量)，通常被重定向到文件或网络中。为了支持这两种情况，ZCOT在<code>ZCObjectOutputStream</code>的构造函数中添加了一个参数<code>volatile</code>(第6行)。当<code>volatile</code>设置为false时，复制的对象将被写入文件，并且内存页可以很快通过GC回收(详细信息请参见第4节)。</p><p>尽管如此，这些<strong>对象仍然在交换空间中保留相应的虚拟地址</strong>。当对象数据被其他jvm读取时，元数据服务器要求发送方传递该文件，以便接收方可以将其映射到相应的内存地址。当volatile为true时，情况就简单了，它表示基于网络的传输。在这种情况下，对象只保存在内存中，并且只有当它们被其他对象读取时才可以回收。</p><h1 id="5-Memory-Management"><a href="#5-Memory-Management" class="headerlink" title="5. Memory Management"></a>5. Memory Management</h1><blockquote><p><em><strong>这里需要对 group 组的概念熟悉一下</strong></em></p></blockquote><h2 id="5-1-Group-based-management"><a href="#5-1-Group-based-management" class="headerlink" title="5.1 Group-based management"></a>5.1 Group-based management</h2><p>与传统的基于dsm的系统不同，ZCOT引入了组，这是一种用于分布式内存管理的语义感知概念。</p><p>正如第2节所分析的，大数据分析框架将序列化对象视为整个数据集(单字节数组)，并将它们一起检索。因此，ZCOT将在同一个<code>writeObject</code>调用中<strong>复制的所有对象放到一个组中，以便将它们一起管理。</strong>当接收端出现页面故障时，ZCOT会将属于同一组的所有相关数据页发送给接收端，避免以后出现故障。<strong>这种机制，即基于组的预取</strong>，利用OSD场景中的语义来减轻传统DSM中基于页面的管理开销。</p><h2 id="5-2-Metadata-Server"><a href="#5-2-Metadata-Server" class="headerlink" title="5.2 Metadata Server"></a>5.2 Metadata Server</h2><p>jvm通过远程过程调用(rpc)与元数据服务器通信，以获取或释放交换空间中的内存资源。</p><p>核心数据结构：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116164414990.png" alt="image-20231116164414990"></p><p>元数据服务器对组是不可知的;组仅由单个jvm管理。</p><p>元数据服务器将共享交换空间划分为大小相等的内存块(<strong>默认为256MB</strong>)，</p><blockquote><p>为什么设置这么大，因为是为了大数据分析应用，一次性传输字节数差不多是 256 MB</p></blockquote><p>以便进行内存分配和回收。它还维护一个<strong>分配位图<em>（allocation map）</em></strong>来标记是否已经分配了一个块。每个块都分配了一个整数ID，这是通过与交换空间的起始地址的相对偏移量来计算的。</p><p>为了跟踪块的存储位置，元数据服务器为每个块维护一个副本集<em>（copy set）</em>，该副本集存储在块映射表<em>（chunk mapping table）</em>中。复制集包含存储相应块(在内存或磁盘中)副本的jvm，copy set 中的 JVMs 也用整数id表示。JVM的ID和信息(如IP地址)之间的映射存储在一个分离的成员表<em>（member table）</em>中。</p><p>由于每个JVM都需要与元数据服务器通信，因此它的可靠性变得相当高。为了容忍元数据服务器上的故障，我们可以为它引入 <strong>replicas（冗余容灾备份）</strong>，并且考虑到元数据服务器和工作jvm之间的通信频率较低(在持续数秒的数据处理阶段进行多次通信)，开销是可以接受的。</p><h2 id="5-3-RPC-interfaces"><a href="#5-3-RPC-interfaces" class="headerlink" title="5.3 RPC interfaces"></a>5.3 RPC interfaces</h2><p>metadata server 提供下列四个 rpc 接口</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">register</span><span class="params">(std::string ip, <span class="type">int</span> port)</span></span>;</span><br><span class="line"><span class="function">Chunk* <span class="title">acquire</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Chunk* <span class="title">get_remote</span><span class="params">(Address addr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">release</span><span class="params">(Chunk* chunk)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>register</code></p><ul><li>只有在启动JVM时才调用register。ZCOT提供了一个JVM选项-XX:+UseZCOT，启用这个选项的JVM会自动生成一个RPC线程，并向元数据服务器发送一个注册RPC，并带有它的IP地址和监听端口。接收到RPC后，元数据服务器将IP和端口号保存到成员表中，生成一个整数作为JVM的ID，并返回该ID。对于后续rpc, jvm应该始终附加返回的ID，以帮助元数据服务器维护对象的存储位置(在上面的接口中省略)。</li></ul></li><li><p><code>acquire</code></p><ul><li><p>当JVM从交换空间中耗尽分配的内存时，它应该发送获取rpc以获取更多内存资源。在接收到获取请求后，元数据服务器扫描其位图以分配可用块。</p><p>之后，元数据服务器记住分配的块与JVM的ID之间的关系，并返回块。<strong>为了减少位图扫描的开销，ZCOT会记住最后一个成功分配的块的地址，并在那里开始扫描。</strong>如果扫描到的地址到达交换空间的末端，ZCOT将从开始继续扫描。为了处理同步获取请求，ZCOT引入了<strong>位图锁</strong>来确保位图被独占访问</p></li></ul></li></ul><blockquote><p>位图锁的设计</p></blockquote><ul><li><code>get_remote</code><ul><li>被遇到 page fault 的 JVM 使用</li><li>由于页面错误表明请求的对象没有存储在本地，所以JVM发送<code>get_remote</code>来获取相应的块。在接收到<code>get_remote</code>之后，元数据服务器获取包含地址的相应块，并通过扫描块映射表查找哪些jvm存储了该块。如3.2节所示，元数据服务器将请求转发给相应的JVM进行实际的数据传输。</li><li>由于块的大小相对较大，发送块可能会带来相当大的性能开销。为了减少传输的数据大小，发送方JVM只发送块中使用过的页面，<strong>这些页面在前端传输中表示为数据的长度</strong>(图7)。</li><li>由于ZCOT基于组的预取机制，发送方可以直接将同一组中的多个块发送给接收方。在这种情况下，接收方负责发送辅助RPC来更新元数据服务器中的副本集</li></ul></li><li><code>release</code><ul><li>当JVM发现块中的对象不再使用时，它会发送<code>release</code>以放弃该块。接收到<code>release</code>后，元数据服务器将从块映射表中相应的副本集中删除JVM的ID。如果没有JVM存储这个块，元数据服务器将通过在位图中将相应的位标记为空闲来回收它。</li></ul></li></ul><h2 id="5-4-GC"><a href="#5-4-GC" class="headerlink" title="5.4 GC"></a>5.4 GC</h2><p>由于交换空间中的对象可以从各个jvm访问，因此它们也会受到GC的影响。为此，ZCOT将其内存管理策略与OpenJDK中的<strong>默认GC算法G1</strong>集成在一起，以确保分布式内存管理的正确性并减少GC开销</p><h3 id="5-4-1-G1-basis"><a href="#5-4-1-G1-basis" class="headerlink" title="5.4.1 G1 basis"></a>5.4.1 G1 basis</h3><ul><li><p>分代划分内存</p></li><li><p>为每个内存区域维护名为 <em><strong>remember set</strong></em> 的元数据，保存指向该区域所有对象的引用</p><blockquote><p>remember set，记忆集：</p><p>参考：<a href="https://blog.csdn.net/kang389110772/article/details/120299478">https://blog.csdn.net/kang389110772/article/details/120299478</a></p><p>参考：<a href="https://blog.csdn.net/huangzhilin2015/article/details/115288697">https://blog.csdn.net/huangzhilin2015/article/details/115288697</a></p><p>G1每一个Region都会对应Remembered Set，它会记录这个Region清理时需要扫描哪几个Region。之所以这么做的原因是因为G1是分了Region，如果只使用Card Table，那么就可能不能发挥Region的作用，甚至会变成FULL GC。所以当CT更新后，会异步的去更新RS。</p></blockquote><ul><li>通过检测Java代码中的所有写操作(也称为<strong>写屏障</strong>)来更新记忆集</li></ul><blockquote><p>write barriers，写屏障：</p><p>参考：<a href="https://juejin.cn/post/6987298527562956831">https://juejin.cn/post/6987298527562956831</a></p><p>参考：<a href="https://blog.csdn.net/nazeniwaresakini/article/details/105947623">https://blog.csdn.net/nazeniwaresakini/article/details/105947623</a></p><p>写屏障，其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念），读屏障的含义也类似。</p><p><strong>对一个对象引用进行写操作（即引用赋值）之前或之后附加执行的逻辑</strong>，相当于为引用赋值挂上的一小段钩子代码。</p></blockquote></li><li><p>stop-the-world</p></li><li><p>在GC1期间，每个选择的区域被同时处理:一个专用的GC线程扫描区域的记忆集，找到所有可访问的对象，并将它们复制到一个空区域(称为幸存者区域)。</p></li></ul><h3 id="5-4-2-Integrated-with-G1"><a href="#5-4-2-Integrated-with-G1" class="headerlink" title="5.4.2 Integrated with G1"></a>5.4.2 Integrated with G1</h3><p>提出了 ZCRe-Region，从 metadata server 分配的一块新区域</p><p><em><strong>这里的细节没太理解,读懂的大佬可以跟我交流下~</strong></em></p><blockquote><p>与G1中的区域相比，zcregion的大小并不固定。每个zcregion对应交换空间中的一个组，其中的所有对象都具有相同的生命周期。由于ZCRegions中的对象与其他区域中的对象具有不同的行为，因此G1应该特别对待它们。首先，我们修改写屏障的行为以考虑区域。当一个引用指向一个zcregion中的对象时，我们不需要记住这个引用，而只是将这个zcregion标记为已使用的。这是因为只有当没有引用指向zcregion中的对象时，才会收集它们。</p><p>类似地，GC线程在GC期间不需要扫描ZCRegions，因为如果存在任何指向该区域的引用，则所有对象都被视为活动对象。当GC结束时，JVM将扫描所有的zcregion，并找到那些不包含传入引用的zcregion。对于那些区域，JVM调用release RPC来回收相应的块。如果将组中的对象写入磁盘，则GC也可以回收相应的ZCRegion，但JVM不会调用释放，因为虚拟地址仍然由组保留</p></blockquote><p>综上所述，我们的设计成功地将交换空间的内存管理与G1GC集成在一起。当GC结束时，根据基于<strong>可达性的算法</strong>自动回收交换空间中的内存资源。</p><p>此外，通过对交换空间中的区域进行特殊处理，避免了不必要的元数据跟踪和对象扫描。在某些情况下，这种设计甚至可以减少GC暂停时间</p><h1 id="6-Transmission-Deduplication"><a href="#6-Transmission-Deduplication" class="headerlink" title="6. Transmission Deduplication"></a>6. Transmission Deduplication</h1><p>以 page rank 算法为例</p><p>在第一轮发送基于URL的网络拓扑时，发送方已将所有URL字符串对（以及两个字符串对象）复制到其相应的地址中。在接下来的几轮中，应用程序发送键值对来更新每个URL的排名值。</p><p>由于所有键值对都是作为对象发送的，因此ZCOT发现所有URL对象都已发送要简单得多。因此，发送方可以直接用交换空间中的地址更新那些键值对中的引用，从而消除URL对象上的重复传输。</p><p>【可拓展点】</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116164445424.png" alt="image-20231116164445424"></p><h2 id="6-1-duplication-detection"><a href="#6-1-duplication-detection" class="headerlink" title="6.1 duplication detection"></a>6.1 duplication detection</h2><p>ZCOT 遵循一个简单的标准：<strong>如果一个对象在 exchange space，那么对它复制的尝试是重复的</strong></p><p>参考上图，以 page rank 为例，假设JVM在第1轮中接收到网络拓扑；它从交换空间读取URL对象，<strong>并在接下来的几轮中使用它们</strong>（而不是重新复制一份再发送出去）。因此，当它将更新后的秩值传播到其他JVM时，它仍然使用从其他JVM接收的URL对象。</p><p>可以简单理解为共享全局变量了，而不是每次函数调用都复制一份</p><p>在接下来的几轮中复制URL排名对时，ZCOT会检查每个对象的地址，从而避免复制那些已经在交换空间中的URL对象。</p><h2 id="6-2-Dependency-management"><a href="#6-2-Dependency-management" class="headerlink" title="6.2 Dependency management"></a>6.2 Dependency management</h2><p>尽管ZCOT中的重复数据消除可以通过避免在同一对象上重复复制来减少网络开销，但它也通过引入组间引用使内存管理变得复杂。如第4.1节所述，<strong>每次对writeObject的调用都会为对象管理创建一个新的组</strong>（这里需要再看看！），每个组都通过调用readObject单独使用。</p><p>在对不同组中的对象进行重复数据消除后，<strong>一个组中的目标可以包含对另一个组的目标的引用</strong>，这一点应该在对一个组进行垃圾收集时得到正确处理。为此，ZCOT将这些引用作为组之间的 <em>dependencies</em> 进行了管理。</p><p>由于大量的组间引用，ZCOT不维护引用级别的依赖关系。<strong>当一个组拥有对其他组中任何对象的引用时，ZCOT会将该组标记为依赖于其他组</strong>。依赖性跟踪仍然是通过扩展写屏障来实现的（即 wrap write barrier）。为了记住所有依赖项，ZCOT扩展了元数据服务器中的块映射表，以包含每个块的依赖项集，该依赖项集存储它所依赖的所有其他块。（见 5.2 metadata server 的描述）</p><p>当JVM发现其组在重复数据消除后依赖于另一个组时，它会向元数据服务器发送一个新的RPC <code>add_dependence</code>。由于元数据服务器不知道组，RPC应该指定它所依赖的组所拥有的所有 chunk ID。这些块ID将被添加到元数据服务器设置的相应依赖项中。</p><blockquote><p>为啥 metadata server 不知道 group？</p></blockquote><p>示例：request chunk4，然后 chunk4 依赖 123，原来的方法是 123 都需要 transfer。但是发现 JVM1 已经有 chunk12 了，所以就只传输 chunk3。</p><p>具体描述见论文。</p><p>有两个关键</p><ul><li>添加依赖</li><li>管理依赖（依赖是如何记录的？）</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231116164500093.png" alt="image-20231116164500093"></p><h2 id="6-3-GC"><a href="#6-3-GC" class="headerlink" title="6.3 GC"></a>6.3 GC</h2><p>由于远程 JVM 可能跨组引用本地 JVM 的组，因此本地 G1GC 需要考虑 remote inter-group references</p><p><strong>改进措施：</strong></p><p>如果 JVM <strong>通过写屏障</strong>探测到 ZCRegion 有来自其它 ZCRegion 的引用</p><blockquote><p>如何通过写屏障检测</p></blockquote><ul><li>则将该 ZCRegion 标记为 pinned，同时该区域无法被回收。</li><li>并将依赖关系通过 RPC 发送给 metadata server</li><li>GC 结束时，pinned 的 chunk 不被收集</li><li>只有当所有依赖它的 chunk 都被 GC 时，pinned 的 chunk 才可被 reclaimed<ul><li>在这种情况下，元数据服务器将向相应副本集中的所有 JVM 发送<code>canRelease</code> 消息，这些JVM将把 ZCRegion 标记为 unpinned，以便在以后的 GC 周期中安全地回收它。</li></ul></li></ul><h2 id="6-4-Internalization"><a href="#6-4-Internalization" class="headerlink" title="6.4 Internalization"></a>6.4 Internalization</h2><p>大数据分析通常会生成大量类型简单的对象，如Integer、String、Double等。OpenJDK提供了一种内部化机制，可以将具有相同内容的对象合并在一起。例如，<strong>如果值在-128和127之间的Integer对象的值相等，则它们将合并为一</strong>。ZCOT也采用了这种重复数据消除机制，但在其分布式交换空间中。它扩展了DCDS，以便<strong>所有JVM在启动期间在相同的虚拟地址分配一个小区域</strong>，以包含全局共享的Integer对象。由于这种优化，可以大大减少传输的整数的数量。</p><h1 id="7-evaluation"><a href="#7-evaluation" class="headerlink" title="7. evaluation"></a>7. evaluation</h1><p><em><strong>overview</strong></em></p><p>我们根据最先进的OSD库和微基准测试和宏基准测试的优化来评估ZCOT。</p><ul><li>微基准包含基本和复杂的数据结构，用于数据传输</li><li>而宏观基准包含两个大数据分析框架(Spark和Flink)</li></ul><p>微基准测试的结果表明，ZCOT优于其他OSD库，特别是对于复杂的数据结构，与Naos相比，ZCOT的加速速度高达4.35倍[39]，这是对OSD最先进的优化。对于macrobenchmark, ZCOT优于Spark和Flink中的默认OSD库，从而分别将应用程序时间提高了23.6%和22.2%</p><h2 id="7-1-测试的-workload"><a href="#7-1-测试的-workload" class="headerlink" title="7.1 测试的 workload"></a>7.1 测试的 workload</h2><ul><li><p>Microbenchmark</p><ul><li>微基准标记包含先前工作[26，39]中使用的四种不同的数据类型：2-dimensional points、key-value pairs、hashmaps 和 media objects。为了模拟大数据场景，我们将它们传输到长度为65536的大数组中。由于一些基线对于大型媒体对象阵列崩溃，我们将该数据结构的长度减少到16384</li></ul></li><li><p>Spark</p><ul><li>一个数据分析引擎，需要JVM之间的大量数据传输。</li></ul></li><li><p>Flink</p><ul><li><p>ApacheFlink[6]（v1.14）是一个用于批处理和流工作负载的分布式数据处理引擎。</p><p>As for baseline，将ZCOT与两个常用的OSD库（JSL和Kryo）以及两个 SOTA 的OSD优化（Naos和Skywy2）进行了比较。</p><p>我们的测试环境包括一个由100 Gbit&#x2F;s Mellanox ConnectX-5 NIC连接的四个节点组成的集群。每个节点包含双Xeon E5-2650 CPU和128GB DRAM</p></li></ul></li></ul><h2 id="7-2-Microbenchmark"><a href="#7-2-Microbenchmark" class="headerlink" title="7.2 Microbenchmark"></a>7.2 Microbenchmark</h2><p>详细表现见论文。在 2-dimensional points 表现一般。主要是因为数据转化上的优化被网络的 overhead 抵消了</p><h2 id="7-3-Spark"><a href="#7-3-Spark" class="headerlink" title="7.3 Spark"></a>7.3 Spark</h2><ol><li>如何集成？</li></ol><p>要在Spark中采用ZCOT，我们需要实现一个新的数据序列化器<code>ZCSerializer</code>来取代默认的<code>KryoSerializer</code>。尽管该名称似乎涉及OSD阶段，但仅出于兼容性考虑，在传输过程中仍然保持零变化。</p><p><code>ZCSerializer</code>包含70行代码，其中大部分是从JSL序列化程序继承的。此外，我们用我们的替换了来自JSL的原始流类。如果Spark用户想要启用ZCOT，ta 只需要（1）将<code>Spark.serializer</code>配置为<code>ZCSerializer</code>，（2）将<code>XX:+UseZCOT</code>添加到所有JVM的启动选项中</p><ol start="2"><li>如何测试？</li></ol><p>使用 spark 官网的4个经典 cases，并进一步将结果分为四个不同的阶段：写入（序列化）、读取（反序列化）、计算和垃圾收集（GC）。由于Spark中的四个阶段不重叠（GC阶段仅包含停止世界时间），因此累积时间等于总执行时间。</p><p>对比得出，ZCOT 主要的优化集中在 OSD 阶段，其中 page rank 由于 OSD 占比大，优化效果最好</p><ol start="3"><li>总结</li></ol><p>尽管ZCOT需要管理复制的组（ZCRegions），但其粗粒度收集策略避免了扫描ZCRegions内的对象。此外，ZCOT通过消除 serialization 阶段<strong>避免了生成单片字节数组</strong>，这可以减轻内存压力，并引入不太频繁的GC。</p><p>注意，ZCOT中的计算时间比JSL和Kryo中的要长一些。这可以由两个原因来解释。</p><ul><li><strong>由于ZCOT在传输过程中不压缩对象内容以实现零变化，因此传输的数据大小大于JSL和Kryo，这导致更大的网络开销（包括在计算部分中）</strong></li><li><strong>重复数据消除模块使同一数据集中的对象分散到不同的虚拟地址范围，这可能导致更多的随机内存访问和缓存未命中。</strong></li></ul><p>重传可以显著减少传输字节数，但由于没有使用 compact format，因此 ZCOT 仍然比 Kryo 和 JSL 的 overhead 更高</p><h2 id="7-4-Flink"><a href="#7-4-Flink" class="headerlink" title="7.4 Flink"></a>7.4 Flink</h2><p>将 ZCOT 的 OSD 接口替换 Flink 的接口即可</p><h1 id="8-Related-work"><a href="#8-Related-work" class="headerlink" title="8. Related work"></a>8. Related work</h1><h2 id="8-1-OSD-优化"><a href="#8-1-OSD-优化" class="headerlink" title="8.1 OSD 优化"></a>8.1 OSD 优化</h2><p>为了优化OSD中耗时的阶段，Kryo[38]、Skyway[26]和Naos[39]等先前的工作已经<strong>改进了传输数据格式或利用了网络硬件技术的进步</strong>。相反，ZCOT旨在消除整个OSD过程。除了基于软件的技术外，另一项工作采用<strong>基于硬件的方法</strong>来减少OSD开销。Optimus Prime[32]构建了一个数据转换加速器（DTA），以提高微服务的OSD吞吐量。麦片[16]与硬件加速器共同设计数据传输格式，以提高Spark应用程序的性能和能效。</p><p>Morpheus[40]将反序列化阶段转移到智能固态硬盘中，而Hgum[46]则利用FPGA来处理OSD任务。ZCOT基于现成的硬件，因此与那些基于硬件的优化正交</p><h2 id="8-2-和其它工作的区别"><a href="#8-2-和其它工作的区别" class="headerlink" title="8.2 和其它工作的区别"></a>8.2 和其它工作的区别</h2><ul><li>for Distributed language runtimes</li></ul><p>Java&#x2F;DSM[43]在用于异构计算的DSM之上构建分布式JVM。</p><p>JESSICA[21，47]提供了单个全局线程空间，并透明地迁移Java线程以实现负载平衡。</p><p>Comet[14]为在移动设备和云上运行的JVM构建了DSM抽象，并依靠其内存模型来实现有效的代码卸载。</p><p>Semeru[41]提出了一种通用的Java堆抽象，这样Java应用程序就可以在内存分解架构中自由访问所有内存资源。这些系统利用共享堆来同步不同端点之间的数据，但它们没有考虑大型应用程序的JVM间通信的性能开销。</p><p>XMem[42]能够在同一物理机器上的多个JVM之间实现高效的类型安全对象共享，但它不考虑分布式环境。</p><p>ZCOT还提出了一种分布式运行时设计，但它主要侧重于增强多个JVM之间的数据传输。</p><ul><li>Runtime optimizations for Java</li></ul><p>ITask[11]使数据处理任务在面临巨大内存压力时可以中断，从而提高性能并减少内存不足错误。</p><p>Yak[27]将应用程序执行划分为历元，并在历元结束时触发GC。</p><p>Broom[12]采用基于区域的设计，并将具有相同生命周期的对象放入同一区域进行快速回收。</p><p>ScissorGC[18，19]提出了阴影区域，以提高全GC阶段的可扩展性。</p><p>Taurus[22，23]协调来自不同JVM的GC，以达到更好的性能或更小的尾部延迟。</p><p>Facade[28]和Deca[36]将大量数据对象存储在堆外内存中，以减少GC压力，而</p><p>Gerenuk[24]允许对序列化数据进行推测性执行，以减少内存占用和GC开销。</p><p>ZCOT专注于消除OSD过程。</p><h1 id="96-总结"><a href="#96-总结" class="headerlink" title="96. 总结"></a>96. 总结</h1><p>主要解决<strong>四个问题</strong></p><ol><li>设计一个所有 JVMs 都能 access 的 exchange space</li><li>让 exchange space 的 abstraction 能适配 OSD</li><li>让 exchange space 的 object 适配于 individual JVM 的 GC</li><li>解决重复传输问题</li></ol><p>如何集成 G1 GC</p><ol><li>提出 ZCRegion，exchange space 里的 group 被对应划分为 ZCRegion</li><li>修改 write barrier 对 ZCRegion 的行为，只 mark 整个 region 是否被使用</li><li>GC 线程不需要检查 ZCRegion</li><li>GC 结束时，JVM 再检查是否有 incoming reference to ZCRegion，若无，调用 release 释放之</li></ol><p>如何 deduplication</p><ol><li>标准：如果对象在 exchange space 里，那么不需要再复制它</li><li>还需要维护 dependency 的关系。维护 group 粒度的 dependency，在 metadata server 的 mapping table 中增加 dep set</li><li>get_remote 时，只 fetch 不存在的 chunk（需要 fetch 所有依赖的 chunk）。同时 fetch 时，如果对象已经在 exchange space 里，不需要 fetch 了</li></ol><h1 id="97-疑问"><a href="#97-疑问" class="headerlink" title="97. 疑问"></a>97. 疑问</h1><ol><li>ZCOT 的 workflow 和直接网络传输有啥区别，虽然避免了对象改变，但本质上还是需要网络传输</li><li>如果有多个 jvm 持有 receiver 所需的 chunk，metadata server 如何转发请求</li></ol><h1 id="98-相关知识"><a href="#98-相关知识" class="headerlink" title="98. 相关知识"></a>98. 相关知识</h1><h2 id="1-JVM-object-representation"><a href="#1-JVM-object-representation" class="headerlink" title="1. JVM object representation"></a>1. JVM object representation</h2><p><em><strong>header（Klass）</strong></em></p><p><em><strong>data</strong></em></p><p>在每个 JVM 中，对象的 Klass 和 data 是不同的，不能之间跨 JVM 移动。异 JVM 无法 interpret</p><blockquote><ol><li>对象头（Object Header）：<ul><li>对象头是一个特定大小的数据结构，用于存储关于对象的元信息和运行时数据。</li><li>对象头包含了一些固定的字段，如对象的哈希码（Hash Code）、锁状态、垃圾回收标记等。</li><li>对象头的具体结构和字段的大小和布局可能会因不同的JVM实现而有所不同。</li></ul></li><li>实例数据（Instance Data）：<ul><li>实例数据是对象中的实际数据，它包含了对象的字段和对应的值。</li><li>实例数据存储了对象的状态信息和其他实例级别的数据。</li><li>实例数据的大小和布局取决于对象所属的类以及其定义的字段。</li></ul></li></ol><p>JVM根据类的定义和实例数据的布局，分配足够的内存来存储对象。对象的内存分配通常是在堆上进行的，可以通过垃圾回收来管理对象的生命周期和内存释放。</p><p>需要注意的是，JVM对对象的内部表示是实现特定的，并且可能因JVM实现、JVM版本和垃圾回收器的不同而有所差异。对象的内部表示通常是透明的，开发人员可以通过使用Java编程语言中的对象操作（如字段访问、方法调用）来访问和操作对象的数据。</p></blockquote><h2 id="2-reference-fixing-problem"><a href="#2-reference-fixing-problem" class="headerlink" title="2. reference fixing problem"></a>2. reference fixing problem</h2><p>klass 在不同的 jvm 中不同，传输的时候需要修改 klass 的引用。</p><p>解决：在 exchange space 中开辟共享区，存放 klass</p><h1 id="99-术语表"><a href="#99-术语表" class="headerlink" title="99. 术语表"></a>99. 术语表</h1><h2 id="OSD"><a href="#OSD" class="headerlink" title="OSD"></a>OSD</h2><p>The object serialization and deserialization</p><h2 id="ZCOT"><a href="#ZCOT" class="headerlink" title="ZCOT"></a>ZCOT</h2><p>Zero-Change Object Transmission</p><h2 id="DCDS"><a href="#DCDS" class="headerlink" title="DCDS"></a>DCDS</h2><p>distributed class-data sharing，分布式类数据共享</p><p>本文的 dcds 是对 openJDK  dcds 功能的扩展</p><h2 id="RDMA"><a href="#RDMA" class="headerlink" title="RDMA"></a>RDMA</h2><p>Remote Direct Memory Access，远程直接数据存取（远程直接内存访问）</p><h2 id="DSM"><a href="#DSM" class="headerlink" title="DSM"></a>DSM</h2><p> distributed-shared memory</p><h2 id="group"><a href="#group" class="headerlink" title="group"></a>group</h2><p>主要是因为大数据分析应用把序列化后的数据当作一个整体进行发送和接受，因此 ZCOT 也成组发送，防止频繁的 page fault</p><p>元数据服务器对组是不可知的；组仅由单独的JVM管理</p><h2 id="memory-chunk"><a href="#memory-chunk" class="headerlink" title="memory chunk"></a>memory chunk</h2><h2 id="ZCRegion"><a href="#ZCRegion" class="headerlink" title="ZCRegion"></a>ZCRegion</h2><p>为了集成 G1 GC 时提出的概念。和 G1 分配的 regions 相比，ZCRegion 的大小不固定</p><h2 id="APPCDS"><a href="#APPCDS" class="headerlink" title="APPCDS"></a>APPCDS</h2><p>Application Class-Data Sharing</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-ElasticFlow：Training Plf for Distributed DL</title>
      <link href="/article/ElasticFlow/"/>
      <url>/article/ElasticFlow/</url>
      
        <content type="html"><![CDATA[<p><a href="https://xinjin.github.io/files/ASPLOS23_ElasticFlow.pdf">ElasticFlow: An Elastic Serverless Training Platform for Distributed Deep Learning</a></p><p>由于笔者将原阅读报告写在 word 上，本文是从 word 复制过来，因此在中英文之间的空格等方面可能有一些格式问题。请读者见谅~</p><h1 id="1-论文研究背景、动机与主要贡献"><a href="#1-论文研究背景、动机与主要贡献" class="headerlink" title="1. 论文研究背景、动机与主要贡献"></a>1. 论文研究背景、动机与主要贡献</h1><h2 id="1-1-研究背景"><a href="#1-1-研究背景" class="headerlink" title="1.1. 研究背景"></a>1.1. 研究背景</h2><ol><li><p>Distributed Training for Deep Learning： Deep Learning（DL）发展火热，为许多应用程序和服务提供支持。相应地，训练DL模型成为一项重要工作。而对于包括许多迭代的DL训练任务，其非常耗时，因此分布式训练被广泛用于加速DL训练过程。</p></li><li><p>Serverless Computing（或FaaS）： Serverless Computing能够对用户屏蔽底层硬件资源的使用和配置，使得用户只需要用函数描述workload并提交至Serverless平台即可。这种计算模式将System相关的底层资源管理offload给服务提供商，让用户专注于解决业务问题。</p></li><li><p>Elastic Training：相比于已提出的许多解决方案，ElasticFlow 不关注如何加速单个 job，而是基于弹性训练的研究进展，在多任务场景的任务调度下实现应用弹性缩放，在云中调度多个作业并利用弹性特性以无服务的方式为作业提供性能保证。</p></li></ol><h2 id="1-2-动机"><a href="#1-2-动机" class="headerlink" title="1.2. 动机"></a>1.2. 动机</h2><p>本文从已有的DL分布式训练痛点出发，主要提出了以下2点动机：</p><ol><li><p><strong>Server centric架构中DL相关问题与系统问题高度耦合。</strong> 对于DL开发者来说，使用server-centric风格的分布式训练时除了配置编写DL相关的业务问题，还需要配置低层的系统问题，显式地请求硬件资源并配置实体物理机的各种参数，如GPU的local batch size、worker数量等。这些系统方面的底层工作对DL开发者来说尤具挑战性。</p></li><li><p>大多数现有解决方案不具备DL作业资源运行时的弹性扩展功能 ，从而<strong>无法提供性能保证，即保证在DDL（截止日期）之前完成作业。</strong>大多数现有解决方案侧重于优化JCT（作业完成时间），但却忽略了对作业DDL的性能保证。它们缺乏弹性向上或向下扩展调整作业资源以优化集群范围内的资源利用率并满足DDL的能力和灵活性。</p></li></ol><h2 id="1-3-主要贡献"><a href="#1-3-主要贡献" class="headerlink" title="1.3. 主要贡献"></a>1.3. 主要贡献</h2><ol><li><p>设计出了分布式DL训练的弹性Serverless Computing平台ElasticFlow解决上述痛点，ElasticFlow将DL业务问题与资源管理配置等系统问题解耦，对用户屏蔽底层系统细节，同时利用弹性扩展来保证DL任务的DDL。</p></li><li><p>提出了minimum satisfactory share的metric来获取作业在非线性scaling曲线下满足DDL所需的最小GPU数量。</p></li><li><p>设计了admission control算法 ，基于minimum satisfactory share进行准入控制，保证所有被允许的作业都能在DDL前完成。</p></li><li><p>设计了一种弹性资源分配算法 ，基于递减收益为已允许的作业弹性分配GPU以最大化资源利用率。</p></li><li><p>实现了ElasticFlow的系统原型 ，并将其与PyTorch集成。测试显示，在满足DDL作业数量的指标上，ElasticFlow的效果比STOA优秀1.46-7.65倍。</p></li></ol><h1 id="2-论文问题描述或定义"><a href="#2-论文问题描述或定义" class="headerlink" title="2. 论文问题描述或定义"></a>2. 论文问题描述或定义</h1><p>本文的问题描述有2个方面： </p><h2 id="2-1-分布式训练的2个问题"><a href="#2-1-分布式训练的2个问题" class="headerlink" title="2.1. 分布式训练的2个问题"></a>2.1. 分布式训练的2个问题</h2><ul><li><strong>训练吞吐（throughput）随 GPU 的数量非线性增长 (non-linear scaling curve)</strong> 。由于参数同步和其他开销，吞吐量不会随着工作线程的数量线性增加。传统的最早截止日期优先（early-deadline-firt，EDF）算法虽然对满足截止日期是有效的，但这种解决方案将整个集群视作一个逻辑工作者，不适用于非线性scaling任务。ElasticFlow的DDL感知调度应该考虑非线性scaling场景。</li><li><strong>Worker的拓扑位置（placement）影响分布式任务的性能</strong>。 并且拓扑相关的布局进一步影响训练吞吐的scaling曲线（Topology-aware），使得该问题与前述问题交织在一起。在为作业分配资源时，ElasticFlow应该结合实际的worker placement考虑一组scaling曲线。</li></ul><h2 id="2-2-算法设计时的具体优化目标"><a href="#2-2-算法设计时的具体优化目标" class="headerlink" title="2.2. 算法设计时的具体优化目标"></a>2.2. 算法设计时的具体优化目标</h2><ol><li><p>Minimum satisfactory share： 对于每个作业，找到能满足其DDL所需的最低资源数量</p></li><li><p>Admission control： 对于新到达的作业，只有ElasticFlow能保证其作业截止日期时作业才能被接受。具体定义如下：</p><p>在如下约束条件下（具体解释：约束1表示每个job_i都能在DDL前达到终止条件，约束2表示对于任何时隙t，所有job所分配的GPU数量总和不能超过系统资源总和)<img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/wps1.jpg" alt="img"></p><p>对所有job按照DDL进行升序排序，  若下式成立（对于任意i，前i个job的GPU时间总和小于系统GPU总数与第i个工作DDL（单位为time unit）的乘积)<img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/wps2.jpg" alt="img"> 则存在合法的资源分配，可以保证作业能在DDL之前完成。</p></li><li><p>Resource allocation： 在满足minimum satisfactory share的基础上，将剩余的空闲资源分配给作业，以进一步提高资源利用率。分配时，需要考虑收益递减效益，即：由于GPU的吞吐scaling曲线随GPU数量是非线性的，一个工作拥有的GPU数量越多，其消耗的GPU时间越多。</p><p>对于每一个作业，考虑下一个时隙的资源分配情况，优化目标如下式所述：在满足三个约束条件（1.满足所有工作的DDL 2.总分配GPU数目不超过当前可用 GPU 数目 3.在下一个时隙中所有GPU均被分配，除非给任一工作分配更多资源都会导致执行更慢）的情况下，  最小化所有工作的GPU时间之和 。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/wps3.jpg" alt="img"></p></li></ol><h1 id="3-论文提出的新思路、新理论、或新方法"><a href="#3-论文提出的新思路、新理论、或新方法" class="headerlink" title="3. 论文提出的新思路、新理论、或新方法"></a>3. 论文提出的新思路、新理论、或新方法</h1><h2 id="3-1-架构层面"><a href="#3-1-架构层面" class="headerlink" title="3.1. 架构层面"></a>3.1. 架构层面</h2><p>ElasticFlow只对DL开发者暴露一个高层次的serverless API。DL开发人员将他们的工作作为serverless function提交给ElasticFlow，随后ElasticFlow利用资源弹性，根据作业的截止日期和集群状态动态地为作业分配资源。Serveless function的参数如下：</p><table><thead><tr><th>参数名称</th><th>说明</th></tr></thead><tbody><tr><td>DNN模型</td><td>要参与训练的DNN模型</td></tr><tr><td>超参数</td><td>如Global batch size、学习率等</td></tr><tr><td>终止条件</td><td>指示工作完成的条件，如最大迭代次数</td></tr><tr><td>DDL</td><td>DL开发者希望完成训练的时间节点</td></tr><tr><td>其它训练组件</td><td>数据集、优化器等</td></tr></tbody></table><p>在serverless API下层加入admission control、resource allocation等组件，对DL开发者屏蔽底层系统资源调度细节。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/wps4.jpg" alt="img"> </p><h2 id="3-2-实现层面"><a href="#3-2-实现层面" class="headerlink" title="3.2. 实现层面"></a>3.2. 实现层面</h2><ol><li><p>Minimum   satisfactory   share： 提出minimum satisfactory share这一指标，将其定义为：每个作业能满足其DDL所需的最低资源数量，以解决深度学习任务中scaling凹曲线所带来的GPU数量增加收益递减问题。</p></li><li><p>Admission   control： 基于minimum satisfactory share进行准入控制，对提交的任务进行submit或drop操作，保证所有任务都能在DDL前完成。</p><ol><li>当集群中没有其它任务时，可以通过二分查找来获得满足已有任务DDL需求的最少GPU，从而完成分配。</li><li>当集群中有其它任务时，考虑某个任务完成DDL所需的GPU需要依赖于其它任务的资源占用情况。而由于DL任务的吞吐scaling曲线是非线性的，本文提出使用  渐进式填充算法（progressive   filling） 来判断新任务是否能够被满足。</li><li>该算法的具体描述如下： 该算法本质上是一个贪心算法，对于每次需要调度任务时，先将新添加的任务添加到任务队列中并按照DDL升序排序，随后按顺序逐个从任务队列中取出任务并调用渐进式填充算法。对每一个任务，渐进地增加GPU分配数量，并计算每个时隙下的工作量，对工作量求和，判断总工作量是否满足任务所需工作量。如果在系统已有GPU资源范围内，找不到一种调度策略满足任务在DDL前完成工作，则丢弃（drop）该工作；否则，提交（submit）该工作。</li></ol></li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/wps5.jpg" alt="img"> </p><ol start="3"><li>Resource   allocation： 目标是在满足minimum satisfactory share的基础上，将剩余的空闲资源分配给作业，充分利用GPU，同时保证所有已提交任务的DDL。<ol><li>本文为资源分配开发了一个贪心算法，将剩余的GPU分配给具有最高边际效益的任务。</li><li>该算法的具体描述如下： 在保证分配给任务新GPU不会导致任务完成时间变长以及minimum satisfactory share的基础上，对任务逐个分配 GPU，计算任务分配GPU后的效益，并以此确定任务的优先级添加至优先队列中。随后在队列中的任务依次出队，实际分配GPU时每次分配给边际效益最高的任务，直到所有GPU被分配完。</li></ol></li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/wps6.jpg" alt="img"> </p><ol start="4"><li>Job   placement： 目标是尽量减少任务拓扑位置（worker placement）对DL任务效益的影响。本文提出了两个具体策略来实现上述目标：<ol><li>开发了一种  topology  -  aware的工作分配算法 ：使用多层分层树来获取GPU拓扑，树的叶节点代表GPU，每个内部结点代表某种连接。为了放置作业，每次找到一个合适的子树，其中包含足够的GPU来容纳作业。而寻找合适子树的方法是  Best  -  Fit ，每次选择空闲GPU数量最接近所需GPU数量的子树，使得作业尽可能分配导同一拓扑的集群中，分配尽可能高的带宽，避免吞吐的低估和资源用量的高估。</li><li>使用  buddy   allocation和job   migration 来消除resource fragmentation，通过buddy allocation和job migration来消除资源碎片。并将每个工作的worker数量限定为2的幂次，如此能保证如果集群中有足够的空闲GPU用于某个作业，则存在包含足够GPU的子树。</li></ol></li></ol><h1 id="4-论文方法的理论分析或实验评估方法与效果"><a href="#4-论文方法的理论分析或实验评估方法与效果" class="headerlink" title="4. 论文方法的理论分析或实验评估方法与效果"></a>4. 论文方法的理论分析或实验评估方法与效果</h1><h2 id="4-1-评估方法"><a href="#4-1-评估方法" class="headerlink" title="4.1. 评估方法"></a>4.1. 评估方法</h2><p>本文在16台服务器的集群上进行测试，其共包含128个NVIDIA A100 GPU。每台服务器配备8个40GB NVIDIA A100 GPU、96核、900GB RAM和8个NVIDIA Mellanox HDR InfiniBand HCAs。</p><ol><li><p>本文在A100 GPU上开发了用于模拟作业级事件的模拟器，通过测试台的物理GPU服务器作为模拟器的输入，对每个作业的吞吐量展开分析</p></li><li><p>对于每个作业，本文随机选择一个具有batch size的DNN模型，使用跟踪中的持续事件和预先测量的吞吐量来计算每个作业所需的迭代次数。</p></li></ol><p>本文主要对以下  2个指标 进行评估：</p><ol><li><p>Deadline satisfactory ratio，即作业在截止日期前完成的比例。</p></li><li><p>Cluster efficiency（CE），它衡量集群中资源的利用效率，具体数学定义如下（其中M是集群中GPU数量，tpt是吞吐量）：</p></li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/wps7.jpg" alt="img"> </p><p>对于SLO作业，使用上述两个指标；对于best-effort作业，主要比较其JCT（作业完成时间）</p><h2 id="4-2-效果"><a href="#4-2-效果" class="headerlink" title="4.2. 效果"></a>4.2. 效果</h2><p>本文选取了6个baseline进行比较，分别是：</p><ul><li>Earliest-Deadline-First (EDF)</li><li>Gandiva</li><li>Tiresias</li><li>Themis</li><li>Chronus</li><li>Pollux（STOA）</li></ul><p>与EDF、Gandiva、Tiresias、Themis、Chronus和Pollux相比，ElasticFlow将能够满足截止日期的作业数量分别提高了8.0倍、2.7倍、2.0倍、2.3倍、1.6倍和2.0倍。在更大的规模上(在16台服务器上，128个GPU)，与EDF、Gandiva、Tiresias、Themis和Chronus相比，ElasticFlow能够满足截止日期的作业数量分别提高了7.65倍、3.17倍、1.46倍、1.71倍和1.62倍。平均而言，与EDF、Gandiva、Tiresias、Themis和Chronus相比，ElasticFlow将截止日期满意率分别提高到12.95倍、2.58倍、2.15倍、1.76倍和1.68倍。</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><h2 id="5-1-论文优点"><a href="#5-1-论文优点" class="headerlink" title="5.1. 论文优点"></a>5.1. 论文优点</h2><ol><li>敏锐察觉到现有分布式DL训练平台的痛点，能够有效结合STOA和现有大部分方法优点，提出了一个serverless架构的弹性计算平台ElasticFlow，大大简化DL开发人员们的使用过程，并能为DL任务提供DDL前完成的性能保证。</li><li>考虑到了分布式训练中的两个挑战：训练吞吐随GPU数量非线性增长以及Worker placement对scaling的影响。同时考虑到了两个问题之间的相互影响，能够从现实情景出发，设计admission control、resource allocation、job placement等方法解决上述挑战。</li><li>本文所提出的ElasticFlow还考虑了SLO和best-effort两种作业的调度情况，对于两种不同类型的作业保持了兼容和可扩展性。</li><li>实验对比验证环境使用了严谨的指标，选取当下主流方法作为baseline，测试数据可信度高，结果令人欣喜。</li><li>本文还对ElasticFlow的系统开销如profiling以及Scaling和migration进行了测试，得出在一般真实场景下，ElasticFlow的系统开销较小，相比于DL任务的训练时长几乎可以忽略不计。</li></ol><h2 id="5-2-论文缺点"><a href="#5-2-论文缺点" class="headerlink" title="5.2. 论文缺点"></a>5.2. 论文缺点</h2><ol><li>在serverless架构的ElasticFlow平台中未对GPU加速话题进行探究。</li><li>对于有恶意的用户（即恶意提交DL任务、挤兑系统资源等），本文未提出详细的额外策略和定价模型来防止此类情况发生。即：本文假定所有用户都是无恶意的，并根据他们的实际需求来按需设定DDL。</li><li>对于集群中结点发生错误的情况，本文未设计详细策略。</li></ol><h2 id="5-3-本文的启示"><a href="#5-3-本文的启示" class="headerlink" title="5.3. 本文的启示"></a>5.3. 本文的启示</h2><ol><li><p>Serverless架构可以对计算平台使用者屏蔽底层资源配置等系统方面知识，从而将专业使用（如DL业务知识）与底层系统解耦，让开发者专注于完成自己的开发任务。</p></li><li><p>分布式计算集群中需要设定弹性资源分配策略，以保证时刻最优工作效率。</p></li><li><p>实际算法设计中需要考虑现实中训练吞吐随GPU数量非线性增长以及Worker placement对scaling的影响，而不是用理想的线性模型进行概括。实际的集群worker分配时需要考虑到topology-aware。</p></li></ol><h2 id="5-4-后续研究思路"><a href="#5-4-后续研究思路" class="headerlink" title="5.4. 后续研究思路"></a>5.4. 后续研究思路</h2><ol><li><p>探究serverless架构下的加速器设计，如对GPU加速以支持更高的workload。</p></li><li><p>对于有恶意的用户（即恶意提交DL任务、挤兑系统资源等），设计详细的额外策略和定价模型来防止此类情况发生。</p></li><li><p>设计容错策略，处理集群中结点发生故障的情况，保证集群的高可用。</p></li></ol><p>​             </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NASM 概念与实战/踩坑记录</title>
      <link href="/article/NASM/"/>
      <url>/article/NASM/</url>
      
        <content type="html"><![CDATA[<ul><li>NJU OS lab-1</li></ul><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221006001450200.png" alt="image-20221006001450200" style="zoom:50%;" /><h1 id="1-NASM-与-GDB-调试"><a href="#1-NASM-与-GDB-调试" class="headerlink" title="1. NASM 与 GDB 调试"></a>1. NASM 与 GDB 调试</h1><h2 id="1-1-安装与运行"><a href="#1-1-安装与运行" class="headerlink" title="1.1. 安装与运行"></a>1.1. 安装与运行</h2><p>在 Ubuntu 下可以通过 apt 安装</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo apt install nasm</span><br></pre></td></tr></table></figure><p>安装后就可以对文件进行汇编了，以<code>big_decimal.asm</code>为例</p><p>在 Ubuntu 下</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nasm -f elf big_decimal.asm -o big_decimal.o</span><br><span class="line">ld -m elf_i386 big_decimal.o -o big_decimal</span><br></pre></td></tr></table></figure><p><code>ld</code>是 GUN 自带的链接工具，可以将目标文件链接起来，我们这里因为只有一个文件因此不需要额外的指令。</p><p>复习一下，我们将一个写好的 C 程序转化为一个可以在 Unix 内核机器上执行的文件，需要经历下面四个步骤：</p><ul><li>预处理：处理 C 中的预处理命令，也就是#开头的那些，默认的生成文件格式为<code>.i</code></li><li>编译：将 C 程序编译为汇编语言， 默认的生成文件格式为<code>.s</code>，这里的<code>.s</code>和我们的<code>.asm</code>没什么区别</li><li>汇编：将汇编语言转化为机器码，默认的生成文件格式为<code>.o</code></li><li>链接：链接动态库和静态库</li></ul><p>因为我们直接在写汇编程序，当然就不需要第一步和第二步了。</p><h2 id="1-2-GDB-调试"><a href="#1-2-GDB-调试" class="headerlink" title="1.2. GDB 调试"></a>1.2. GDB 调试</h2><p>说到 GUN，不得不提今天的另一个主角，那就是 GDB，GNU symbolic debugger，它是一个在 Unix 内核中广受好评的调试工具。</p><p>我们可以使用 GDB 来调试我们的汇编代码</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nasm -f elf big_decimal.asm -o big_decimal.o</span><br><span class="line">ld -m elf_i386 big_decimal.o -o big_decimal</span><br><span class="line">sudo gdb big_decimal</span><br></pre></td></tr></table></figure><p>接下来进入 gdb 界面，开始你的调试工作。</p><p>和前面说到的一样，使用<code>gdb</code> 打开你的文件就好了，因为<code>gdb</code>要控制另一个进程，所以别忘了给它开权限。</p><p>可以在汇编文件中设置断点，并在你想停止的地方<code>call</code>它，比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break_demo:</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>然后只要在<code>gdb</code>中</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">b break_demo</span><br></pre></td></tr></table></figure><p>就可以让它在执行到<code>b</code>的时候中止程序。</p><p>可以使用指令</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">i registers</span><br></pre></td></tr></table></figure><p>查看代码运行的位置和寄存器状态。</p><p>如果你的代码有<code>stdout</code>的输出，可能会破坏这个 layout 的格局，这时候使用<code>refresh</code>指令刷新它。</p><p>最后，可以使用<code>x</code>指令查看你的内存状况，比如查看<code>0x40201c</code>开始的 20 个 bits 的内存</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x/20b 0x40201c</span><br></pre></td></tr></table></figure><h1 id="2-NASM-详解"><a href="#2-NASM-详解" class="headerlink" title="2. NASM 详解"></a>2. NASM 详解</h1><h2 id="2-1-NASM-程序的结构"><a href="#2-1-NASM-程序的结构" class="headerlink" title="2.1. NASM 程序的结构"></a>2.1. NASM 程序的结构</h2><p>NASM 是基于行的。大多数程序由指令后跟一个或多个部分组成。行可以具有可选标签。大多数行都有一条指令,后跟零个或多个操作数。</p><p><a href="https://raw.githubusercontent.com/zhangjunlei26/NASM-Tutorial-CN/master/assets/nasmstructure.png"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221004164300281.png" alt="image-20221004164300281"></a></p><p>通常,您将代码放在的部分中,<code>.text</code>并将常量数据放在的部分中<code>.data</code>。</p><h2 id="2-2-NASM-语法"><a href="#2-2-NASM-语法" class="headerlink" title="2.2. NASM 语法"></a>2.2. NASM 语法</h2><h3 id="2-2-1-基础指令"><a href="#2-2-1-基础指令" class="headerlink" title="2.2.1. 基础指令"></a>2.2.1. 基础指令</h3><p>有数百条指令。您无法一次全部学习它们。从这些 start:</p><table><thead><tr><th><code>mov</code> <em>x</em>,<em>y</em></th><th><em>x</em> ← <em>y</em></th></tr></thead><tbody><tr><td><code>and</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> and <em>y</em></td></tr><tr><td><code>or</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> or <em>y</em></td></tr><tr><td><code>xor</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> xor <em>y</em></td></tr><tr><td><code>add</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> + <em>y</em></td></tr><tr><td><code>sub</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> – <em>y</em></td></tr><tr><td><code>inc</code> <em>x</em></td><td><em>x</em> ← <em>x</em> + 1</td></tr><tr><td><code>dec</code> <em>x</em></td><td><em>x</em> ← <em>x</em> – 1</td></tr><tr><td><code>syscall</code></td><td>调用操作系统例程</td></tr><tr><td><code>db</code></td><td>一个<a href="http://www.nasm.us/xdoc/2.11.02/html/nasmdoc3.html#section-3.2">伪指令</a> 声明字节, 这将是在内存中的程序运行时</td></tr></tbody></table><ul><li><code>cmp</code> 做比较</li><li><code>je</code>如果先前的比较相等则跳转。</li><li><code>jne</code>(如果不等于则跳转)</li><li><code>jl</code>(如果不等于则跳转)</li><li><code>jnl</code>(如果不小于则跳转)</li><li><code>jg</code>(如果大于则跳转)</li><li><code>jng</code>(如果不大于则跳转)</li><li><code>jle</code>(如果小于或等于则跳转)</li><li><code>jnle</code>(如果不小于或等于则跳转)</li><li><code>jge</code>(如果大于或等于则跳转)</li><li><code>jnge</code>(如果不大于或等于则跳转)</li><li><code>equ</code>实际上不是真正的指令。它只是定义了供汇编程序本身使用的缩写。(这是一个意义深远的想法)</li><li>本<code>.bss</code>节适用于<em>可写</em>数据。</li></ul><h3 id="2-2-2-伪指令"><a href="#2-2-2-伪指令" class="headerlink" title="2.2.2. 伪指令"></a>2.2.2. 伪指令</h3><p>伪指令不是 x86&#x2F;x64 机器的真实指令，伪指令是用于给编译器指示如何进行编译。</p><h4 id="2-2-2-1-nasm-定义的-7-种数据-size"><a href="#2-2-2-1-nasm-定义的-7-种数据-size" class="headerlink" title="2.2.2.1. nasm 定义的 7 种数据 size"></a>2.2.2.1. nasm 定义的 7 种数据 size</h4><ul><li>byte ： 8 位</li><li>word ： 16 位</li><li>dword ： 32 位</li><li>qword ： 64 位</li><li>tword ： 80 位</li><li>oword ： 128 位</li><li>yword ： 256 位</li></ul><p>oword 可以对应 Microsoft MASM 的 xmmword 类型，yword 对应 Microsoft MASM 的 ymmword 类型。</p><p>tword, oword 以及 yword 使用在 非整型 数据，使用在 float 和 SSE 型数据。</p><h4 id="2-2-2-2-定义初始化数据：db-家族"><a href="#2-2-2-2-定义初始化数据：db-家族" class="headerlink" title="2.2.2.2. 定义初始化数据：db 家族"></a>2.2.2.2. 定义初始化数据：db 家族</h4><p>nasm 定义了用于初始化上面 7 种 size 的 db 家族，它们用于定义初化常量值。</p><ul><li>db : define byte</li><li>dw ：define word</li><li>dd ：define doubleword</li><li>dq ：define quadword</li><li>dt ：define tword</li><li>do ：define oword</li><li>dy ：define yword</li></ul><p>正如前面所说的：dt , do , dy 不接受整型数值常量，它们被使用在定义 float 或 SSE 数据常量。dt 可以定义 extended-precision float 数据，do 可以定义 quad-precision float，dy 可定义 ymm 数据。而 dq 可以定义 double-precision float 数据，dd 可以定义 single-precision float 数据。</p><h4 id="2-2-2-3-定义非初始化数据：resb-家族"><a href="#2-2-2-3-定义非初始化数据：resb-家族" class="headerlink" title="2.2.2.3. 定义非初始化数据：resb 家族"></a>2.2.2.3. 定义非初始化数据：resb 家族</h4><p>程序中使用到的非初始化数据通常放在 <code>bss section</code> 里，<code>bss</code> 代表 <strong>uninitialized storage space</strong>(如果您试图在一个<code>.text</code>小节中使用它们,将会出现错误)：</p><p>nasm 使用了 resb （reserve byte） 家族来定义非初始化数据。</p><ul><li>resb ：reserve byte</li><li>resw ：reserve word</li><li>resd ：reserve doubword</li><li>resq ：reserve quadword</li><li>rest ：reserve tword</li><li>reso ：reserve oword</li><li>resy ：reserve yword</li></ul><p>resb 相当于 Microsoft MASM 语法中的 db ?</p><p>下面是 NASM Manual 的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buffer:         resb    64              ; reserve 64 bytes</span><br><span class="line">wordvar:        resw    1               ; reserve a word</span><br><span class="line">realarray       resq    10              ; array of ten reals</span><br><span class="line">ymmval:         resy    1               ; one YMM register</span><br></pre></td></tr></table></figure><h3 id="2-3-5-使用-equ-定义常量"><a href="#2-3-5-使用-equ-定义常量" class="headerlink" title="2.3.5 使用 equ 定义常量"></a>2.3.5 使用 equ 定义常量</h3><p>equ 用来为标识符定义一个 整型 常量，它的作用类似 C 语言中的 #define</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a  equ 0                          ; OK</span><br><span class="line">b  equ &#x27;abcd&#x27;                     ; OK! b = 0x64636261</span><br><span class="line">c  equ &#x27;abcdefghi&#x27;                ; warning! c = 0x6867666564636261</span><br><span class="line">d  equ 1.2                        ; error!</span><br><span class="line"></span><br><span class="line">    section .data</span><br><span class="line">string db &#x27;hello,word&#x27;,0</span><br><span class="line">len    equ $-string               ; OK! len = 0x0b</span><br><span class="line"></span><br><span class="line">    section .text</span><br><span class="line">textlen equ  _end - entry         ; OK! textlen = 0x05</span><br><span class="line"></span><br><span class="line">_entry:</span><br><span class="line">    mov ecx, textlen</span><br><span class="line"></span><br><span class="line">_end:</span><br></pre></td></tr></table></figure><p>例子中： b 定义为常量 ‘abcd’ 它将是字符串的 ASCII 码序列，‘abcdefghi’ 常量将会被截断，整型常量最长为 quadword（8 bytes)，而 d 企图被定义为一个 float 常量，这产生会错误。len 和 textlen 被定义为编译期确定的数值。</p><h2 id="2-3-寄存器"><a href="#2-3-寄存器" class="headerlink" title="2.3. 寄存器"></a>2.3. 寄存器</h2><p>您可以将每个寄存器的最低 32 位视为寄存器本身,但可以使用以下名称：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R0D R1D R2D R3D R4D R5D R6D R7D R8D R9D R10D R11D R12D R13D R14D R15D</span><br><span class="line">EAX ECX EDX EBX ESP EBP ESI EDI</span><br></pre></td></tr></table></figure><p>您可以使用以下名称将每个寄存器的最低 16 位看作一个寄存器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R0W R1W R2W R3W R4W R5W R6W R7W R8W R9W R10W R11W R12W R13W R14W R15W</span><br><span class="line">AX CX DX BX SP BP SI DI</span><br></pre></td></tr></table></figure><p>您可以使用以下名称将每个寄存器的最低 8 位看作一个寄存器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R0B R1B R2B R3B R4B R5B R6B R7B R8B R9B R10B R11B R12B R13B R14B R15B</span><br><span class="line">AL CL DL BL SPL BPL SIL DIL</span><br></pre></td></tr></table></figure><p>由于历史原因，<code>R0...R3</code>的第 15 至 8 位被命名为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AH CH DH BH</span><br></pre></td></tr></table></figure><h2 id="2-4-操作数"><a href="#2-4-操作数" class="headerlink" title="2.4. 操作数"></a>2.4. 操作数</h2><h3 id="2-4-1-内存操作数"><a href="#2-4-1-内存操作数" class="headerlink" title="2.4.1. 内存操作数"></a>2.4.1. 内存操作数</h3><ul><li>其实就是几种寻址的方式<ul><li>直接寻址</li><li>寄存器间接寻址</li><li>寄存器相对寻址</li><li>基址加变址</li><li>相对基址加变址</li></ul></li><li>注意：没有立即寻址和寄存器寻址</li></ul><p>这些是寻址的基本形式：</p><ul><li><code>[ number ]</code></li><li><code>[ reg ]</code></li><li><code>[ reg + reg*scale ]</code> <em>小数位数只能是 1、2、4 或 8</em></li><li><code>[ reg + number ]</code></li><li><code>[ reg + reg*scale + number ]</code></li></ul><p>这个数字叫做<strong>位移</strong> ; 普通寄存器称为<strong>基</strong> ; 带有刻度的寄存器称为<strong>索引</strong>。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[750]               ; 仅位移</span><br><span class="line">[rbp]               ; 仅基址寄存器</span><br><span class="line">[rcx + rsi*4]       ; 基数+指数*比例</span><br><span class="line">[rbp + rdx]         ; scale is 1</span><br><span class="line">[rbx-8]             ; 位移-8</span><br><span class="line">[rax + rdi*8 + 500] ; 所有四个组成部分</span><br><span class="line">[rbx + counter]     ; 使用变量&quot;counter&quot;地址作为偏移</span><br></pre></td></tr></table></figure><h3 id="2-4-2-直接操作数"><a href="#2-4-2-直接操作数" class="headerlink" title="2.4.2. 直接操作数"></a>2.4.2. 直接操作数</h3><p>这些可以用多种方式编写。以下是官方文档中的一些示例。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200         ; 十进制数</span><br><span class="line">0200        ; 仍然是十进制-前导0不会使其变为八进制</span><br><span class="line">0200d       ; 显式十进制-d后缀</span><br><span class="line">0d200       ; 也十进制-0d prefex</span><br><span class="line">0c8h        ; 十六进制-h后缀,但是前导0是必需的,因为c8h看起来像var</span><br><span class="line">0xc8        ; hex-经典的0x前缀</span><br><span class="line">0hc8        ; 十六进制-由于某些原因,NASM偏爱0h写法</span><br><span class="line">310q        ; 八进制-q后缀</span><br><span class="line">0q310       ; 八进制-0q前缀</span><br><span class="line">11001000b   ; 二进制-b后缀</span><br><span class="line">0b1100_1000 ; 二进制-0b前缀,顺便说一下,允许使用下划线</span><br></pre></td></tr></table></figure><h2 id="2-5-使用-C-库"><a href="#2-5-使用-C-库" class="headerlink" title="2.5. 使用 C 库"></a>2.5. 使用 C 库</h2><p>仅使用 syscall 编写独立程序就已经很酷了，但很少见。我们想使用 C 库中的好东西。</p><p>为何在 C 语言程序中，看上去都是从 <code>main</code>函数开始执行？这是因为 C library 的内部有<code>_start</code>标签！<code>_start</code>开始处的代码会做一些初始化的工作，然后调用<code>main</code>函数中的代码，最后执行清理工作，最终执行 60 号系统调用以退出。因此，您只需要实现<code>main</code>函数即可，我们可以在汇编语言中实现这么做：</p><p>如果您有 Linux,请尝试以下操作：</p><p>hola.asm</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 使用C库将&quot; Hola,mundo&quot;写入控制台。程序运行在 Linux 或者其他在 C 语言库中不使用下划线的操作系统上。</span><br><span class="line">; 如何编译执行:</span><br><span class="line">; nasm -felf64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span><br><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">global    main</span><br><span class="line">          extern    puts</span><br><span class="line"></span><br><span class="line">          section   .text</span><br><span class="line">main:                                       ; 这里被 C library初始化代码所调用</span><br><span class="line">          mov       rdi, message            ; rdi中的第一个整数(或指针)参数</span><br><span class="line">          call      puts                    ; puts(message)</span><br><span class="line">          ret                               ; 由 main 函数返回 C 语言库例程</span><br><span class="line">message:</span><br><span class="line">          db        &quot;Hola, mundo&quot;, 0        ; 注意字符串必须在C中以0结尾</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nasm -felf64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span><br><span class="line">Hola, mundo</span><br></pre></td></tr></table></figure><h2 id="2-6-字符常量"><a href="#2-6-字符常量" class="headerlink" title="2.6. 字符常量"></a>2.6. 字符常量</h2><p>在 nasm 中，可以使用 3 种引号来提供字符</p><ul><li>’ …’ （单引号）</li><li>” …” （双引号）</li><li><code> …</code> （反引号）</li></ul><p>如下示例，它们的结果是一样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db  &#x27;abcd&#x27;</span><br><span class="line">db  &quot;abcd&quot;</span><br><span class="line">db  `abcd`</span><br></pre></td></tr></table></figure><h1 id="3-实践-OS-lab1"><a href="#3-实践-OS-lab1" class="headerlink" title="3. 实践 - OS lab1"></a>3. 实践 - OS lab1</h1><ul><li>使用 nasm 实现大数加法和乘法</li></ul><h2 id="3-1-思路"><a href="#3-1-思路" class="headerlink" title="3.1. 思路"></a>3.1. 思路</h2><ul><li><p>输入输出</p><ul><li>需要熟悉 Linux 系统调用（ics 教过）</li><li>需要熟悉寄存器的使用</li><li>打印 int 数组需要 itoa</li></ul></li><li><p>加法</p><ul><li>按位加，细节略</li></ul></li><li><p>减法</p><ul><li>找出绝对值较大者，计算<code>dest - src // (abs(dest) &gt; abs(src))</code></li><li>按位减，每次减要考虑借位，其他细节略</li></ul></li><li><p>乘法</p><ul><li><p>$$<br>基本原理：<br>\Sigma_{i+j&#x3D;k}(a_i \times b_j) &#x3D; c_k<br>$$</p></li><li><p>先按位乘，最后再统一 normalize</p></li></ul></li><li><p>技巧</p><ul><li>string 转 int 数组后倒序存储，方便 int 数组正序遍历</li><li>比如<code>&quot;123&quot;</code>，存储为<code>[3, 2, 1]</code></li></ul></li></ul><h2 id="3-2-踩坑"><a href="#3-2-踩坑" class="headerlink" title="3.2. 踩坑"></a>3.2. 踩坑</h2><ul><li>jmp 的函数无须 ret！！！<ul><li>否则即使 push 的已全部 pop，ret 仍会 segmentation fault</li></ul></li><li>调用栈的使用</li><li>ebp 用 leave 弹出</li><li>intel 语法（nasm）的 mov 不接受两个 opcode</li><li>.bss 和.data 定义出的是指针</li><li>区分字符（’1’）和数字（0x1）</li><li>loop 循环不可轻易 jmp 到压栈代码段（除非是设计好的）</li><li>gdb 和 objdump 结合的使用</li><li>每次循环后要清空bss和寄存器</li></ul><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h1><p><a href="https://github.com/zhangjunlei26/NASM-Tutorial-CN">zhangjunlei26&#x2F;NASM-Tutorial-CN: Nasm 指南中文 (NASM Tutorial) (github.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/263102219">NASM 与 GDB 的使用指南：如何编好你的汇编 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/jadeshu/article/details/89159196">(29 条消息) nasm 汇编讲解_jadeshu 的博客-CSDN 博客_nasm</a></p><p>[学习 nasm 语言-阿里云开发者社区 (aliyun.com)](<a href="https://developer.aliyun.com/article/25221#:~:text=%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8">https://developer.aliyun.com/article/25221#:~:text=代码中使用</a> byte 关键字对 memory 操作数进行了修饰，指明 memory 操作数的大小为 byte,语法）有些不同， masm 的语法是： 在 masm 语法中需配合 ptr 指示字。)</p><p><a href="https://zhuanlan.zhihu.com/p/297925056">GDB 使用详解 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/u014470361/article/details/102230583">(29 条消息) GDB 调试查看内存数据_夜风~的博客-CSDN 博客_gdb 查看内存数据</a></p><p><a href="https://blog.csdn.net/weixin_44395686/article/details/104727314">(29 条消息) 使用 GDB 查看和修改寄存器的值_@HDS 的博客-CSDN 博客_gdb 查看寄存器的值</a></p><p><a href="http://www.bytekits.com/nasm/system-callback.html">Nasm 系统调用 - 字节流 (bytekits.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> nasm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iPad + RD client 实现 Win10 远程控制</title>
      <link href="/article/Win10-RD-client/"/>
      <url>/article/Win10-RD-client/</url>
      
        <content type="html"><![CDATA[<p>由于游戏本不便携 + 续航差；而 ipad 正好完美弥补了上述缺点。某日下午上课正好看到朋友在用远程桌面记笔记，遂请教之，晚上回宿舍后倒腾出了本篇记录。</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027202123527.png" alt="image-20221027202123527" style="zoom:60%;"><h2 id="1-开启-Win10-远程桌面功能"><a href="#1-开启-Win10-远程桌面功能" class="headerlink" title="1. 开启 Win10 远程桌面功能"></a>1. 开启 Win10 远程桌面功能</h2><ul><li>前往<a href="https://github.com/stascorp/rdpwrap/releases%E4%B8%8B%E8%BD%BD%E5%8E%8B%E7%BC%A9%E5%8C%85%EF%BC%88%E6%9C%80%E6%96%B0%E7%89%88%E5%8D%B3%E5%8F%AF%EF%BC%89">https://github.com/stascorp/rdpwrap/releases下载压缩包（最新版即可）</a></li><li>解压得到如下文件</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027191109863.png" alt="image-20221027191109863"></p><ul><li><p>管理员权限运行 install.bat 文件，然后双击 RDPConf.exe 。正常应该是全绿，可以看到我这里第三行报错。<img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027191413015.png" alt="image-20221027191413015"></p></li><li><p>找到上图框出版本号的 rdpwrap.ini 文件，下载后将其复制到 C:\Program Files\RDP Wrapper 中。**<em>注意：复制之前一定要先关闭 Remote Desktop Services 服务，复制完成之后在打开 Remote Desktop Services 服务</em>**</p><ul><li>关闭 Remote Desktop Services 方法：右击此电脑-&gt;管理-&gt;服务与应用程序-&gt;服务-&gt;选择 Remote Desktop Services -&gt;关闭</li></ul></li><li><p>随后再次双击 RDPConf.exe 可以看到启动成功</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027191623785.png" alt="image-20221027191623785"></p><h2 id="2-服务器内网穿透"><a href="#2-服务器内网穿透" class="headerlink" title="2. 服务器内网穿透"></a>2. 服务器内网穿透</h2><h3 id="2-1-服务端"><a href="#2-1-服务端" class="headerlink" title="2.1. 服务端"></a>2.1. 服务端</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://ghproxy.com/https://github.com/fatedier/frp/releases/download/v0.45.0/frp_0.45.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf frp_0.45.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">cd frp_0.45.0_linux_amd64</span><br></pre></td></tr></table></figure><ul><li>编辑 frps.ini</li></ul><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_addr</span> = xxx.xxx.xxx.xxx  <span class="comment">##云服务器内网ip</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">auto_token</span> = username</span><br><span class="line"><span class="attr">dashboard_user</span> = admin</span><br><span class="line"><span class="attr">dashboard_pwd</span> = admin</span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br></pre></td></tr></table></figure><ul><li><p>执行如下命令 后台持续运行此任务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure><p>打开浏览器输入<code>xx.xx.xx.xx(云服务器公网ip):7500</code>（需要提前放行 3389、7000、7500 端口）</p><p>出现如下画面即配置成功。</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027194029822.png" alt="image-20221027194029822"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027192439031.png" alt="image-20221027192439031"></p><h3 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2. 客户端"></a>2.2. 客户端</h3><p>进入 <a href="https://github.com/fatedier/frp/releases">Releases · fatedier&#x2F;frp (github.com)</a>下载如下版本</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027194215035.png" alt="image-20221027194215035"></p><p>将刚才 github 上下载的 frp_0.44.0_windows_amd64.zip 解压出来，编辑文件夹中的 frpc.ini，直接用记事本打开即可，复制以下字段保存。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = xxx.xxx.xxx.xxx ##服务器公网ip</span><br><span class="line">bind_port = 7000</span><br><span class="line">auto_token = username</span><br><span class="line"></span><br><span class="line">[username]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 3389</span><br><span class="line">remote_port = 3390</span><br></pre></td></tr></table></figure><p><strong>注意：server_addr 字段为云服务器公网 ip，这里的 bind_port，auto_token 需要与 frps.ini 文件中的 bind_port，auto_token 匹配。</strong></p><p>进入 frp 目录打开 cmd 命令窗口，启动 frp 客户端服务<code>.\frpc.exe -c frpc.ini</code> ，出现如下提示即配置成功！</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027192357724.png" alt="image-20221027192357724"></p><h4 id="2-2-1-脚本启动-frp-客户端服务"><a href="#2-2-1-脚本启动-frp-客户端服务" class="headerlink" title="2.2.1. 脚本启动 frp 客户端服务"></a>2.2.1. 脚本启动 frp 客户端服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%1&quot;</span> == <span class="string">&quot;h&quot;</span> goto begin</span><br><span class="line">mshta vbscript:createobject(<span class="string">&quot;wscript.shell&quot;</span>).run(<span class="string">&quot;&quot;</span><span class="string">&quot;%~nx0&quot;</span><span class="string">&quot; h&quot;</span>,0)(window.close)&amp;&amp;<span class="built_in">exit</span></span><br><span class="line">:begin</span><br><span class="line">REM</span><br><span class="line"><span class="built_in">cd</span> &amp;&#123;你的 frp 安装路径&#125;</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>将以上代码新建为<code>frp.bat</code>文件，双击即可运行。</p><p>如果想关闭进程，就<code>Ctrl + shift + esc</code>打开资源管理器关闭一个叫<code>frpc</code>的进程。</p><hr><h2 id="3-参考资料："><a href="#3-参考资料：" class="headerlink" title="3. 参考资料："></a>3. 参考资料：</h2><p><a href="https://zhuanlan.zhihu.com/p/572216097">iPad 远程登录 windows 主机（内网穿透 RD client 版） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/339089087">利用 iPad 的 RD client 软件远程控制 PC - 知乎 (zhihu.com)</a></p><p><a href="https://www.johng-mit.cn/technology/rdp/">使用 RD Client + frp 内网穿透实现 iPad 远程控制 - 杂项 - 技术 | Feast &#x3D; 身如蘆葦 &#x3D; 人間似夢 (johng-mit.cn)</a></p><p><strong><em>特别感谢：zzb 同学</em></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> RD client </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 7. Join Algorithms</title>
      <link href="/article/CMU-15-445-7-Join-Algorithms/"/>
      <url>/article/CMU-15-445-7-Join-Algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="7-Join-Algorithms"><a href="#7-Join-Algorithms" class="headerlink" title="7. Join Algorithms"></a>7. Join Algorithms</h1><ul><li>为什么需要 join</li></ul><p>由于为消除 table 中信息的冗余，我们会采取<strong>normalize</strong>来使得数据库 table 的设计符合一定范式，但是之后需要使用<strong>join</strong>来重建原来的 tuple</p><p>一般使用<strong>inner equijoin</strong>,<strong>inner equijoin</strong>连接两张表中 key 相同的 tuple。其他 join 算法可以通过该算法调整得到</p><h2 id="7-1-Join-operator-output"><a href="#7-1-Join-operator-output" class="headerlink" title="7.1. Join operator output"></a>7.1. Join operator output</h2><ul><li>copy outer 和 inner tuples 的 attributes into a new tuple.</li><li>Subsequent operators in the query plan never need to go back to the base tables to get more data.</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930094703596.png" alt="image-20220930094703596"></p><ul><li><p>两种处理方式</p><ul><li>可以在 Join 的时候将所有非 Join Attributes 都放入新的 tuple 中，这样 Join 之后的操作都不需要从 tables 中重新获取数据</li></ul><p>![image](<a href="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-La5GNw04x8dghkKNnFu%2F-La5KYkuE3zEy5hImXRs%2FScreen">https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-La5GNw04x8dghkKNnFu%2F-La5KYkuE3zEy5hImXRs%2FScreen</a> Shot 2019-03-16 at 7.49.45 PM.jpg?alt&#x3D;media&amp;token&#x3D;5d9c0b76-0bd8-4224-b105-52edd6b2cb79)</p><ul><li>也可以在 Join 的时候只复制 Join Attributes 以及 record id，后续操作自行根据 record id 去 tables 中获取相关数据。对于列存储数据库，这是比较理想的处理方式，被称为 <strong>Late Materialization</strong>。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930095130571.png" alt="image-20220930095130571"></p></li></ul><h2 id="7-2-Cost-analysis"><a href="#7-2-Cost-analysis" class="headerlink" title="7.2. Cost analysis"></a>7.2. Cost analysis</h2><ul><li>由于数据库中的数据量通常较大，无法一次性载入内存，因此 Join Algorithm 的设计目的，在于减少磁盘 I&#x2F;O，因此我们衡量 Join Algorithm 好坏的标准，就是 I&#x2F;O 的数量。此外我们不需要考虑 Join 结果的大小，因为不论使用怎样的 Join Algorithm，结果集的大小都一样。</li><li>用笛卡尔积加谓词筛选实现 join 非常低效</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/1743182-20220227162356973-2142439747.png" alt="image"></p><h2 id="7-3-Nested-Loop-Join"><a href="#7-3-Nested-Loop-Join" class="headerlink" title="7.3. Nested Loop Join"></a>7.3. Nested Loop Join</h2><h3 id="7-3-1-分类"><a href="#7-3-1-分类" class="headerlink" title="7.3.1. 分类"></a>7.3.1. 分类</h3><ul><li>其实就是嵌套 for 循环</li><li>Stupid nested loop join<ul><li>效率极其低下</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930103128904.png" alt="image-20220930103128904"></p><ul><li>Block nested loop join<ul><li>更少的磁盘 IO</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930103647389.png" alt="image-20220930103647389"></p><ul><li>Index nested loop join</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930103932165.png" alt="image-20220930103932165"></p><h3 id="7-3-2-总结"><a href="#7-3-2-总结" class="headerlink" title="7.3.2. 总结"></a>7.3.2. 总结</h3><ul><li>总是选择较小的 table 作为 outer table（因为较小 table 是作为乘数）</li><li>尽可能多的缓存 outer table 到 buffer 里</li><li>扫描 Inner Table 时，尽量使用索引</li></ul><h2 id="7-4-Sort-Merge-Join"><a href="#7-4-Sort-Merge-Join" class="headerlink" title="7.4. Sort-Merge Join"></a>7.4. Sort-Merge Join</h2><h3 id="7-4-1-Sort"><a href="#7-4-1-Sort" class="headerlink" title="7.4.1. Sort"></a>7.4.1. Sort</h3><ul><li>对 join key(s)进行排序</li></ul><h3 id="7-4-2-Merge"><a href="#7-4-2-Merge" class="headerlink" title="7.4.2. Merge"></a>7.4.2. Merge</h3><ul><li>用 cursors 扫描两个排好序的表，然后 emit key(s)匹配的 tuples</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930104754006.png" alt="image-20220930104754006"></p><h2 id="7-5-Hash-Join"><a href="#7-5-Hash-Join" class="headerlink" title="7.5. Hash Join"></a>7.5. Hash Join</h2><h3 id="7-5-1-Build"><a href="#7-5-1-Build" class="headerlink" title="7.5.1. Build"></a>7.5.1. Build</h3><ul><li>扫描外表，然后使用哈希函数<em>h1</em>在 join attributes 上生成一个哈希表</li></ul><h3 id="7-5-2-Probe"><a href="#7-5-2-Probe" class="headerlink" title="7.5.2. Probe"></a>7.5.2. Probe</h3><ul><li>扫描内标，然后在每个 tuple 上使用<em>h1</em>，跳转到哈希表上并找到匹配的 tuple</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930105402810.png" alt="image-20220930105402810"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 6. Query Execution</title>
      <link href="/article/CMU-15-445-6-Query-Execution/"/>
      <url>/article/CMU-15-445-6-Query-Execution/</url>
      
        <content type="html"><![CDATA[<h1 id="6-Query-Execution"><a href="#6-Query-Execution" class="headerlink" title="6. Query Execution"></a>6. Query Execution</h1><ul><li>how to execute queries using table heaps and indexes.</li></ul><h2 id="6-1-Query"><a href="#6-1-Query" class="headerlink" title="6.1. Query"></a>6.1. Query</h2><ul><li>Query operators are arranged in a tree.</li><li>数据从底层向根节点流动</li><li>根节点的输出为 query 的输出</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929143456391.png" alt="image-20220929143456391"></p><h2 id="6-2-Sorting"><a href="#6-2-Sorting" class="headerlink" title="6.2. Sorting"></a>6.2. Sorting</h2><ul><li>我们在 query 时，时常需要 retrieve tuples in a specific order</li><li>但是 data 通常 not fit in memory（有时需要向磁盘 IO）。我们需要用一种能考虑到 IO 开销的技术</li><li>需要排序算法的原因：<strong>本质在于 tuples 在 table 中没有顺序</strong>，无论是用户还是 DBMS 本身，在处理某些任务时希望 tuples 能够按一定的顺序排列，如：<ul><li>若 tuples 已经排好序，去重操作将变得很容易（DISTINCT)</li><li>批量将排好序的 tuples 插入到 B+ Tree index 中，速度更快</li><li>Aggregations (GROUP BY)</li></ul></li></ul><h3 id="6-2-1-External-Merge-Sort"><a href="#6-2-1-External-Merge-Sort" class="headerlink" title="6.2.1. External Merge Sort"></a>6.2.1. External Merge Sort</h3><p>思想是分治，就是把大数据分成独立的 <strong>*runs*</strong> 再分别 sort 它们。它们可以写回到硬盘，也可以读出来。这个算法包含两步： <strong>Phase #1 - Sorting：</strong> 首先算法会 sort 可以放在内存的小 chunk，然后写回到硬盘中。 <strong>Phase #2 - Merge：</strong> 然后合并这些子文件到一个大的单独文件中。</p><ul><li>Divide-and-conquer sorting（分治排序）<ul><li>先排序：将数据分为多个 chunk，每个 chunk 可以 fit in main-memory，然后将它们排序，再将排好序的 data 写回 disk</li><li>再合并：将排好的 data 合并成一个 larger file</li></ul></li><li>复杂度：见 ppt</li></ul><h4 id="6-2-1-1-2-Way-External-Merge-Sort"><a href="#6-2-1-1-2-Way-External-Merge-Sort" class="headerlink" title="6.2.1.1. 2-Way External Merge Sort"></a>6.2.1.1. 2-Way External Merge Sort</h4><ul><li><p>“2” represents the number of runs that we are going to merge into a new run for each pass.</p></li><li><p>假设：</p><ul><li>Files 本分成 N 个 pages</li><li>DBMS 有 B 个 fixed-size buffers</li></ul></li><li><p><em>Pass #0</em></p><ul><li>从 table 中读入 B pages tuples</li><li>将这些 tuples 排序后<strong>写回</strong>到 disk 中</li><li>每一轮成为一个 run</li></ul></li><li><p><em>Pass #1,2,3,…</em></p></li><li><p>递归地将一对 runs 合并成一个两倍长度的 run</p></li><li><p>这一操作值需要 3 个 buffer pages ( 2 个用于输入，1 个用于输出)</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929145647966.png" alt="image-20220929145647966"></p><h5 id="6-2-1-1-2-双重-buffering-优化"><a href="#6-2-1-1-2-双重-buffering-优化" class="headerlink" title="6.2.1.1.2. 双重 buffering 优化"></a>6.2.1.1.2. 双重 buffering 优化</h5><ul><li>当系统在处理当前 run 的时候，提前将下一次 run 取进第二个 buffer。<ul><li>通过充分利用 disk，减少等待 IO 的时间。</li></ul></li></ul><h4 id="6-2-1-2-General-External-Merge-Sort"><a href="#6-2-1-2-General-External-Merge-Sort" class="headerlink" title="6.2.1.2. General External Merge Sort"></a>6.2.1.2. General External Merge Sort</h4><ul><li>就是把 2-way 泛化成 N-way，充分利用磁盘空间</li></ul><h3 id="6-2-2-Using-B-Tree"><a href="#6-2-2-Using-B-Tree" class="headerlink" title="6.2.2. Using B+ Tree"></a>6.2.2. Using B+ Tree</h3><ul><li>如果需要排序的属性已经有了 B+树索引，我们可以用 B+树来加速排序</li></ul><h2 id="6-3-Aggregation"><a href="#6-3-Aggregation" class="headerlink" title="6.3. Aggregation"></a>6.3. Aggregation</h2><p>aggregation 就是对一组 tuples 的某些值做统计，转化成一个标量，如平均值、最大值、最小值等，aggregation 的实现通常有两种方案：</p><ul><li>Sorting</li></ul><p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-L_joWM39KHaJfccjyzE%2F-L_kEY93VltutLrspExH%2FScreen%20Shot%202019-03-12%20at%2012.51.50%20PM.jpg?alt=media&token=8f780e68-b277-48d4-93b6-ce7ffb61a217" alt="image"></p><ul><li><h2 id="Hashing-不需要排序-在-DBMS-扫描的时候填冲一个暂时的-hash-table，对于每一个-record，检查它是否已经存在于-hash-table-DISTINCT：丢弃-GROUP-BY：进行聚合计算"><a href="#Hashing-不需要排序-在-DBMS-扫描的时候填冲一个暂时的-hash-table，对于每一个-record，检查它是否已经存在于-hash-table-DISTINCT：丢弃-GROUP-BY：进行聚合计算" class="headerlink" title="Hashing- 不需要排序- 在 DBMS 扫描的时候填冲一个暂时的 hash table，对于每一个 record，检查它是否已经存在于 hash table  - DISTINCT：丢弃  - GROUP BY：进行聚合计算"></a>Hashing<br>- 不需要排序<br>- 在 DBMS 扫描的时候填冲一个暂时的 hash table，对于每一个 record，检查它是否已经存在于 hash table<br>  - DISTINCT：丢弃<br>  - GROUP BY：进行聚合计算</h2></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 5. Index Concurrency Control</title>
      <link href="/article/CMU-15-445-5-Index-Concurrency-Control/"/>
      <url>/article/CMU-15-445-5-Index-Concurrency-Control/</url>
      
        <content type="html"><![CDATA[<h1 id="5-Index-Concurrency-Control"><a href="#5-Index-Concurrency-Control" class="headerlink" title="5. Index Concurrency Control"></a>5. Index Concurrency Control</h1><h2 id="5-1-concurrency（并发）"><a href="#5-1-concurrency（并发）" class="headerlink" title="5.1. concurrency（并发）"></a>5.1. concurrency（并发）</h2><p>A concurrency control protocol 的正确性标准在于：</p><ul><li>logical correctness：线程必须能够完整正确的看到其应该看到的数据</li><li>physical correctness：数据内部是否完整合理，比如一个数据结构指针不会指向非法的内存地址</li></ul><h2 id="5-2-Lock-Latches"><a href="#5-2-Lock-Latches" class="headerlink" title="5.2. Lock &amp; Latches"></a>5.2. Lock &amp; Latches</h2><ul><li><p>Lock：</p><p>是一个高层，逻辑上的原语，其在事务之间保护数据库的内容。</p><ul><li><p>保护数据库中的逻辑内容</p><ul><li>逻辑内容可以是 tuple、tuple set、table、db</li></ul></li><li><p>一个 txn(transaction 的简写)会<strong>全程</strong>持有 lock</p></li><li><p>在查询执行时，数据库可以将 lock 暴露给用户</p></li><li><p>lock 需要能够回滚变化，比如说，如果一个被 lock 锁上的 tuple 被修改了，这次修改可以回滚</p></li></ul></li><li><p>Latch(有时又叫 mutex)：</p><p>是一个底层保护原语，在线程之间，其用来保护 DBMS 内部数据结构的关键区域(比如，数据结构，内存区域)</p><ul><li><p>latch 只有在操作执行的时候才会持有</p></li><li><p>latch 并不需要能够回滚数据，因为 latch 所尝试进行的操作本质上是原子性操作</p></li><li><p>存在两种 latch mode</p><ul><li><strong>READ：</strong>多个线程可以同时读，也就是线程可以持有<strong>read latch</strong>，即使是其他线程也持有<strong>read latch</strong></li></ul></li></ul></li><li><p><strong>WRITE：</strong>对于<strong>write latch</strong>，当一个 thread 持有时，其他 thread 就不能持有</p></li></ul><h3 id="5-2-1-Latch-的实现"><a href="#5-2-1-Latch-的实现" class="headerlink" title="5.2.1. Latch 的实现"></a>5.2.1. Latch 的实现</h3><ul><li>Blocking OS Mutex</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929123045453.png" alt="image-20220929123045453"></p><ul><li>Test-and-Set Spin Latch</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929123101195.png" alt="image-20220929123101195"></p><ul><li>Reader-Writer Latches</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929123141190.png" alt="image-20220929123141190"></p><p><a href="https://www.cnblogs.com/mlmz/p/15935749.html">CMU15445 Lecture 9 Index Concurrency Control - 抿了抿嘴丶 - 博客园 (cnblogs.com)</a></p><ul><li>其实正式的读写线程调度取决于上下文和使用策略。不能一昧的读优先，因为这样可能造成写进程 starvation。</li></ul><h3 id="5-2-2-Hash-Table-Latching"><a href="#5-2-2-Hash-Table-Latching" class="headerlink" title="5.2.2. Hash Table Latching"></a>5.2.2. Hash Table Latching</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221022165348816.png" alt="image-20221022165348816"></p><ul><li><p>区别是 latches 的粒度，后者更小。</p><ul><li>前者方便，但减少并行性：因为无法让两个线程同时操作不同的 slot</li><li>后者并行性更高。付出的代价更高：因为扫描每个 slot 都要获取 latch</li></ul></li><li><p>在 hash table 中，由于线程都是从上往下（同方向）扫描，因此不用考虑死锁的问题</p><ul><li>即来自另一个方向的线程在我争抢该处写锁前就将内容修改，无法保证数据一致性，即前一条线程刚修改完，但我之前刚通过读锁读了数据，修改的数据是在原来的数据上进行的，此时，如果不重新读，事务会出现问题，所以就需要做更多考虑了，如果都是从上往下的，那就无须考虑这点</li></ul></li></ul><h3 id="5-2-3-B-Tree-Latching"><a href="#5-2-3-B-Tree-Latching" class="headerlink" title="5.2.3. B+ Tree Latching"></a>5.2.3. B+ Tree Latching</h3><ul><li><p>这里的情况更复杂。比如有一条线程可能正在遍历 B+Tree，接着在它到达叶子结点之前，另一条线程对 B+Tree 进行了修改，这引起了节点间的拆分与合并。使得 B+Tree 中节点的位置可能会有所移动，我所查找的数据可能就并不在原来的位置上了，甚至在最糟糕的情况下，指针指向了内存中的一个无效内存地址，导致 segmentation fault，并且程序崩溃。</p></li><li><p>如何处理？</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221022203308518.png" alt="image-20221022203308518"></p><ul><li>即 latch crabbing 或者 latch doubling<ul><li>一种允许多条线程在同一时间访问 B+ Tree 的技术</li><li>在任何时候，当我们在一个节点中时，我们必须在该节点上挂一个 latch，不管是写模式还是读模式的 latch 都可以。</li><li>接着，在我们跳到我们的孩子节点之前，我们要拿到我们孩子节点上的 latch，以及我们想要到达的下一个节点的 latch。</li><li>然后，当我们落到那个孩子节点上时，我们要对它里面的内容进行测试。如果我们判断出来移到到该孩子节点是安全的话，那么，对我们来说将父节点上的 latch 释放掉是 ok 的。<ul><li>如何判断安全？<ul><li>如果我们要进行一次修改，我们所在的节点无须进行拆分或合并操作，也不用去管在它下面所发生的事情</li></ul></li></ul></li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221022203812729.png" alt="image-20221022203812729"></p><ul><li>例子</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221022204015361.png" alt="image-20221022204015361"></p><ul><li>A -&gt; B：不安全，不释放 A latch</li><li>B -&gt; D：安全，因为 D 已满（相反，如果是 insert 操作，则 D 不满才是安全的），不管 D 下面发生了什么，都不会影响到 B 和 A，可以释放 B 和 A 的 latches</li><li>D -&gt; H：安全，释放 D 的 latch，删除完后，释放 H</li></ul><p>基本上来讲，在 B+Tree 中，当线程往下进行遍历时，线程会通过一个 stack 来保存它一路上所持有的 latch</p><p>在某个时间点，当我在一个安全的节点处时，我就可以释放掉该节点之前所有节点上的 latch</p><ul><li>注意：释放时：想尽量快的先释放更上层的 latch，因为这样可以尽快减小 latch 对其他线程的影响。但是由于是栈结构，所以还是 FILO</li></ul><h3 id="5-2-4-乐观和悲观"><a href="#5-2-4-乐观和悲观" class="headerlink" title="5.2.4. 乐观和悲观"></a>5.2.4. 乐观和悲观</h3><ul><li>但是这样的锁机制存在着一个问题：每个线程访问 B+树时都需要在根节点获得 write latch。但是 W latch 是独占的，会造成并发性的性能瓶颈。</li><li>因此会有乐观锁：<ul><li>乐观地假设我不会去进行任何拆分操作，向下访问 B+Tree 的时候，我所采用的是 read latch，而不是 write latch。然后，我在对叶子节点进行处理时，会使用 write latch。</li><li>如果我判断出我并不需要进行拆分的话，that’s good. 如果我在进行拆分或合并操作时犯错了，那么，我直接终止操作，并在根节点处重启该操作，在向下遍历的时候获取 write latch</li><li>这样可以有效避免，非拆分合并操作占用非叶子结点 W latch 造成性能瓶颈的情况：因为非拆分合并操作不会造成非叶子结点的变化</li></ul></li></ul><h2 id="5-3-Observation"><a href="#5-3-Observation" class="headerlink" title="5.3. Observation"></a>5.3. Observation</h2><ul><li><p>目前所有的遍历都是从上到下。如果有从左到右的遍历呢？</p></li><li><p>如果是 Write 操作，可能会存在死锁问题</p></li><li><p>解决方法：中断其中之一</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 3. Hash Table</title>
      <link href="/article/CMU-15-445-3-Hash-Table/"/>
      <url>/article/CMU-15-445-3-Hash-Table/</url>
      
        <content type="html"><![CDATA[<h1 id="3-Hash-Table"><a href="#3-Hash-Table" class="headerlink" title="3. Hash Table"></a>3. Hash Table</h1><p>[CMU-15-445 Lecture 6 Hash Tables - 知乎 (zhihu.com)</p><h2 id="3-1-Hash-Function"><a href="#3-1-Hash-Function" class="headerlink" title="3.1. Hash Function"></a>3.1. Hash Function</h2><h2 id="3-2-Hash-Scheme"><a href="#3-2-Hash-Scheme" class="headerlink" title="3.2. Hash Scheme"></a>3.2. Hash Scheme</h2><h3 id="3-2-1-static-hash-scheme"><a href="#3-2-1-static-hash-scheme" class="headerlink" title="3.2.1. static hash scheme"></a>3.2.1. static hash scheme</h3><h4 id="3-2-1-1-线性"><a href="#3-2-1-1-线性" class="headerlink" title="3.2.1.1. 线性"></a>3.2.1.1. 线性</h4><h4 id="3-2-1-2-Robin-Hood-Hashing"><a href="#3-2-1-2-Robin-Hood-Hashing" class="headerlink" title="3.2.1.2. Robin Hood Hashing"></a>3.2.1.2. Robin Hood Hashing</h4><ul><li>不清晰，需要学习一下</li></ul><h4 id="3-2-1-3-Cuckoo-Hashing"><a href="#3-2-1-3-Cuckoo-Hashing" class="headerlink" title="3.2.1.3. Cuckoo Hashing"></a>3.2.1.3. Cuckoo Hashing</h4><ul><li>多个 hash 表，对应不同的 hash function</li></ul><p>上述谈论的 3 种方案都是静态哈希，这就意味着哈希表的大小是固定的，我们必须提前知道我们想要保存的 key 的大概数量，这样才能知道如何分配空间使得其足够容纳并能最小化哈希碰撞。但是现实没有那么理想，一旦超过容量，就要扩容。扩容并非是直接 append 一段内存，一般来说得重建整个哈希表并迁移。当我们谈到分布式数据库时我们还会谈到一致性哈希算法，这个算法无需调整大小（令人期待的算法）。但是对于单机数据库中的哈希表，我们还是得重新构建，这也是动态的哈希所要解决的问题。</p><h3 id="3-2-2-dynamic-hash-scheme"><a href="#3-2-2-dynamic-hash-scheme" class="headerlink" title="3.2.2. dynamic hash scheme"></a>3.2.2. dynamic hash scheme</h3><h4 id="3-2-2-1-Chained-Hashing"><a href="#3-2-2-1-Chained-Hashing" class="headerlink" title="3.2.2.1. Chained Hashing"></a>3.2.2.1. Chained Hashing</h4><h4 id="3-2-2-2-Extendible-Hashing"><a href="#3-2-2-2-Extendible-Hashing" class="headerlink" title="3.2.2.2. Extendible Hashing"></a>3.2.2.2. Extendible Hashing</h4><ul><li>妙，但不好理解。多看看</li></ul><h4 id="3-2-2-3-Linear-Hashing"><a href="#3-2-2-3-Linear-Hashing" class="headerlink" title="3.2.2.3. Linear Hashing"></a>3.2.2.3. Linear Hashing</h4><h3 id="3-2-3-布隆过滤器"><a href="#3-2-3-布隆过滤器" class="headerlink" title="3.2.3. 布隆过滤器"></a>3.2.3. 布隆过滤器</h3><ul><li>这篇文章写的很好</li></ul><p><a href="https://developer.aliyun.com/article/773205">布隆过滤器，这一篇给你讲的明明白白-阿里云开发者社区 (aliyun.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 2. Buffer Pools</title>
      <link href="/article/CMU-15-445-2-Buffer-Pools/"/>
      <url>/article/CMU-15-445-2-Buffer-Pools/</url>
      
        <content type="html"><![CDATA[<h1 id="2-Buffer-Pools"><a href="#2-Buffer-Pools" class="headerlink" title="2. Buffer Pools"></a>2. Buffer Pools</h1><p><a href="https://www.jianshu.com/p/fecd0358cd29">【学习笔记 3】数据库中的 buffer pool - 简书 (jianshu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/364322857">CMU 15445 学习笔记——Buffer Pool - 知乎 (zhihu.com)</a></p><ul><li>这段内存完全是由数据库控制而不是操作系统</li><li>类似于数据库的内存</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220927172727486.png" alt="image-20220927172727486"></p><h2 id="2-1-Lock-和-Latch"><a href="#2-1-Lock-和-Latch" class="headerlink" title="2.1. Lock 和 Latch"></a>2.1. Lock 和 Latch</h2><ul><li><p>lock 更高级，保护高级内容 from other transaction。</p></li><li><p>事务运行时持有 lock</p></li><li><p>要求能够回滚 changes</p></li><li><p>可以暴露给开发人员</p></li><li><p>latch 是更底层的概念，来保护数据结构和内存</p></li><li><p>不需要能够回滚 changes</p></li><li><p>有点类似 mutex（互斥锁）</p></li></ul><h2 id="2-2-page-table-和-page-directory"><a href="#2-2-page-table-和-page-directory" class="headerlink" title="2.2. page table 和 page directory"></a>2.2. page table 和 page directory</h2><ul><li>page directory<ul><li>page id 到数据库文件中的 page location 的映射</li><li>所有 changes 必须持久化</li></ul></li><li>page table<ul><li>page id 到 buffer pool frames 中 page copy 的银蛇</li><li>内存中的数据，不需要在磁盘中保存</li></ul></li></ul><h2 id="2-3-buffer-pool-optimization"><a href="#2-3-buffer-pool-optimization" class="headerlink" title="2.3. buffer pool optimization"></a>2.3. buffer pool optimization</h2><h3 id="2-3-1-Multiple-Buffer-Pool"><a href="#2-3-1-Multiple-Buffer-Pool" class="headerlink" title="2.3.1. Multiple Buffer Pool"></a>2.3.1. Multiple Buffer Pool</h3><ul><li>有多个 buffer pool</li><li>在每个 buffer pool 有局部策略</li><li>比如对每个表都有一个 buffer pool</li><li>可以一定程度缓解多线程争抢 latch 的场景</li></ul><p>Approach Methods：</p><h4 id="2-3-1-1-Object-Id"><a href="#2-3-1-1-Object-Id" class="headerlink" title="2.3.1.1. Object Id"></a>2.3.1.1. Object Id</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928103255171.png" alt="image-20220928103255171"></p><h4 id="2-3-1-2-Hashing"><a href="#2-3-1-2-Hashing" class="headerlink" title="2.3.1.2. Hashing"></a>2.3.1.2. Hashing</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928103318990.png" alt="image-20220928103318990"></p><h3 id="2-3-2-pre-fetching"><a href="#2-3-2-pre-fetching" class="headerlink" title="2.3.2. pre-fetching"></a>2.3.2. pre-fetching</h3><ul><li><p>为了最小化磁盘 IO 的影响</p></li><li><p>pre-fetching 的方法</p><ul><li>Sequential Scans</li><li>Index Scans</li></ul></li></ul><h3 id="2-3-3-scan-sharing"><a href="#2-3-3-scan-sharing" class="headerlink" title="2.3.3. scan sharing"></a>2.3.3. scan sharing</h3><ul><li>复用某次查询的数据，用于其他的查询<ul><li>不是 caching，caching 指的是完全相同的查询</li><li>但是 scan sharing 只在乎是否取了同一个 page，而不是查询</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928105027699.png" alt="image-20220928105027699"></p><h3 id="2-3-4-buffer-pool-bypass"><a href="#2-3-4-buffer-pool-bypass" class="headerlink" title="2.3.4. buffer pool bypass"></a>2.3.4. buffer pool bypass</h3><ul><li>为了避免从 page table（hash 表）中查询的开销。</li><li>给每个查询线程分配一个本地内存作为该线程的缓存</li></ul><h2 id="2-4-replace-policy"><a href="#2-4-replace-policy" class="headerlink" title="2.4. replace policy"></a>2.4. replace policy</h2><ul><li>lRU（Least Recently Used）<ul><li>单独维护一个 queue，根据 page 的修改顺序排列</li><li>实现<ul><li>每个 page 带一个时间戳</li><li>clock：每个 page 带一个标志位（reference bit）<ul><li>代表我们上次 check 后，该 page 是否被访问</li><li>page 在一个环形队列（like a clock）</li><li>不是严格的 LRU</li><li>其实它的基本假设是：如果一个 page 在一段时间内不被使用，那么它大概率也不会再被使用，即可移除</li></ul></li></ul></li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928143037173.png" alt="image-20220928143037173"></p><ul><li>问题：sequential flooding。</li></ul><h3 id="2-4-1-解决-sequential-flooding"><a href="#2-4-1-解决-sequential-flooding" class="headerlink" title="2.4.1. 解决 sequential flooding"></a>2.4.1. 解决 sequential flooding</h3><h4 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h4><ul><li><p>记录每页的 K 次历史记录</p></li><li><p>不是看哪个 page 的时间戳最老，而是看时间戳之间的间隔</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928145520506.png" alt="image-20220928145520506"></p><h4 id="localization"><a href="#localization" class="headerlink" title="localization"></a>localization</h4><ul><li>从本地的角度移除最少使用的 page，而不是全局的角度</li></ul><h4 id="priority-hints"><a href="#priority-hints" class="headerlink" title="priority hints"></a>priority hints</h4><h4 id="dirty-page"><a href="#dirty-page" class="headerlink" title="dirty page"></a>dirty page</h4><ul><li>每个 page 有一个 dirty bit<ul><li>告诉我们自从上次 page 被放入后，是否被修改</li></ul></li><li>要么每次 drop 掉不 dirty 的 page，但这些 page 可能会被用到</li><li>要么每次写出一个 dirty page 到磁盘（产生一次 IO），再将其替换之（又产生一次 IO）</li><li>数据库一般有一个定时任务线程，负责定时写出 dirty page，然后将其置为 clean</li></ul><p>project 说明在 13：40<a href="https://www.zhihu.com/zvideo/1416128309478862848">(2 封私信) CMU 15-445 18 Buffer Pools 04 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 1. Disk Manager</title>
      <link href="/article/CMU-15-445-1-Disk-Manager/"/>
      <url>/article/CMU-15-445-1-Disk-Manager/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Disk-Manager"><a href="#1-Disk-Manager" class="headerlink" title="1. Disk Manager"></a>1. Disk Manager</h1><ul><li>面向磁盘的数据库系统<ul><li>主要存储放在磁盘上，每次查询时，访问的数据不在内存中</li></ul></li></ul><h2 id="1-1-none-volatile-storage"><a href="#1-1-none-volatile-storage" class="headerlink" title="1.1. (none) volatile storage"></a>1.1. (none) volatile storage</h2><ul><li>此部分在计组和 ics 已经学过，不再赘述</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220923152440566.png" alt="image-20220923152440566"></p><h2 id="1-2-总览目标"><a href="#1-2-总览目标" class="headerlink" title="1.2. 总览目标"></a>1.2. 总览目标</h2><ul><li>给应用提供一种假象：它总是拥有足够的内存来处理</li><li>允许 DBMS 来用超过内存的大小处理数据库</li></ul><h2 id="1-3-mmap"><a href="#1-3-mmap" class="headerlink" title="1.3. mmap"></a>1.3. mmap</h2><ul><li>虚存的思想。交给 OS 来处理缺页中断</li><li>但是在数据库系统里，这样会产生问题（read 不会产生问题，但是 write 要谨慎）：有时候页与页之间写有顺序要求（比如日志和并发控制），而 os 并不知道这些事情，导致会出现错误</li><li>因此：慎用 mmap。事实上，数据库总是能够接管 os 能干的事情，并能够比 os 干的更好</li></ul><h2 id="1-4-file-storage"><a href="#1-4-file-storage" class="headerlink" title="1.4. file storage"></a>1.4. file storage</h2><ul><li>DBMS 将数据库存储在磁盘上的一个或多个文件中<ul><li>OS 对它们的内容并无所知</li></ul></li><li>Storage manager 负责维护数据库的文件<ul><li>page 可以保存很多类型，比如 tuples，meta-data 等</li><li>但是一般一个 page 只存储一个类型的</li><li>每个物理 page 有一个实际 id 对应它</li></ul></li><li>不同的 DBMS 通过不同的方式管理磁盘上的页<ul><li>堆文件（Heap File）组织（Organization）</li><li>Sequential &#x2F; Sorted File Organization</li></ul></li></ul><h2 id="1-5-Heap-File"><a href="#1-5-Heap-File" class="headerlink" title="1.5. Heap File"></a>1.5. Heap File</h2><ul><li>无序的 pages 集合。其中 tuples 是无序（随机）的存储于其中</li></ul><h2 id="1-6-Page-Layout"><a href="#1-6-Page-Layout" class="headerlink" title="1.6. Page Layout"></a>1.6. Page Layout</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220924122654927.png" alt="image-20220924122654927"></p><ul><li>通过 fileId + pageId + slotId 来寻找具体的 slot</li></ul><h2 id="1-7-Tuple-Layout"><a href="#1-7-Tuple-Layout" class="headerlink" title="1.7. Tuple Layout"></a>1.7. Tuple Layout</h2><ul><li>tuple is a sequence of bytes</li><li>DBMS 需要解释这些 sequence of byte</li></ul><h3 id="1-7-1-tuple-header"><a href="#1-7-1-tuple-header" class="headerlink" title="1.7.1. tuple header"></a>1.7.1. tuple header</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220924154320372.png" alt="image-20220924154320372"></p><h3 id="1-7-2-tuple-data"><a href="#1-7-2-tuple-data" class="headerlink" title="1.7.2. tuple data"></a>1.7.2. tuple data</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220924154420159.png" alt="image-20220924154420159"></p><h1 id="剩余笔记"><a href="#剩余笔记" class="headerlink" title="剩余笔记"></a>剩余笔记</h1><p><a href="https://zhuanlan.zhihu.com/p/454591350">CMU-15-445 Lecture 4 数据库存储（下） - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学软件学院-云计算第一次作业-OBS展示</title>
      <link href="/article/Cloud-computing-OBS/"/>
      <url>/article/Cloud-computing-OBS/</url>
      
        <content type="html"><![CDATA[<h1 id="云计算第一次实践：网络测试-个人主页"><a href="#云计算第一次实践：网络测试-个人主页" class="headerlink" title="云计算第一次实践：网络测试+个人主页"></a>云计算第一次实践：网络测试+个人主页</h1><p>2022-Fall Cloud Computing</p><p>描述：下图即为 Huawei OBS 存储对象</p><img src="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png"><h1 id="一、过程记录"><a href="#一、过程记录" class="headerlink" title="一、过程记录"></a>一、过程记录</h1><h2 id="1-网络测试"><a href="#1-网络测试" class="headerlink" title="1. 网络测试"></a>1. 网络测试</h2><h3 id="1-1-测试过程描述：虚拟机申请过程、测试工具、操作过程"><a href="#1-1-测试过程描述：虚拟机申请过程、测试工具、操作过程" class="headerlink" title="1.1. 测试过程描述：虚拟机申请过程、测试工具、操作过程"></a>1.1. 测试过程描述：虚拟机申请过程、测试工具、操作过程</h3><h3 id="1-2-跨区域公网：虚拟机网络配置情况-测试结果"><a href="#1-2-跨区域公网：虚拟机网络配置情况-测试结果" class="headerlink" title="1.2. 跨区域公网：虚拟机网络配置情况 + 测试结果"></a>1.2. 跨区域公网：虚拟机网络配置情况 + 测试结果</h3><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921205319574.png" alt="image-20220921205319574"></p><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921205336815.png" alt="image-20220921205336815"></p><h3 id="1-3-同区域跨可用区公网：虚拟机网络配置情况-测试结果"><a href="#1-3-同区域跨可用区公网：虚拟机网络配置情况-测试结果" class="headerlink" title="1.3. 同区域跨可用区公网：虚拟机网络配置情况 + 测试结果"></a>1.3. 同区域跨可用区公网：虚拟机网络配置情况 + 测试结果</h3><h3 id="1-3-1-公网"><a href="#1-3-1-公网" class="headerlink" title="1.3.1. 公网"></a>1.3.1. 公网</h3><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921191009640.png" alt="image-20220921191009640"></p><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921191000516.png" alt="image-20220921191000516"></p><h3 id="1-3-2-私网"><a href="#1-3-2-私网" class="headerlink" title="1.3.2. 私网"></a>1.3.2. 私网</h3><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921203324190.png" alt="image-20220921203324190"></p><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921203335678.png" alt="image-20220921203335678"></p><h3 id="1-4-同可用区公网-私网：虚拟机网络配置情况-测试结果"><a href="#1-4-同可用区公网-私网：虚拟机网络配置情况-测试结果" class="headerlink" title="1.4. 同可用区公网+私网：虚拟机网络配置情况 + 测试结果"></a>1.4. 同可用区公网+私网：虚拟机网络配置情况 + 测试结果</h3><h4 id="1-4-1-公网"><a href="#1-4-1-公网" class="headerlink" title="1.4.1. 公网"></a>1.4.1. 公网</h4><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921154258878.png" alt="image-20220921154258878"></p><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921154328161.png" alt="image-20220921154328161"></p><h4 id="1-4-2-私网"><a href="#1-4-2-私网" class="headerlink" title="1.4.2. 私网"></a>1.4.2. 私网</h4><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921154807390.png" alt="image-20220921154807390"></p><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921154817551.png" alt="image-20220921154817551"></p><h2 id="2-个人主页"><a href="#2-个人主页" class="headerlink" title="2. 个人主页"></a>2. 个人主页</h2><p>（1）对应的 OBS 链接</p><ul><li><a href="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/">https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com</a></li></ul><p>（2）上传的 obs 图片链接</p><ul><li><a href="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png">https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png</a></li></ul><p>（3）个人主页地址（公网 IP）</p><ul><li><a href="http://116.204.103.36/">http://116.204.103.36/</a></li></ul><h1 id="二、详细作业叙述"><a href="#二、详细作业叙述" class="headerlink" title="二、详细作业叙述"></a>二、详细作业叙述</h1><ol><li>201250214-彭俊植</li><li>网络测试：</li></ol><ul><li><p><strong>虚拟机申请过程：</strong></p><ul><li>虚拟机 ①<ul><li>华北-乌兰察布一&#x2F;可用区 2</li><li>ID：test0921-wlcb2qu</li><li>配置 1C4G；系统镜像 CentOS 8.2 64bit；按需计费</li><li>带宽：5 Mbit&#x2F;s</li><li>公网 ip：116.204.103.253；私网 ip：192.168.0.173</li></ul></li><li>虚拟机 ②<ul><li>华北-乌兰察布一&#x2F;可用区 2</li><li>ID：test0921-wlcb2qu-02</li><li>配置 1C4G；系统镜像 CentOS 8.2 64bit；按需计费</li><li>带宽：5 Mbit&#x2F;s</li><li>公网 ip：116.204.103.36；私网 ip：192.168.0.83</li></ul></li><li>虚拟机 ③<ul><li>华北-乌兰察布一&#x2F;可用区 3</li><li>ID：test0921-wlcb3qu</li><li>配置 1C4G；系统镜像 CentOS 8.2 64bit；按需计费</li><li>带宽：5 Mbit&#x2F;s</li><li>公网 ip：121.37.97.146；私网 ip：192.168.0.128</li></ul></li><li>虚拟机 ④<ul><li>西南-贵阳一&#x2F;可用区 1</li><li>ID：test0921-guiyang1qu</li><li>配置 1C4G；系统镜像 CentOS 8.2 64bit；按需计费</li><li>带宽：5 Mbit&#x2F;s</li><li>公网 ip：140.210.210.244；私网 ip：192.168.0.109</li></ul></li></ul></li><li><p><strong>测试工具</strong>：iperf 3.1.3</p></li><li><p><strong>操作过程</strong></p><ul><li>先按如上配置申请四台虚拟机，并开放必要的 5000、22、ICMP 等端口，并安装 iperf 3.1.3。随后分别按作业要求所述的三种情况展开测试。</li><li>测试手段如下：同时开启两台虚拟机，一台作为客户端，一台作为服务端。先在服务端运行命令<code>iperf3 –s –i 5 –p 5000</code>，再于客户端运行命令<code>Iperf3 –c $&#123;serverIP&#125; –i 5 –t 100 –p 5000</code>。其中客户端中第二个参数填上服务端的 ip（可视实验情况选择填写公网 ip 或私网 ip）。观察屏幕输出结果，并进行记录。</li></ul></li><li><p><strong>跨区域</strong></p><ul><li>公网：服务端为 wlcb2qu-02，客户端为 guiyang1qu。测试结果为客户端 sender 5.18 Mbits&#x2F;sec，receiver 4.85 Mbits&#x2F;sec，服务端 receiver 4.85 Mbits&#x2F;sec</li><li>私网：ping 不通</li></ul></li><li><p><strong>同区域跨可用区</strong></p><ul><li>公网：服务端为 wlcb3qu ，客户端为 wlcb2qu-02。测试结果为客户端 sender 5.56 Mbits&#x2F;sec，receiver 5.46 Mbits&#x2F;sec，服务端 receiver 5.46 Mbits&#x2F;sec</li><li>私网：可 ping 通，服务端为 wlcb3qu，客户端为 wlcb2qu-02。测试结果为客户端 sender 531 Mbits&#x2F;sec，receiver 531 Mbits&#x2F;sec，服务端 receiver 531 Mbits&#x2F;sec</li></ul></li><li><p><strong>同区域同可用区</strong></p><ul><li><p>公网：服务端为 wlcb2qu-02 ，客户端为 wlcb2qu。测试结果为客户端 sender 5.38 Mbits&#x2F;sec，receiver 5.35 Mbits&#x2F;sec，服务端 receiver 5.34 Mbits&#x2F;sec</p></li><li><p>私网：可 ping 通，服务端为 wlcb2qu，客户端为 wlcb2qu-02。测试结果为客户端 sender 55.4 Gbits&#x2F;sec，receiver 55.4 Gbits&#x2F;sec，服务端 receiver 55.4 Gbits&#x2F;sec</p><p>3.个人主页</p></li></ul></li></ul><p>（1）对应的 OBS 链接</p><ul><li><a href="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/">https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com</a></li></ul><p>（2）上传的 obs 图片链接</p><ul><li><a href="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png">https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png</a></li></ul><p>（3）个人主页地址</p><ul><li><a href="http://116.204.103.36/">http://116.204.103.36/</a> （部署在虚拟机 ② 上）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 整理重点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS Melodic 安装踩坑</title>
      <link href="/article/ROS-installation/"/>
      <url>/article/ROS-installation/</url>
      
        <content type="html"><![CDATA[<img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221006110534808.png" alt="image-20221006110534808" style="zoom:67%;" /><hr><h2 id="1-安装过程"><a href="#1-安装过程" class="headerlink" title="1. 安装过程"></a>1. 安装过程</h2><ul><li>安装 amd64 Ubuntu18.04 虚拟机（基于 virtual box）</li><li>配置安装源<code>sudo sh -c &#39;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;</code></li><li>设置密钥<code>sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 </code></li><li><code>sudo apt update</code></li><li>出现报错。输入<code>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F42ED6FBAB17C654</code>解决</li><li>开始安装 ROS Melodic <code>sudo apt-get install ros-melodic-desktop-full</code></li><li>避免后面出现<code>sudo rosdep：找不到命令</code>提示，执行如下命令<code>sudo apt install python-rosdep</code></li><li>初始化 rosdep<code>sudo rosdep init</code><ul><li>此处出现最大问题，由于众所周知的原因，init 失败，无法 hit 到 raw.githubusercontent</li><li><strong><em>解决：</em></strong><ul><li>定位 rosdep 资源下载函数：&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;rosxxx&#x2F;xxxx.py 文件（有若干个文件）</li><li>直接修改源 py 代码，在所有下载 url 地址前添加<a href="https://ghproxy.com/%E5%89%8D%E7%BC%80%E6%9D%A5%E5%BA%94%E7%94%A8%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1">https://ghproxy.com/前缀来应用代理服务</a></li></ul></li></ul></li><li>执行 rosdep 更新<code>rosdep update</code></li><li>添加 ros 环境变量<code>echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrc source ~/.bashrc</code></li><li>安装 rosinstall<code>sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential</code></li><li><strong><em>到此安装完成，可以运行命令启动小海龟</em></strong></li></ul><h2 id="2-运行截图"><a href="#2-运行截图" class="headerlink" title="2. 运行截图"></a>2. 运行截图</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221006110534808.png" alt="image-20221006110534808"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Redis 发布订阅实现IM消息队列</title>
      <link href="/article/RedisMQ-IM/"/>
      <url>/article/RedisMQ-IM/</url>
      
        <content type="html"><![CDATA[<p>使用Redis的发布订阅模式实现即时通讯功能的消息队列中间件，以适应分布式模块中即时通讯服务的需要。</p><p>整合方式：SpringBoot + WebSocket + Redis</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/60047df223d04285afea73d1cacfa688.png" alt="在这里插入图片描述"></p><h2 id="1-发布订阅模式"><a href="#1-发布订阅模式" class="headerlink" title="1. 发布订阅模式"></a>1. 发布订阅模式</h2><p>Redis的发布订阅机制是一种消息通信模式，包括三个部分，发布者（pub）发送消息，订阅者（sub）接收信息和<code>Channel</code>，这里的<code>Channel</code>类似于<code>Kafka</code>中的<code>topic</code>的概念。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/20210702104227710.png" alt="img"></p><p>发布者和订阅者都是<code>Redis</code>客户端，<code>Channel</code>则为<code>Redis</code>服务器端，可以理解为一种特殊的数据<a href="https://so.csdn.net/so/search?q=%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">存储结构</a>。发布者将消息发送到某个的频道，订阅了这个频道的订阅者就能接收到这条消息。</p><p>Redis客户端可以订阅任意数量的频道。</p><p><code>Redis</code>的这种发布订阅机制与基于主题的发布订阅类似，<code>Channel</code>相当于主题。</p><p>下图展示频道channel1，以及订阅这个频道的三个客户端–client2，client5和client1之间的关系</p><p><img src="https://img-blog.csdnimg.cn/ae3ee06fde0b4b81ad1278a920dbfcc2.png#pic_center" alt="img"></p><p>当有新消息通过PUBLISH命令发送给频道channel1时，这个消息就会被发送给订阅它的三个客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/ce1bfeef41514ea59745f713fc49d439.png" alt="在这里插入图片描述"></p><h3 id="1-1-相关命令"><a href="#1-1-相关命令" class="headerlink" title="1.1. 相关命令"></a>1.1. 相关命令</h3><h4 id="1-1-1-订阅者-等待接收消息"><a href="#1-1-1-订阅者-等待接收消息" class="headerlink" title="1.1.1. 订阅者&#x2F;等待接收消息"></a>1.1.1. 订阅者&#x2F;等待接收消息</h4><p>首先打开 Redis 客户端，然后订阅了一个名为“bbx”的 channel，使用如下命令:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE bbx</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;bbx&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>使用SUBSCRIBE命令订阅了名为 bbx 的 channel。命令执行后该客户端会出处于等待接收消息的阻塞状态。</p><h4 id="1-1-2-发布者-发送消息"><a href="#1-1-2-发布者-发送消息" class="headerlink" title="1.1.2. 发布者&#x2F;发送消息"></a>1.1.2. 发布者&#x2F;发送消息</h4><p>下面再启动一个 Redis 客户端，输入如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH bbx hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH bbx world</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><h4 id="1-1-3-订阅者-成功接收消息"><a href="#1-1-3-订阅者-成功接收消息" class="headerlink" title="1.1.3. 订阅者&#x2F;成功接收消息"></a>1.1.3. 订阅者&#x2F;成功接收消息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE bbx</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;bbx&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">#等待读取推送消息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span><span class="comment">#消息</span></span><br><span class="line">2) <span class="string">&quot;bbx&quot;</span><span class="comment">#频道</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span><span class="comment">#消息具体内容</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;bbx&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2. 原理"></a>1.2. 原理</h3><blockquote><p>源码：pubsub.c</p></blockquote><p>Redis通过<code>PUBLISH</code>，<code>SUBSCRIBE</code>和<code>PSUBSCRIBE</code>等命令实现发布和订阅功能</p><p>通过<code>SUBSCRIBE</code>命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个频道，字典的值则是一个链表，链表中保存了所有订阅这个频道的客户端。<code>SUBSCRIBE</code>命令的关键，就是将客户端添加到给定频道的订阅链表中。</p><p>通过<code>PUBLISH</code>命令向订阅者发送消息，redis-server会使用给定频道作为键，在它维护的频道字典中查找记录了订阅这个频道的所有客户端的链表，将消息发布给所有订阅者</p><p>Pub和Sub从字面上理解就是发布（Publish）和订阅（Subscribe），在redis中，可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的信息，这一功能最明显的用法就是实时消息系统，比如普通的即时聊天，群聊等功能。</p><h3 id="1-3-缺点"><a href="#1-3-缺点" class="headerlink" title="1.3. 缺点"></a>1.3. 缺点</h3><ul><li>消息无法持久化，存在丢失风险，即消息一经发布，即使没有任何订阅方处理,该条消息就会丢失</li><li>没有类似ACK的机制，即发布方不会确保订阅方成功接收</li><li>广播机制，下游消费能力取决于消费方本身。广播机制无法通过添加多个消费方增强消费能力, 因为这和发布&#x2F;订阅模型本身的目的是不符的。广播机制的目的是一个一个发布者被多个订阅进行不同的处理</li></ul><p>解决方法：</p><blockquote><ol><li>添加持久化层，加入redis缓存和MySQL</li><li>结合WebSocket，实现消息推送、握手、心跳检测和广播等机制</li></ol></blockquote><h2 id="2-和SpringBoot、WebSocket的整合"><a href="#2-和SpringBoot、WebSocket的整合" class="headerlink" title="2. 和SpringBoot、WebSocket的整合"></a>2. 和SpringBoot、WebSocket的整合</h2><h3 id="2-1-依赖"><a href="#2-1-依赖" class="headerlink" title="2.1. 依赖"></a>2.1. 依赖</h3><ul><li><em><strong>spring-boot-starter-web</strong></em>：帮助我们启动一个Web服务器；</li><li><em><strong>spring-boot-starter-data-redis</strong></em>：帮助我们集成Redis；</li><li><em><strong>lombok</strong></em>：方便我们使用 <em><strong>@Slf4j</strong></em>&#x2F;<em><strong>@Data</strong></em> 等，简化代码；</li><li><em><strong>spring-boot-starter-websocket</strong></em>：帮助我们在SpringBoot客户端起WebSocket进程</li></ul><h3 id="2-2-架构"><a href="#2-2-架构" class="headerlink" title="2.2. 架构"></a>2.2. 架构</h3><h4 id="2-2-1-整体架构"><a href="#2-2-1-整体架构" class="headerlink" title="2.2.1. 整体架构"></a>2.2.1. 整体架构</h4><blockquote><p>Redis(消息队列)——&gt; MySQL(持久化) ——&gt; WebSockets(消息转发)——&gt; FrontEnd(客户端)</p></blockquote><h4 id="2-2-2-后端架构"><a href="#2-2-2-后端架构" class="headerlink" title="2.2.2. 后端架构"></a>2.2.2. 后端架构</h4><blockquote><p>Controller——(n,1)——&gt;Redis——(1,n)———&gt;Listener——(1,n)——&gt;WebSockets</p></blockquote><h3 id="2-3-Redis配置"><a href="#2-3-Redis配置" class="headerlink" title="2.3. Redis配置"></a>2.3. Redis配置</h3><h4 id="2-3-1-自定义RedisTemplate"><a href="#2-3-1-自定义RedisTemplate" class="headerlink" title="2.3.1. 自定义RedisTemplate"></a>2.3.1. 自定义RedisTemplate</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTemp</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-发布订阅配置"><a href="#2-3-2-发布订阅配置" class="headerlink" title="2.3.2. 发布订阅配置"></a>2.3.2. 发布订阅配置</h4><p>由于我们在发布者、订阅者的代码中均没有指定要订阅的channel，因此需要在其他地方（发布订阅配置类）指定channel。</p><p>此配置类主要实现了Redis消息监听器容器，这个容器加载了RedisConnectionFactory和消息监听器；可以添加多个监听不同话题的redis监听器，只需要把消息监听器和相应的消息订阅处理器绑定，该消息监听器通过反射技术调用消息订阅处理器的相关方法进行一些业务处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubConfig</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisConnectionFactory = redisConnectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;配置消息监听器&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageListener <span class="title function_">listener</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ConnectionListener.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;配置 发布/订阅 的 Topic&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ChannelTopic <span class="title function_">channelTopic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChannelTopic</span>(<span class="string">&quot;nxb message test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;将消息监听器绑定到消息容器&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * 并进行容器的设置</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisMessageListenerContainer <span class="title function_">messageListenerContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RedisMessageListenerContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisMessageListenerContainer</span>();</span><br><span class="line">        container.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">// 此处可以更换订阅主题</span></span><br><span class="line">        container.addMessageListener(listener(), channelTopic());</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-消费者（sub）"><a href="#2-4-消费者（sub）" class="headerlink" title="2.4. 消费者（sub）"></a>2.4. 消费者（sub）</h3><p>这里需要实现<code>MessageListener</code>接口。目的是利用<code>onMessage</code>方法，监听<code>channel</code>中的消息队列，实现接受消息。</p><p>消费者的核心方法是<code>onMessage</code>，方法传入订阅到的消息，然后进行处理即可。</p><p>这里把redis的消费者方法和websocket进行了整合，redis消费者收到上游消息后，由websocket转发给对应用户，再转发给前端。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负责订阅redis发布的接受器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionListener</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, WebSocket&gt; webSockets = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ConnectionListener</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionListener</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ConnectionListener</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConnectionListener <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收到消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, <span class="type">byte</span>[] pattern)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        <span class="type">MessageVO</span> <span class="variable">messageVO</span> <span class="operator">=</span> JSON.parseObject((String)JSON.parse(message.toString()), MessageVO.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;received message: &quot;</span>+ messageVO);</span><br><span class="line">        sendMessage(messageVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addConnection</span><span class="params">(String userId,WebSocket webSocket)</span>&#123;</span><br><span class="line">        webSockets.put(userId,webSocket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containConnection</span><span class="params">(String userId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webSockets.containsKey(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeConnection</span><span class="params">(String userId)</span>&#123;</span><br><span class="line">        webSockets.remove(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">connectionCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webSockets.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(MessageVO message)</span>&#123;</span><br><span class="line">        <span class="comment">// 优化逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (containConnection(message.getUser()))&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> message.getUser();</span><br><span class="line">            webSockets.get(key).sendMessage(message);</span><br><span class="line">            System.out.println(message + <span class="string">&quot; has been sent to &quot;</span> + key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-生产者（pub）"><a href="#2-5-生产者（pub）" class="headerlink" title="2.5. 生产者（pub）"></a>2.5. 生产者（pub）</h3><p>指定要发布到的channel和要发布的消息。注意这里的channel由配置类进行管理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息发布者服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublishService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入自定义redisTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChannelTopic channelTopic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Publish.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message   the message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(Object message)</span> &#123;</span><br><span class="line">        redisUtil.convertAndSend(channelTopic.getTopic(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>redisUtil</code>封装了转发消息方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向通道发布消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">convertAndSend</span><span class="params">(String channel, Object message)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(channel)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redisTemplate.convertAndSend(channel, message);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息成功，channel：&#123;&#125;，message：&#123;&#125;&quot;</span>, channel, message);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;发送消息失败，channel：&#123;&#125;，message：&#123;&#125;&quot;</span>, channel, message);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><h3 id="3-1-测试类"><a href="#3-1-测试类" class="headerlink" title="3.1. 测试类"></a>3.1. 测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSubPubTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChannelTopic topic;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC</span> <span class="operator">=</span> <span class="string">&quot;TEST_TOPIC1&quot;</span>; <span class="comment">// 订阅主题</span></span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">        <span class="type">MessageVO</span> <span class="variable">messageVO</span> <span class="operator">=</span> MessageVO.builder()</span><br><span class="line">                .user(<span class="string">&quot;pengzna&quot;</span>)</span><br><span class="line">                .msg(<span class="string">&quot;hello world！&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        redisUtil.convertAndSend(topic.getTopic(), messageVO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-测试结果"><a href="#3-2-测试结果" class="headerlink" title="3.2. 测试结果"></a>3.2. 测试结果</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220726182800342.png" alt="image-20220726182800342"></p><hr><p><em>参考资料</em></p><ul><li><a href="https://www.runoob.com/redis/redis-pub-sub.html">Redis 发布订阅 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://www.cnblogs.com/kendoziyu/p/15802698.html">SpringBoot整合Redis实现发布订阅功能实践 - 极客子羽 - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/BBQ__ZXB/article/details/124980860">(26条消息) Spring boot整合Redis实现发布订阅（超详细）_BBQ__XB的博客-CSDN博客_springboot 发布订阅</a></li><li><a href="https://blog.csdn.net/Vector97/article/details/118407461?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-118407461-blog-124980860.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-118407461-blog-124980860.pc_relevant_default&utm_relevant_index=2">(26条消息) Springboot集成Redis实现发布订阅功能（Java Lettuce客户端）_iFence的博客-CSDN博客_lettuce 发布订阅</a></li><li><a href="https://blog.csdn.net/weixin_44874132/article/details/124192307">(26条消息) SpringBoot整合redis实现发布订阅模式_叶枫^_^的博客-CSDN博客_redis发布订阅 springboot</a></li><li>jfy同学代码</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> spring </tag>
            
            <tag> redis </tag>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript ·入门</title>
      <link href="/article/TypeScript-learning/"/>
      <url>/article/TypeScript-learning/</url>
      
        <content type="html"><![CDATA[<p>参考资料：<a href="https://juejin.cn/post/6844904182843965453">https://juejin.cn/post/6844904182843965453</a></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172916652ec072e3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom: 33%;" /><h2 id="1-TypeScript-简介"><a href="#1-TypeScript-简介" class="headerlink" title="1. TypeScript 简介"></a>1. TypeScript 简介</h2><h3 id="1-1-TypeScript-与-JavaScript-的区别"><a href="#1-1-TypeScript-与-JavaScript-的区别" class="headerlink" title="1.1 TypeScript 与 JavaScript 的区别"></a>1.1 TypeScript 与 JavaScript 的区别</h3><table><thead><tr><th>TypeScript</th><th>JavaScript</th></tr></thead><tbody><tr><td>JavaScript 的超集用于解决大型项目的代码复杂性</td><td>一种脚本语言，用于创建动态网页。</td></tr><tr><td>可以在编译期间发现并纠正错误</td><td>作为一种解释型语言，只能在运行时发现错误</td></tr><tr><td>强类型，支持静态和动态类型</td><td>弱类型，没有静态类型选项</td></tr><tr><td>最终被编译成 JavaScript 代码，使浏览器可以理解</td><td>可以直接在浏览器中使用</td></tr><tr><td>支持模块、泛型和接口</td><td>不支持模块，泛型或接口</td></tr><tr><td>支持 ES3，ES4，ES5 和 ES6 等</td><td>不支持编译其他 ES3，ES4，ES5 或 ES6 功能</td></tr><tr><td>社区的支持仍在增长，而且还不是很大</td><td>大量的社区支持以及大量文档和解决问题的支持</td></tr></tbody></table><h3 id="1-2-获取-TypeScript"><a href="#1-2-获取-TypeScript" class="headerlink" title="1.2 获取 TypeScript"></a>1.2 获取 TypeScript</h3><p>命令行的 TypeScript 编译器可以使用 Node.js 包来安装。</p><p><strong>1.安装 TypeScript</strong></p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>npm install -g typescript</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>2.编译 TypeScript 文件</strong></p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>tsc helloworld.ts</span><br><span class="line"><span class="comment"># helloworld.ts =&gt; helloworld.js</span></span><br></pre></td></tr></table></figure><h2 id="2-TypeScript-基础类型"><a href="#2-TypeScript-基础类型" class="headerlink" title="2. TypeScript 基础类型"></a>2. TypeScript 基础类型</h2><h3 id="2-1-Boolean-类型"><a href="#2-1-Boolean-类型" class="headerlink" title="2.1 Boolean 类型"></a>2.1 Boolean 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let isDone: <span class="attr">boolean</span> = <span class="literal">false</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">isDone</span> = <span class="literal">false</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-Number-类型"><a href="#2-2-Number-类型" class="headerlink" title="2.2 Number 类型"></a>2.2 Number 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let count: <span class="attr">number</span> = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">count</span> = <span class="number">10</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-String-类型"><a href="#2-3-String-类型" class="headerlink" title="2.3 String 类型"></a>2.3 String 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let name: <span class="attr">string</span> = <span class="string">&quot;Semliker&quot;</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">name</span> = <span class="string">&#x27;Semlinker&#x27;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-Array-类型"><a href="#2-4-Array-类型" class="headerlink" title="2.4 Array 类型"></a>2.4 Array 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let list: number<span class="section">[]</span> = <span class="section">[1, 2, 3]</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let list: Array&lt;number&gt; = <span class="section">[1, 2, 3]</span><span class="comment">; // Array&lt;number&gt;泛型语法</span></span><br><span class="line">// ES5：var <span class="attr">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-5-Enum-类型"><a href="#2-5-Enum-类型" class="headerlink" title="2.5 Enum 类型"></a>2.5 Enum 类型</h3><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。</p><h4 id="2-5-1-数字枚举"><a href="#2-5-1-数字枚举" class="headerlink" title="2.5.1.数字枚举"></a><strong>2.5.1.数字枚举</strong></h4><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  NORTH,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dir: <span class="attr">Direction</span> = Direction.NORTH<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。上面的枚举示例代码经过编译后会生成以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;NORTH&#x27;</span>] = <span class="number">0</span>)] = <span class="string">&#x27;NORTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;SOUTH&#x27;</span>] = <span class="number">1</span>)] = <span class="string">&#x27;SOUTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;EAST&#x27;</span>] = <span class="number">2</span>)] = <span class="string">&#x27;EAST&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;WEST&#x27;</span>] = <span class="number">3</span>)] = <span class="string">&#x27;WEST&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;))</span><br><span class="line"><span class="keyword">var</span> dir = <span class="title class_">Direction</span>.<span class="property">NORTH</span></span><br></pre></td></tr></table></figure><p>当然我们也可以设置 NORTH 的初始值，比如：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  <span class="attr">NORTH</span> = <span class="number">3</span>,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-字符串枚举"><a href="#2-5-2-字符串枚举" class="headerlink" title="2.5.2.字符串枚举"></a>2.5.<strong>2.字符串枚举</strong></h4><p>在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  <span class="attr">NORTH</span> = <span class="string">&quot;NORTH&quot;</span>,</span><br><span class="line">  <span class="attr">SOUTH</span> = <span class="string">&quot;SOUTH&quot;</span>,</span><br><span class="line">  <span class="attr">EAST</span> = <span class="string">&quot;EAST&quot;</span>,</span><br><span class="line">  <span class="attr">WEST</span> = <span class="string">&quot;WEST&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码对于的 ES5 代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;NORTH&#x27;</span>] = <span class="string">&#x27;NORTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;SOUTH&#x27;</span>] = <span class="string">&#x27;SOUTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;EAST&#x27;</span>] = <span class="string">&#x27;EAST&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;WEST&#x27;</span>] = <span class="string">&#x27;WEST&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2-5-3-异构枚举"><a href="#2-5-3-异构枚举" class="headerlink" title="2.5.3.异构枚举"></a>2.5.<strong>3.异构枚举</strong></h4><p>异构枚举的成员值是数字和字符串的混合：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Enum &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">  <span class="attr">C</span> = <span class="string">&quot;C&quot;</span>,</span><br><span class="line">  <span class="attr">D</span> = <span class="string">&quot;D&quot;</span>,</span><br><span class="line">  <span class="attr">E</span> = <span class="number">8</span>,</span><br><span class="line">  F,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码对于的 ES5 代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Enum</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">Enum</span>) &#123;</span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;A&#x27;</span>] = <span class="number">0</span>)] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;B&#x27;</span>] = <span class="number">1</span>)] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[<span class="string">&#x27;C&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[<span class="string">&#x27;D&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;E&#x27;</span>] = <span class="number">8</span>)] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;F&#x27;</span>] = <span class="number">9</span>)] = <span class="string">&#x27;F&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Enum</span> || (<span class="title class_">Enum</span> = &#123;&#125;))</span><br></pre></td></tr></table></figure><p>通过观察上述生成的 ES5 代码，我们可以发现数字枚举相对字符串枚举多了 “反向映射”：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(Enum.A) <span class="comment">//输出：0</span></span><br><span class="line">console.<span class="built_in">log</span>(Enum[<span class="number">0</span>]) <span class="comment">// 输出：A</span></span><br></pre></td></tr></table></figure><h3 id="2-6-Any-类型"><a href="#2-6-Any-类型" class="headerlink" title="2.6 Any 类型"></a>2.6 Any 类型</h3><p>在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的<strong>顶级类型</strong>（也被称作全局超级类型）。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let notSure: <span class="attr">any</span> = <span class="number">666</span><span class="comment">;</span></span><br><span class="line"><span class="attr">notSure</span> = <span class="string">&quot;Semlinker&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">notSure</span> = <span class="literal">false</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p><code>any</code> 类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由：TypeScript 允许我们对 <code>any</code> 类型的值执行任何操作，而无需事先执行任何形式的检查。比如：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">let value: any;</span><br><span class="line"></span><br><span class="line">value<span class="selector-class">.foo</span><span class="selector-class">.bar</span>; <span class="comment">// OK</span></span><br><span class="line">value<span class="selector-class">.trim</span>(); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">value</span>(); <span class="comment">// OK</span></span><br><span class="line">new <span class="built_in">value</span>(); <span class="comment">// OK</span></span><br><span class="line">value<span class="selector-attr">[0]</span><span class="selector-attr">[1]</span>; <span class="comment">// OK</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在许多场景下，这太宽松了。使用 <code>any</code> 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 <code>any</code> 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 <code>any</code> 带来的问题，TypeScript 3.0 引入了 <code>unknown</code> 类型。</p><h3 id="2-7-Unknown-类型"><a href="#2-7-Unknown-类型" class="headerlink" title="2.7 Unknown 类型"></a>2.7 Unknown 类型</h3><p>就像所有类型都可以赋值给 <code>any</code>，所有类型也都可以赋值给 <code>unknown</code>。这使得 <code>unknown</code> 成为 TypeScript 类型系统的另一种顶级类型（另一种是 <code>any</code>）。下面我们来看一下 <code>unknown</code> 类型的使用示例：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let value: unknown<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">value</span> = <span class="literal">true</span><span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = <span class="number">42</span><span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = <span class="string">&quot;Hello World&quot;</span><span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = []<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = &#123;&#125;<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = Math.random<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = null<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = undefined<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = new TypeError()<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = Symbol(<span class="string">&quot;type&quot;</span>)<span class="comment">; // OK</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对 <code>value</code> 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 <code>unknown</code> 的值赋值给其他类型的变量时会发生什么？</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let value: unknown<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let value1: <span class="attr">unknown</span> = value<span class="comment">; // OK</span></span><br><span class="line">let value2: <span class="attr">any</span> = value<span class="comment">; // OK</span></span><br><span class="line">let value3: <span class="attr">boolean</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value4: <span class="attr">number</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value5: <span class="attr">string</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value6: <span class="attr">object</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value7: any<span class="section">[]</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value8: <span class="attr">Function</span> = value<span class="comment">; // Error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>unknown</code> 类型只能被赋值给 <code>any</code> 类型和 <code>unknown</code> 类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 <code>unknown</code> 类型的值。毕竟我们不知道变量 <code>value</code> 中存储了什么类型的值。</p><p>现在让我们看看当我们尝试对类型为 <code>unknown</code> 的值执行操作时会发生什么。以下是我们在之前 <code>any</code> 章节看过的相同操作：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">let value: unknown;</span><br><span class="line"></span><br><span class="line">value<span class="selector-class">.foo</span><span class="selector-class">.bar</span>; <span class="comment">// Error</span></span><br><span class="line">value<span class="selector-class">.trim</span>(); <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">value</span>(); <span class="comment">// Error</span></span><br><span class="line">new <span class="built_in">value</span>(); <span class="comment">// Error</span></span><br><span class="line">value<span class="selector-attr">[0]</span><span class="selector-attr">[1]</span>; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>将 <code>value</code> 变量类型设置为 <code>unknown</code> 后，这些操作都不再被认为是类型正确的。通过将 <code>any</code> 类型改变为 <code>unknown</code> 类型，我们已将允许所有更改的默认设置，更改为<strong>禁止任何更改</strong>。</p><h3 id="2-8-Tuple-类型"><a href="#2-8-Tuple-类型" class="headerlink" title="2.8 Tuple 类型"></a>2.8 Tuple 类型</h3><p>众所周知，数组一般由同种类型的值组成，<strong>但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组</strong>。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。</p><p>元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值。为了更直观地理解元组的概念，我们来看一个具体的例子：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let tupleType: <span class="section">[string, boolean]</span><span class="comment">;</span></span><br><span class="line"><span class="attr">tupleType</span> = [<span class="string">&quot;Semlinker&quot;</span>, <span class="literal">true</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>在上面代码中，我们定义了一个名为 <code>tupleType</code> 的变量，它的类型是一个类型数组 <code>[string, boolean]</code>，然后我们按照正确的类型依次初始化 tupleType 变量。与数组一样，我们可以通过下标来访问元组中的元素：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(tupleType[<span class="number">0</span>]); <span class="comment">// Semlinker</span></span><br><span class="line">console.<span class="built_in">log</span>(tupleType[<span class="number">1</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在元组初始化的时候，如果出现类型不匹配的话，比如：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">tupleType</span> = [<span class="literal">true</span>, <span class="string">&quot;Semlinker&quot;</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>此时，TypeScript 编译器会提示以下错误信息：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>]: <span class="type">Type</span> <span class="string">&#x27;true&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> assignable to <span class="built_in">type</span> <span class="string">&#x27;string&#x27;</span>.</span><br><span class="line">[<span class="number">1</span>]: <span class="type">Type</span> <span class="string">&#x27;string&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> assignable to <span class="built_in">type</span> <span class="string">&#x27;boolean&#x27;</span>.</span><br></pre></td></tr></table></figure><p>很明显是因为类型不匹配导致的。在元组初始化的时候，我们还必须提供<strong>每个属性的值</strong>，不然也会出现错误，比如：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">tupleType</span> = [<span class="string">&quot;Semlinker&quot;</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>此时，TypeScript 编译器会提示以下错误信息：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Property <span class="string">&#x27;1&#x27;</span> <span class="keyword">is</span> missing <span class="keyword">in</span> <span class="built_in">type</span> <span class="string">&#x27;[string]&#x27;</span> but required <span class="keyword">in</span> <span class="built_in">type</span> <span class="string">&#x27;[string, boolean]&#x27;</span>.</span><br></pre></td></tr></table></figure><h3 id="2-9-Void-类型"><a href="#2-9-Void-类型" class="headerlink" title="2.9 Void 类型"></a>2.9 Void 类型</h3><p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数返回值为void</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is my warning message&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码编译生成的 ES5 代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is my warning message&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，声明一个 void 类型的变量没有什么作用，因为它的值只能为 <code>undefined</code> 或 <code>null</code>：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let unusable: <span class="attr">void</span> = undefined<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-10-Null-和-Undefined-类型"><a href="#2-10-Null-和-Undefined-类型" class="headerlink" title="2.10 Null 和 Undefined 类型"></a>2.10 Null 和 Undefined 类型</h3><p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者有各自的类型分别为 <code>undefined</code> 和 <code>null</code>。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let u: <span class="attr">undefined</span> = undefined<span class="comment">;</span></span><br><span class="line">let n: <span class="attr">null</span> = null<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。<strong>然而，如果你指定了<code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自的类型。</strong></p><h3 id="2-11-Never-类型"><a href="#2-11-Never-类型" class="headerlink" title="2.11 Never 类型"></a>2.11 Never 类型</h3><p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如，<code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">controlFlowAnalysisWithNever</span>(<span class="params">foo: Foo</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里 foo 被收窄为 string 类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里 foo 被收窄为 number 类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// foo 在这里是 never</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">check</span>: <span class="built_in">never</span> = foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然而他忘记同时修改 <code>controlFlowAnalysisWithNever</code> 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 <code>boolean</code> 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保</p><p><code>controlFlowAnalysisWithNever</code> 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：<strong>使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。</strong></p><h2 id="3-TypeScript-断言"><a href="#3-TypeScript-断言" class="headerlink" title="3. TypeScript 断言"></a>3. TypeScript 断言</h2><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p><p>类型断言有两种形式：</p><h3 id="3-1-“尖括号”-语法"><a href="#3-1-“尖括号”-语法" class="headerlink" title="3.1. “尖括号” 语法"></a>3.1. “尖括号” 语法</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let someValue: <span class="attr">any</span> = <span class="string">&quot;this is a string&quot;</span><span class="comment">;</span></span><br><span class="line">let strLength: <span class="attr">number</span> = (&lt;string&gt;someValue).length<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-as-语法"><a href="#3-2-as-语法" class="headerlink" title="3.2. as 语法"></a>3.2. as 语法</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let someValue: <span class="attr">any</span> = <span class="string">&quot;this is a string&quot;</span><span class="comment">;</span></span><br><span class="line">let strLength: <span class="attr">number</span> = (someValue as string).length<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="4-类型守卫"><a href="#4-类型守卫" class="headerlink" title="4. 类型守卫"></a>4. 类型守卫</h2><blockquote><p>A type guard is some expression that performs a runtime check that guarantees the type in some scope. —— TypeScript 官方文档</p></blockquote><p>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。目前主要有四种的方式来实现类型保护：</p><h3 id="4-1-in-关键字"><a href="#4-1-in-关键字" class="headerlink" title="4.1 in 关键字"></a>4.1 in 关键字</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Admin</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">privileges</span>: <span class="built_in">string</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">startDate</span>: <span class="title class_">Date</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnknownEmployee</span> = <span class="title class_">Employee</span> | <span class="title class_">Admin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printEmployeeInformation</span>(<span class="params">emp: UnknownEmployee</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Name: &#x27;</span> + emp.<span class="property">name</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;privileges&#x27;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Privileges: &#x27;</span> + emp.<span class="property">privileges</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;startDate&#x27;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Start Date: &#x27;</span> + emp.<span class="property">startDate</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-typeof-关键字"><a href="#4-2-typeof-关键字" class="headerlink" title="4.2 typeof 关键字"></a>4.2 typeof 关键字</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>(padding + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>) + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typeof</code> 类型保护只支持两种形式：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== typename</code>，<code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>， <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</p><h3 id="4-3-instanceof-关键字"><a href="#4-3-instanceof-关键字" class="headerlink" title="4.3 instanceof 关键字"></a>4.3 instanceof 关键字</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Padder</span> &#123;</span><br><span class="line">  <span class="title function_">getPaddingString</span>(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceRepeatingPadder</span> <span class="keyword">implements</span> <span class="title class_">Padder</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">getPaddingString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>(<span class="variable language_">this</span>.<span class="property">numSpaces</span> + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringPadder</span> <span class="keyword">implements</span> <span class="title class_">Padder</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">getPaddingString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">padder</span>: <span class="title class_">Padder</span> = <span class="keyword">new</span> <span class="title class_">SpaceRepeatingPadder</span>(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> <span class="title class_">SpaceRepeatingPadder</span>) &#123;</span><br><span class="line">  <span class="comment">// padder的类型收窄为 &#x27;SpaceRepeatingPadder&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-自定义类型保护的类型谓词"><a href="#4-4-自定义类型保护的类型谓词" class="headerlink" title="4.4 自定义类型保护的类型谓词"></a>4.4 自定义类型保护的类型谓词</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): x is <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">x: <span class="built_in">any</span></span>): x is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-联合类型和类型别名"><a href="#5-联合类型和类型别名" class="headerlink" title="5. 联合类型和类型别名"></a>5. 联合类型和类型别名</h2><h3 id="5-1-联合类型"><a href="#5-1-联合类型" class="headerlink" title="5.1 联合类型"></a>5.1 联合类型</h3><p>联合类型通常与 <code>null</code> 或 <code>undefined</code> 一起使用：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sayHello</span> = (<span class="params">name: <span class="built_in">string</span> | <span class="literal">undefined</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，这里 <code>name</code> 的类型是 <code>string | undefined</code> 意味着可以将 <code>string</code> 或 <code>undefined</code> 的值传递给<code>sayHello</code> 函数。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sayHello</span>(&quot;Semlinker&quot;);</span><br><span class="line"><span class="built_in">sayHello</span>(undefined);</span><br></pre></td></tr></table></figure><p>通过这个示例，你可以凭直觉知道类型 A 和类型 B 联合后的类型是同时接受 A 和 B 值的类型。</p><h3 id="5-2-可辨识联合"><a href="#5-2-可辨识联合" class="headerlink" title="5.2 可辨识联合"></a>5.2 可辨识联合</h3><p>TypeScript 可辨识联合（Discriminated Unions）类型，也称为代数数据类型或标签联合类型。<strong>它包含 3 个要点：可辨识、联合类型和类型守卫。</strong></p><p>这种类型的本质是结合联合类型和字面量类型的一种类型保护方法。<strong>如果一个类型是多个类型的联合类型，且多个类型含有一个公共属性，那么就可以利用这个公共属性，来创建不同的类型保护区块。</strong></p><p><strong>1.可辨识</strong></p><p>可辨识要求联合类型中的每个元素都含有一个单例类型属性，比如：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">enum CarTransmission &#123;</span><br><span class="line">  Automatic = <span class="number">200</span>,</span><br><span class="line">  Manual = <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Motorcycle &#123;</span><br><span class="line">  vType: <span class="string">&quot;motorcycle&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  make: number; <span class="comment">// year</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Car &#123;</span><br><span class="line">  vType: <span class="string">&quot;car&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  transmission: CarTransmission</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Truck &#123;</span><br><span class="line">  vType: <span class="string">&quot;truck&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  capacity: number; <span class="comment">// in tons</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们分别定义了 <code>Motorcycle</code>、 <code>Car</code> 和 <code>Truck</code> 三个接口，在这些接口中都包含一个 <code>vType</code> 属性，该属性被称为可辨识的属性，而其它的属性只跟特性的接口相关。</p><p><strong>2.联合类型</strong></p><p>基于前面定义了三个接口，我们可以创建一个 <code>Vehicle</code> 联合类型：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">type <span class="attr">Vehicle</span> = Motorcycle | Car | Truck<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>现在我们就可以开始使用 <code>Vehicle</code> 联合类型，对于 <code>Vehicle</code> 类型的变量，它可以表示不同类型的车辆。</p><p><strong>3.类型守卫</strong></p><p>下面我们来定义一个 <code>evaluatePrice</code> 方法，该方法用于根据车辆的类型、容量和评估因子来计算价格，具体实现如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">const <span class="attr">EVALUATION_FACTOR</span> = Math.PI<span class="comment">;</span></span><br><span class="line">function evaluatePrice(vehicle: Vehicle) &#123;</span><br><span class="line">  return vehicle.capacity * EVALUATION_FACTOR<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myTruck: <span class="attr">Truck</span> = &#123; vType: <span class="string">&quot;truck&quot;</span>, capacity: <span class="number">9.5</span> &#125;<span class="comment">;</span></span><br><span class="line">evaluatePrice(myTruck)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>对于以上代码，TypeScript 编译器将会提示以下错误信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Property <span class="string">&#x27;capacity&#x27;</span> does not exist on <span class="built_in">type</span> <span class="string">&#x27;Vehicle&#x27;</span>.</span><br><span class="line">Property <span class="string">&#x27;capacity&#x27;</span> does not exist on <span class="built_in">type</span> <span class="string">&#x27;Motorcycle&#x27;</span>.</span><br></pre></td></tr></table></figure><p>原因是在 Motorcycle 接口中，并不存在 <code>capacity</code> 属性，而对于 Car 接口来说，它也不存在 <code>capacity</code> 属性。那么，现在我们应该如何解决以上问题呢？这时，我们可以使用类型守卫。下面我们来重构一下前面定义的 <code>evaluatePrice</code> 方法，重构后的代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">evaluatePrice</span>(<span class="params">vehicle: Vehicle</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (vehicle.<span class="property">vType</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;car&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.<span class="property">transmission</span> * <span class="variable constant_">EVALUATION_FACTOR</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;truck&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.<span class="property">capacity</span> * <span class="variable constant_">EVALUATION_FACTOR</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;motorcycle&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.<span class="property">make</span> * <span class="variable constant_">EVALUATION_FACTOR</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们使用 <code>switch</code> 和 <code>case</code> 运算符来实现类型守卫，从而确保在 <code>evaluatePrice</code> 方法中，我们可以安全地访问 <code>vehicle</code> 对象中的所包含的属性，来正确的计算该车辆类型所对应的价格。</p><h3 id="5-3-类型别名"><a href="#5-3-类型别名" class="headerlink" title="5.3 类型别名"></a>5.3 类型别名</h3><p>类型别名用来给一个类型起个新名字。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">type <span class="attr">Message</span> = string | string[]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">greet</span> = (message: Message) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="6-交叉类型"><a href="#6-交叉类型" class="headerlink" title="6. 交叉类型"></a>6. 交叉类型</h2><p>TypeScript 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它<strong>包含了所需的所有类型的特性</strong>。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IWorker</span> &#123;</span><br><span class="line">  <span class="attr">companyId</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IStaff</span> = <span class="title class_">IPerson</span> &amp; <span class="title class_">IWorker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">staff</span>: <span class="title class_">IStaff</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;E1006&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">33</span>,</span><br><span class="line">  <span class="attr">companyId</span>: <span class="string">&#x27;EFT&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(staff)</span><br></pre></td></tr></table></figure><p>在上面示例中，我们首先为 IPerson 和 IWorker 类型定义了不同的成员，然后通过 <code>&amp;</code> 运算符定义了 IStaff 交叉类型，所以该类型同时拥有 IPerson 和 IWorker 这两种类型的成员。</p><h2 id="7-TypeScript-函数"><a href="#7-TypeScript-函数" class="headerlink" title="7. TypeScript 函数"></a>7. TypeScript 函数</h2><h3 id="7-1-TypeScript-函数与-JavaScript-函数的区别"><a href="#7-1-TypeScript-函数与-JavaScript-函数的区别" class="headerlink" title="7.1 TypeScript 函数与 JavaScript 函数的区别"></a>7.1 TypeScript 函数与 JavaScript 函数的区别</h3><table><thead><tr><th>TypeScript</th><th>JavaScript</th></tr></thead><tbody><tr><td>含有类型</td><td>无类型</td></tr><tr><td>箭头函数</td><td>箭头函数（ES2015）</td></tr><tr><td>函数类型</td><td>无函数类型</td></tr><tr><td>必填和可选参数</td><td>所有参数都是可选的</td></tr><tr><td>默认参数</td><td>默认参数</td></tr><tr><td>剩余参数</td><td>剩余参数</td></tr><tr><td>函数重载</td><td>无函数重载</td></tr></tbody></table><h3 id="7-2-箭头函数"><a href="#7-2-箭头函数" class="headerlink" title="7.2 箭头函数"></a>7.2 箭头函数</h3><p><strong>1.常见语法</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reading&#x27;</span>));</span><br><span class="line"></span><br><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function"><span class="params">title</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(title));</span><br><span class="line"></span><br><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">title, idx, arr</span>) =&gt;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(idx + <span class="string">&#x27;-&#x27;</span> + title);</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">title, idx, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(idx + <span class="string">&#x27;-&#x27;</span> + title);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>2.使用示例</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未使用箭头函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span></span><br><span class="line">  self.<span class="property">publishDate</span> = <span class="number">2016</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(self.<span class="property">publishDate</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">publishDate</span> = <span class="number">2016</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">publishDate</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-参数类型和返回类型"><a href="#7-3-参数类型和返回类型" class="headerlink" title="7.3 参数类型和返回类型"></a>7.3 参数类型和返回类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-函数类型"><a href="#7-4-函数类型" class="headerlink" title="7.4 函数类型"></a>7.4 函数类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数类型，然后再赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">IdGenerator</span>: <span class="function">(<span class="params">chars: <span class="built_in">string</span>, nums: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">IdGenerator</span> = createUserId</span><br></pre></td></tr></table></figure><h3 id="7-5-可选参数及默认参数"><a href="#7-5-可选参数及默认参数" class="headerlink" title="7.5 可选参数及默认参数"></a>7.5 可选参数及默认参数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可选参数：加个问号即可</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span>, age?: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name: <span class="built_in">string</span> = <span class="string">&#x27;Semlinker&#x27;</span>,</span></span><br><span class="line"><span class="params">  id: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  age?: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在声明函数时，可以通过 <code>?</code> 号来定义可选参数，比如 <code>age?: number</code> 这种形式。在实际使用时，需要注意的是可选参数要放在普通参数的后面，不然会导致编译错误。</p><h3 id="7-6-剩余参数"><a href="#7-6-剩余参数" class="headerlink" title="7.6 剩余参数"></a>7.6 剩余参数</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加...表示剩余参数</span></span><br><span class="line">function <span class="built_in">push</span>(array, ...items) &#123;</span><br><span class="line">  items<span class="selector-class">.forEach</span>(function (item) &#123;</span><br><span class="line">    array<span class="selector-class">.push</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="selector-tag">a</span> = <span class="selector-attr">[]</span>;</span><br><span class="line"><span class="built_in">push</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="7-7-函数重载"><a href="#7-7-函数重载" class="headerlink" title="7.7 函数重载"></a>7.7 函数重载</h3><p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: Combinable, b: Combinable</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">toString</span>() + b.<span class="title function_">toString</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们为 add 函数提供了多个函数类型定义，从而实现函数的重载。之后，可恶的错误消息又消失了，因为这时 result 变量的类型是 <code>string</code> 类型。在 TypeScript 中除了可以重载普通函数之外，我们还可以重载类中的成员方法。</p><p>方法重载是指在同一个类中方法同名，参数不同（参数类型不同、参数个数不同或参数个数相同时参数的先后顺序不同），调用时根据实参的形式，选择与它匹配的方法执行操作的一种技术。所以类中成员方法满足重载的条件是：在同一个类中，方法名相同且参数列表不同。下面我们来举一个成员方法重载的例子：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: number, <span class="attr">b</span>: number): number;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: <span class="keyword">string</span>, <span class="attr">b</span>: <span class="keyword">string</span>): <span class="keyword">string</span>;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: <span class="keyword">string</span>, <span class="attr">b</span>: number): <span class="keyword">string</span>;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: number, <span class="attr">b</span>: <span class="keyword">string</span>): <span class="keyword">string</span>;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: Combinable, <span class="attr">b</span>: Combinable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof a === <span class="string">&quot;string&quot;</span> || typeof b === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.<span class="title function_ invoke__">toString</span>() + b.<span class="title function_ invoke__">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">calculator</span> = <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">result</span> = calculator.<span class="title function_ invoke__">add</span>(<span class="string">&quot;Semlinker&quot;</span>, <span class="string">&quot; Kakuqo&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里需要注意的是，当 TypeScript 编译器处理函数重载时，它会查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。另外在 Calculator 类中，<code>add(a: Combinable, b: Combinable)&#123; &#125;</code> 并不是重载列表的一部分，因此对于 add 成员方法来说，我们只定义了四个重载方法。</p><h2 id="8-TypeScript-数组"><a href="#8-TypeScript-数组" class="headerlink" title="8. TypeScript 数组"></a>8. TypeScript 数组</h2><h3 id="8-1-数组解构"><a href="#8-1-数组解构" class="headerlink" title="8.1 数组解构"></a>8.1 数组解构</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> five_array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">;[x, y, z] = five_array</span><br></pre></td></tr></table></figure><h3 id="8-2-数组展开运算符"><a href="#8-2-数组展开运算符" class="headerlink" title="8.2 数组展开运算符"></a>8.2 数组展开运算符</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let <span class="attr">two_array</span> = [<span class="number">0</span>, <span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">let <span class="attr">five_array</span> = [...two_array, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="8-3-数组遍历"><a href="#8-3-数组遍历" class="headerlink" title="8.3 数组遍历"></a>8.3 数组遍历</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">colors</span>: <span class="built_in">string</span>[] = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> colors) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-TypeScript-对象"><a href="#9-TypeScript-对象" class="headerlink" title="9. TypeScript 对象"></a>9. TypeScript 对象</h2><h3 id="9-1-对象解构"><a href="#9-1-对象解构" class="headerlink" title="9.1 对象解构"></a>9.1 对象解构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Semlinker&quot;</span>,</span><br><span class="line">  gender: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; name, gender &#125; = person;</span><br></pre></td></tr></table></figure><h3 id="9-2-对象展开运算符"><a href="#9-2-对象展开运算符" class="headerlink" title="9.2 对象展开运算符"></a>9.2 对象展开运算符</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Semlinker&quot;</span>,</span><br><span class="line">  gender: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line">  address: <span class="string">&quot;Xiamen&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装对象</span></span><br><span class="line"><span class="keyword">let</span> personWithAge = &#123; ...person, age: <span class="number">33</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取除了某些项外的其它项</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, ...rest &#125; = person;</span><br></pre></td></tr></table></figure><h2 id="10-TypeScript-接口"><a href="#10-TypeScript-接口" class="headerlink" title="10. TypeScript 接口"></a>10. TypeScript 接口</h2><p>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。</p><p>TypeScript 中的接口是一个非常灵活的概念，除了可用于<a href="https://link.juejin.cn/?target=https://ts.xcatliu.com/advanced/class-and-interfaces.html%23%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状（Shape）」进行描述。</p><h3 id="10-1-对象的形状"><a href="#10-1-对象的形状" class="headerlink" title="10.1 对象的形状"></a>10.1 对象的形状</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let Semlinker: Person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Semlinker&quot;</span>,</span><br><span class="line">  age: <span class="number">33</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-2-可选-只读属性"><a href="#10-2-可选-只读属性" class="headerlink" title="10.2 可选 | 只读属性"></a>10.2 可选 | 只读属性</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只读属性用于限制只能在<strong>对象刚刚创建的时候修改其值</strong>。此外 TypeScript 还提供了 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let a: number<span class="section">[]</span> = <span class="section">[1, 2, 3, 4]</span><span class="comment">;</span></span><br><span class="line">let ro: ReadonlyArray&lt;number&gt; = a<span class="comment">;</span></span><br><span class="line">ro<span class="section">[0]</span> = 12<span class="comment">; // error!</span></span><br><span class="line">ro.push(5)<span class="comment">; // error!</span></span><br><span class="line"><span class="attr">ro.length</span> = <span class="number">100</span><span class="comment">; // error!</span></span><br><span class="line"><span class="attr">a</span> = ro<span class="comment">; // error!</span></span><br></pre></td></tr></table></figure><h2 id="11-TypeScript-类"><a href="#11-TypeScript-类" class="headerlink" title="11. TypeScript 类"></a>11. TypeScript 类</h2><h3 id="11-1-类的属性与方法"><a href="#11-1-类的属性与方法" class="headerlink" title="11.1 类的属性与方法"></a>11.1 类的属性与方法</h3><p>在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。</p><p>在 TypeScript 中，我们可以通过 <code>Class</code> 关键字来定义一个类：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="keyword">static</span> <span class="attr">cname</span>: <span class="built_in">string</span> = <span class="string">&#x27;Greeter&#x27;</span></span><br><span class="line">  <span class="comment">// 成员属性</span></span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数 - 执行初始化操作</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getClassName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Class name is Greeter&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成员方法</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那么成员属性与静态属性，成员方法与静态方法有什么区别呢？这里无需过多解释，我们直接看一下以下编译生成的 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Greeter</span> = <span class="comment">/** <span class="doctag">@class</span> */</span> (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 构造函数 - 执行初始化操作</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Greeter</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="title class_">Greeter</span>.<span class="property">getClassName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Class name is Greeter&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 成员方法</span></span><br><span class="line">  <span class="title class_">Greeter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="title class_">Greeter</span>.<span class="property">cname</span> = <span class="string">&#x27;Greeter&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Greeter</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">var</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="11-2-访问器"><a href="#11-2-访问器" class="headerlink" title="11.2 访问器"></a>11.2 访问器</h3><p>在 TypeScript 中，我们可以通过 <code>getter</code> 和 <code>setter</code> 方法来实现数据的封装和有效性校验，防止出现异常数据。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">&#x27;Hello TypeScript&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_fullName</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_fullName</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">newName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">&#x27;Hello TypeScript&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_fullName</span> = newName</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error: Unauthorized update of employee!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>()</span><br><span class="line">employee.<span class="property">fullName</span> = <span class="string">&#x27;Semlinker&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (employee.<span class="property">fullName</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(employee.<span class="property">fullName</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-类的继承"><a href="#11-3-类的继承" class="headerlink" title="11.3 类的继承"></a>11.3 类的继承</h3><p>继承 (Inheritance) 是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。</p><p>继承是一种 <a href="https://link.juejin.cn/?target=https://zh.wikipedia.org/wiki/Is-a">is-a </a>关系：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172916651d29ba48~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>在 TypeScript 中，我们可以通过 <code>extends</code> 关键字来实现继承：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = theName</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snake</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distanceInMeters = <span class="number">5</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Slithering...&#x27;</span>)</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">move</span>(distanceInMeters)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> <span class="title class_">Snake</span>(<span class="string">&#x27;Sammy the Python&#x27;</span>)</span><br><span class="line">sam.<span class="title function_">move</span>()</span><br></pre></td></tr></table></figure><h3 id="11-4-ECMAScript-私有字段"><a href="#11-4-ECMAScript-私有字段" class="headerlink" title="11.4 ECMAScript 私有字段"></a>11.4 ECMAScript 私有字段</h3><p>在 TypeScript 3.8 版本就开始支持<strong>ECMAScript 私有字段</strong>，使用方式如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  #<span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.#name&#125;</span>!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> semlinker = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Semlinker&#x27;</span>)</span><br><span class="line"></span><br><span class="line">semlinker.#name</span><br><span class="line"><span class="comment">//     ~~~~~</span></span><br><span class="line"><span class="comment">// Property &#x27;#name&#x27; is not accessible outside class &#x27;Person&#x27;</span></span><br><span class="line"><span class="comment">// because it has a private identifier.</span></span><br></pre></td></tr></table></figure><p>与常规属性（甚至使用 <code>private</code> 修饰符声明的属性）不同，私有字段要牢记以下规则：</p><ul><li>私有字段以 <code>#</code> 字符开头，有时我们称之为私有名称；</li><li>每个私有字段名称都唯一地限定于其包含的类；</li><li>不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；</li><li>私有字段不能在包含的类之外访问，甚至不能被检测到。</li></ul><h2 id="12-TypeScript-泛型"><a href="#12-TypeScript-泛型" class="headerlink" title="12. TypeScript 泛型"></a>12. TypeScript 泛型</h2><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p><p><strong>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</strong></p><p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p><p>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p><h3 id="12-1-泛型接口"><a href="#12-1-泛型接口" class="headerlink" title="12.1 泛型接口"></a>12.1 泛型接口</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">interface GenericIdentityFn<span class="operator">&lt;</span><span class="built_in">T</span><span class="operator">&gt;</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">(</span>arg<span class="operator">:</span> <span class="built_in">T</span><span class="punctuation">)</span><span class="operator">:</span> <span class="built_in">T</span>;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="12-2-泛型类"><a href="#12-2-泛型类" class="headerlink" title="12.2 泛型类"></a>12.2 泛型类</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">  zeroValue: T<span class="comment">;</span></span><br><span class="line">  add: (x: T, y: T) =&gt; T<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="attr">myGenericNumber</span> = new GenericNumber&lt;number&gt;()<span class="comment">;</span></span><br><span class="line"><span class="attr">myGenericNumber.zeroValue</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="attr">myGenericNumber.add</span> = function (x, y) &#123;</span><br><span class="line">  return x + y<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="12-3-泛型变量"><a href="#12-3-泛型变量" class="headerlink" title="12.3 泛型变量"></a>12.3 泛型变量</h3><p>对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：</p><ul><li>T（Type）：表示一个 TypeScript 类型</li><li>K（Key）：表示对象中的键类型</li><li>V（Value）：表示对象中的值类型</li><li>E（Element）：表示元素类型</li></ul><h3 id="12-4-泛型工具类型"><a href="#12-4-泛型工具类型" class="headerlink" title="12.4 泛型工具类型"></a>12.4 泛型工具类型</h3><p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍 Partial 工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。</p><h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a><strong>1.typeof</strong></h4><p>在 TypeScript 中，<code>typeof</code> 操作符可以用来获取一个变量声明或对象的类型。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">sem</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;semlinker&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sem</span> = <span class="keyword">typeof</span> sem <span class="comment">// -&gt; Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toArray</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [x]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Func</span> = <span class="keyword">typeof</span> toArray <span class="comment">// -&gt; (x: number) =&gt; number[]</span></span><br></pre></td></tr></table></figure><h4 id="2-keyof"><a href="#2-keyof" class="headerlink" title="2.keyof"></a><strong>2.keyof</strong></h4><p><code>keyof</code> 操作符可以用来一个对象中的所有 key 值：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> K1 = keyof Person; // <span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="built_in">type</span> K2 = keyof Person[]; // <span class="string">&quot;length&quot;</span> | <span class="string">&quot;toString&quot;</span> | <span class="string">&quot;pop&quot;</span> | <span class="string">&quot;push&quot;</span> | <span class="string">&quot;concat&quot;</span> | <span class="string">&quot;join&quot;</span></span><br><span class="line"><span class="built_in">type</span> K3 = keyof &#123; [x: <span class="built_in">string</span>]: Person &#125;;  // <span class="built_in">string</span> | number</span><br></pre></td></tr></table></figure><h4 id="3-in"><a href="#3-in" class="headerlink" title="3.in"></a><strong>3.in</strong></h4><p><code>in</code> 用来遍历枚举类型：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Keys = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Obj =  &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: <span class="built_in">any</span></span><br><span class="line">&#125; // -&gt; &#123; a: <span class="built_in">any</span>, b: <span class="built_in">any</span>, c: <span class="built_in">any</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="4-infer"><a href="#4-infer" class="headerlink" title="4.infer"></a><strong>4.infer</strong></h4><p>在条件类型语句中，可以用 <code>infer</code> 声明一个类型变量并且对它进行使用。</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">type ReturnType<span class="operator">&lt;</span><span class="built_in">T</span><span class="operator">&gt;</span> <span class="operator">=</span> <span class="built_in">T</span> extends <span class="punctuation">(</span></span><br><span class="line">  ...args<span class="operator">:</span> <span class="built_in">any</span><span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">)</span> <span class="operator">=</span><span class="operator">&gt;</span> infer R <span class="operator">?</span> R <span class="operator">:</span> <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><p>以上代码中 <code>infer R</code> 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p><p><strong>5.extends</strong></p><p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">interface ILengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ILengthwise</span>&gt;<span class="params">(arg: T)</span></span>: T &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">arg</span>.length);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arg</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">loggingIdentity</span>(<span class="number">3</span>);  <span class="comment">// Error, number doesn&#x27;t have a .length property</span></span><br></pre></td></tr></table></figure><p>这时我们需要传入符合约束类型的值，必须包含必须的属性：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">loggingIdentity</span>(&#123;<span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>6.Partial</strong></p><p><code>Partial&lt;T&gt;</code> 的作用就是将某个类型里的属性全部变为可选项 <code>?</code>。</p><p><strong>定义：</strong></p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"> <span class="operator">*</span> node_modules<span class="operator">/</span>typescript<span class="operator">/</span>lib<span class="operator">/</span>lib.es5.d.ts</span><br><span class="line"> <span class="operator">*</span> Make <span class="built_in">all</span> properties <span class="keyword">in</span> <span class="built_in">T</span> optional</span><br><span class="line"> <span class="operator">*</span><span class="operator">/</span></span><br><span class="line">type Partial<span class="operator">&lt;</span><span class="built_in">T</span><span class="operator">&gt;</span> <span class="operator">=</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">[</span>P <span class="keyword">in</span> keyof <span class="built_in">T</span><span class="punctuation">]</span><span class="operator">?</span><span class="operator">:</span> <span class="built_in">T</span><span class="punctuation">[</span>P<span class="punctuation">]</span>;</span><br><span class="line"><span class="punctuation">&#125;</span>;</span><br></pre></td></tr></table></figure><p>在以上代码中，首先通过 <code>keyof T</code> 拿到 <code>T</code> 的所有属性名，然后使用 <code>in</code> 进行遍历，将值赋给 <code>P</code>，最后通过 <code>T[P]</code> 取得相应的属性值。中间的 <code>?</code> 号，用于将所有属性变为可选。</p><p><strong>示例：</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line">  title: <span class="keyword">string</span>;</span><br><span class="line">  description: <span class="keyword">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTodo</span>(<span class="params">todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">todo1</span> = &#123;</span><br><span class="line">  title: <span class="string">&quot;organize desk&quot;</span>,</span><br><span class="line">  description: <span class="string">&quot;clear clutter&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">todo2</span> = <span class="title function_ invoke__">updateTodo</span>(todo1, &#123;</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&quot;throw out trash&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的 <code>updateTodo</code> 方法中，我们利用 <code>Partial&lt;T&gt;</code> 工具类型，定义 <code>fieldsToUpdate</code> 的类型为 <code>Partial&lt;Todo&gt;</code>，即：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   title?: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">   description?: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> front-end </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM 复习及前端架构</title>
      <link href="/article/DOM-review-frontend-%20architecture/"/>
      <url>/article/DOM-review-frontend-%20architecture/</url>
      
        <content type="html"><![CDATA[<h2 id="1-DOM基础"><a href="#1-DOM基础" class="headerlink" title="1. DOM基础"></a>1. DOM基础</h2><ul><li>DOM是Document Object Model的简写，文档对象模型</li><li>DOM是HTML的编程接口</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714162844731.png" alt="image-20220714162844731"></p><p>HTML文件和DOM树是一一对应的关系</p><h3 id="1-1-DOM基本操作"><a href="#1-1-DOM基本操作" class="headerlink" title="1.1. DOM基本操作"></a>1.1. DOM基本操作</h3><h4 id="1-1-1-查"><a href="#1-1-1-查" class="headerlink" title="1.1.1. 查"></a>1.1.1. 查</h4><ol><li><p>通过id查找</p><p><code>document.getElementById(&#39;&#39;)</code></p></li><li><p>通过标签名查找</p><p><code>document.getElementsByTagName(&#39;&#39;)</code></p><p>返回的是NodeList（类数组的对象）</p></li><li><p>通过class查找</p><p><code>document.getElementsByClass(&#39;&#39;)</code></p></li><li><p>根据传入的css选择器，查找匹配的DOM结点</p><ol><li><code>document.querySelector(&quot;p&quot;)</code> 只返回第一个匹配到的DOM结点</li><li><code>document.querySelectorAll(&quot;.detail&quot;)</code> 返回类为detail的所有DOM结点的集合<ol><li>eg: <code>document.querySelectorAll(&quot;ul &gt; li&quot;)</code>; 匹配嵌套在ul中的所有li元素</li><li><code>document.querySelectorAll(&quot;img+h3&quot;)</code>；匹配所有紧邻在img后的h3元素</li><li><code>document.querySelectorAll(&#39;[data-index]&#39;)</code>; 匹配所有有data-index属性的元素</li></ol></li></ol></li><li><p>根据已获取的结点，拿到该节点的子节点或父节点</p><ol><li><code>document.getElementById(&#39;&#39;).parentNode / nextElementSibling / [0]</code></li></ol></li></ol><h4 id="1-1-2-改"><a href="#1-1-2-改" class="headerlink" title="1.1.2. 改"></a>1.1.2. 改</h4><ol><li><p>改innerHTML</p><p><code>dom.innerHTML = &quot;&lt;strong&gt;修改内容&lt;strong&gt;&quot;</code></p></li><li><p>改textContent</p><p><code>dom.textContent = &quot;修改text内容&quot;</code></p></li><li><p>修改style值</p><p><code>dom.style = &quot;color: blue&quot;</code></p></li><li><p>修改指定属性值</p><p><code>dom.setAttribute(&quot;some-attribute&quot;, &quot;666&quot;)</code></p></li></ol><h4 id="1-1-3-增"><a href="#1-1-3-增" class="headerlink" title="1.1.3. 增"></a>1.1.3. 增</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCurrentTimeStr</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">const</span> hour = date.<span class="title function_">getHours</span>();</span><br><span class="line">    <span class="keyword">const</span> minutes = date.<span class="title function_">getMinutes</span>();</span><br><span class="line">    <span class="keyword">const</span> second = date.<span class="title function_">getSeconds</span>();</span><br><span class="line">    <span class="keyword">return</span> [hour, minutes, second].<span class="title function_">join</span>(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建元素</span></span><br><span class="line"><span class="keyword">let</span> newDom = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>)</span><br><span class="line">newDom.<span class="property">textContent</span> = <span class="string">&quot;页面加载时间为&quot;</span> + <span class="title function_">getCurrentTimeStr</span>();</span><br><span class="line"><span class="comment">// 将新创建的结点添加到body的子节点列表的末尾处</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(newDom) <span class="comment">// or ParentNode.appendChild(newDom)</span></span><br></pre></td></tr></table></figure><h4 id="1-1-4-删"><a href="#1-1-4-删" class="headerlink" title="1.1.4. 删"></a>1.1.4. 删</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> liToRemove = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">liToRemove.<span class="title function_">remove</span>();</span><br></pre></td></tr></table></figure><h2 id="2-DOM事件"><a href="#2-DOM事件" class="headerlink" title="2. DOM事件"></a>2. DOM事件</h2><h3 id="2-1-什么是DOM事件"><a href="#2-1-什么是DOM事件" class="headerlink" title="2.1. 什么是DOM事件"></a>2.1. 什么是DOM事件</h3><ul><li>Demo</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> liDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;something&quot;</span>)</span><br><span class="line"><span class="comment">// DOM 0级</span></span><br><span class="line">liDom.<span class="property">onclick</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exe!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>页面上的DOM之间是嵌套的结构，如果给内层DOM绑定了事件监听函数，则外层的DOM也会相应触发点击事件</li></ul><h3 id="2-2-DOM事件传播"><a href="#2-2-DOM事件传播" class="headerlink" title="2.2. DOM事件传播"></a>2.2. DOM事件传播</h3><ul><li>事件捕获阶段 –&gt; 目标事件阶段 –&gt; 事件冒泡阶段</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714170409071.png" alt="image-20220714170409071"></p><h3 id="2-2-addEventListener"><a href="#2-2-addEventListener" class="headerlink" title="2.2. addEventListener"></a>2.2. addEventListener</h3><p>DOM 2级</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> liDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;something&quot;</span>)</span><br><span class="line">liDom.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exe!(回调1)&#x27;</span>)</span><br><span class="line">&#125;); <span class="comment">// 其实还有第三个参数，once：是否只响应一次；capture：是否在捕获阶段触发（默认是false：即在冒泡阶段触发）</span></span><br><span class="line">liDom.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exe!(回调2)&#x27;</span>)</span><br><span class="line">&#125;, &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">liDom.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exe!(回调3)&#x27;</span>)</span><br><span class="line">&#125;, &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><ul><li>和直接onClick相比，可以给一个DOM绑定多个事件</li></ul><h2 id="3-BOM"><a href="#3-BOM" class="headerlink" title="3. BOM"></a>3. BOM</h2><p>Browser Object Model，控制浏览器的行为的接口</p><h3 id="3-1-通过window访问"><a href="#3-1-通过window访问" class="headerlink" title="3.1. 通过window访问"></a>3.1. 通过window访问</h3><ul><li>通过window可以访问浏览器提供的BOM对象<ul><li>location</li><li>navigator</li><li>screen</li><li>alert、prompt、confirm</li><li>localStorage</li><li>…</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;welcome!&quot;</span>) <span class="comment">// 提示框</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="variable language_">window</span>,<span class="title function_">prompt</span>(<span class="string">&quot;请输入...&quot;</span>, <span class="string">&quot;张三&quot;</span>) <span class="comment">// 输入提示框，用户可以输入内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iinfo = <span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span> <span class="comment">// 获取浏览器和系统信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&quot;是否跳转？&quot;</span>) <span class="comment">// 弹出确认框 </span></span><br><span class="line"><span class="keyword">if</span>(res) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;http://www.baidu.com&quot;</span> <span class="comment">// 跳转到百度首页</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以省window</span></span><br><span class="line">location.<span class="property">href</span> <span class="comment">// 完整url</span></span><br><span class="line">location.<span class="property">protocol</span> <span class="comment">// 协议头</span></span><br><span class="line">location.<span class="property">host</span> <span class="comment">// 域名</span></span><br><span class="line">location.<span class="property">pathname</span> <span class="comment">// 路径</span></span><br><span class="line">location.<span class="property">search</span> <span class="comment">// 参数</span></span><br><span class="line">location.<span class="property">hash</span> <span class="comment">// 哈希值</span></span><br></pre></td></tr></table></figure><h2 id="4-AJAX"><a href="#4-AJAX" class="headerlink" title="4. AJAX"></a>4. AJAX</h2><p>AJAX是异步的Javascript和XML，可以请求服务端数据，并将数据更新到页面上，且是异步的</p><h3 id="4-1-XMLHttpRequest"><a href="#4-1-XMLHttpRequest" class="headerlink" title="4.1. XMLHttpRequest"></a>4.1. XMLHttpRequest</h3><p>使用XMLHttpRequest对象与服务器通信</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> httpRequest = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="keyword">if</span>(!httpRequest) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;浏览器不支持XMLHttpRequest，如IE！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    httpRequest.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 服务器响应时触发此回调函数</span></span><br><span class="line">        <span class="keyword">if</span> (httpRequest.<span class="property">readyState</span> === httpRequest.<span class="property">DONE</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (httpRequest.<span class="property">status</span> === <span class="number">200</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(httpRequest.<span class="property">responseText</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error!&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;readyState change: &quot;</span> + httpRequest.<span class="property">readyState</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    httpRequest.<span class="title function_">open</span>(</span><br><span class="line">        <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;url&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    httpRequest.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-Fetch"><a href="#4-2-Fetch" class="headerlink" title="4.2. Fetch"></a>4.2. Fetch</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;url&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">myJson</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myJson)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-架构模式"><a href="#5-架构模式" class="headerlink" title="5. 架构模式"></a>5. 架构模式</h2><p>从一个例子开始…</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714173054756.png" alt="image-20220714173054756"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;save&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;age&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> listHtml = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;tr&gt;</span></span><br><span class="line"><span class="string">    &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">    &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">    &lt;/tr&gt;`</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> tableElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="property">innerHTML</span> += listHtml</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;upload&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> listElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> lineElement = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;tr&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    lineElement.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tds = item.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;td&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> name = tds[<span class="number">0</span>].<span class="property">innerText</span>;</span><br><span class="line">        <span class="keyword">let</span> age = tds[<span class="number">1</span>].<span class="property">innerText</span>;</span><br><span class="line">        result.<span class="title function_">push</span>(&#123;name, age&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714173909347.png" alt="image-20220714173909347"></p><p>修改：维护一个全局result，然后每次增加时添加数据到result，最后导出的时候就不需要从dom中取，直接取result即可</p><h2 id="6-MVC"><a href="#6-MVC" class="headerlink" title="6. MVC"></a>6. MVC</h2><h3 id="6-1-架构"><a href="#6-1-架构" class="headerlink" title="6.1. 架构"></a>6.1. 架构</h3><ul><li>Model ：比如前文中提到的result全局数组</li><li>View</li><li>Controller</li></ul><h3 id="6-2-基于MVC的代码重构"><a href="#6-2-基于MVC的代码重构" class="headerlink" title="6.2. 基于MVC的代码重构"></a>6.2. 基于MVC的代码重构</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> model = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller = &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> name = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;age&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">        model.<span class="title function_">push</span>(&#123; name, age &#125;);</span><br><span class="line">        view.<span class="title function_">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">upload</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(model)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> view = &#123;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = model;</span><br><span class="line">        <span class="keyword">let</span> listHtml = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123;name, age&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            listHtml += <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;tr&gt;</span></span><br><span class="line"><span class="string">                &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">                &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;/tr&gt;</span></span><br><span class="line"><span class="string">            `</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> tableElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="property">innerHTML</span> = listHtml</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;save&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    controller.<span class="title function_">add</span>();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;upload&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    controller.<span class="title function_">upload</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714174712763.png" alt="image-20220714174712763"></p><ul><li><p>再优化：单一职责</p></li><li><p>如何监听model变化？</p><ul><li><p>观察者模式</p><ul><li><code>addEventListener</code>就是一个观察者模式</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">target.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line">target.<span class="title function_">dispatchEvent</span>(<span class="string">&#x27;click&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>现在我们自己引入一个类似的事件监听器</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line">event.<span class="title function_">on</span>(<span class="string">&#x27;addItem&#x27;</span>, showList); <span class="comment">// 注册一个addItem方法，并传showList方法</span></span><br><span class="line">event.<span class="title function_">emit</span>(<span class="string">&#x27;addItem&#x27;</span>)；</span><br></pre></td></tr></table></figure></li><li><p>用观察者模式改写model层</p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_events</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">on</span>(<span class="params">evt, listener</span>) &#123;</span><br><span class="line">        (<span class="variable language_">this</span>.<span class="property">_event</span>[evt] || (<span class="variable language_">this</span>.<span class="property">_events</span>[evt] = [])).<span class="title function_">push</span>(listen)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> event = <span class="title class_">EventEmmitter</span>();</span><br><span class="line">event.<span class="title function_">on</span>(<span class="string">&#x27;add&#x27;</span>, view.<span class="property">update</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> model = &#123;</span><br><span class="line">    _value = [],</span><br><span class="line"><span class="title function_">push</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span>.<span class="title function_">push</span>(value);</span><br><span class="line">        event.<span class="title function_">emit</span>(<span class="string">&#x27;add&#x27;</span>); <span class="comment">// 每次push之后触发add方法（即view.update方法）</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller = &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> name = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;age&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">        model.<span class="title function_">push</span>(&#123; name, age &#125;);</span><br><span class="line">        <span class="comment">// view.update();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">upload</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(model.<span class="title function_">get</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> view = &#123;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = model.<span class="title function_">get</span>();</span><br><span class="line">        <span class="keyword">let</span> listHtml = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123;name, age&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            listHtml += <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;tr&gt;</span></span><br><span class="line"><span class="string">                &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">                &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;/tr&gt;</span></span><br><span class="line"><span class="string">            `</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> tableElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="property">innerHTML</span> = listHtml</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714175834918.png" alt="image-20220714175834918"></p><h2 id="7-MVVM"><a href="#7-MVVM" class="headerlink" title="7. MVVM"></a>7. MVVM</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714175940359.png" alt="image-20220714175940359"></p><p>修改ViewModel可以同步更新到View上</p><p>MVC：如何更新Model …&amp; 能够观察到Model更新的方法</p><p>MVVM：包含数据驱动视图更新的机制 &amp; 渲染视图的模板引擎</p><h3 id="7-1-如何绑定视图和数据的关系"><a href="#7-1-如何绑定视图和数据的关系" class="headerlink" title="7.1. 如何绑定视图和数据的关系"></a>7.1. 如何绑定视图和数据的关系</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714182522507.png" alt="image-20220714182522507"></p><h3 id="7-2-Vue实现MVVM的思路"><a href="#7-2-Vue实现MVVM的思路" class="headerlink" title="7.2. Vue实现MVVM的思路"></a>7.2. Vue实现MVVM的思路</h3><h4 id="7-2-1-数据劫持"><a href="#7-2-1-数据劫持" class="headerlink" title="7.2.1. 数据劫持"></a>7.2.1. 数据劫持</h4><blockquote><p>数据劫持 为什么要数据劫持？带着这个问题我们先来看下如何实现数据劫持，在vue2的源码中有个名为defineReactive$$1的方法，该方法就是用来实现数据劫持的，但该方法也只是个壳子，最终实现数据劫持的还是靠的<strong>js原生的Object.defineProperty方法</strong>，这也是vue2死活不支持ie8的原因之一。</p></blockquote><p>Object.defineProperty方法接受三个参数：</p><ul><li>第一个参数是被劫持的对象</li><li>第二个参数是被劫持的对象中的属性（key）</li><li>第三个参数是一个配置项对象（包括：value、enumerable、configurable、get和set等几个属性），如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,key,&#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们在做数据劫持时主要用到的就是get和set两个属性。</p><p>通过该方法，被劫持的对象属性，只要在外界获取或者修改属性值都会触发get或set方法，这样我们就可以在get或set中对属性做一些额外对操作。</p><p>了解了数据劫持的实现，也就知道了我们为什么要做数据劫持。是因为我们可以通过数据劫持对数据做一些额外对操作从而实现响应式数据。下面我们以vue的data为例实现一个简单的数据劫持。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="comment">// data必须是一个对象</span></span><br><span class="line">    <span class="comment">// &#123;&#125;.toString.call(): 判断类型</span></span><br><span class="line">    <span class="keyword">if</span>( (&#123;&#125;).<span class="property">toString</span>.<span class="title function_">call</span>(data) !== <span class="string">&#x27;[object Object]&#x27;</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//获取data中所有的属性</span></span><br><span class="line">    <span class="comment">// ES5 引入了Object.keys方法，成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的键名。</span></span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data); </span><br><span class="line">    <span class="comment">//循环遍历keys为data中的每个属性做数据劫持</span></span><br><span class="line">    keys.<span class="title function_">foreach</span>(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">defineReactive$$1</span>(data, key, data[key]);</span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive$$1</span>(<span class="params">obj, key, val</span>)&#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newV</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newV !== val)&#123;</span><br><span class="line">                val = newV;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-2-模板编译"><a href="#7-2-2-模板编译" class="headerlink" title="7.2.2. 模板编译"></a>7.2.2. 模板编译</h4><blockquote><p>为什么要模板编译？ 我们知道在vue中是通过一些指令或者小胡子语法来实现数据绑定的，而浏览器并不认识这些指令或者小胡子语法，因此在页面加载后需要将这些语法转换成真正的数据呈现给用户。</p></blockquote><p>下面我们以input元素和v-model指令为例来实现一个简单的模板编译。 本案例中实现模板编译的流程：</p><blockquote><ul><li>遍历#app下所有的节点，然后根据节点的类型做相应的操作<ul><li>如果是元素节点，获取该节点中所有的属性（attributes）并遍历看是否有v-model指令<ul><li>如果有v-model指令，则根据该指令绑定的属性名（data中的属性名）获取到对应到值，并赋值给节点的value属性</li></ul></li><li>如果是文本节点，则看该文本内容中是否包含小胡子语法<ul><li>如果有小胡子语法，同样需要解析出小胡子中绑定的属性名（data中的属性名）并获取到对应到值替换该文本内容</li></ul></li></ul></li><li>遍历完每个节点后再将该节点作为子节点添加到html到文档碎片中</li><li>最后再将整个文档碎片添加到dom中 需要说明到是：在vue中实现是借助虚拟dom实现的，而这里为了简单就借助文档碎片来模拟虚拟dom实现，另外为什么一定要用文档碎片，不能直接遍历节点吗？直接遍历也是可以的但是这样一来由于不停的修改节点势必会造成大量的性能消耗，而通过文档碎片在所有节点遍历完成后只需要一次消耗，这样就大大降低了回流重汇带来的性能损耗。</li></ul></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nodeTofragment</span>(<span class="params">el, vm</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">    <span class="keyword">let</span> child;</span><br><span class="line">    <span class="keyword">while</span>(child = el.<span class="property">firstChild</span>)&#123;</span><br><span class="line">        <span class="title function_">compile</span>(child, vm);<span class="comment">//模板编译</span></span><br><span class="line">        fragment.<span class="title function_">appendChild</span>(child);<span class="comment">//将节点添加到文档碎片中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compile</span>(<span class="params">node, vm</span>)&#123;</span><br><span class="line">    <span class="comment">// 每个节点都有个节点类型属性（nodeType）对应的值分别是：1元素、2文本、8注释和9根节点</span></span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">nodeType</span> === <span class="number">1</span>)&#123;<span class="comment">//  如果是元素节点</span></span><br><span class="line">        <span class="comment">// 遍历所有的属性，看是否有v-model指令</span></span><br><span class="line">        [...node.<span class="property">attributes</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="regexp">/^v-/</span>.<span class="title function_">test</span>(item.<span class="property">nodeName</span>))&#123;<span class="comment">//nodeName就是属性名，如：class、type、v-model等</span></span><br><span class="line">                node.<span class="property">value</span> = vm.<span class="property">$data</span>[item.<span class="property">nodeValue</span>]; <span class="comment">//nodeValue就是属性名中对应的值，如v-model=&quot;name&quot;中的name</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 元素节点还可能有很多子节点或孙子节点等，因此还需递归处理</span></span><br><span class="line">        [...node.<span class="property">childNodes</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">compile</span>(item, vm);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.<span class="property">nodeType</span> === <span class="number">3</span>)&#123; <span class="comment">// 如果是文本节点</span></span><br><span class="line">        <span class="comment">// 检测该文本中是否包含小胡子语法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/\&#123;\&#123;\w+\&#125;\&#125;/</span>.<span class="title function_">test</span>(node.<span class="property">textContent</span>))&#123;</span><br><span class="line">            <span class="comment">// 将小胡子替换为真正的数据</span></span><br><span class="line">            node.<span class="property">textContent</span> = node.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>, <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">                <span class="comment">// 参数a是匹配到到大的正则内容</span></span><br><span class="line">                <span class="comment">// 参数b是小分组中匹配到到内容 所以b就对应的data中定义的属性</span></span><br><span class="line">                <span class="keyword">return</span> vm.<span class="property">$data</span>[b];</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-3-双向绑定"><a href="#7-2-3-双向绑定" class="headerlink" title="7.2.3. 双向绑定"></a>7.2.3. 双向绑定</h4><p>vue主要是利用数据劫持加发布订阅模式来实现数据的双向绑定的。</p><p>在前面数据劫持的时候我们提到，数据劫持的目的就是为了在获取数据或给数据赋值之前对数据做一些额外的操作，那么这些额外的操作其实就是利用发布订阅模式对数据属性进行监控，比如说data中的name属性，首先需要知道这个name属性都在哪里用到了，以便后面如果name值发生改变时及时通知用到name的地方同步更新，这个在vue中叫做依赖收集。怎么才能知道name属性都在哪里用到了呢，这个时候数据劫持就派上用场了，前面说过只要外界对name进行访问都会触发Object.defineProperty中的get函数，那么我们就可以利用这个特点在get函数中对name属性进行监听收集。大概实现思路如下：</p><blockquote><ul><li>首先我们需要定义一个Dep类，用于对属性进行依赖收集和通知用到属性到地方进行同步更新</li><li>然后再定义一个Watcher类，用于对属性进行监听，并实现属性值的同步更新</li><li>在模板编译的时候，通过watcher来监听属性</li><li>在数据劫持的get函数中进行依赖收集</li><li>在数据劫持的set函数中通知各个watcher进行数据更新</li></ul></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span> = [];<span class="comment">//事件池 存储watcher实例对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addSub</span>(<span class="params">sub</span>)&#123;</span><br><span class="line">        <span class="comment">//sub就是watcher的实例</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">notify</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            item.<span class="title function_">update</span>();<span class="comment">//调用watcher的update</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">node, key, vm</span>)&#123;</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;<span class="comment">//用于标识只用通过Watcher监听过的属性才会进行依赖收集</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span> = node;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getValue</span>();</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getValue</span>();<span class="comment">//首先获取下最新值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeType</span> === <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeType</span> === <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">key</span>];</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-3-完整代码"><a href="#7-3-完整代码" class="headerlink" title="7.3.  完整代码"></a>7.3.  完整代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向绑定</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addSubs</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">update</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">node, key, vm</span>) &#123;</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getValue</span>();</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getValue</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">key</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">observe</span>(<span class="variable language_">this</span>.<span class="property">$data</span>)</span><br><span class="line">  <span class="title function_">nodeTofragment</span>(<span class="variable language_">this</span>.<span class="property">$el</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;西瓜watermelon&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据劫持</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((&#123;&#125;).<span class="property">toString</span>.<span class="title function_">call</span>(data) !== <span class="string">&#x27;[object Object]&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data);</span><br><span class="line">  keys.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">defineReactive$$1</span>(data, key, data[key]);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive$$1</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">addSubs</span>(<span class="title class_">Dep</span>.<span class="property">target</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newV</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newV !== val) &#123;</span><br><span class="line">        val = newV</span><br><span class="line">        dep.<span class="title function_">notify</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板编译</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nodeTofragment</span>(<span class="params">el, vm</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line">  <span class="keyword">while</span> (child = el.<span class="property">firstChild</span>) &#123;</span><br><span class="line">    <span class="title function_">compiler</span>(child, vm);</span><br><span class="line">    fragment.<span class="title function_">appendChild</span>(child);</span><br><span class="line">  &#125;</span><br><span class="line">  el.<span class="title function_">appendChild</span>(fragment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compiler</span>(<span class="params">node, vm</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;<span class="comment">//元素节点</span></span><br><span class="line">    [...node.<span class="property">attributes</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/^v-/</span>.<span class="title function_">test</span>(item.<span class="property">nodeName</span>)) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(node, item.<span class="property">nodeValue</span>, vm)</span><br><span class="line">        node.<span class="property">value</span> = vm.<span class="property">$data</span>[item.<span class="property">nodeValue</span>];</span><br><span class="line">        node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          vm.<span class="property">$data</span>[item.<span class="property">nodeValue</span>] = node.<span class="property">value</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [...node.<span class="property">childNodes</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">compiler</span>(item, vm);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/\&#123;\&#123;\w+\&#125;\&#125;/</span>.<span class="title function_">test</span>(node.<span class="property">textContent</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      node.<span class="property">textContent</span> = node.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>, <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(node, b, vm)</span><br><span class="line">        <span class="keyword">return</span> vm.<span class="property">$data</span>[b]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>我自己个的vue - mvvm<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-设计模式"><a href="#8-设计模式" class="headerlink" title="8. 设计模式"></a>8. 设计模式</h2><h3 id="8-1-观察者模式"><a href="#8-1-观察者模式" class="headerlink" title="8.1. 观察者模式"></a>8.1. 观察者模式</h3><p>当对象之间存在一对多的依赖关系时，其中一个对象的状态发生改变，所有依赖它的对象都会收到通知，这就是观察者模式。</p><p>在观察者模式中，只有两种主体：目标对象 (<code>Object</code>) 和 观察者 (<code>Observer</code>)。宗门任务大殿就是目标对象，弟子们就是观察者。</p><ul><li>目标对象 <code>Subject</code>：<ul><li>维护观察者列表 <code>observerList</code> ———— 维护拥有订阅权限的弟子列表</li><li>定义添加观察者的方法 ———— 提供弟子购买订阅权限的功能</li><li>当自身发生变化后，通过调用自己的 <code>notify</code> 方法依次通知每个观察者执行 <code>update</code> 方法 ———— 发布对应任务后通知有订阅权限的弟子</li></ul></li><li>观察者 <code>Observer</code> 需要实现 <code>update</code> 方法，供目标对象调用。<code>update</code>方法中可以执行自定义的业务逻辑 ———— 弟子们需要定义接收任务通知后的方法，例如去抢任务或任务不适合，继续等待下一个任务</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220715000730818.png" alt="image-20220715000730818"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params">&#123;taskType, taskInfo&#125;</span>) &#123;</span><br><span class="line">        <span class="comment">// 假设任务分为日常route和战斗war</span></span><br><span class="line">        <span class="keyword">if</span> (taskType === <span class="string">&quot;route&quot;</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>不需要日常任务`</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">goToTaskHome</span>(taskInfo);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">goToTaskHome</span>(<span class="params">info</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>去任务大殿抢<span class="subst">$&#123;info&#125;</span>任务`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observerList</span> = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addObserver</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">push</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">notify</span>(<span class="params">task</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发布五星任务&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> observer.<span class="title function_">update</span>(task))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line"><span class="keyword">const</span> stu1 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&quot;弟子1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> stu2 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&quot;弟子2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stu1 stu2 购买五星任务通知权限</span></span><br><span class="line">subject.<span class="title function_">addObserver</span>(stu1);</span><br><span class="line">subject.<span class="title function_">addObserver</span>(stu2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务殿发布五星战斗任务</span></span><br><span class="line"><span class="keyword">const</span> warTask = &#123;</span><br><span class="line">    <span class="attr">taskType</span>: <span class="string">&#x27;war&#x27;</span>,</span><br><span class="line">    <span class="attr">taskInfo</span>: <span class="string">&quot;猎杀时刻&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务大殿通知购买权限弟子</span></span><br><span class="line">subject.<span class="title function_">notify</span>(warTask);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务殿发布五星日常任务</span></span><br><span class="line"><span class="keyword">const</span> routeTask = &#123;</span><br><span class="line">    <span class="attr">taskType</span>: <span class="string">&#x27;route&#x27;</span>,</span><br><span class="line">    <span class="attr">taskInfo</span>: <span class="string">&quot;种树浇水&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.<span class="title function_">notify</span>(routeTask);</span><br></pre></td></tr></table></figure><h3 id="8-2-发布订阅模式"><a href="#8-2-发布订阅模式" class="headerlink" title="8.2. 发布订阅模式"></a>8.2. 发布订阅模式</h3><ul><li>基本概念</li></ul><blockquote><p>基于一个事件（主题）通道，希望接收通知的对象 <code>Subscriber</code> 通过自定义事件订阅主题，被激活事件的对象 <code>Publisher</code> 通过发布主题事件的方式通知各个订阅该主题的 <code>Subscriber</code> 对象。</p></blockquote><p>因此发布订阅模式与观察者模式相比，发布订阅模式中有三个角色，发布者 <code>Publisher</code> ，事件调度中心 <code>Event Channel</code> ，订阅者 <code>Subscriber</code> 。</p><p>我们继续以弟子领取任务为栗子，宗门感觉把任务订阅放在任务大殿中有些繁琐，于是决定在任务大殿和弟子中间添加<strong>中介</strong>。弟子在中介中订阅其需要的任务类型，当任务大殿发布任务后，中介会将发布任务给对应的订阅者。</p><ul><li><p>宗门任务大殿: 任务发布者 —— <code>Publisher</code></p></li><li><p>中介功能 —— <code>Event Channel</code></p><ul><li><p>维护任务类型，以及每种任务下的订阅情况</p></li><li><p>给订阅者提供订阅功能 —— <code>subscribe</code> 功能</p></li><li><p>当宗门发布任务后，中介会给所有的订阅者发布任务 —— <code>publish</code> 功能</p></li></ul></li><li><p>弟子: 任务接受者 —— <code>Subscriber</code></p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220715000719802.png" alt="image-20220715000719802"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PubSub</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 事件中心</span></span><br><span class="line">        <span class="comment">// 存储格式: warTask: [], routeTask: []</span></span><br><span class="line">        <span class="comment">// 每种事件(任务)下存放其订阅者的回调函数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 订阅方法</span></span><br><span class="line">    <span class="title function_">subscribe</span>(<span class="params">type, cb</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">events</span>[type] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">push</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发布方法</span></span><br><span class="line">    <span class="title function_">publish</span>(<span class="params">type, ...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">forEach</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(...args))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消订阅方法</span></span><br><span class="line">    <span class="title function_">unsubscribe</span>(<span class="params">type, cb</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="keyword">const</span> cbIndex = <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">findIndex</span>(<span class="function"><span class="params">e</span>=&gt;</span> e === cb)</span><br><span class="line">            <span class="keyword">if</span> (cbIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">splice</span>(cbIndex, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">events</span>[type];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">unsubscribeAll</span>(<span class="params">type</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">events</span>[type];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个中介公司</span></span><br><span class="line"><span class="keyword">let</span> pubsub = <span class="keyword">new</span> <span class="title class_">PubSub</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弟子一订阅战斗任务</span></span><br><span class="line">pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;warTask&#x27;</span>, <span class="keyword">function</span> (<span class="params">taskInfo</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;宗门殿发布战斗任务，任务信息:&quot;</span> + taskInfo);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 弟子一订阅战斗任务</span></span><br><span class="line">pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;routeTask&#x27;</span>, <span class="keyword">function</span> (<span class="params">taskInfo</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;宗门殿发布日常任务，任务信息:&quot;</span> + taskInfo);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 弟子三订阅全类型任务</span></span><br><span class="line">pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;allTask&#x27;</span>, <span class="keyword">function</span> (<span class="params">taskInfo</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;宗门殿发布五星任务，任务信息:&quot;</span> + taskInfo);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布战斗任务</span></span><br><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;warTask&#x27;</span>, <span class="string">&quot;猎杀时刻&quot;</span>);</span><br><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;allTask&#x27;</span>, <span class="string">&quot;猎杀时刻&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布日常任务</span></span><br><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;routeTask&#x27;</span>, <span class="string">&quot;种树浇水&quot;</span>);</span><br><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;allTask&#x27;</span>, <span class="string">&quot;种树浇水&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在发布订阅模式中，发布者和订阅者不知道对方的存在。需要第三方中介，将订阅者和发布者串联起来，利用中介过滤和分配所有输入的消息。也就是说，<strong>发布-订阅模式用来处理不同系统组件的信息交流，即使这些组件不知道对方的存在</strong>。</p></blockquote><h4 id="8-3-观察者模式和发布订阅模式的差异"><a href="#8-3-观察者模式和发布订阅模式的差异" class="headerlink" title="8.3. 观察者模式和发布订阅模式的差异"></a>8.3. 观察者模式和发布订阅模式的差异</h4><table><thead><tr><th>设计模式</th><th>观察者模式</th><th>发布订阅模式</th></tr></thead><tbody><tr><td>主体</td><td>Object观察者、Subject目标对象</td><td>Publisher发布者、Event Channel事件中心、Subscribe订阅者</td></tr><tr><td>主体关系</td><td>Subject中通过observerList记录ObServer</td><td>Publisher和Subscribe不想不知道对方，通过中介联系</td></tr><tr><td>优点</td><td>角色明确，Subject和Object要遵循约定的成员方法</td><td>松散耦合，灵活度高，通常应用在异步编程中</td></tr><tr><td>缺点</td><td>紧耦合</td><td>当事件类型变多时，会增加维护成本</td></tr><tr><td>使用案例</td><td>双向数据绑定</td><td>事件总线EventBus</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Typescript 实现的简易 MVVM 框架</title>
      <link href="/article/a-MVVM-toy-with-TypeScript/"/>
      <url>/article/a-MVVM-toy-with-TypeScript/</url>
      
        <content type="html"><![CDATA[<p>2022年秋季百度暑期课程的大作业，用typescript实现的简易MVVM框架。</p><p>实现了数据劫持、单向绑定、双向绑定、发布订阅模式等</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714175940359.png" alt="image-20220714175940359" style="zoom:50%;" /><h1 id="1-核心原理"><a href="#1-核心原理" class="headerlink" title="1. 核心原理"></a>1. 核心原理</h1><p>与 MVC 相比，MVVM 包含数据驱动视图更新的机制 &amp; 渲染视图的模板引擎。总的来说 MVVM 框架的核心原理如下：</p><h2 id="1-1-数据劫持"><a href="#1-1-数据劫持" class="headerlink" title="1.1. 数据劫持"></a>1.1. 数据劫持</h2><blockquote><p>通过 js 原生的<code>Object.defineProperty</code>方法，可以进行数据劫持。而做数据劫持时主要用到的就是 get 和 set 两个属性。通过该方法，被劫持的对象属性，只要在外界获取或者修改属性值都会触发 get 或 set 方法，这样我们就可以在 get 或 set 中对属性做一些额外对操作。</p></blockquote><p>由此，可以通过数据劫持对数据做一些额外的操作从而实现响应式数据。</p><h2 id="1-2-模板编译"><a href="#1-2-模板编译" class="headerlink" title="1.2. 模板编译"></a>1.2. 模板编译</h2><blockquote><p>为什么要模板编译？ 我们知道在 vue 中是通过一些指令或者小胡子语法来实现数据绑定的，而浏览器并不认识这些指令或者小胡子语法，因此在页面加载后需要将这些语法转换成真正的数据呈现给用户。</p></blockquote><p><strong>本次大作业中</strong>，我实现模板编译的主要流程如下：</p><ul><li><p>遍历#app 下所有的节点，然后根据节点的类型做相应的操作</p><ul><li>如果是元素节点，获取该节点中所有的属性（attributes）并遍历看是否有 v-model、v-bind、v-on 指令<ul><li>如果有相应指令，则根据该指令绑定的属性名（data 中的属性名）获取到对应到值，并赋值给节点的 value 属性</li></ul></li><li>如果是文本节点，则看该文本内容中是否包含小胡子语法<ul><li>如果有小胡子语法，同样需要解析出小胡子中绑定的属性名（data 中的属性名）并获取到对应到值替换该文本内容</li></ul></li></ul></li><li><p>遍历完每个节点后再将该节点作为子节点添加到 html 到文档碎片中</p></li><li><p>最后再将整个文档碎片添加到 dom 中。</p><blockquote><p>说明：这里借鉴了虚拟 dom 的思路，本次大作业借助文档碎片来模拟虚拟 dom 实现。</p><p>使用虚拟 dom 思路可以避免直接遍历由于不停的修改节点而带来的性能消耗，通过文档碎片在所有节点遍历完成后只需要一次消耗，可以降低了回流重汇带来的性能损耗。</p></blockquote></li></ul><h2 id="1-3-双向绑定"><a href="#1-3-双向绑定" class="headerlink" title="1.3. 双向绑定"></a>1.3. 双向绑定</h2><blockquote><p>本次大作业主要是利用数据劫持加发布订阅模式来实现数据的双向绑定的。</p></blockquote><p>数据劫持的目的是为了在获取数据或给数据赋值之前对数据做一些额外的操作，那么这些额外的操作其实就是利用发布订阅模式对数据属性进行监控。大概实现思路如下：</p><ul><li>定义一个 Watcher 类，用于对属性进行监听，并实现属性值的同步更新</li><li>在模板编译的时候，通过 watcher 来监听属性</li><li>在数据劫持的 get 函数中进行依赖收集</li><li>在数据劫持的 set 函数中通知各个 watcher 进行数据更新</li></ul><h1 id="2-代码架构"><a href="#2-代码架构" class="headerlink" title="2. 代码架构"></a>2. 代码架构</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MVVM</span><br><span class="line">│</span><br><span class="line">├─ src</span><br><span class="line">│  ├─ compile</span><br><span class="line">│  │  └─ compile.ts // compile模块</span><br><span class="line">│  ├─ const</span><br><span class="line">│  │  └─ regex.ts // 正则表达式枚举</span><br><span class="line">│  ├─ observer</span><br><span class="line">│  │  └─ observer.ts // observer模块</span><br><span class="line">│  ├─ watcher</span><br><span class="line">│  │  └─ watcher.ts // wather类</span><br><span class="line">│  └─ index.ts // 主入口文件</span><br><span class="line">├─ test</span><br><span class="line">│  ├─ unitTest // 单元测试文件</span><br><span class="line">│  │  ├─ vBind.test.js</span><br><span class="line">│  │  ├─ vModel.test.js</span><br><span class="line">│  │  └─ vOn.test.js</span><br><span class="line">│  ├─ index.html // 集成测试html</span><br><span class="line">│  └─ mock.js // mock</span><br><span class="line">├─ .gitignore</span><br><span class="line">├─ package-lock.json</span><br><span class="line">├─ package.json</span><br><span class="line">├─ README.md</span><br><span class="line">├─ tsconfig.json</span><br><span class="line">└─ webpack.config.js</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-1-MVVM"><a href="#2-1-MVVM" class="headerlink" title="2.1. MVVM"></a>2.1. MVVM</h2><p>入口文件，在这里对 vue 当中的<code>$el、$methods、$data</code>进行初始化，调用 <code>observer</code> 遍历<code>$data</code>的数据并进行挟持，调用<code>compile</code>遍历<code>$el</code>下的所有节点，解析之类和取值操作。遍历<code>$data</code>的数据，通过<code>Object.defineProperty</code>的<code>getter</code>和<code>setter</code>实现对<code>$data</code> 的代理。</p><h2 id="2-2-Observer"><a href="#2-2-Observer" class="headerlink" title="2.2. Observer"></a>2.2. Observer</h2><p>遍历 <code>$data</code>，通过 <code>Object.defineProperty</code> 设置 <code>getter</code> 和 <code>setter</code>，在 <code>setter</code> 知道数据发生了改变，然后通知 <code>Wacher</code> 去更新 <code>view</code>。</p><h2 id="2-3-Compile"><a href="#2-3-Compile" class="headerlink" title="2.3. Compile"></a>2.3. Compile</h2><p>遍历<code>$el</code> 下的所有节点，解析指令和取值操作等，为每个节点绑定更新函数（在这里），绑定事件和 <code>method</code> 的关系，同时也添加订阅者，当接受到视图更新的订阅消息后，调用更新函数，实现视图更新。同时在添加订阅者的时候，初始化渲染视图。</p><h2 id="2-4-Watcher"><a href="#2-4-Watcher" class="headerlink" title="2.4. Watcher"></a>2.4. Watcher</h2><p><code>Watcher</code> 作为订阅者，充当 <code>Observer</code> 和 <code>Compile</code> 的中间桥梁，包含 <code>update</code> 方法，<code>update</code> 方法调用 <code>Compile</code> 中绑定的事件更新函数，实现对视图的初始化和更新操作。</p><h1 id="3-实例"><a href="#3-实例" class="headerlink" title="3. 实例"></a>3. 实例</h1><blockquote><p>实现功能：</p><ul><li>v-on（事件绑定）</li><li>v-bind（单向绑定）</li><li>v-model（双向绑定）</li><li>小胡子语法（插值表达式，双向绑定）</li></ul></blockquote><h2 id="3-1-HTML"><a href="#3-1-HTML" class="headerlink" title="3.1. HTML"></a>3.1. HTML</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;id&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>获取输入值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title function_">MVVM</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">message</span>: <span class="string">&#x27;测试&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&#x27;百度前端&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">id</span>: <span class="string">&#x27;1234&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">handleClick</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">message</span> + <span class="string">&#x27;:&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;, 点击确定会修改值&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;修改了值为此~&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="number">1234</span>))</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-效果展示"><a href="#3-2-效果展示" class="headerlink" title="3.2. 效果展示"></a>3.2. 效果展示</h2><p><strong><em>v-model</em></strong><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220719232943560.png" alt="image-20220719232943560"></p><p><strong><em>v-on &#x2F; v-bind</em></strong><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220719232957753.png" alt="image-20220719232957753"></p><h1 id="4-单元测试"><a href="#4-单元测试" class="headerlink" title="4. 单元测试"></a>4. 单元测试</h1><blockquote><p>考虑到我编写的都是类，在<code>MVVM</code>类构造的时候即调用所有模块，进行绑定、注册、监听、订阅等工作。因此选择构造 dom 对 v-on（事件绑定）、v-model（双向绑定）、v-bind（数据单向绑定）进行测试</p></blockquote><h2 id="4-1-测试配置"><a href="#4-1-测试配置" class="headerlink" title="4.1. 测试配置"></a>4.1. 测试配置</h2><ul><li><p>测试工具：<code>&quot;jest&quot;: &quot;^28.1.3&quot;</code></p></li><li><p>测试环境：<code>&quot;node.js&quot;: &quot;^v16.13.2&quot;</code></p></li><li><p><code>package.json</code>配置</p><ul><li><pre><code class="json">&#123;  &quot;dependencies&quot;: &#123;    &quot;http&quot;: &quot;^0.0.1-security&quot;,    &quot;jest-environment-jsdom&quot;: &quot;^28.1.3&quot;,    &quot;jsdom&quot;: &quot;^20.0.0&quot;,    &quot;text-encoding&quot;: &quot;^0.7.0&quot;  &#125;,  &quot;name&quot;: &quot;mvvm&quot;,  &quot;description&quot;: &quot;简易的MVVM框架，用typescript实现&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;directories&quot;: &#123;    &quot;test&quot;: &quot;test&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@babel/core&quot;: &quot;^7.18.9&quot;,    &quot;@babel/preset-env&quot;: &quot;^7.18.9&quot;,    &quot;@babel/preset-typescript&quot;: &quot;^7.18.6&quot;,    &quot;@types/chai&quot;: &quot;^4.3.1&quot;,    &quot;@types/jest&quot;: &quot;^28.1.6&quot;,    &quot;@types/mocha&quot;: &quot;^9.1.1&quot;,    &quot;babel-jest&quot;: &quot;^28.1.3&quot;,    &quot;chai&quot;: &quot;^4.3.6&quot;,    &quot;jest&quot;: &quot;^28.1.3&quot;,    &quot;mocha&quot;: &quot;^10.0.0&quot;,    &quot;ts-loader&quot;: &quot;^9.3.1&quot;,    &quot;ts-node&quot;: &quot;^10.9.1&quot;,    &quot;typescript&quot;: &quot;^4.7.4&quot;,    &quot;webpack&quot;: &quot;^5.73.0&quot;,    &quot;webpack-cli&quot;: &quot;^4.10.0&quot;  &#125;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;jest&quot;,    &quot;build&quot;: &quot;webpack&quot;,    &quot;coverage&quot;: &quot;jest --coverage&quot;  &#125;,  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git+https://github.com/Pengzna/MVVM-toy.git&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;bugs&quot;: &#123;    &quot;url&quot;: &quot;https://github.com/Pengzna/MVVM-toy/issues&quot;  &#125;,  &quot;homepage&quot;: &quot;https://github.com/Pengzna/MVVM-toy#readme&quot;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `jest.config.js`配置</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">      transform: &#123;</span><br><span class="line">        &#x27;^.+\\.js$&#x27;: &#x27;babel-jest&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      testEnvironment: &#x27;jsdom&#x27;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h2 id="4-2-测试代码"><a href="#4-2-测试代码" class="headerlink" title="4.2. 测试代码"></a>4.2. 测试代码</h2><h3 id="4-2-1-vBind-test-js"><a href="#4-2-1-vBind-test-js" class="headerlink" title="4.2.1. vBind.test.js"></a>4.2.1. vBind.test.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">MVVM</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../../src/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;v-bind test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div v-bind:id=&quot;id&quot;&gt;&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;button v-on:click=&quot;handleClick&quot;&gt;获取输入值&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title function_">MVVM</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;测试&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;百度前端&#x27;</span>,</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> testNode = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;1234&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> actualValue = <span class="string">&#x27;&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;&#x27;</span></span><br><span class="line">  <span class="title function_">expect</span>(testNode.<span class="property">textContent</span>).<span class="title function_">toBe</span>(actualValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-2-2-vModel-test-js"><a href="#4-2-2-vModel-test-js" class="headerlink" title="4.2.2. vModel.test.js"></a>4.2.2. vModel.test.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">MVVM</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../../src/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;v-model test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div v-bind:id=&quot;id&quot;&gt;&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;button v-on:click=&quot;handleClick&quot;&gt;获取输入值&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title function_">MVVM</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;测试&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;百度前端&#x27;</span>,</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> actualValue = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>].<span class="property">value</span></span><br><span class="line">  <span class="title function_">expect</span>(vue.<span class="property">name</span>).<span class="title function_">toBe</span>(actualValue)</span><br><span class="line">  <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="comment">// 触发v-model需要触发事件。</span></span><br><span class="line">  input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    vue.<span class="property">name</span> = <span class="string">&#x27;修改后&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> inputEvent = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">  input.<span class="title function_">dispatchEvent</span>(inputEvent)</span><br><span class="line">  <span class="keyword">const</span> modifiedValue = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>].<span class="property">value</span></span><br><span class="line">  <span class="title function_">expect</span>(vue.<span class="property">name</span>).<span class="title function_">toBe</span>(modifiedValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-2-3-vOn-test-js"><a href="#4-2-3-vOn-test-js" class="headerlink" title="4.2.3. vOn.test.js"></a>4.2.3. vOn.test.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">MVVM</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../../src/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;v-on test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div v-bind:id=&quot;id&quot;&gt;&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;button v-on:click=&quot;handleClick&quot; id=&quot;bt&quot;&gt;获取输入值&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title function_">MVVM</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;测试&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;百度前端&#x27;</span>,</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="attr">handleClick</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;修改了值为此~&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;bt&#x27;</span>).<span class="title function_">click</span>()</span><br><span class="line">  <span class="keyword">const</span> actualValue = <span class="string">&#x27;修改了值为此~&#x27;</span></span><br><span class="line">  <span class="title function_">expect</span>(vue.<span class="property">name</span>).<span class="title function_">toBe</span>(actualValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-3-测试结果"><a href="#4-3-测试结果" class="headerlink" title="4.3. 测试结果"></a>4.3. 测试结果</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220720123743581.png" alt="image-20220720123743581"></p><h2 id="4-4-测试覆盖率"><a href="#4-4-测试覆盖率" class="headerlink" title="4.4. 测试覆盖率"></a>4.4. 测试覆盖率</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220722113152793.png" alt="image-20220722113152793"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220722113218413.png" alt="image-20220722113218413"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学软件学院-软件工程与计算Ⅱ大作业心得</title>
      <link href="/article/SE%E2%85%A1-significant-hw/"/>
      <url>/article/SE%E2%85%A1-significant-hw/</url>
      
        <content type="html"><![CDATA[<p>笔者在南京大学软件学院2022年春-软件工程与计算Ⅱ课程中获得99分，其中大作业118分（满分100，拿了18分的 bonus）。因此记录下自己的作业心得。</p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="1-面向接口编程"><a href="#1-面向接口编程" class="headerlink" title="1. 面向接口编程"></a>1. 面向接口编程</h3><ul><li>主要用于代码复用、消除循环依赖、实现拓展等</li><li>方法：抽象公共父类（最低阶）、<strong>泛型编程</strong>（更灵活，根据具体类注入，可以实现参数和实现的多态）。下面以个人项目实践中的根据泛型实现面向接口编程举出实例：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口类，通过泛型注入具体参数，实现每个方法的参数多态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SheetService</span> &lt;SheetVO, SheetState&gt;&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建单据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userVO 操作用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetVO 单据VO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSheet</span><span class="params">(UserVO userVO, SheetVO sheetVO)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据状态获取单据(state == null 则获取所有单据)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state 单据状态</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 符合条件的所有单据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;SheetVO&gt; <span class="title function_">getSheetByState</span><span class="params">(SheetState state)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据进货单id进行审批(state == 审批完成&quot;/&quot;审批失败&quot;)</span></span><br><span class="line"><span class="comment">     * 在controller层进行权限控制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetId 单据id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state 单据修改后的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">approval</span><span class="params">(String sheetId, SheetState state)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据单据Id搜索单据信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetId 单据Id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SheetVO <span class="title function_">getSheetById</span><span class="params">(String sheetId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxSheetServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SheetService</span>&lt;xxxSheetVO, xxxSheetState&gt;</span><br></pre></td></tr></table></figure><h3 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h3><ul><li>策略模式：<ul><li>将策略方法抽象成接口，用不同的实现类实现它。</li><li>在调用 service 里组合接口类（而不是具体的实现类），根据情况向接口中注入具体的类。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PromotionStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据type制定不同的促销策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">makePromotionStrategy</span><span class="params">(PromotionStrategyVO promotionStrategyVO)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// service类（调用strategy）</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">makePromotionStrategy</span><span class="params">(PromotionStrategyVO promotionStrategyVO)</span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;制定促销策略&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    PromotionStrategy promotionStrategy;</span><br><span class="line">    <span class="comment">// 策略模式</span></span><br><span class="line">    <span class="keyword">switch</span> (promotionStrategyVO.getType())&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            promotionStrategy = <span class="keyword">new</span> <span class="title class_">UserPromotionStrategy</span>(promotionStrategyDao, customerDao);</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;对不同级别用户制定促销策略...&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            promotionStrategy = <span class="keyword">new</span> <span class="title class_">SpecialPricePromotionStrategy</span>(promotionStrategyDao);</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;制定特价包（组合商品降价）...&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            promotionStrategy = <span class="keyword">new</span> <span class="title class_">TotalAmountPromotionStrategy</span>(promotionStrategyDao);</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;针对不同总价制定促销策略...&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;错误：未指定促销策略类型！&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;完成促销策略制定&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> promotionStrategy.makePromotionStrategy(promotionStrategyVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-定时任务"><a href="#3-定时任务" class="headerlink" title="3. 定时任务"></a>3. 定时任务</h3><ul><li><p>比较简单，主要通过 SpringBoot 的<code>org.springframework.scheduling.annotation.Scheduled</code> 包实现</p></li><li><p>需要书写<code>cron</code> 表达式，跟 Linux 系统的 cron 定时任务语法相似</p></li></ul><h3 id="4-AOP（面向切面编程）"><a href="#4-AOP（面向切面编程）" class="headerlink" title="4. AOP（面向切面编程）"></a>4. AOP（面向切面编程）</h3><ul><li><p>思想：通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。</p><ul><li><p>所谓的切面（Aspect），可以简单理解为程序中的共性功能。AOP 通过关注程序中的共性功能（面），将其通过一些技术（预编译、代理等）进行统一处理，从而减少代码重复，提高效率。</p></li><li><p>一般认为切面 &#x3D; 通知 + 切入点</p><ul><li><blockquote><p>切入点是指我们要对哪些 Joinpoint 进行拦截的定义，通俗的说就是<code>被增强类中的被增强的方法</code>，即切入的地方。注意，被增强类中并不是所有的方法都被代理了</p></blockquote></li><li><blockquote><p>所谓通知是指拦截到 Joinpoint （被增强的方法）之后所要做的事情就是通知，通俗的说就是<code>对被增强的方法进行增强的代码</code>，即要做的事情</p></blockquote></li></ul></li><li><p>典型的 AOP 应用场景有：HTTP request 的鉴权授权、日志记录等</p></li></ul></li><li><p>使用：</p></li></ul><blockquote><p>Spring Boot 使用 AOP 需要添加 spring-boot-starter-aop 依赖，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;` `&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;` `&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;` `&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></blockquote><p>代码实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示当前的类是一个配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//该注解只能用在类上，作用：代表当前类是一个切面类</span></span><br><span class="line"><span class="comment">// 切面 == 通知 +　切入点</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdviceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Before</span>：前置通知</span></span><br><span class="line"><span class="comment">     * value：切入点表达式  二者加起来构建成为一个切面</span></span><br><span class="line"><span class="comment">     * JoinPoint：连接点：可以理解为两个圆形的切点，从这个切点就可以获取到当前执行的目标类及方法</span></span><br><span class="line"><span class="comment">     * 前置通知和后置通知的参数的都是 JoinPoint， 前置后置通知都没有返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 方法级别：具体到某个具体的方法</span></span><br><span class="line">    <span class="comment">// @Before(value = &quot;execution(* com.xxx.xxx.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="comment">// value值里可以加权限控制，比如public * com.xxx.xxx等</span></span><br><span class="line">    <span class="comment">// 表示service包下的所有类所有方法都执行该前置通知</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;within(com.xxx.xxx.service.*)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before开始执行查询.......&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行的目标类是: &quot;</span> + joinPoint.getTarget());</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行的目标方法是: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行的目标方法参数是: &quot;</span> + joinPoint.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知，属性参数同上面的前置通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 前置通知和后置通知独有的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(value = &quot;execution(* com.xxx.xxx.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after查询结束.......&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取执行目标类和方法名等等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proceedingJoinPoint 环绕通知的正在执行中的连接点（这是环绕通知独有的参数）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标方法执行的返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Around</span>: 环绕通知，有返回值，环绕通知必须进行放行方法（就相当于拦截器），否则目标方法无法执行)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;execution(* com.xxx.xxx.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroud</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aroud环绕通知开始.......&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;执行的目标类 = &quot;</span> + proceedingJoinPoint.getTarget());</span><br><span class="line">        System.out.println(<span class="string">&quot;执行的目标方法 = &quot;</span> + proceedingJoinPoint.getSignature().getName());</span><br><span class="line">        <span class="comment">// 必须方法目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;aroud环绕通知结束.......&quot;</span>);</span><br><span class="line">        <span class="comment">// 将目标方法的返回值进行返回，否则调用目标方法的方法无法获取到返回值</span></span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Bean-的装配"><a href="#5-Bean-的装配" class="headerlink" title="5. Bean 的装配"></a>5. Bean 的装配</h3><ul><li><p>这里主要记录踩到的坑，具体的知识点较为庞杂，在本周的学习中进行具体的记录</p></li><li><p>主要是装配时发生了空指针异常，而异常类已经标上了相关注解。百思不得其解，最后发现 SpringBoot 对 bean 的装配是自动管理，即不需要程序员手动 new。而一旦程序员手动 new，SpringBoot 即认为程序员接管了装配，不再进行自动配置。而本人的异常即为手动 new 了对象造成。</p></li></ul><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><ul><li>resultType &#x2F; resultMap<ul><li>用于指定返回类，用途相似，一般用 resultType 更方便。详细的知识点在之后的文档学习中具体记录。</li></ul></li></ul><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><ul><li><p>Agent</p><ul><li>可以简单理解为执行 pipeline 的环境。一般选择代码构建所需的环境。</li><li><blockquote><p>在配置前端 Jenkins 时，曾遇到 npm: not found 错误。原因是 Jenkins 所在容器未安装 nodejs，也并未挂载宿主机的 nodejs 脚本。解决方法是配置 node 某个版本（我用的是 node: 14)的 agent。在 agent 中执行 npm</p></blockquote></li></ul></li><li><p>Pipeline</p><ul><li>简单的说就是 Jenkins 执行的一个个任务。可以按照环境清理（Image clear）、环境准备（Prepare）、构建（Build）、测试（Test）、打包（Deploy）等步骤细分</li></ul></li><li><p>Docker in docker</p><ul><li>由于我的 Jenkins 部署在 docker 中，而有时需要在 Jenkins 环境下执行 docker 命令，即（Docker in docker），我是通过挂载宿主机的 docker 脚本和 docker.sock 实现的</li></ul></li></ul><h2 id="Gitlab-runner"><a href="#Gitlab-runner" class="headerlink" title="Gitlab-runner"></a>Gitlab-runner</h2><ul><li><p>基本配置</p><ul><li>基本照着网上的教程一路走下来即可。踩的一个大坑是需要手动在配置文件里指定<code>clone_url</code> （仓库的地址）。并且这个地址亲测不能是 ci&#x2F;cd 页面给的 http 地址，必须与仓库 url 一致（如果是 https 必须是 https）。但是由此在设置<code>artifact</code> 时可能会带来请求拦截问题，目前尚未解决。</li></ul></li><li><p>Volumes</p><ul><li>与上述 Jenkins 同样，需要挂载宿主机的 docker 脚本和 docker.sock 来实现 Docker in docker</li></ul></li><li><p>Type</p><ul><li>我用的是 docker，没试过 shell 等其他类型</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 整理重点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 学习-2</title>
      <link href="/article/Spring-learning2/"/>
      <url>/article/Spring-learning2/</url>
      
        <content type="html"><![CDATA[<h1 id="2-SpringBoot-集成-NoSQL"><a href="#2-SpringBoot-集成-NoSQL" class="headerlink" title="2. SpringBoot 集成 NoSQL"></a>2. SpringBoot 集成 NoSQL</h1><h2 id="2-1-Redis"><a href="#2-1-Redis" class="headerlink" title="2.1. Redis"></a>2.1. Redis</h2><p>使用 <code>spring-boot-starter-data-redis</code> starter 可方便地引入相关依赖。默认情况下，它使用 <a href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>。该 starter 可处理传统应用程序和响应式应用程序。</p><h3 id="2-1-1-连接"><a href="#2-1-1-连接" class="headerlink" title="2.1.1. 连接"></a>2.1.1. 连接</h3><p>您可以像所有 Spring Bean 一样注入自动配置的 <code>RedisConnectionFactory</code>、<code>StringRedisTemplate</code> 或普通的 <code>RedisTemplate</code> 实例。默认情况下，实例将尝试在 <code>localhost:6379</code> 上连接 Redis 服务器，以下是 bean 示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">(StringRedisTemplate template)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><blockquote><p>您还可以注册任意数量个实现了 <code>LettuceClientConfigurationBuilderCustomizer</code> 的 bean，以进行更高级的自定义。如果你使用 Jedis，则可以使用 <code>JedisClientConfigurationBuilderCustomizer</code>。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 学习-1</title>
      <link href="/article/Spring-learning/"/>
      <url>/article/Spring-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="1-IoC-容器"><a href="#1-IoC-容器" class="headerlink" title="1. IoC 容器"></a>1. IoC 容器</h1><ul><li>Inversion of Control （IoC）</li></ul><h2 id="1-1-Spring-IoC-Container-Bean"><a href="#1-1-Spring-IoC-Container-Bean" class="headerlink" title="1.1. Spring IoC Container &amp; Bean"></a>1.1. Spring IoC Container &amp; Bean</h2><blockquote><p>IoC 也成为依赖注入，是对象仅通过<strong>*构造函数参数、工厂方法的参数 或在对象实例被构造 或从工厂方法返回后在对象实例上设置的属性来定义它们的依赖项</strong>。*</p></blockquote><ul><li>容器在创建 Bean 时注入这些依赖性。这个过程是 Bean 本身的逆过程，因此得名控制反转<ul><li><a href="https://blog.csdn.net/sinat_36817189/article/details/123410280">(26 条消息) 浅谈控制反转（IoC）<em>米碎师兄的博客-CSDN 博客</em>控制反转</a></li></ul></li><li>在 Spring 中，构成应用程序主干并由 Spring IoC 容器管理的对象称为 bean。</li><li>bean 是由 Spring IoC 容器实例化、组装和管理的对象。 否则，bean 只是应用程序中众多对象之一。 Bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。</li></ul><h2 id="1-2-容器概述"><a href="#1-2-容器概述" class="headerlink" title="1.2. 容器概述"></a>1.2. 容器概述</h2><blockquote><p><code>org.springframework.context.ApplicationContext</code> 接口代表 Spring IoC 容器，负责实例化、配置和组装 bean。 容器通过读取配置元数据来获取有关要实例化、配置和组装哪些对象的指令。 配置元数据以 XML、**<em>Java 注解</em>**或 Java 代码表示。 它可以让您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。</p></blockquote><ul><li>一般来说，创建并初始化了<code>ApplicationContext</code>后，就有了一个完全配置且可执行的系统或应用程序</li></ul><h3 id="1-2-1-配置元数据"><a href="#1-2-1-配置元数据" class="headerlink" title="1.2.1. 配置元数据"></a>1.2.1. 配置元数据</h3><p>方式主要有三</p><ul><li>基于 XML（基本用不到，不详述）</li><li>基于注解（后文提到）</li><li>基于 Java（后文提到）</li></ul><h3 id="1-2-2-实例化容器"><a href="#1-2-2-实例化容器" class="headerlink" title="1.2.2. 实例化容器"></a>1.2.2. 实例化容器</h3><ul><li>Spring 的实例化用的比较少了，略</li></ul><h3 id="1-2-3-使用容器"><a href="#1-2-3-使用容器" class="headerlink" title="1.2.3. 使用容器"></a>1.2.3. 使用容器</h3><ul><li>Spring 的实例化用的比较少了，略</li></ul><h2 id="1-3-Bean-概述"><a href="#1-3-Bean-概述" class="headerlink" title="1.3. Bean 概述"></a>1.3. Bean 概述</h2><ul><li>略</li></ul><h2 id="1-4-依赖关系"><a href="#1-4-依赖关系" class="headerlink" title="1.4. 依赖关系"></a>1.4. 依赖关系</h2><h3 id="1-4-1-依赖注入"><a href="#1-4-1-依赖注入" class="headerlink" title="1.4.1. 依赖注入"></a>1.4.1. 依赖注入</h3><ul><li>基于构造函数的依赖注入<ul><li>基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数代表一个依赖项。 调用带有特定参数的 <code>static</code> 工厂方法来构造 bean 几乎是等效的，本讨论将类似地处理构造函数和 <code>static</code> 工厂方法的参数。 以下示例显示了一个只能使用构造函数注入进行依赖注入的类</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot 中多用注解结合构造函数进行 DI</p><ul><li>构造函数参数解析<ul><li>构造函数参数解析匹配通过使用参数的类型发生。 如果 bean 定义的构造函数参数中不存在潜在的歧义，那么在 bean 定义中定义构造函数参数的顺序就是在实例化 bean 时将这些参数提供给适当的构造函数的顺序。</li></ul></li><li>Spring 中构造函数消歧义的问题<ul><li>略，SpringBoot 中很少碰到</li></ul></li><li>依赖解析流程<ul><li>容器执行 bean 依赖解析如下：<ul><li><code>ApplicationContext</code> 是用描述所有 bean 的配置元数据创建和初始化的。 配置元数据可以由 XML、Java 代码或注解指定。</li><li>对于每个 bean，它的依赖关系以属性、构造函数参数或静态工厂方法的参数（如果您使用它而不是普通构造函数）的形式表示。 在实际创建 bean 时，将这些依赖关系提供给 bean。</li><li>每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个 bean 的引用。</li><li>作为值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型。 默认情况下，Spring 可以将字符串格式提供的值转换为所有内置类型，例如 <code>int</code>、<code>long</code>、<code>String</code>、<code>boolean</code> 等等。</li></ul></li></ul></li></ul><h2 id="1-5-基于注解的容器配置"><a href="#1-5-基于注解的容器配置" class="headerlink" title="1.5. 基于注解的容器配置"></a>1.5. 基于注解的容器配置</h2><h3 id="1-5-1-Required"><a href="#1-5-1-Required" class="headerlink" title="1.5.1. @Required"></a>1.5.1. @Required</h3><p><code>@Required</code> 注解适用于 bean 属性 setter 方法，如下例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此注解表明必须在配置时通过 bean 定义中的显式属性值或通过自动装配来填充受影响的 bean 属性。 如果尚未填充受影响的 bean 属性，则容器将引发异常。 避免以后出现 <code>NullPointerException</code> 实例等。</p><blockquote><p><code>@Required</code> 注解和 <code>RequiredAnnotationBeanPostProcessor</code> 从 Spring Framework 5.1 开始正式弃用，赞成使用构造函数注入进行所需设置（或 <code>InitializingBean.afterPropertiesSet 的自定义实现 ()</code> 或自定义 <code>@PostConstruct</code> 方法以及 bean 属性 setter 方法）</p></blockquote><h3 id="1-5-2-Autowired"><a href="#1-5-2-Autowired" class="headerlink" title="1.5.2. @Autowired"></a>1.5.2. @Autowired</h3><p>您可以将 <code>@Autowired</code> 注解应用于构造函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从 Spring Framework 4.3 开始，如果目标 bean 只定义了一个构造函数，则不再需要在这样的构造函数上添加 <code>@Autowired</code> 注解。 但是，如果有多个构造函数可用且没有主&#x2F;默认构造函数，则必须至少用 <code>@Autowired</code> 注解其中一个构造函数，以便指示容器使用哪一个。</p></blockquote><p>您还可以将 <code>@Autowired</code> 注解应用于 <em>传统</em> setter 方法，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以将注解应用于具有任意名称和多个参数的方法，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span><br><span class="line"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您也可以将 <code>@Autowired</code> 应用于字段，甚至将其与构造函数混合，如下例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以通过将 <code>@Autowired</code> 注解添加到需要该类型数组的字段或方法来指示 Spring 从 <code>ApplicationContext</code> 提供特定类型的所有 bean，如 以下示例显示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，当给定注入点没有匹配的候选 bean 可用时，自动装配失败。 对于声明的数组、集合或映射，至少需要一个匹配元素。</p><p>默认行为是将带注解的方法和字段视为指示所需的依赖项。 您可以更改此行为，如下例所示，通过将不可满足的注入点标记为非必需（即，通过在 <code>@ 自动连线</code>到<code>false</code>）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-Primary"><a href="#1-5-3-Primary" class="headerlink" title="1.5.3. @Primary"></a>1.5.3. @Primary</h3><ul><li><code>@Primary</code> 表示当多个 bean 是自动装配到单值依赖项的候选者时，应优先考虑特定 bean。 如果候选中恰好存在一个主要 bean，则它成为自动装配的值。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> MovieCatalog <span class="title function_">firstMovieCatalog</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MovieCatalog <span class="title function_">secondMovieCatalog</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-4-使用泛型作为自动装配限定符"><a href="#1-5-4-使用泛型作为自动装配限定符" class="headerlink" title="1.5.4. 使用泛型作为自动装配限定符"></a>1.5.4. 使用泛型作为自动装配限定符</h3><ul><li>可以用泛型和<code>@Autowired</code>搭配装配</li></ul><h3 id="1-5-5-Resource"><a href="#1-5-5-Resource" class="headerlink" title="1.5.5. @Resource"></a>1.5.5. @Resource</h3><p>Spring 还通过在字段或 bean 属性 setter 方法上使用 JSR-250 <code>@Resource</code> 注解 (<code>javax.annotation.Resource</code>) 来支持注入。</p><p>在没有指定显式名称的 <code>@Resource</code> 用法的唯一情况下，与 <code>@Autowired</code> 类似，<code>@Resource</code> 找到主要类型匹配而不是 一个特定的命名 bean 并解析众所周知的可解析依赖项：<code>BeanFactory</code>、<code>ApplicationContext</code>、<code>ResourceLoader</code>、<code>ApplicationEventPublisher</code> 和 <code>MessageSource</code> 接口。</p><h3 id="1-5-6-Value"><a href="#1-5-6-Value" class="headerlink" title="1.5.6. @Value"></a>1.5.6. @Value</h3><p><code>@Value</code> 通常用于注入外化属性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String catalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(<span class="meta">@Value(&quot;$&#123;catalog.name&#125;&quot;)</span> String catalog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.catalog = catalog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用以下配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>以及以下 <code>application.properties</code> 文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">catalog.name=MovieCatalog</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>catalog</code> 参数和字段将等于 <code>MovieCatalog</code> 值。</p><p>Spring 提供了一个默认的宽松嵌入值解析器。 它将尝试解析属性值，如果无法解析，则属性名称（例如 <code>$&#123;catalog.name&#125;</code>）将作为值注入。 如果你想对不存在的值保持严格的控制，你应该声明一个 <code>PropertySourcesPlaceholderConfigurer</code> bean，如下例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PropertySourcesPlaceholderConfigurer <span class="title function_">propertyPlaceholderConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertySourcesPlaceholderConfigurer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Spring Boot 默认配置一个 <code>PropertySourcesPlaceholderConfigurer</code> bean，它将从 <code>application.properties</code> 和 <code>application.yml</code> 文件中获取属性。</p></blockquote><p>当 <code>@Value</code> 包含 <a href="https://geekdoc.top/docs/languages/java/spring-framework/5.3.11/reference/html/core.html#expressions"><code>SpEL</code> 表达式</a> 时，该值将在运行时动态计算，如下例所示：</p><ul><li>注：SpEL 表达式是 Spring 表达式语言</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String catalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(<span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;user.catalog&#x27;] + &#x27;Catalog&#x27; &#125;&quot;)</span> String catalog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.catalog = catalog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-7-Component-和进一步的定型注解"><a href="#1-5-7-Component-和进一步的定型注解" class="headerlink" title="1.5.7. @Component 和进一步的定型注解"></a>1.5.7. @Component 和进一步的定型注解</h3><p><code>@Repository</code> 注解是任何实现存储库角色或构造型（也称为数据访问对象或 DAO）的类的标记。 此标记的用途之一是自动转换异常。</p><p>Spring 提供了更多构造型注解：<code>@Component</code>、<code>@Service</code> 和 <code>@Controller</code>。 <code>@Component</code> 是任何 Spring 管理的组件的通用构造型。</p><p><code>@Repository</code>、<code>@Service</code> 和 <code>@Controller</code> 是 <code>@Component</code> 的特化，用于更具体的用例（在分别为持久层、服务层和表示层）。因此，您可以使用 <code>@Component</code> 注解您的组件类，但是，通过使用 <code>@Repository</code>、<code>@Service</code> 或 <code>@ 注解它们Controller</code> 相反，您的类更适合由工具处理或与切面相关联。例如，这些构造型注解是切入点的理想目标。 <code>@Repository</code>、<code>@Service</code> 和 <code>@Controller</code> 还可以在 Spring Framework 的未来版本中携带额外的语义。因此，如果您在服务层使用 <code>@Component</code> 或 <code>@Service</code> 之间做出选择，<code>@Service</code> 显然是更好的选择。同样，如前所述，<code>@Repository</code> 已经被支持作为持久层中自动异常转换的标记。</p><h2 id="1-6-基于-Java-的容器配置"><a href="#1-6-基于-Java-的容器配置" class="headerlink" title="1.6. 基于 Java 的容器配置"></a>1.6. 基于 Java 的容器配置</h2><h3 id="1-6-1-Bean-和-Component"><a href="#1-6-1-Bean-和-Component" class="headerlink" title="1.6.1. @Bean 和@Component"></a>1.6.1. @Bean 和@Component</h3><p>Spring 的新 Java 配置支持中的核心工件是 <code>@Configuration</code> 注解类和 <code>@Bean</code> 注解方法。</p><p><code>@Bean</code> 注解用于指示一个方法实例化、配置和初始化一个由 Spring IoC 容器管理的新对象。 对于熟悉 Spring 的 &#96;&#96;XML 配置的人来说，<code> </code>@Bean<code>注解与元素扮演着相同的角色。 您可以将带有</code>@Bean<code>注解的方法与任何 Spring</code>@Component<code>一起使用。 然而，它们最常与</code>@Configuration&#96; bean 一起使用。</p><p>用 <code>@Configuration</code> 注解一个类表明它的主要目的是作为 bean 定义的来源。 此外，<code>@Configuration</code> 类允许通过调用同一类中的其他 <code>@Bean</code> 方法来定义 bean 间的依赖关系。 最简单的 <code>@Configuration</code> 类如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-Component-注解"><a href="#使用-Component-注解" class="headerlink" title="使用 Component 注解"></a>使用 Component 注解</h5><p><code>@Configuration</code> 是一个类级别的注解，表明一个对象是 bean 定义的来源。 <code>@Configuration</code> 类通过带有 <code>@Bean</code> 注解的方法来声明 bean。 对 <code>@Configuration</code> 类上的 <code>@Bean</code> 方法的调用也可用于定义 bean 间的依赖关系。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学2022春-黄骏老师史纲重点整理</title>
      <link href="/article/2022-history-review/"/>
      <url>/article/2022-history-review/</url>
      
        <content type="html"><![CDATA[<p>2022年春 黄骏老师班</p><blockquote><p>参考： 2018版教材、2021版教材、黄骏老师重点、腿姐背诵手册、xqh同学总结重点、2021年春同学总结重点、2020年学长学姐总结重点</p></blockquote><p>考试体验</p><ul><li>重点外的内容：戊戌变法的时间、南昌起义、抗日战争中的国际援助</li><li>大约20分重点外，80分重点内。书写量大，前面的题目给的空少、字多</li><li>90+不多，大部分同学在85 - 90之间。</li></ul><p>建议</p><ul><li>黄骏老师最近几年考题均有重点外内容，如有条件可以平时听课，黄骏老师讲课很有意思。如果平时没有听课，考前复习务必把课本过一遍，对重大历史事件和基本历史常识要有宏观把握。</li><li>背诵类课程建议画思维导图复习，本人同样整理有史纲思维导图，但由于格式受限便不放此，有需要的同学可以联系我</li><li>本人记忆力算平均水平，考试周用了4整天背诵、巩固、强化本重点的所有内容。此复习时间和强度供大家参考</li><li>黄骏老师的课有考勤，务必做好签到</li></ul><p><em><strong>整理不易，如果觉得有用，请支持公益</strong></em></p><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220725222848913.png" alt="image-20220725222848913" style="zoom:50%;" /></div><p>思维导图（不完全、无内容版，需要整版请联系我）</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220725223756857.png" alt="image-20220725223756857"></p><h2 id="1-列强的入侵"><a href="#1-列强的入侵" class="headerlink" title="1. 列强的入侵"></a>1. 列强的入侵</h2><h3 id="方式方法"><a href="#方式方法" class="headerlink" title="方式方法"></a>方式方法</h3><p>（1）<strong>军事</strong>侵略：首先和主要的侵略方式<br>（2）<strong>政治</strong>控制： 控制中国政府或培植代理人，操纵中国的内政、外交。<br>（3）<strong>经济</strong>掠夺： 强迫中国支付巨额的战争赔款，利用其与清政府签订的不平等条约赋予的特权，进一步扩大对中国的商品倾销和资本输出<br>（4）<strong>文化</strong>渗透： 如目的是宣扬殖民主义奴化思想。</p><h3 id="几场重要的中外战争"><a href="#几场重要的中外战争" class="headerlink" title="几场重要的中外战争"></a>几场重要的中外战争</h3><ol><li><strong>鸦片战争( 1840 )</strong><ul><li><strong>名词解释：</strong>1840年至1842年英国对中国发动的一场非正义的侵略战争，也是中国近代屈辱史的开端。鸦片战争以中国失败并赔款割地告终。中英双方签订了中国历史上第一个丧权辱国不平等条约《南京条约》。中国开始失去了领土、领海、关税、司法主权，开始沦为半殖民地半封建社会。同时，鸦片战争也揭开了近代中国人民反抗外来侵略的历史新篇章。</li></ul></li></ol><ul><li><p>1840 年 4 月，英国国会通过对华战争的决定。同年 6 月，英国侵华舰队封锁了珠江海口和广东海面。鸦片战争正式爆发。</p></li><li><p><strong>开始沦为半殖民地半封建社会</strong>， 社会性质、主要矛盾、历史任务阶级关系开始变化</p></li><li><p><strong>第一个不平等条约（ 南京条约，1842）</strong>，之后还有中英（ 虎门条约，1843）、中美（望厦条约，1844）、中法（ 黄埔条约，1844）</p></li><li><p>已经开始失去了领土、领海、关税、司法主权</p><ul><li>割占香港岛，破坏了中国的主权和领土完整；外国船舰可在中国领海自由航行，破坏了中国的领海主权；外国人在华不受中国法律管束，享受领事裁判权，破坏了中国的司法主权；协定关税，则破坏了中国的关税主权</li></ul></li><li><p>民族意识开始在少数人中觉醒。</p></li><li><p>引起的反抗： 太平天国起义，而镇压太平天国起义又是洋务运动的首要原因。</p></li></ul><ol start="2"><li><p><strong>第二次鸦片战争（1856）</strong></p><ul><li><p><strong>名词解释：</strong>英、法两国在美、俄支持下联合发动的侵华战争。其目的是英、法为了进一步打开中国市场，扩大在华侵略利益。第二次鸦片战争期间，英法联军在强迫清政府签订《天津条约》《北京条约》的同时，表示愿意帮助清政府镇压太平天国，终于使清政府基本屈服。</p></li><li><p>第二次鸦片战争后，英、法各得赔款800万两白银。</p></li></ul></li><li><p><strong>甲午战争(1894一1895)</strong></p><ul><li><strong>名词解释：</strong>日本侵略中国和朝鲜的战争。最终中国战败，战后签订了《马关条约》，甲午战争标志着洋务运动的失败，给<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E6%B0%91%E6%97%8F/1186">中华民族</a>带来空前严重的民族危机，使中国进一步沦为半殖民地半封建社会，使得中国民族意识普遍觉醒；另一方面则使日本国力更为强大，为其跻身列强奠定了重要基础。</li></ul></li></ol><ul><li>进一步沦为半殖民地半封建社会</li><li>中日（ 马关条约〉，中国失去了台湾，列强以竞相租借港湾为起点，掀起了瓜分中国的狂潮</li><li>民族意识普遍觉醒（中日甲午战争以后，当中华民族面临生死存亡的关头时，中国人才开始有了普遍的民族意识的觉醒。）</li><li>标志着洋务运动的失败</li><li>引起的反抗：民族危亡、救亡， 维新运动(1898) 兴起</li></ul><ol start="3"><li>八国联军侵华(1900)<ul><li><strong>名词解释：</strong>1900年5月28日以英、俄、日、法、意、美、德、奥为首的八个主要国家组成的对中国的武装侵略战争。侵略军制造了众多惨案，并最终与中国签订《辛丑条约》，从此中国完全沦为半殖民地半封建社会。</li></ul></li></ol><ul><li><p>侵略军制造众多惨案：1900 年 8 月，八国联军侵占北京后，皇宫以及北海、中南海、颐和园等禁苑里的无数金银财宝、珍贵文物古籍遭到他们的肆意劫掠。日本侵略军还从户部银库掠去300万两库银。八国联军总司令、德国元帅瓦德西承认：“所有中国此次所受毁损及抢劫之损失，其详数将永远不能查出，但为数必极重大无疑。”1900 年，俄国入侵中国东北时，先后制造了海兰泡惨案和江东六十四屯惨案。同年8 月，八国联军侵占北京后，仅在庄王府一处，就烧死和杀死义和团团民与平民 1700 多人。</p></li><li><p>1900年八国联军侵华战争期间，欧美报刊纷纷公开讨论如何瓜分中国。</p></li><li><p>签订《辛丑条约》，中国完全沦为半殖民地半封建社会。</p></li><li><p>引起的反抗： 辛亥革命。</p></li></ul><h3 id="一系列不平等条约"><a href="#一系列不平等条约" class="headerlink" title="一系列不平等条约"></a>一系列不平等条约</h3><h4 id="中英《南京条约》"><a href="#中英《南京条约》" class="headerlink" title="中英《南京条约》"></a>中英《南京条约》</h4><ul><li><p>1842年</p></li><li><p>内容</p><ol><li>把香港岛割让给英国</li><li>向英国赔偿鸦片烟价、商欠、军费共二千一百万银元</li><li>五口通商，开放广州、福州、厦门、宁波、上海五处为通商口岸，允许英人居<br>住并设派领事</li><li>协定关税，英商应纳进出口货税、饷费，中国海关无权自主</li><li>废除公行制度，准许英商在华自由贸易等</li></ol></li><li><p>签订原因</p><ul><li>第一次鸦片战争失败</li></ul></li><li><p>后果</p><ul><li>中国开始沦为半殖民地半封建社会；破坏了原有的自给自足的自然经济体系，促进了资本主义的发展——半殖民地半封建经济体系</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611151709794.png" alt="image-20220611151709794"></p><h4 id="中俄边境诸约"><a href="#中俄边境诸约" class="headerlink" title="中俄边境诸约"></a>中俄边境诸约</h4><ol><li>1858 年俄国胁迫黑龙江将军奕山与之签订《瑷珲条约》，割去黑龙江以北 60<br>万平方公里领土</li><li>1860 年，俄国通过签订中俄《北京条约》，割去乌苏里江以东40万平方公里领<br>土</li><li>1864 年，俄国强迫清政府签订《勘分西北界约记》，割去中国西北 44 万平方<br>公里领土</li><li>1881年，通过《改订伊犁条约》和 5 个勘界议定书，割去中国西北 7 万多平方<br>公里领土</li><li>通过这一系列不平等条约，俄国共侵占中国领土 150 多万平方公里</li></ol><h4 id="中俄、美、英、法《天津条约》"><a href="#中俄、美、英、法《天津条约》" class="headerlink" title="中俄、美、英、法《天津条约》"></a>中俄、美、英、法《天津条约》</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611152353606.png" alt="image-20220611152353606"></p><h4 id="中英、中法《北京条约》"><a href="#中英、中法《北京条约》" class="headerlink" title="中英、中法《北京条约》"></a>中英、中法《北京条约》</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611152328498.png" alt="image-20220611152328498"></p><h4 id="中日《马关条约》"><a href="#中日《马关条约》" class="headerlink" title="中日《马关条约》"></a>中日《马关条约》</h4><p>1895年</p><ul><li><p>内容</p><ul><li>中国割让辽东半岛（后因三国干涉还辽而未能得逞）、台湾岛及其附属各岛<br>屿、澎湖列岛给日本</li><li>中国赔偿 2 亿两白银，加上“赎辽费”3000 万两，威海卫日军“守备费”150<br>万两，共 23150 万两</li><li>增开沙市、重庆、苏州、杭州为商埠，并允许日本在中国的通商口岸投资办厂</li></ul></li><li><p>签订原因</p><ul><li>甲午中日战争失败（1894年）</li></ul></li><li><p>后果</p><p>①台湾等大片领土的割让，进一步破坏了中国主权的完整，刺激了列强瓜分中国的野心，民族危机进一步加深。而且还造成了台湾和大陆难以弥补的隔阂，遗患至今。</p><p>②巨额赔款，加重了中国人民的负担。同时，加速了日本军国主义的发展，刺激其侵略野心。清朝因此大借外债，致使列强控制了中国的经济命脉。</p><p>③通商口岸开放，使帝国主义侵略势力深入到中国内地，中国民族危机空前严重，半殖民地化程度大大加深。</p><p>④该条约适应了帝国主义列强对华资本输出的需要，随后列强掀起了瓜分中国的狂潮。允许在华投资办厂，其他列强引用“利益均沾”的条款，争先恐后地在中国开设工厂，严重阻碍了中国民族资本主义的发展。同时也反映出列强对华经济侵略由商品输出到资本输出的过程。</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611152145246.png" alt="image-20220611152145246"></p><h4 id="《辛丑条约》"><a href="#《辛丑条约》" class="headerlink" title="《辛丑条约》"></a>《辛丑条约》</h4><p>1901年</p><ul><li><p>内容</p><ul><li>中国应支付赔款额 4.5 亿两白银，分 39 年还清，本息共计 10 亿两，并以关税<br>和盐税等作抵押</li></ul><ol start="2"><li>划定北京东交民巷为使馆界，允许各国驻兵保护，不准中国人在界内居住</li><li>拆毁天津大沽口到北京沿线设防的炮台，允许列强各国派驻兵驻扎北京到山海<br>关铁路沿线要地</li><li>清政府保证严禁人民参加反帝运动</li><li>外国认为各个通商章程中应修之处或其他应办的通商事项，清政府概允商议</li><li>惩办“首祸诸臣”</li><li>改总理各国事务衙门为外务部，班列六部之前</li><li>清政府对德、日道歉</li></ol></li><li><p>签订原因</p><ul><li>八国联军侵华（1900年）</li></ul></li><li><p>后果</p><ul><li>《辛丑条约》的签订，进一步加强了帝国主义对中国的全面控制和掠夺， 表明清政府已完全成为帝国主义统治中国的工具，标志着中国已完全沦为半殖民地半封建社会。</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611152153485.png" alt="image-20220611152153485"></p><h2 id="2-早期的维新思想"><a href="#2-早期的维新思想" class="headerlink" title="2. 早期的维新思想"></a>2. 早期的维新思想</h2><p>P40</p><h3 id="鸦片战争前后"><a href="#鸦片战争前后" class="headerlink" title="鸦片战争前后"></a>鸦片战争前后</h3><p>(1) <strong>林则徐</strong>： 他组织翻译西方书刊，编成<strong>《四洲志》</strong>， 睁眼看世界第一人。<br>(2) <strong>魏源</strong>： 《海国图志》，<strong>师夷长技以制夷</strong>。主张学习外国先进的<strong>军事和科学</strong>技术。<br>(3) <strong>郑观应</strong>(19世纪70年代后）： 不仅主张学习西方的科学技术．同时<strong>也要求吸纳西方的政治、经济学说</strong>。（具有比较强烈的反对外国侵略、希望中国独立富强的爱国思想以及具有一定程度反对封建专制的民主思想；在《盛世危言》中提出大力发展民族工商业，同西方国家进行“商战”，设立议院，实行“君民共主”制度等主张。这些主张具有重要的思想启蒙的意义。）</p><h3 id="甲午战争后：-救亡思想"><a href="#甲午战争后：-救亡思想" class="headerlink" title="甲午战争后： 救亡思想"></a>甲午战争后： 救亡思想</h3><p>(1) <strong>严复</strong>： 喊出<strong>“救亡”</strong>口号。用“物竞天择“ “适者生存”的社会进化论思想，为这种危机意识和民族意识提供了理论根据。<br>(2) <strong>孙中山</strong>喊出了“<strong>振兴中华</strong>”的时代最强音</p><p>(3) <strong>梁启超，康有为</strong>: <strong>救亡图存和振兴中华</strong></p><h2 id="3-太平天国运动失败的原因"><a href="#3-太平天国运动失败的原因" class="headerlink" title="3. 太平天国运动失败的原因"></a>3. 太平天国运动失败的原因</h2><p>P47</p><p>(1) <strong>农民不是先进生产力的代表，具有小农局限性</strong>（根本原因） ，因而无法从根本上<br>提出完整的、正确的政治纲领和社会改革方案。<br>(2) 后期领导集团腐败分裂，领导集团的一些人在生活上追求享乐，在政治上争权夺利。<br>(3) 太平天国在<em><em>军事战略上出现了巨大失误</em><br>(4) <strong>没有科学指导思想</strong>。指导思想即</em>*拜上帝教教义**不能指导甚至误导斗争</p><p>(5) <strong>未能正确对待儒学</strong>，笼统排斥或保留糟粕</p><p>(6) <strong>对西方侵略者没有达到理性认识</strong>。对资本主义侵略性认识不足</p><ul><li>太平天国起义及其失败表明，在半殖民地半封建的中国，农民具有伟大的革命潜力；但它自身不能担负起领导反帝反封建斗争取得胜利的重任。单纯的农民战争不可能完成争取民族独立和人民解放的历史任务。</li></ul><blockquote><ol><li>阶级限制，缺少理论和纲领</li><li>领导集团腐败分裂</li><li>军事战略失误</li><li>宗教限制性，不能指导甚至误导斗争</li><li>未能正确对待传统儒学，笼统排斥或保留糟粕</li><li>未能正确分析敌我态势，对资本主义侵略性认识不足</li></ol></blockquote><h2 id="4-洋务运动的历史作用"><a href="#4-洋务运动的历史作用" class="headerlink" title="4. 洋务运动的历史作用"></a>4. 洋务运动的历史作用</h2><p>P50</p><p>(1) <strong>促进早期工业和民族资本主义发展</strong>。（提出自强求富的主张，集中力量优先发展军事工业。发展民用企业）<br>(2)<strong>开启中国近代教育</strong>，开阔视野和眼界。（开办新式学堂，官派留学生，翻译自然科学书籍）</p><p>(3) <strong>使社会风气和价值观念开始变化</strong>。有利于资本主义经济发展和社会风气的改变。</p><p>(4) <strong>是中国近代化的开端</strong>。</p><blockquote><ol><li>促进早期工业和民族资本主义发展</li><li>开启中国近代教育，利用近代自然科学开阔眼界</li><li>冲击传统观念，有利于资本主义经济发展，改变社会风气</li></ol></blockquote><h2 id="5-戊戌变法的内容和意义"><a href="#5-戊戌变法的内容和意义" class="headerlink" title="5. 戊戌变法的内容和意义"></a>5. 戊戌变法的内容和意义</h2><p>P55</p><p>1898年</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ol><li>政治方面：改革行政机构，裁撤闲散、重叠机构；裁汰冗员，澄清吏治，提倡<br>廉政；提倡向皇帝上书言事；准许旗人自谋生计，取消他们享受国家供养的特<br>权。（但是，<strong>在光绪皇帝发布的新政诏令中，并没有采纳维新派多次提出的开</strong><br><strong>国会等政治主张。这些政令和措施并未触及封建制度的根本，所要推行的是一</strong><br><strong>种十分温和的不彻底的改革方案。</strong>）</li><li>经济方面：保护、奖励农工商业和交通采矿业，中央设立农工商总局与铁路矿<br>务总局，各省设立商务局；提倡开办实业，奖励发明创造；注重农业发展，提<br>倡西法垦殖，建立新式农场；广办邮政，修筑铁路；开办商学、商报，设立商<br>会等各类组织；改革财政，编制国家预决算。</li><li>军事方面：裁减旧式绿营兵，改练新式陆军；采用西洋兵制，练洋操，习洋枪<br>等。</li><li>文化教育方面：创设京师大学堂，各省书院改为高等学堂，在各设立中、小<br>学堂；提倡西学，废除八股，改试策论，开经济特科；设立译书局，翻译外国<br>书籍，派人出国留学；奖励新著，奖励创办报刊，准许自由组织学会。</li></ol><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>P56</p><p>(1) 戊戌维新运动是一次<strong>爱国救亡运动</strong>，推动了中华民族的觉醒。<br>(2) 戊戌维新运动是一场<strong>资产阶级性质的政治改革运动</strong>， 在政治、经济等领域一定程度上<strong>冲击了封建制度</strong>。<br>(3) 戊戌维新运动是一场<strong>思想启蒙运动</strong>。 宣传自由平等、社会进化观念、批判封建君权以及封建伦理、促进了民主思想的传播；</p><p>(4)对中国近代教育的发展起了积极的推动作用。维新派主张采用西方近代教育制度，兴办新式学堂。</p><p>(5) 戊戌变法在<strong>改革社会风习方面也提出新的主张</strong>。比如主张废除各处吸食鸦片及妇女裹足等恶俗陋习</p><h2 id="6-（清末）革命和改良的辩论"><a href="#6-（清末）革命和改良的辩论" class="headerlink" title="6. （清末）革命和改良的辩论"></a>6. （清末）革命和改良的辩论</h2><p>P66</p><h3 id="为什么辩"><a href="#为什么辩" class="headerlink" title="为什么辩"></a>为什么辩</h3><p>20世纪初我国民族危机加深，社会矛盾激化，清政府已陷入无法照旧统治下去的境地，以孙中山等为首的资产阶级革命派迅速发展壮大。在资产阶级民主革命思潮广泛传播、革命形势日益成熟的时候，<strong>康有为、梁启超</strong>等人坚持走改良道路，反对用革命手段推翻清朝统治。&#x2F;&#x2F; <strong>1905 年至 1907 年</strong>间，围绕中国究竟是采用革命手段还是改良方式这个问题，革命派与改良派展开了一场大论战。</p><h3 id="辩什么"><a href="#辩什么" class="headerlink" title="辩什么"></a>辩什么</h3><ul><li><strong>要不要以革命手段推翻清王朝（ 核心）</strong><ul><li>改良派：革命会引起下层社会暴乱，招致外国的干涉、瓜分。不能革命，只能改良、立宪。</li><li>革命派：<ol><li>清政府是帝国主义的“鹰犬”，只有通过革命，才能“免瓜分之祸”，获得民族独立和社会进步。</li><li>与革命的牺牲相比，不革命下，清王朝统治给人民带来的牺牲更大</li><li>人们在革命过程中的付出，是以换取历史的进步作为补偿的。革命本身正是为了建设，破坏与建设是革命的两个方面。</li></ol></li></ul></li><li><strong>要不要推翻帝制，实行共和。</strong><ul><li>改良派：中国“国民恶劣”“智力低下”，没有实行民主共和政治的能力。因此，只能实行君主立宪。</li><li>革命派：不是“国民恶劣”，而是“政府恶劣”。民主共和是大势所趋，人心所向。只有“兴民权改民主”，才是中国的唯一出路。</li></ul></li><li><strong>要不要进行社会革命。</strong><ul><li>改良派：反对土地国有，反对平均地权。他们认为土地问题不是中国最重要的问题，不存在社会革命的可能。社会革命只会导致中国的大动乱。主张土地国有是危害国本，并表示在这个问题上“宁死不让”。</li><li>革命派：中国存在着严重的“地主强权”“地权失平”的现象。必须通过平均地权以实现土地国有，在进行政治革命的同时实现社会革命，才能避免贫富不均等社会问题的岀现。</li></ul></li></ul><h3 id="什么人在辩"><a href="#什么人在辩" class="headerlink" title="什么人在辩"></a>什么人在辩</h3><ul><li><p><strong>资产阶级革命派（孙中山等人）</strong>和<strong>资产阶级改良派（康、梁等坚持走改良道路的人）</strong>。是<strong>同一阶级内部不同派别的论战</strong>。</p></li><li><p>注意与维新运动的第一次论战相比较。</p><ul><li>两次论战相同点是内容都为3 个方面，维新派都参与了论战。</li><li>两次论战的不同点是第一次为不同阶级的论战，即资产阶级思想与封这主义思想在中国的笫一次正面交锋；第二次为同一阶级内部不同派别的论战。记住“革命派“永远是主张民主、革命、共和即可。</li></ul></li></ul><h2 id="7-同盟会"><a href="#7-同盟会" class="headerlink" title="7. 同盟会"></a>7. 同盟会</h2><p>P64</p><h3 id="兴起"><a href="#兴起" class="headerlink" title="兴起"></a>兴起</h3><ul><li><strong>名词解释</strong>：于<strong>1905年</strong>、孙中山、黄兴等人以<strong>兴中会</strong>和<strong>华兴会</strong>为基础在日本成立，同盟会以<strong>《民报》为机关报</strong>，是近代中国第一个领导<strong>资产阶级革命的全国性政党</strong>，标志着中国资产阶级民主革命进入新阶段。政治纲领是<strong>“驱除鞑虏，恢复中华，创立民国，平均地权”</strong>。孙将纲领概括为三民主义：民族，民权，民生</li></ul><blockquote><p>但是，同盟会纲领中的民族主义没有从正面鲜明地提出反对帝国主义的主张。当时的革命派对于帝国主义的本质认识不清，害怕帝国主义干涉，甚至幻想以承认不平等条约“继续有效”为条件来换取列强对自己的支持。同时，他们也没有明确地把汉族军阀、官僚、地主作为革命对象，从而给了这部分人后来从内部和外部破坏革命以可乘之机。</p></blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>1894年11月，孙在檀香山组建了第一个革命团体兴中会</li><li>1895年，孙在广州策划武装起义，失败后流亡海外，继续从事反清革命活动</li><li>在资产阶级革命思想的传播过程中，资产阶级革命团体也在各地次第成立。从1904年开始，出现了十多个革命团体，其中最重要的有华兴会、科学补习所、光复会、岳王会等。</li></ul><h2 id="8-辛亥革命"><a href="#8-辛亥革命" class="headerlink" title="8. 辛亥革命"></a>8. 辛亥革命</h2><p>P68</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li>爆发于1911年，辛亥革命是<strong>资产阶级领导</strong>的以<strong>反对封建君主专制制度、建立资产阶级共和国为目的的革命</strong>，是一次比较完全意义上的资产阶级民主革命。</li><li>在近代历史上，辛亥革命是中国人民为救亡图存、振兴中华而奋起革命的一个里程<br>碑，它使中国发生了历史性的巨变，具有伟大的历史意义。</li><li>1911 年 10 月 10 日晚，<strong>武昌首义</strong>取得胜利，之后，清王朝迅速土崩瓦解。1912 年 2 月 12 日，清帝被迫退位。在中国延续了两千多年的封建帝制终于覆灭。、</li><li>中华民国临时政府宣告成立 1911 年底，孙中山被选举为临时大总统。1912 年 1 月 1 日，孙中山在南京宣誓就职，改国号为中华民国，定 1912 年为民国元年，并成立中华民国临时政府。</li><li>1912 年 3 月，临时参议院颁布《中华民国临时约法》（以下简称《临时约法》）。<br>这是中国历史上第一部具有资产阶级共和国宪法性质的法典。</li></ul><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><ul><li><strong>民族危机加深，社会矛盾激化。</strong>20世纪初，帝国主义列强在迫使中国签订《辛丑条约》，中国彻底沦为半殖民半封建社会。中国人民为救亡图存而前赴后继的顽强斗争</li><li>清末“新政“破产预备立宪并没有能够挽救清王朝，反而激化了社会矛盾，加重了危机。主要原因在于，清政府改革的根本目的是延续其反动统治。</li><li><strong>民族资本主义初步发展，形成了资产阶级革命派</strong>， 其骨干是一批资产阶级、小资产阶级知识分子</li></ul><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li>民主、共和、革命</li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>民族资产阶级领导的、比较完整的、真正意义上的资产阶级民主革命</li></ul><h3 id="意义-1"><a href="#意义-1" class="headerlink" title="意义"></a>意义</h3><p>(1) 是中国人民<strong>为救亡图存、振兴中华</strong>而奋起革命的一个里程碑，它使中国发生了历史性的巨变，具有伟大的历史意义。<br>(2) <strong>推翻了</strong>封建势力的政治代表、帝国主义在中国的代理人清王朝的统治，沉重打击了中外反动势力。<br>(3) <strong>结束了中国两千多年封建杜会的君主专制制度</strong>，建立了中国历史上第一个资产阶级共和政府，使民主共和的观念开始深入人心<br>(4)推动了中国人民的<strong>思想解放</strong>，激发了人民的爱国热悄和民族觉醒，打开了思想进步的闸门。<br>(5)推动了中国的<strong>社会变革</strong>， 促使中国的社会经济、思想习惯和社会风俗等方面发生了新的积极变化。<br>(6)不仅在一定程度上打击了帝国主义的侵略势力，而且推动了亚洲各国民族解放运动的高涨。</p><h3 id="失败原因"><a href="#失败原因" class="headerlink" title="失败原因"></a>失败原因</h3><p>(1) 从根本上说：在帝国主义时代．在半殖民地半封建的中国，<strong>资本主义的建国方案是行不通的</strong><br>(2) 主观方面来说：<strong>资产阶级革命派本身有许多弱点和错误</strong>（根源于民族资产阶级的软弱性． 妥协性）</p><h2 id="9-五四运动"><a href="#9-五四运动" class="headerlink" title="9. 五四运动"></a>9. 五四运动</h2><p>P106，108</p><p><strong>名词解释</strong>：是1<strong>919年5月4日</strong>发生在北京的一场以青年学生为主，广大群众、市民、工商人士等阶层共同参与的，通过<strong>示威游行、罢工等多种形式进行的爱国运动</strong>。五四运动的直接导火索是巴黎和会的外交失利，1919年5月4日北京学生在天安门前游行示威，1919年6月5日起，上海工人开始罢工抗议。最终迫于人民群众的压力，北洋政府不得不罢免亲日派官僚曹汝霖等的职务。中国政府代表也没有出席巴黎和约的签字仪式。五四运动的直接斗争目标得到了实现。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li><strong>巴黎和会的外交失利（直接导火线）</strong>——<strong>北京学生游行示威</strong>（<strong>1919年5月4日</strong>，北京大学等十几所学校的学生在天安门前示威游行）——<strong>上海工人罢工抗议</strong>（1919年6月5日起）—— 迫于人民群众的压力，北洋政府不得不于 6 月 10 日宣布罢免亲日派官僚曹汝霖、章宗祥、陆宗舆的职务。6 月 28 日，中国政府代表也没有出席巴黎和约的签字仪式。五四运动的直接斗争目标得到了实现。</li><li>(1) 参与人： 学生群众，后来发展为有工人阶级、小资产阶级和资产阶级参加的全国范割的革命运动。<br>(2) 两个转向：斗争的主力由学生转向了工人，运动的中心由北京转到了上海。</li></ul><h3 id="意义-2"><a href="#意义-2" class="headerlink" title="意义"></a>意义</h3><ul><li><p>1.一次彻底的<strong>反帝反封建运动</strong></p><p>2.一次真正的<strong>群众运动</strong></p><p>3.促进了<strong>马克思主义在中国的传播</strong>以及与工人运动的结合——为共产党的成立作了思想以及干部上的准备</p><p>4.<strong>新民主主义革命的开端</strong></p></li></ul><h2 id="10-中国共产主义革命"><a href="#10-中国共产主义革命" class="headerlink" title="10. 中国共产主义革命"></a>10. 中国共产主义革命</h2><ul><li><p>（重点）</p></li><li><p>国民大革命（1925 - 1927） </p></li><li><p>土地革命时期（1927 - 1937）</p><ul><li>1927 - 南昌起义<ul><li>打响了武装反抗国民党反动统治的第一枪。建军的开始，党指挥枪原则的发端。</li></ul></li><li>1927 - 秋收起义<ul><li>第一次公开打出“工农革命军”的旗帜，之后创建井冈山革命根据地</li></ul></li><li>1927 - 广州起义<ul><li>对国民党屠杀政策的英勇反击</li></ul></li></ul></li><li><p>八七会议（1927年）</p><p>(1) 彻底清算了陈独秀右倾机会主义错误。<br>(2) 确定了土地革命和武装反抗国民党反动统治的总方针， 会议还提<br>出了“整顿改编自己的队伍，纠正过去严重的错误，而找着新的道路”的<br>任务。<br>(3) 会议选出了以撒秋白为首的中央临时政治局（毛泽东在会上提<br>出：枪杆子里出政权）</p></li><li><p>古田会议（1929年）</p><p>(1) 确立了思想建党、政治建军原则． 必须绝对服从共产党的领导，必须担负打仗、筹款和做群众工作的任务，必须加强政治工作。<br>(2) 强调必须加强思想和政治路线的教育．纠正党内的错误思想<br>(3) 古田会议决议创造性地解决了在农村环境中、在党组织和军队以农民为主要成分的环境下，如何从加强思想建设入手，保待党的无产阶级先锋队性质和建设党领导的新型人民军队的问题｀这是人民军队完全区别与一切旧军队的政治特质和根本优势， 对于中国革命新道路的开辟和坚持具有重要的意义。</p></li><li><p>中国共产党建立政权：</p><ul><li>1931 年11 月成立了中华苏维埃共和国临时中央政府，毛泽东当选为主席。中华苏维埃共和国实行工农兵代表大会制度。</li></ul></li><li><p>遵义会议</p><p>(1) 解决了当时具有决定意义的军事问题和组织问题。由张闻天代替博古负总的责任，成立了由周恩来、毛泽东、王稼祥组成的新的“ 三人团”，全权负责红军的军事行动。<br>(2) 标志着中国共产党在政治上走向成熟： 同共产国际的联系中断的情况下独立自主地作出的决策。<br>(3) 开始确立以毛泽东为代表的马克思主义的正确路线在中共中央的领导地位<br>(4) 挽救了中国共产党、挽救了中国工农红军、挽救了中国革命，是中国共产党历史上一个生死攸关的转折点。</p></li></ul><h3 id="长征"><a href="#长征" class="headerlink" title="长征"></a>长征</h3><p>P143</p><p><strong>名词解释</strong>：土地革命战争时期，<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E5%B7%A5%E5%86%9C%E7%BA%A2%E5%86%9B/425591">中国工农红军</a>主力撤离长江南北各苏区，转战两年，到达陕甘苏区的战略转移行动。</p><p><strong>1934年10月</strong>，第五次反“围剿”失败后，中央主力红军为摆脱国民党军队的包围追击，被迫实行战略性转移，退出中央根据地，进行长征。</p><ul><li><p>缘起</p><ul><li>国民党从1930 年起， 下令＂困剿”革命根据地。前四次反“ 围剿”在毛泽东指挥下，取得了胜利。<strong>但是第五次反“围剿”由于执行了以王明为代表的“左”倾教条主义路线而失败，最后不得不进行战略转移——长征。</strong></li></ul></li><li><p>经过</p><ul><li>1934年10月，第五次反“围剿”失败后，中央主力红军为摆脱国民党军队的包围追击，被迫实行战略性转移，退出中央根据地，进行长征。</li><li>长征的两次会师<br>( 1 ) 1935年11 月初，中央红军在陕北吴起镇同红十五军团会合，中国共产党所领导的革命力县有了新的落脚点和战略基地。至此，中央红军的<strong>二万五千里</strong>长征胜利结束。<br>( 2) 1936年10月，红二、四方面军先后同红一方面军在甘肃会宁、静宁将台堡（今屈宁夏回族自治区）会师。至此， 三大主力红军的长征胜利结束。</li></ul></li><li><p><strong>长征的意义</strong><br>(1) 宣告了国民党反动派消灭中国共产党和红军的图谋彻底失败。<br>(2) 宣告了中国共产党和红军肩负着民族希望顺利实现了北上抗日的战略转移。<br>(3) 实现了中国共产党和中国革命事业从挫折走向胜利的伟大转折。</p></li><li><p>为什么叫长征</p><ul><li><strong>二万五千里</strong>长征</li></ul></li></ul><h2 id="11-抗日战争中日本方面"><a href="#11-抗日战争中日本方面" class="headerlink" title="11. 抗日战争中日本方面"></a>11. 抗日战争中日本方面</h2><ul><li>（重点）</li></ul><h3 id="918事变"><a href="#918事变" class="headerlink" title="918事变"></a>918事变</h3><p><strong>名词解释</strong>：1931年9月18日日本关东军突然袭击沈阳，以武力侵占东北的事件。是日本帝国主义侵华的开端。九·一八事变也标志着世界反法西斯战争的起点，揭开了第二次世界大战东方战场的序幕</p><p>1931年9月18日——关东军——柳条湖——炮轰北大营（炸毁沈阳柳条湖附近日本修筑的南满铁路路轨，并嫁祸于中国军队，日军以此为借口，炮轰中国东北军北大营）</p><p>蒋介石——攘外必先安内——使得日本侵略者更加肆无忌惮地进攻中国</p><h3 id="华北事变"><a href="#华北事变" class="headerlink" title="华北事变"></a>华北事变</h3><p><strong>名词解释</strong>：1935 年日本侵略军蚕食侵犯华北地区的一系列事件的统称，日本在华北制造一系列事端，向中国政府提出使华北政权“特殊化”的要求。中国政府在<strong>河北、察哈尔</strong>两省的主权大部丧失，华北成为日军可以自由岀人的“真空地带”。接着，日方又策动<strong>华北五省</strong>（河北、察哈尔、绥远、山西、山东）<strong>两市</strong>（北平、天津）“防共自治运动”，制造傀儡政权。</p><h3 id="卢沟桥事变"><a href="#卢沟桥事变" class="headerlink" title="卢沟桥事变"></a>卢沟桥事变</h3><ul><li><p><strong>名词解释</strong>：1937 年 7 月 7 日，驻丰台日军一个中队在卢沟桥以北举行军事演习。日军借口一名士兵失踪，要求进入宛平县城搜查，遭到拒绝后，即炮轰宛平城，向卢沟桥的中国驻军进攻。日本全面侵华战争由此开始。</p></li><li><p>1937年7月7日——宛平，驻丰台日军</p><p>“七七事变”是全民族抗战的开始，在东方开辟了世界第一个大规模的反法西斯战场</p><p>（1937.7.7夜，驻丰台日军一中队在卢沟桥以北举行军事演习。日军借口一名士兵失踪，要求进入宛平县城搜查，遭拒后，炮轰宛平城，进攻中国驻军。日本全面侵华战争由此开始。）</p></li></ul><h2 id="12-抗日战争中中国方面"><a href="#12-抗日战争中中国方面" class="headerlink" title="12. 抗日战争中中国方面"></a>12. 抗日战争中中国方面</h2><h3 id="抗日民族统一战线"><a href="#抗日民族统一战线" class="headerlink" title="抗日民族统一战线"></a>抗日民族统一战线</h3><p>P157</p><ul><li>形成过程<ul><li>1.<strong>九一八事变</strong>后，抗日救亡运动在全国兴起。</li><li>（华北事变后，中日民族矛盾进一步激化。在中国共产党关于救亡图存、全民抗战的号召和中共地下党组织的领导下，1935 年 12 月 9 日，北平学生举行声势浩大的抗日游行，喊出“反对华北自治”、“打倒日本帝国主义”、“停止内战，一致对外”等口号，遭到国民党军警镇压。12 月 16 日，北平学生和市民一万多人在天桥召开市民大会。会后，举行了更大规模的示威游行。）</li><li>2.<strong>华北事变后</strong>，中日民族矛盾进一步激化，<strong>1935年</strong>爆发<strong>一二·九</strong>运动。它促进了中华民族的觉醒，标志着中国人民抗日救亡运动新高潮的到来。</li><li>3.<strong>1935年12月</strong>，中共中央在<strong>瓦窑堡会议</strong>中，提出了在抗日的条件下与民族资产阶级重建统一战线的新政策。抗日民族统一战线正式被提出</li><li>4.<strong>1936年12月</strong>，<strong>西安事变的和平解决</strong>： 成为时局转换的枢纽。十年内战的局面由此结束，国内和平基本实现</li><li>5.<strong>1937年2月</strong> 中共中央致电<strong>国民党五届三中全会</strong>， 提出停止内战、一致对外等五项要求。全会表示同意国共两党进行谈判， 并在会议文件上第一次写上了“抗日”的字样。</li><li>6.<strong>1937年 七七事变</strong>爆发第二天，中国共产党通电全国，号召全中国同胞团结起来抵抗日本侵略。8月，国共两党达成将红军主力改编成国民革命军<strong>第八路军</strong>（简称八路军，不久改称第十八集团军）等协议。</li><li>7.<strong>1937年9月</strong>，<strong>《中共中央为公布国共合作宣言》</strong>发表；蒋介石发表实际承认共产党合法地位的谈话，以国共两党第二次合作为基础的抗日民族统 一战线正式形成</li></ul></li></ul><h3 id="西安事变"><a href="#西安事变" class="headerlink" title="西安事变"></a>西安事变</h3><ul><li>缘起和过程<ul><li>蒋介石他于 <strong>1936 年 12 月</strong>初到达西安，逼迫张学良、杨虎城攻打陕甘的红军。12 日凌晨，<strong>张学良、杨虎城</strong>（在对蒋介石“哭谏”无效的情况下，）为了实现停止内战、共同抗日，（毅然实行“兵谏”，）<strong>扣留了蒋介石</strong>。这就是西安事变。</li><li>中国共产党派周恩来等到西安，并参加张、杨同南京方面代表宋美龄、宋子文的和平谈判。蒋介石被迫作出了<strong>停止“剿共”、联合红军抗日</strong>等六项承诺。</li></ul></li><li>历史作用<ul><li>西安事变的和平解决成为<strong>时局转换的枢纽</strong>，十年内战的局面由此结束，<strong>国内和平基本实现</strong>。</li></ul></li></ul><h2 id="13-论持久战"><a href="#13-论持久战" class="headerlink" title="13. 论持久战"></a>13. 论持久战</h2><p>P162</p><ul><li>什么背景下写作<ul><li>抗日战争是一场弱国对强国的战争，战争的基本走势怎样？应当坚持什么样的战略方针？这是必须首先回答的一个重要问题</li><li><strong>1938 年</strong> 5 月至 6 月间，毛泽东发表《论持久战》的讲演，总结抗战 10 个月来的经验，系统地阐明了持久抗战的总方针。</li></ul></li><li>内容<ul><li>日本强，中国弱，<strong>强弱对比决定了抗战只能是持久战</strong></li><li>日本是<strong>小国</strong>，发动的是<strong>退步、野蛮</strong>的侵略战争，中国是<strong>大国</strong>，进行的是<strong>进步的、正义</strong>的反侵略战争，中国已经有了代表中华民族和中国人民根本利益的、在政治上成熟的中国共产党及其领导的抗日根据地和人民军队，<strong>最后胜利将属于中国</strong></li><li>强调“<strong>兵民是胜利之本</strong>”，战胜日本的侵略，必须进行人民战争</li><li>科学<strong>预测</strong>了抗日战争的<strong>发展进程</strong>：战略防御——战略相持——战略反攻<strong>三个阶段</strong></li><li>揭示了抗战的<strong>发展规律</strong>和<strong>坚持抗战争取胜利必须实行</strong>的战略方针，对全国抗战的战略指导起到了积极作用</li></ul></li></ul><h2 id="14-重庆谈判"><a href="#14-重庆谈判" class="headerlink" title="14. 重庆谈判"></a>14. 重庆谈判</h2><p>P183 P185</p><ul><li><p>缘起</p><ul><li>战后的政治形势，总的说来，对中国人民实现建设新中国的目标是有利的。在国际上，帝国主义遭到削弱，社会主义国家、民族解放运动的力量有了新的发展，世界反动势力已经难以集中起来干涉中国革命。在国内，中国人民的觉悟程度、组织程度空前提高，经过整风学习，中国共产党在毛泽东思想的基础上达到了高度的团结。中国人民克服一切困难，实现其基本历史要求的时机已经到来。</li><li>国民党统治集团作为大地主、大资产阶级的政治代表，其根本目标是使战后的中国回复到战前的状态，即坚持蒋介石的独裁统治，继续走半殖民地半封建社会的老路。由于中国共产党及其领导的人民革命力量的存在和发展，是它实现上述目标的主要障碍，还在抗战的中期、后期，蒋介石就开始采取避战观战以便保存实力、准备发动反共内战的方针。抗战刚胜利，中国就面临着内战的危险。</li><li>以武力消灭共产党及其领导的人民军队和解放区政权，是蒋介石集团的既定方针。由于全国人民强烈要求和平、反对内战，由于国民党的军队大部分远在西南、西北后方，要把它们运往内战前线、完成内战部署需要相当的时间，由于国际上苏联、美国等都表示希望中国能够实行和平建国，因此，蒋介石在积极准备内战的同时，又表示愿意与中共进行和平谈判。（其目的，一是以此敷衍国内外舆论，掩盖其正在进行的内战准备；二是诱使中共交出人民军队和解放区政权，以期不战而控制全中国；三是如果谈判不成，即放手发动内战，并把战争责任转嫁给中国共产党。）</li><li>国民党的反共方针得到了美国政府的支持。</li><li>中国共产党争取和平民主的方针<ul><li>中国共产党曾经希望通过和平的途径对中国进行政治社会的改革，逐步向建设新中国这个目标迈进。因为，中国人民在经历了长期的战争之后，有和平建国的强烈要求，中国共产党应当充分考虑人民群众的这种愿望。同时，由于人民力量强大，加上其他条件，中国共产党估计，造成国共两党合作（加上民主同盟等）、和平发展的新阶段的可能性是存在的。中国共产党应当努力争取中国出现这种局面。</li><li>还在 1945 年 5 月中共召开七大时，毛泽东就提出，对蒋介石拟采取“洗脸”政策而不是“砍头”政策。8 月 24 日，毛泽东根据时局变化进一步指岀，抗战结束，和平建设阶段开始。中央正考虑同国民党进行谈判，避免内战，实现和平建国。8 月 25 日，中共中央在对时局的宣言中明确提岀<strong>“和平、民主、团结”</strong>的口号。</li></ul></li></ul></li></ul><hr><p>  精简版缘起：</p><ul><li><p>蒋介石保存实力，准备发动反共内战的方针；国民党军队远在后方，蒋希望争取完成军队内战部署的实践；全国人民渴望和平反对内战，美苏希望中国和平建国。故蒋一边积极备战，一边表示愿意和中共和谈</p></li><li><p>蒋介石希望：敷衍舆论，掩盖内战准备；诱使共产党交出军队和解放区政权；谈判不成即发动内战，让共产党承担责任</p></li><li><p>美国希望：让蒋成为其在亚洲的主要支持者以稳定亚洲战线；遏制苏联；维护美国在中国的殖民主义利益</p></li><li><p>共产党希望：和平建国；国共合作、和平发展的新阶段存在可能（和平、民主、团结的口号）</p></li><li><p>经过</p><ul><li><p><strong>1945.5</strong>，召开<strong>七大</strong>时，毛提出对蒋介石采取“洗脸”而不是“砍头”政策。<strong>8.24</strong>，毛指出抗战结束，和平建设阶段开始。中央正<strong>考虑同国民党进行谈判，实现和平建国</strong>。<strong>8.25</strong>，中共中央在对时局的宣言中明确提出“<strong>和平、民主、团结</strong>”的口号。</p><p><strong>1945.8.14&#x2F;20&#x2F;23</strong>，蒋介石<strong>3次电邀</strong>毛到重庆共商“国际国内各种重要问题”。<strong>8.28</strong>，毛与周恩来，王若飞<strong>赴重庆谈判</strong>。<strong>10.10</strong>，双方签署<strong>《政府与中共代表会谈纪要》，即“双十协定”</strong>，确认和平建国基本方针，同意“长期合作，坚决避免内战”。<strong>1946.1.10</strong>，国共双方<strong>下达停战令</strong>，同一天，<strong>政治协商会议</strong>在重庆开幕。中共推动政协会议达成了政府组织、国民大会、和平建国纲领、宪法草案、军事问题五项协议。</p></li></ul></li><li><p>内容</p><ul><li>1945 年10月10日“ 双十协定”， 确认和平建国的方针。同意“长期合作，坚决避免内战” 。</li><li>1946年1月， 中共推动政协会议达成了政府组织、国民大会、和平建国纲领、宪法草案、军事问题五项协议。这些决议贯彻了和平民主原则，勋认了和平建国方针，确定了国会制、内阁制和省自治的政治制度。</li><li>不过， 政协的上述协议及其他协议，还不是新民主主义性质的。但它有利于冲破蒋介石的独裁统治和实行民主政治．有利千和平建国、因而在相当程度上是有利千人民的</li></ul></li></ul><h2 id="15-三大战役"><a href="#15-三大战役" class="headerlink" title="15. 三大战役"></a>15. 三大战役</h2><ul><li>在毛泽东和中共中央军委的领导和指挥下，在人民群众的热烈支援下，中国人民解放军先后发动了辽沈、淮海、平津三大战役。</li><li><strong>辽沈战役</strong>自 1948 年 9 月 12 日开始至 11 月 2 日结束，历时 52 天。东北野战军<br>（第四野战军）主力 70 万人在林彪（司令员）、罗荣桓（政委）领导下，共歼敌 47.2万人。</li><li><strong>淮海战役</strong>自 1948 年 11 月 6 日开始至 1949 年 1 月 10 日结束，历时 66 天。华<br>东野战军（第三野战军）、中原野战军（第二野战军）以及地方武装共 60 万人，在由刘伯承（二野总司令）、陈毅（三野司令员兼政委）、邓小平（二野政委）、粟裕（三野副司令员兼第二副政委）、谭震林（三野第一副政委）组成的总前委（邓小平为书记）领导下，歼敌 55.5 万人。</li><li><strong>平津战役</strong>自 1948 年 11 月 29 日开始至 1949 年 1 月 31 日结束，历时 64 天。人<br>关作战的东北野战军、华北解放军主力与地方武装共 100 万人，在由林彪、罗荣桓、聂荣臻（司令员）组成的平津前线总前委领导下，歼灭和改编国民党军队 52 万余人。</li><li><strong>意义</strong>：三大战役基本摧毁国民党赖以维持反动统治的主要军事力量。三大战役，无论是战争的规模还是取得的成果，在中国战争史上是空前的，在世界战争史上也是罕见的。这是人民战争的胜利，是毛泽东军事思想的胜利。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611174307800.png" alt="image-20220611174307800"></p><h2 id="16-毛泽东论十大关系"><a href="#16-毛泽东论十大关系" class="headerlink" title="16. 毛泽东论十大关系"></a>16. 毛泽东论十大关系</h2><ul><li>（重点），以21年为准&#x2F; 2021 P215</li></ul><ol><li>在<strong>重工业和轻工业、农业</strong>的关系问题上，要用多发展一些农业、轻工业的办法<br>来发展重工业（重工业仍是重点）</li><li>在<strong>沿海工业</strong>和<strong>内地工业</strong>的关系问题上，要充分利用和发展沿海的工业基地，以<br>便更有力量来发展和支持内地工业；新建工业放内地，一是平衡布局，二是利<br>于备战。</li><li>在<strong>经济建设</strong>和<strong>国防建设</strong>的关系问题上，在强调加强国防建设的重要性时，提出<br>把军政费用降到一个适当的比例，增加经济建设费用。只有把经济建设发展得<br>更快了，国防建设才能够有更大的进步；</li><li>在<strong>国家、生产单位</strong>和<strong>生产者个人</strong>的关系问题上，三者的利益必须兼顾，不能只<br>顾一头，既要提倡艰苦奋斗，又要关心群众生活；变苏联的“义务交售制”为<br>缩小工农业剪刀差和等价交换。</li><li>在<strong>中央和地方</strong>的关系问题上，要在巩固中央统一领导的前提下，扩大地方的权<br>力，让地方办更多的事情，发挥中央和地方两个积极性。（中央不同地方商量<br>不冒下命令）</li><li>在<strong>汉族与少数民族</strong>的关系问题上，要着重反对大汉族主义，也要反对地方民族<br>主义，要诚心诚意地积极帮助少数民族发展经济建设和文化建设；（汉族“人<br>口众多”，少数民族“地大物博”）</li><li>在<strong>党和非党</strong>的关系问题上，共产党和民主党派要长期共存，互相监督；（民主<br>党派中的很多人是不同程度的反对派）</li><li>在<strong>革命和反革命</strong>的关系问题上，必须分清敌我，化消极因素为积极因素；（给<br>反革命分子以自新的机会）</li><li>在<strong>是非关系问题</strong>上，对犯错误的同志要实行“惩前毖后，治病救人”的方针，<br>要允许人家犯错误，允许并帮助他们改正错误；</li><li>在<strong>中国和外国</strong>的关系问题上，要学习一切民族、一切国家的长处，包括资本主<br>义国家先进的科学技术和科学管理方法，要反对不加分析地一概排斥或一概照<br>搬。</li></ol><ul><li>一个基本方针： 调动一切积极因素为社会主义事业服务。</li></ul><p>《论十大关系》是中国开始探索自己的社会主义建设道路的标志，它在新的历史条件下从经济方面和政治方面提出了新的指导方针，为中共八大的召开作了理论准备。</p><h2 id="17-7000人大会"><a href="#17-7000人大会" class="headerlink" title="17. 7000人大会"></a>17. 7000人大会</h2><p>2018 P261 &#x2F; 2021 P222</p><ul><li><strong>1962年1、2月间，扩大的中共中央工作会议（即“七千人大会”）</strong>在北京召开。<strong>刘少奇</strong>代表中央提出的书<strong>面报告草稿</strong>，总结了 <strong>“大跃进”</strong>以来经济建设工作的经验教训，分析了产生<strong>缺点错误</strong>的原因。</li><li><strong>毛泽东</strong>着重阐述了民主集中制的极端重要性，并带头做了自我批评（，特别强调在社会主义建设上，我们还有很大的<strong>盲目性</strong>，今后要下苦功夫调查研究，弄清楚社会主义经济的规律。要使中国赶上和超过世界上最先进的资本主义国家，没有一百多年的时间是不行的。这是党中央和毛泽东对社会主义建设长期性的进一步认识。）</li><li><strong>邓小平、周恩来</strong>分别代表中央书记处和国务院在大会上作自我批评，并提出恢复党的优良传统和克服目前困难的主要办法。</li><li>意义：这次会议发扬了党内的<strong>民主</strong>和<strong>自我批评</strong>精神，统一了全党的认识，对动员全党团结奋斗战胜困难起了极其重要的作用。</li></ul><h2 id="18-四个现代化目标"><a href="#18-四个现代化目标" class="headerlink" title="18. 四个现代化目标"></a>18. 四个现代化目标</h2><p>2021 P223</p><ul><li>背景：当国民经济调整工作取得巨大成就的时候，党适时提出了新的奋斗目标。</li><li>内容：<strong>1964年</strong>底，<strong>周恩来</strong>在<strong>三届全国人大一次会议上</strong>郑重提出实现“四个现代化”的历史任务，即“在不太长的历史时期内，把我国建设成为一个具<strong>有现代农业、现代工业、现代国防和现代科学技术</strong>的社会主义强国，赶上和超过世界先进水平”</li><li><strong>分两步走实现现代化的战略构想</strong>，即从第三个五年计划开始，<strong>第一步</strong>，经过二个五年计划时期，建立一个独立的比较完整的工业体系和国民经济体系；<strong>第二步</strong>，全面实现农业、工业、国防和科学技术的现代化，使中国经济走在世界前列</li><li>意义：“四个现代化”从此成为党和全国各族人民的共同奋斗目标，成为凝聚和团结全国各族人民不懈奋斗的强大精神力量。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 整理重点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coursera: ML04-高级算法与工程</title>
      <link href="/article/Coursera-Machine-Learning-04/"/>
      <url>/article/Coursera-Machine-Learning-04/</url>
      
        <content type="html"><![CDATA[<h1 id="高级算法与工程"><a href="#高级算法与工程" class="headerlink" title="高级算法与工程"></a>高级算法与工程</h1><p>Machine Learning - Android Ng</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221005220433978.png" alt="image-20221005220433978" /><h2 id="4-1-评价-ml-系统"><a href="#4-1-评价-ml-系统" class="headerlink" title="4.1. 评价 ml 系统"></a>4.1. 评价 ml 系统</h2><ul><li>计算测试误差的函数就是减去正则化项的损失函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912140823902.png" alt="image-20220912140823902"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912141619989.png" alt="image-20220912141619989"></p><h3 id="4-1-1-选择模型"><a href="#4-1-1-选择模型" class="headerlink" title="4.1.1. 选择模型"></a>4.1.1. 选择模型</h3><ul><li>把数据集分为训练集、测试集和交叉验证集<ul><li>中心思想：更加公平（不是更加准确）</li></ul></li><li>先选择交叉验证误差最小的模型</li><li>可以使用测试集误差来代表泛化误差，评估模型的泛化误差</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912143933334.png" alt="image-20220912143933334"></p><p><em>训练集在不同的模型上拟合出每个模型的最优 WB_，_交叉验证集用来选择不同的模型_，_测试集用来检验该模型的好坏效果（误差）</em></p><h3 id="4-1-2-诊断模型"><a href="#4-1-2-诊断模型" class="headerlink" title="4.1.2. 诊断模型"></a>4.1.2. 诊断模型</h3><ul><li><p>如何决定第二步做什么，以提高学习的效果</p></li><li><p>方法：观察算法的偏差和方差（Bias and Variance）</p></li><li><p>$J_{train}$很高时，往往意味着 Bias 高（欠拟合）</p></li><li><p>$J_{cv}$高时，且$J_{cv}$比$J_{train}$高很多时，往往意味着 Variance 高（过拟合）</p></li></ul><p>$J_{cv}$和$J_{train}$都比较低时，是比较理想的</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912145232640.png" alt="image-20220912145232640"></p><h3 id="4-1-4-选择正则化参数-λ"><a href="#4-1-4-选择正则化参数-λ" class="headerlink" title="4.1.4. 选择正则化参数 λ"></a>4.1.4. 选择正则化参数 λ</h3><p>λ ~ w 的值 ~ J</p><ul><li>测试过程如下，选择$J_{cv}$最小的模型</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912150559968.png" alt="image-20220912150559968"></p><ul><li>λ 和$J$的关系</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912150827232.png" alt="image-20220912150827232"></p><h3 id="4-1-4-如何评价模型错误率"><a href="#4-1-4-如何评价模型错误率" class="headerlink" title="4.1.4. 如何评价模型错误率"></a>4.1.4. 如何评价模型错误率</h3><ul><li>与其直接看误差，不如以人类水平为基准进行评判</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912151316029.png" alt="image-20220912151316029"></p><h4 id="4-1-4-1-性能基准"><a href="#4-1-4-1-性能基准" class="headerlink" title="4.1.4.1. 性能基准"></a>4.1.4.1. 性能基准</h4><ul><li>人类水平（常用于非结构化数据，如图像、语音、文本）</li><li>竞争对手的算法表现</li><li>经验</li></ul><hr><ul><li>基准线水平</li><li>训练误差($J_{train}$)</li><li>交叉验证误差($J_{cv}$)</li><li>前两者之间的差 indicates <strong>bias</strong>，后两者之间的差 indicates <strong>variance</strong></li></ul><p>一般 4%以上的差距就认为很大了</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912151730402.png" alt="image-20220912151730402"></p><h3 id="4-1-5-学习曲线"><a href="#4-1-5-学习曲线" class="headerlink" title="4.1.5. 学习曲线"></a>4.1.5. 学习曲线</h3><h4 id="4-1-5-1-debug-算法的方法"><a href="#4-1-5-1-debug-算法的方法" class="headerlink" title="4.1.5.1. debug 算法的方法"></a>4.1.5.1. debug 算法的方法</h4><table><thead><tr><th>方法</th><th>解决</th></tr></thead><tbody><tr><td>更多训练集</td><td>高方差</td></tr><tr><td>尝试更小的特征集</td><td>高方差</td></tr><tr><td>增加特征</td><td>高偏差</td></tr><tr><td>增加多项式项数</td><td>高偏差</td></tr><tr><td>减少 λ</td><td>高偏差</td></tr><tr><td>增加 λ</td><td>高方差</td></tr></tbody></table><hr><h4 id="4-1-5-2-神经网络应用"><a href="#4-1-5-2-神经网络应用" class="headerlink" title="4.1.5.2. 神经网络应用"></a>4.1.5.2. 神经网络应用</h4><p>我们往往需要在 keep a balance between bias and variance. 但是神经网络给我们提供了一个全新的视角和方法。它可以自动帮我们完成权衡。具体解释如下：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912152954919.png" alt="image-20220912152954919"></p><ul><li>tf 代码</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912153956951.png" alt="image-20220912153956951"></p><h4 id="4-1-5-误差分析"><a href="#4-1-5-误差分析" class="headerlink" title="4.1.5 误差分析"></a>4.1.5 误差分析</h4><ul><li>人工检查 100 个数据集，并将它们按照共同特征分类</li><li>然后进行一些针对性补丁，比如添加一些更加具有针对性的数据集</li></ul><h2 id="4-2-数据增强"><a href="#4-2-数据增强" class="headerlink" title="4.2. 数据增强"></a>4.2. 数据增强</h2><ul><li>Data argumentation</li><li>通过已有的训练集来进行新的训练：比如把训练集 A image 进行一些变化，然后重新进行训练（人为的增大训练集）<ul><li>注意：对数据所作的改变和扭曲，应该是测试集中噪声或变形的代表<ul><li>随机无意义的噪声和扭曲是没有意义的</li></ul></li></ul></li><li>广泛的应用于图像和音频中</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913145331970.png" alt="image-20220913145331970"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913145418719.png" alt="image-20220913145418719"></p><h2 id="4-3-迁移学习"><a href="#4-3-迁移学习" class="headerlink" title="4.3. 迁移学习"></a>4.3. 迁移学习</h2><ul><li>可以用来自不同任务的数据完成学习</li><li>应对数据少或数据难以获取的情况</li></ul><p>以下图为例：先在有 1 million 个数据的训练集上训练出可以识别 1000 个类别的神经网络（比如猫、狗等等…），随后保持上述神经网络除了 output 层外的参数不变（把上述神经网络除了 output 层 copy 一遍），迁移到拟训练的数据集上进行训练。训练有两种选择：</p><ul><li>只训练 output 层的参数</li><li>训练所有参数。但是以 copy 的神经网络参数作为初始值</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913151057762.png" alt="image-20220913151057762"></p><ul><li>先在大型数据集上进行训练，然后在较小的数据集上进一步参数调优，这两个步骤称为<strong>监督预训练</strong>（supervised pretraining）</li><li>然后运行梯度下降等算法在新数据集上，进行<strong>微调</strong>（fine tuning）</li></ul><p>需要注意的是：预训练的神经网络必须和最终需要的神功网络是同一类型的。比如要训练图像相关的神经网络，必须使用图像相关的预训练神经网络</p><h2 id="4-4-构建-ml-系统的周期"><a href="#4-4-构建-ml-系统的周期" class="headerlink" title="4.4. 构建 ml 系统的周期"></a>4.4. 构建 ml 系统的周期</h2><ol><li>确定项目范围</li><li>收集数据</li><li>训练模型</li><li>部署模型</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913152206879.png" alt="image-20220913152206879"></p><h3 id="4-4-1-MLOps"><a href="#4-4-1-MLOps" class="headerlink" title="4.4.1. MLOps"></a>4.4.1. MLOps</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913153544268.png" alt="image-20220913153544268"></p><ul><li>有点类似 DevOps</li></ul><h2 id="4-5-数据倾斜"><a href="#4-5-数据倾斜" class="headerlink" title="4.5. 数据倾斜"></a>4.5. 数据倾斜</h2><ul><li>评价一个罕见类的学习算法性能<ul><li>构造混淆矩阵（2 * 2 矩阵）</li><li>精度（Precision）：评价算法是否准确：当算法诊断有病时，确诊的概率</li><li>召回率（Recall）：评价算法对真正病人是否有用（样本中的正例有多少被预测正确了或找的全）</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913155045987.png" alt="image-20220913155045987"></p><h3 id="4-5-1-Trade-off-between-P-and-R"><a href="#4-5-1-Trade-off-between-P-and-R" class="headerlink" title="4.5.1. Trade off between P and R"></a>4.5.1. Trade off between P and R</h3><p>提高 threshold 会提高 Precision，降低 Recall</p><ul><li>建议根据具体的应用场景进行权衡</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913160656496.png" alt="image-20220913160656496"></p><h4 id="4-5-1-1-F-score"><a href="#4-5-1-1-F-score" class="headerlink" title="4.5.1.1. F score"></a>4.5.1.1. F score</h4><ul><li>权衡 Recall 和 Precision 的参数</li></ul><p>$$<br>F_1 \ scrore &#x3D; \frac{1}{\frac{1}{2}(\frac{1}{P} + \frac{1}{R})} &#x3D; 2\frac{PR}{P+R}<br>$$</p><ul><li>这个式子会关注二者中较小的部分（其实就是 P 和 R 的调和平均值）</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913161128892.png" alt="image-20220913161128892"></p><h2 id="4-6-决策树"><a href="#4-6-决策树" class="headerlink" title="4.6. 决策树"></a>4.6. 决策树</h2><ul><li>Decision Tree</li></ul><h3 id="4-6-1-步骤"><a href="#4-6-1-步骤" class="headerlink" title="4.6.1. 步骤"></a>4.6.1. 步骤</h3><ul><li>选择根节点的特征</li><li>选择在每个节点上区分的特征（为了最大化的分类，保证分类纯度 purity）</li><li>何时停止树的划分（stop splitting）<ul><li>当结点里 100%都是同一类</li><li>当分裂（split）结点会导致树超过最大深度</li><li>当分裂（split）后对纯度产生的增益小于阈值（threshold）</li><li>当结点里 examples 的数量小于阈值（threshold）</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914111707277.png" alt="image-20220914111707277"></p><h3 id="4-6-2-熵"><a href="#4-6-2-熵" class="headerlink" title="4.6.2. 熵"></a>4.6.2. 熵</h3><ul><li>entropy</li><li>度量样本不纯程度</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914112420889.png" alt="image-20220914112420889"></p><p>$$<br>p_0 \ &#x3D; \ 1\ - \ p_1 \<br>H(p_1) &#x3D; -p_1log_2(p_1) - p_0log_2(p_0) \<br>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  &#x3D; -p_1log_2(p_1) - (1-p_1)log_2(1-P_1) \<br>Note: 0log(0) &#x3D; 0<br>$$</p><h4 id="4-6-2-1-如何利用熵度量-node"><a href="#4-6-2-1-如何利用熵度量-node" class="headerlink" title="4.6.2.1. 如何利用熵度量 node"></a>4.6.2.1. 如何利用熵度量 node</h4><ul><li>使用加权平均。因为我们认为分到了较多 examples 的分支的熵是更重要的</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914113505023.png" alt="image-20220914113505023"></p><h4 id="4-6-2-2-信息增益"><a href="#4-6-2-2-信息增益" class="headerlink" title="4.6.2.2. 信息增益"></a>4.6.2.2. 信息增益</h4><p>根节点的熵 - 子节点的加权平均熵</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914113723924.png" alt="image-20220914113723924"></p><ul><li>计算公式</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914113852006.png" alt="image-20220914113852006"></p><h3 id="4-6-4-Decision-Tree-Learning"><a href="#4-6-4-Decision-Tree-Learning" class="headerlink" title="4.6.4. Decision Tree Learning"></a>4.6.4. Decision Tree Learning</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914114051924.png" alt="image-20220914114051924"></p><ul><li>building decision tree 是一个递归过程</li></ul><h3 id="4-6-5-one-hot-编码"><a href="#4-6-5-one-hot-编码" class="headerlink" title="4.6.5. one-hot 编码"></a>4.6.5. one-hot 编码</h3><p>用于处理不止 2 种取值的离散变量</p><ul><li>如果一个分类特征有 k 种可能的取值，那么把这 k 种特征按照 0、1 进行编码取值</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914120302571.png" alt="image-20220914120302571"></p><ul><li><p>如果看任何一行，总有一个特征是 1，因此称之为 one-hot（独热）编码</p></li><li><p>one-hot 编码不仅适用于决策树，还适用于神经网络</p></li></ul><h3 id="4-6-6-处理连续变量"><a href="#4-6-6-处理连续变量" class="headerlink" title="4.6.6. 处理连续变量"></a>4.6.6. 处理连续变量</h3><ul><li><p>对连续变量进行划分处理（分类），即将连续变量区间设置阈值，将其分为 2 个子集</p></li><li><p>分类的标准是谁贡献了更大的信息增益</p></li><li><p>一般划分值的候选方法是：将值 list 排序，然后取所有值之间的中点</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914140944926.png" alt="image-20220914140944926"></p><h2 id="4-7-回归预测中的决策树"><a href="#4-7-回归预测中的决策树" class="headerlink" title="4.7. 回归预测中的决策树"></a>4.7. 回归预测中的决策树</h2><ul><li>决策树会根据叶子结点中样本数据的平均值做出预测</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914141648061.png" alt="image-20220914141648061"></p><ul><li><p>在回归预测中，决定结点选择哪种划分策略的标准不再是熵，而是<strong>带权方差</strong>（variance）</p></li><li><p>就像最终决策树的衡量公式是信息增益，我们在这里计算的也实际上是方差减少量</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914142137648.png" alt="image-20220914142137648"></p><h2 id="4-8-决策树集合"><a href="#4-8-决策树集合" class="headerlink" title="4.8. 决策树集合"></a>4.8. 决策树集合</h2><ul><li><p>使用单个决策树的缺点是：其对数据的微小变化非常敏感。(一旦数据微小变化，那么结点的信息增益可能会变化很多，从而导致决策树变的完全不同)</p><ul><li>解决方法：构建更多的决策树，即决策树集合，使得预测结果更健壮</li></ul></li><li><p>使用树集合，然后都运行数据，进行预测。多数的结果即为预测结果。</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914143400270.png" alt="image-20220914143400270"></p><h3 id="4-8-1-有放回抽样"><a href="#4-8-1-有放回抽样" class="headerlink" title="4.8.1. 有放回抽样"></a>4.8.1. 有放回抽样</h3><ul><li>Sampling with replacement</li></ul><h3 id="4-8-2-随机森林算法"><a href="#4-8-2-随机森林算法" class="headerlink" title="4.8.2. 随机森林算法"></a>4.8.2. 随机森林算法</h3><h4 id="4-8-2-1-袋装决策树算法"><a href="#4-8-2-1-袋装决策树算法" class="headerlink" title="4.8.2.1. 袋装决策树算法"></a>4.8.2.1. 袋装决策树算法</h4><ul><li>对于一个大小为 m 的训练集<ul><li>使用有放回抽样获得同样大小为 m 的训练集，然后训练出一个决策树</li><li>重复以上过程直到训练出需要的决策树数量（一般是 100，记为**<em>B</em>**）</li></ul></li><li>问题<ul><li>根节点及其附近的特征仍然相似</li><li>导致算法不够精确，需要改进</li></ul></li></ul><h4 id="4-8-2-2-改进成随机森林算法"><a href="#4-8-2-2-改进成随机森林算法" class="headerlink" title="4.8.2.2. 改进成随机森林算法"></a>4.8.2.2. 改进成随机森林算法</h4><ul><li>在每个结点中，当需要选择一个特征来 split node 时，如果有 n 个特征可以选择，那么我们每次<strong>随机选择</strong>k（k &lt; n ）个特征构成 n 个特征的子集，让算法在这个子集中进行选择（即计算信息增益然后进行 split）</li><li>比单一决策树更健壮的原因是：随机森林算法探索了更多训练集微小变化的可能，能够对有放回取样过程导致的所有数据变化进行平均，使得训练出来的模型更 robust</li></ul><h3 id="4-8-3-XGBoost-增强决策树算法"><a href="#4-8-3-XGBoost-增强决策树算法" class="headerlink" title="4.8.3. XGBoost 增强决策树算法"></a>4.8.3. XGBoost 增强决策树算法</h3><ul><li>非常类似于针对性训练，比如刻意训练不熟练的一段，而不是总是训练整首曲子</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914150804159.png" alt="image-20220914150804159"></p><ul><li>XGBoost（eXtreme Gradient Boosting）<ul><li>增强决策树的一种开源实现</li><li>高效</li><li>对默认拆分条件有很好的选择</li><li>内置正则化以防止过拟合</li><li>和 dl 一样，是算法竞赛的热门算法</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914151101334.png" alt="image-20220914151101334"></p><h2 id="4-9-决策树和神经网络的使用时机"><a href="#4-9-决策树和神经网络的使用时机" class="headerlink" title="4.9. 决策树和神经网络的使用时机"></a>4.9. 决策树和神经网络的使用时机</h2><ul><li>决策树和树集合<ul><li>对表格化（结构化）tabular（structured）数据表现很好</li><li>不建议在非结构化数据上使用（图像、音频、文本）</li><li>训练迅速</li><li>小的决策树可能是人类可以理解的（可解释性）</li></ul></li><li>神经网络<ul><li>对结构化和非结构化数据都表现良好</li><li>比决策树慢（训练时长等）</li><li>可以使用迁移学习（而决策树不行）</li><li>当构建多个模型共同协作的系统时，神经网络模型更容易串在一起（决策树一次只能训练一个）</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coursera: ML03-深度学习</title>
      <link href="/article/Coursera-Machine-Learning-03/"/>
      <url>/article/Coursera-Machine-Learning-03/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><p>Machine Learning - Android Ng</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221005220433978.png" alt="image-20221005220433978" /><h2 id="3-1-神经网络概论"><a href="#3-1-神经网络概论" class="headerlink" title="3.1. 神经网络概论"></a>3.1. 神经网络概论</h2><ul><li><p>尝试模仿（mimic）人脑</p></li><li><p>用处</p><ul><li>speech -&gt; images -&gt; text(NLP) -&gt; …</li></ul></li><li><p>每个神经元接受一些输入，做一些计算，然后将输出送给下一个神经元</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909155125086.png" alt="image-20220909155125086"></p><ul><li>可以将神经元分为不同层（layer），每层接受相似的输入，输出不同的结果</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909164348707.png" alt="image-20220909164348707"></p><ul><li><p>神经网络不需要自己进行特征工程，中间的隐藏层即通过输入初始特征来输出更好的特征</p></li><li><p>需要自己决定的是神经网络的架构：即有多少层，每层有多少神经元</p></li></ul><h3 id="3-1-1-一些-notation"><a href="#3-1-1-一些-notation" class="headerlink" title="3.1.1. 一些 notation"></a>3.1.1. 一些 notation</h3><ul><li>方括号上标代表第 x 层</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220910172611765.png" alt="image-20220910172611765"></p><ul><li>每层接受的输入向量上标是上一层的</li><li>$a^{[0]}$一般表示输入向量</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911170844379.png" alt="image-20220911170844379"></p><h3 id="3-1-2-forward-propagation"><a href="#3-1-2-forward-propagation" class="headerlink" title="3.1.2. forward propagation"></a>3.1.2. forward propagation</h3><ul><li>前向传播</li><li>从神经网络层自左向右传播</li></ul><h2 id="3-2-TensorFlow-介绍"><a href="#3-2-TensorFlow-介绍" class="headerlink" title="3.2. TensorFlow 介绍"></a>3.2. TensorFlow 介绍</h2><h3 id="3-2-1-Demo"><a href="#3-2-1-Demo" class="headerlink" title="3.2.1. Demo"></a>3.2.1. Demo</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">200.0</span>, <span class="number">17.0</span>]])</span><br><span class="line"><span class="comment"># Dense是神经网络一种层的名字</span></span><br><span class="line">layer_1 = Dense(units=<span class="number">3</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line"><span class="comment"># a1是一个1 * 3矩阵（张量），通过a1.numpy()可以把它转换为numpy矩阵</span></span><br><span class="line">a1 = layer_1(x)</span><br><span class="line">layer_2 = Dense(units=<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">a2 = layer_2(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Threshold</span></span><br><span class="line"><span class="keyword">if</span> a2 &gt;= <span class="number">0.5</span></span><br><span class="line">yhat = <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    yhat = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 法2</span></span><br><span class="line">layer_1 = Dense(units=<span class="number">3</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">layer_2 = Dense(units=<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">model = Sequential([layer_1, layer_2 ])</span><br><span class="line">x = np.array([[]])</span><br><span class="line">y = np.array([[]])</span><br><span class="line">model.<span class="built_in">compile</span>(...)</span><br><span class="line">model.fit(x,y)</span><br><span class="line">model.predict(x_new)</span><br></pre></td></tr></table></figure><h3 id="3-2-2-Tf-的数据格式"><a href="#3-2-2-Tf-的数据格式" class="headerlink" title="3.2.2. Tf 的数据格式"></a>3.2.2. Tf 的数据格式</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911175020421.png" alt="image-20220911175020421"></p><h3 id="3-2-3-Tensor（张量）"><a href="#3-2-3-Tensor（张量）" class="headerlink" title="3.2.3. Tensor（张量）"></a>3.2.3. Tensor（张量）</h3><ul><li>可以近似理解为一种矩阵</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911175521941.png" alt="image-20220911175521941"></p><h2 id="3-3-Python-向前传播的原理"><a href="#3-3-Python-向前传播的原理" class="headerlink" title="3.3. Python 向前传播的原理"></a>3.3. Python 向前传播的原理</h2><ul><li>forward prop</li><li>手写全连接层（full connected）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dense</span>(<span class="params">a_in, W, b, g</span>):</span><br><span class="line">    units = W.shape[<span class="number">1</span>]</span><br><span class="line">    a_out = np.zeros(units)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(units):</span><br><span class="line">        <span class="comment"># W[:,j]是提取出W第j列的写法</span></span><br><span class="line">        <span class="comment"># 通常：大写字母用来表示矩阵，小写字母用来表示向量</span></span><br><span class="line">        w = W[:,j]</span><br><span class="line">        z = np.dot(w, a_in) + b[j]</span><br><span class="line">        a_out[j] = g(z)</span><br><span class="line">    <span class="keyword">return</span> a_out</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sequential</span>(<span class="params">x</span>):</span><br><span class="line">    a1 = dense(x, W1, b1)</span><br><span class="line">    a2 = dense(a1, W2, b2)</span><br><span class="line">    a3 = dense(a2, W3, b3)</span><br><span class="line">    a4 = dense(a3, W4, b4)</span><br><span class="line">    f_x = a4</span><br><span class="line">    <span class="keyword">return</span> f_x</span><br></pre></td></tr></table></figure><h2 id="3-4-AI-和神经网络的关系"><a href="#3-4-AI-和神经网络的关系" class="headerlink" title="3.4. AI 和神经网络的关系"></a>3.4. AI 和神经网络的关系</h2><h3 id="3-4-1-ANI-和-AGI"><a href="#3-4-1-ANI-和-AGI" class="headerlink" title="3.4.1. ANI 和 AGI"></a>3.4.1. ANI 和 AGI</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911194524599.png" alt="image-20220911194524599"></p><h3 id="3-4-2-The-“one-learning-algorithm”-hypothesis"><a href="#3-4-2-The-“one-learning-algorithm”-hypothesis" class="headerlink" title="3.4.2. The “one learning algorithm” hypothesis"></a>3.4.2. The “one learning algorithm” hypothesis</h3><p>科学家发现人脑的可塑性非常强：非常小的一片人脑区域就能做很多事情，比如当把图像输给听觉区域时，听觉区域又会学会识别图像。这带来一个假设：存在一种或几种算法，可以使得机器学习&#x2F;神经网络实现非常多的事情</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911195232097.png" alt="image-20220911195232097"></p><h2 id="3-5-算法中的向量化实现"><a href="#3-5-算法中的向量化实现" class="headerlink" title="3.5. 算法中的向量化实现"></a>3.5. 算法中的向量化实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.array([[<span class="number">200</span>, <span class="number">17</span>]])</span><br><span class="line">W = np.array([[<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>],</span><br><span class="line">              [-<span class="number">2</span>, <span class="number">4</span>, -<span class="number">6</span>]])</span><br><span class="line">B = np.array([[-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dense</span>(<span class="params">A_in, W, B, g</span>):</span><br><span class="line">    <span class="comment"># np.matmul = matrix multiplication</span></span><br><span class="line">    Z = np.matmul(A_in, W) + B</span><br><span class="line">    A_out = g(z)</span><br><span class="line">    <span class="keyword">return</span> A_out</span><br></pre></td></tr></table></figure><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911200229967.png" alt="image-20220911200229967"></p><ul><li><p>使用矩阵和向量运算的好处是：可以利用硬件进行并行计算，显著提高运算速度</p></li><li><p>在 TensorFlow 的约定中：一个样本的数据通常在矩阵的行中</p></li></ul><h2 id="3-6-TensorFlow-实现"><a href="#3-6-TensorFlow-实现" class="headerlink" title="3.6. TensorFlow 实现"></a>3.6. TensorFlow 实现</h2><ul><li>tf 编译模型的关键是定义损失函数</li><li>第一步：定义模型</li><li>第二步：使用损失函数编译模型</li><li>第三步：训练模型</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911200855784.png" alt="image-20220911200855784"></p><h3 id="3-6-1-前述基本步骤在-tf-中的对应"><a href="#3-6-1-前述基本步骤在-tf-中的对应" class="headerlink" title="3.6.1. 前述基本步骤在 tf 中的对应"></a>3.6.1. 前述基本步骤在 tf 中的对应</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911201643919.png" alt="image-20220911201643919"></p><ul><li>tf 的 model.fi 通过反向传播实现了梯度下降</li></ul><h2 id="3-7-激活函数详解"><a href="#3-7-激活函数详解" class="headerlink" title="3.7. 激活函数详解"></a>3.7. 激活函数详解</h2><ul><li>一些激活函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911203411855.png" alt="image-20220911203411855"></p><h3 id="3-7-1-ReLU"><a href="#3-7-1-ReLU" class="headerlink" title="3.7.1. ReLU"></a>3.7.1. ReLU</h3><ul><li>Rectified Linear Unit 修正线性单元</li><li>计算速度比 sigmoid 更快</li><li>只有左端是趋于 flat 的，因此在梯度下降时比 sigmoid 更有优势，学习速度更快</li><li>一般作为隐藏层的默认激活函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911203303924.png" alt="image-20220911203303924"></p><h3 id="3-7-2-softmax"><a href="#3-7-2-softmax" class="headerlink" title="3.7.2. softmax"></a>3.7.2. softmax</h3><ul><li>逻辑回归的泛化</li><li>针对多分类环境</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911205212945.png" alt="image-20220911205212945"></p><h4 id="3-7-2-1-softmax-函数的损失函数"><a href="#3-7-2-1-softmax-函数的损失函数" class="headerlink" title="3.7.2.1. softmax 函数的损失函数"></a>3.7.2.1. softmax 函数的损失函数</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911205507260.png" alt="image-20220911205507260"></p><ul><li>可以和 sigmoid 类比，$a_j$越接近 1，损失越小，这会刺激$a_j$不断接近 1</li></ul><h3 id="3-7-3-如何选择激活函数"><a href="#3-7-3-如何选择激活函数" class="headerlink" title="3.7.3. 如何选择激活函数"></a>3.7.3. 如何选择激活函数</h3><ul><li>sigmoid：二元分类问题，因为神经网络在学习 y&#x3D;1 的概率</li><li>linear：回归</li><li>ReLU：回归，且结果是非负值</li></ul><h3 id="3-7-4-为什么我们需要激活函数"><a href="#3-7-4-为什么我们需要激活函数" class="headerlink" title="3.7.4. 为什么我们需要激活函数"></a>3.7.4. 为什么我们需要激活函数</h3><ul><li>简单来说，如果我们不使用激活函数，那么所有神经网络将变成如同线性回归般的简单计算。多层神经网络不能提供提升计算复杂特征的能力，也不能学习任何比线性函数更复杂的东西，违背了我们创造神经网络的初衷</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911204521409.png" alt="image-20220911204521409"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911204532625.png" alt="image-20220911204532625"></p><h2 id="3-8-多分类"><a href="#3-8-多分类" class="headerlink" title="3.8. 多分类"></a>3.8. 多分类</h2><ul><li>y 是离散的，且可能的取值大于 2 种</li><li>使用 softmax 激活函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911210538665.png" alt="image-20220911210538665"></p><ul><li>softmax 函数在这里和其他激活函数的区别是，softmax 函数一次性算出$a_1, a_2, …, a_i$的所有值，并计算出它们的概率。而其他激活函数仅仅只是一次计算出一个。</li></ul><h3 id="3-8-1-使用-tf-实现"><a href="#3-8-1-使用-tf-实现" class="headerlink" title="3.8.1. 使用 tf 实现"></a>3.8.1. 使用 tf 实现</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911210704162.png" alt="image-20220911210704162"></p><ul><li>一种 tf 实现的版本，但是实际上有更好的版本。因此</li></ul><h4 id="3-8-1-1-优化计算精度"><a href="#3-8-1-1-优化计算精度" class="headerlink" title="3.8.1.1. 优化计算精度"></a>3.8.1.1. 优化计算精度</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911211123650.png" alt="image-20220911211123650"></p><ul><li>在输出层使用 linear 激活函数（目的是为了不先计算 a&#x2F;z，而是把整个式子放到最后再统一计算，避免了计算中间值而带来的精度误差），然后在 compile 选项里加上<code>from_logits=True</code></li></ul><h3 id="3-8-2-多标签分类问题"><a href="#3-8-2-多标签分类问题" class="headerlink" title="3.8.2. 多标签分类问题"></a>3.8.2. 多标签分类问题</h3><ul><li>multi-label classification problem</li><li>输出是一个标签向量，表示是否包含某个向量</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911212040447.png" alt="image-20220911212040447"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911212149890.png" alt="image-20220911212149890"></p><h2 id="3-9-Adam-算法"><a href="#3-9-Adam-算法" class="headerlink" title="3.9. Adam 算法"></a>3.9. Adam 算法</h2><ul><li><p>Adaptive Moment estimation，自适应矩估计</p></li><li><p>可以自动调整学习率$\alpha$</p></li><li><p>对于不同模型使用不同$\alpha$</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911212752093.png" alt="image-20220911212752093"></p><h3 id="3-9-1-使用"><a href="#3-9-1-使用" class="headerlink" title="3.9.1. 使用"></a>3.9.1. 使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential([</span><br><span class="line">    Dense(units=<span class="number">25</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">    Dense(units=<span class="number">15</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">    Dense(units=<span class="number">10</span>, activation=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=Adam(learning_rate=le-<span class="number">3</span>),                loss=SparseCategoricalCrossentropy(from_logits=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">model.fit(X,Y,epochs=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>在 compile 里面加一个优化器参数即可，然后设置一个默认的学习率</p><h2 id="3-10-Layer-Types"><a href="#3-10-Layer-Types" class="headerlink" title="3.10. Layer Types"></a>3.10. Layer Types</h2><h3 id="3-10-1-Dense-layer"><a href="#3-10-1-Dense-layer" class="headerlink" title="3.10.1. Dense layer"></a>3.10.1. Dense layer</h3><p>全连接层，接受前一层的所有激活，然后通过一个激活函数得到它自己的输出</p><h3 id="3-10-2-Convolutional-Layer"><a href="#3-10-2-Convolutional-Layer" class="headerlink" title="3.10.2. Convolutional Layer"></a>3.10.2. Convolutional Layer</h3><p>卷积层</p><ul><li><p>每一个神经元只关注**<em>part of</em>**前一层的输出</p></li><li><p>优点：</p><ul><li>计算更快</li><li>所需的训练数据更少，也更不容易过拟合</li></ul></li><li><p>例子<img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911213905765.png" alt="image-20220911213905765"></p></li><li><p>可选择参数：每层的神经元数，每个神经元得到的输入数量</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coursera: ML02-逻辑回归与正则化</title>
      <link href="/article/Coursera-Machine-Learning-02/"/>
      <url>/article/Coursera-Machine-Learning-02/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑回归与正则化"><a href="#逻辑回归与正则化" class="headerlink" title="逻辑回归与正则化"></a>逻辑回归与正则化</h1><p>Machine Learning - Android Ng</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221005220433978.png" alt="image-20221005220433978" /><h2 id="2-1-逻辑回归"><a href="#2-1-逻辑回归" class="headerlink" title="2.1. 逻辑回归"></a>2.1. 逻辑回归</h2><ul><li>使用 0 和 1 来代表 negative 和 positive</li></ul><h3 id="2-1-1-Sigmoid-函数"><a href="#2-1-1-Sigmoid-函数" class="headerlink" title="2.1.1. Sigmoid 函数"></a>2.1.1. Sigmoid 函数</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908214617691.png" alt="image-20220908214617691"></p><ul><li>通常将函数作为输入，然后输出[0,1]</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908215053672.png" alt="image-20220908215053672"></p><h3 id="2-1-2-决策边界"><a href="#2-1-2-决策边界" class="headerlink" title="2.1.2. 决策边界"></a>2.1.2. 决策边界</h3><p>当我们把$wx+b$作为自变量输入 sigmoid 函数时，假设我们取 0.5 作为 sigmoid 函数的分界点（大于 0.5 认为是 positive，小于 0.5 认为是 negative），我们可以推导出：</p><p>$$<br>wx + b \gt 0<br>$$</p><p>是 positive，从而我们抽象出</p><p>$$<br>wx + b &#x3D; 0<br>$$</p><p>作为<strong>决策边界</strong></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908220316763.png" alt="image-20220908220316763"></p><p>当然决策边界也可以是非线性（多项的）</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908220441800.png" alt="image-20220908220441800"></p><h3 id="2-1-3-代价函数"><a href="#2-1-3-代价函数" class="headerlink" title="2.1.3. 代价函数"></a>2.1.3. 代价函数</h3><ul><li>关键之处是原来的平方误差损失函数作用在 sigmoid 函数后不再是凸函数了（convex-function），导致梯度下降不好作用。</li><li>因此需要找到一种是凸函数的代价函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908220902583.png" alt="image-20220908220902583"></p><ul><li>因此找到如下损失函数：</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908221515195.png" alt="image-20220908221515195"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908230028302.png" alt="image-20220908230028302"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908230124286.png" alt="image-20220908230124286"></p><h2 id="2-2-实现梯度下降"><a href="#2-2-实现梯度下降" class="headerlink" title="2.2. 实现梯度下降"></a>2.2. 实现梯度下降</h2><ul><li>梯度下降的大公式是一样的，但是求导的细节有不同 👇</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908230531967.png" alt="image-20220908230531967"></p><h2 id="2-3-过拟合"><a href="#2-3-过拟合" class="headerlink" title="2.3. 过拟合"></a>2.3. 过拟合</h2><ul><li><p>overfitting &#x2F; high variance</p></li><li><p>过于贴近训练集，导致实际预测结果的不准确（如下图右三）</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909141900666.png" alt="image-20220909141900666"></p><h3 id="2-3-1-debug-address-methods"><a href="#2-3-1-debug-address-methods" class="headerlink" title="2.3.1. debug &#x2F; address methods"></a>2.3.1. debug &#x2F; address methods</h3><ul><li>收集更多的训练数据</li><li>考虑使用较少的特征<ul><li>选择最相关的特征（最小的特征子集）</li><li>course 2 会学习自动特征的算法</li></ul></li><li>正则化（Regularization）<ul><li>保留所有的特征，但尽量避免它们产生过拟合</li><li>把一些特征的参数调小（接近 0）</li><li>是否正则化 b 对实际模型的影响不大（一般不正则化 b）</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909142655263.png" alt="image-20220909142655263"></p><h2 id="2-4-正则化"><a href="#2-4-正则化" class="headerlink" title="2.4. 正则化"></a>2.4. 正则化</h2><ul><li><p>正则化的思想是：如果有很多特征，我全部使用的话可能会造成过拟合，而我也不知道哪些特征是重要的，哪些是不重要的，那么我就对所有的这些特征进行建模，并对他们进行正则化奖励或惩罚（penalize）。不重要的参数会被惩罚的非常小。从而得到不那么容易过拟合的模型</p></li><li><p>公式</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909143702593.png" alt="image-20220909143702593"></p><ul><li>注意：λ 下面有分母 2m。这样可以保证当 m（训练集样本）增大时，先前的 λ 仍然有用</li><li>加入正则化后的 cost function，前一项是为了让模型拟合数据，而后一项是为了防止模型过拟合。参数 λ 平衡了这两个功能。我们往往需要选择一个权衡两者的 λ</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909144416958.png" alt="image-20220909144416958"></p><h2 id="2-5-加入正则化后的梯度下降"><a href="#2-5-加入正则化后的梯度下降" class="headerlink" title="2.5. 加入正则化后的梯度下降"></a>2.5. 加入正则化后的梯度下降</h2><h3 id="2-5-1-线性回归"><a href="#2-5-1-线性回归" class="headerlink" title="2.5.1. 线性回归"></a>2.5.1. 线性回归</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909144754578.png" alt="image-20220909144754578"></p><ul><li>加上正则化之后，使得每次梯度下降后的$w_j$下降一点点</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909152304619.png" alt="image-20220909152304619"></p><h3 id="2-5-2-逻辑回归"><a href="#2-5-2-逻辑回归" class="headerlink" title="2.5.2. 逻辑回归"></a>2.5.2. 逻辑回归</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909152918725.png" alt="image-20220909152918725"></p><ul><li>求导之后的梯度下降更新项和线性回归一模一样</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909153007372.png" alt="image-20220909153007372"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coursera: ML01-概论与线性回归</title>
      <link href="/article/Coursera-Machine-Learning-01/"/>
      <url>/article/Coursera-Machine-Learning-01/</url>
      
        <content type="html"><![CDATA[<h1 id="概论与线性回归"><a href="#概论与线性回归" class="headerlink" title="概论与线性回归"></a>概论与线性回归</h1><p>Machine Learning - Android Ng</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221005220433978.png" alt="image-20221005220433978" /><h2 id="1-1-分类"><a href="#1-1-分类" class="headerlink" title="1.1. 分类"></a>1.1. 分类</h2><ul><li>监督学习</li><li>无监督学习</li><li>增强学习（reinforcement learning）</li></ul><h2 id="1-2-监督学习"><a href="#1-2-监督学习" class="headerlink" title="1.2. 监督学习"></a>1.2. 监督学习</h2><ul><li>supervised learning</li><li>通过给予机器正确的例子（包括答案）让其学习</li></ul><h3 id="1-2-1-回归"><a href="#1-2-1-回归" class="headerlink" title="1.2.1. 回归"></a>1.2.1. 回归</h3><ul><li>regression</li><li>从无限多个可能的 output 中预测一个结果（连续），output 一般是数字</li></ul><h3 id="1-2-2-分类算法"><a href="#1-2-2-分类算法" class="headerlink" title="1.2.2. 分类算法"></a>1.2.2. 分类算法</h3><ul><li>classification</li><li>和回归的区别是：只有两个或有限的可能的输出</li><li>预测类别，而类别不一定是数字</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220906145641543.png" alt="image-20220906145641543"></p><ul><li>上图例子（预测乳腺癌）中，只有肿瘤大小一个输入。但实际上可以有多个输入</li></ul><h2 id="1-3-无监督学习"><a href="#1-3-无监督学习" class="headerlink" title="1.3. 无监督学习"></a>1.3. 无监督学习</h2><ul><li>Unsupervised learning</li><li>在无监督学习中，得到的数据是无 label 的，即无结果</li><li>目的只是找到一些数据中的模式或结构，而不是得到什么具体的结论</li></ul><h3 id="1-3-1-聚类"><a href="#1-3-1-聚类" class="headerlink" title="1.3. 1. 聚类"></a>1.3. 1. 聚类</h3><ul><li>clustering</li><li>获取没有标签的 data，并试图自动将他们分到不同的类别（聚簇）中</li></ul><h3 id="1-3-2-异常检测"><a href="#1-3-2-异常检测" class="headerlink" title="1.3.2. 异常检测"></a>1.3.2. 异常检测</h3><ul><li>Anomaly detection</li></ul><h3 id="1-3-3-降维"><a href="#1-3-3-降维" class="headerlink" title="1.3.3. 降维"></a>1.3.3. 降维</h3><ul><li>Dimensionality reduction</li></ul><h2 id="1-4-线性回归模型"><a href="#1-4-线性回归模型" class="headerlink" title="1.4. 线性回归模型"></a>1.4. 线性回归模型</h2><ul><li>属于监督学习</li></ul><h4 id="1-4-1-数据表"><a href="#1-4-1-数据表" class="headerlink" title="1.4.1. 数据表"></a>1.4.1. 数据表</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220906224237839.png" alt="image-20220906224237839"></p><h4 id="1-4-2-训练集"><a href="#1-4-2-训练集" class="headerlink" title="1.4.2. 训练集"></a>1.4.2. 训练集</h4><p>用来训练模型的数据，包括输入（变量、特征或输入特征）和输出（目标变量）</p><p>一些专业术语<img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220906224737300.png" alt="image-20220906224737300" style="zoom: 50%;" /><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220906225335017.png" alt="image-20220906225335017" style="zoom:50%;" /></p><h2 id="1-5-成本函数"><a href="#1-5-成本函数" class="headerlink" title="1.5. 成本函数"></a>1.5. 成本函数</h2><p>$$<br>J(w,b) &#x3D; \frac{1}{2m} \Sigma_{i&#x3D;1}^m (y_{hat}^{(i)} - y^{(i)})^2<br>$$</p><p>平方残差损失函数常常用于线性回归中。我们希望找到一个模型让损失函数最下</p><h2 id="1-6-梯度下降"><a href="#1-6-梯度下降" class="headerlink" title="1.6. 梯度下降"></a>1.6. 梯度下降</h2><ul><li>gradient descent</li></ul><p>$$<br>min_{w_1,….,w_n,b}J(W_1,W_2,…,W_n,b)<br>$$</p><p>对应多参数的损失函数，可以使用梯度下降找到使其最小的点。</p><p>注意：如果对于一些不是吊床形和碗形的图像，可能存在不止一个极小值</p><ul><li>选择一个 w 和 b 作为起始点</li><li>然后沿着斜率最陡的方向下降</li></ul><p>$$<br>w &#x3D; w - \alpha \frac{\alpha}{\alpha w}J(w,b)<br>$$</p><p>$$<br>b &#x3D; b - \alpha \frac{\alpha}{\alpha b}J(w,b)<br>$$</p><p>$\alpha$叫做学习率</p><ul><li>一个例子</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220907181123570.png" alt="image-20220907181123570"></p><h3 id="1-6-1-学习率"><a href="#1-6-1-学习率" class="headerlink" title="1.6.1. 学习率"></a>1.6.1. 学习率</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908120058580.png" alt="image-20220908120058580"></p><p>学习率太小：梯度下降太慢</p><p>学习率太大：可能无法收敛，反而发散</p><h4 id="1-6-1-1-如何选择好的学习率"><a href="#1-6-1-1-如何选择好的学习率" class="headerlink" title="1.6.1.1. 如何选择好的学习率"></a>1.6.1.1. 如何选择好的学习率</h4><ul><li>debug 梯度下降的方法是：将学习率设定为非常小，然后看迭代后 J 是否收敛（向极小值&#x2F;最小值逼近）</li></ul><h3 id="1-6-2-批量梯度下降"><a href="#1-6-2-批量梯度下降" class="headerlink" title="1.6.2. 批量梯度下降"></a>1.6.2. 批量梯度下降</h3><p>Batch gradient descent</p><p>‘Batch’的意思是梯度下降的每一步都使用所有的训练集</p><h3 id="1-6-3-矢量化"><a href="#1-6-3-矢量化" class="headerlink" title="1.6.3. 矢量化"></a>1.6.3. 矢量化</h3><ul><li>多元线性回归</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908171348625.png" alt="image-20220908171348625"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908172417233.png" alt="image-20220908172417233"></p><ul><li>矢量化快速的原因主要是可以理由计算机的并行硬件进行并行计算，而 for 循环只能在循环中一个个循环的计算。</li></ul><h3 id="1-6-4-多元回归的梯度下降"><a href="#1-6-4-多元回归的梯度下降" class="headerlink" title="1.6.4. 多元回归的梯度下降"></a>1.6.4. 多元回归的梯度下降</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908193206271.png" alt="image-20220908193206271"></p><h2 id="1-7-正规方程法"><a href="#1-7-正规方程法" class="headerlink" title="1.7. 正规方程法"></a>1.7. 正规方程法</h2><ul><li><p>normal equation</p></li><li><p>只针对线性回归，不需要迭代即可求解 w 和 b 的方法</p></li><li><p>不适用其他方法</p></li><li><p>当 features 很大（&gt; 10000）时，处理很慢</p></li></ul><h2 id="1-8-特征缩放"><a href="#1-8-特征缩放" class="headerlink" title="1.8. 特征缩放"></a>1.8. 特征缩放</h2><ul><li>让梯度下降更快</li><li>让多维数据彼此之间的范围变得 comparable</li><li>归一化（mean normalization），让所有参数在[-1, 1]之间</li></ul><p>$$<br>x_i &#x3D; \frac{x_i - μ_i}{max - min}<br>$$</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908195407614.png" alt="image-20220908195407614"></p><ul><li>Z-scroe 归一化（normalization）</li><li>计算每个特征的标准差</li></ul><p>$$<br>X_i &#x3D; \frac{x_i - μ_i}{\sigma_i}<br>$$</p><ul><li>一样可以达到让所有参数在[-1, 1]之间</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908195556934.png" alt="image-20220908195556934"></p><h2 id="1-9-检查梯度下降-work-well"><a href="#1-9-检查梯度下降-work-well" class="headerlink" title="1.9. 检查梯度下降 work well"></a>1.9. 检查梯度下降 work well</h2><ul><li><p>通过学习曲线（绘制 J-iteration 函数图像）观察函数变平的时候</p></li><li><p>通过自动收敛测试。其实很类似微积分证明极限的思想。当 J 每次增减小于 δ（极小）时，认为已经收敛</p></li></ul><h2 id="1-10-特征工程"><a href="#1-10-特征工程" class="headerlink" title="1.10. 特征工程"></a>1.10. 特征工程</h2><ul><li><p>Feature engineering</p></li><li><p>通过直觉来设计一个新特征，通常通过改变或结合已有特征来实现</p></li><li><p>选择正确且适当的特征是机器学习模型 work well 的重要前提</p></li></ul><h2 id="1-11-多项式回归"><a href="#1-11-多项式回归" class="headerlink" title="1.11. 多项式回归"></a>1.11. 多项式回归</h2><ul><li>Polynomial regression</li><li>即使用高次、开根等项进行回归拟合</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的博客之旅</title>
      <link href="/article/My-blog/"/>
      <url>/article/My-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="We-‘re-all-dream-catchers"><a href="#We-‘re-all-dream-catchers" class="headerlink" title="We ‘re all dream catchers"></a>We ‘re all dream catchers</h1><div align="center"><img src="https://img12.360buyimg.com/ddimg/jfs/t1/211882/23/840/1275331/616c428cE344ef7a9/75747b1c2a7151c3.jpg" alt="图片替换文本" width="90%" height="auto" align="center" /></div><blockquote><p><strong>1、缘起</strong></p></blockquote><div align="center"><img src="https://img14.360buyimg.com/ddimg/jfs/t1/211102/13/4596/3483452/616294f3E062d1039/173e374926c19dc3.jpg" alt="图片替换文本" width="400" height="240" align="center" /></div><p>   我还记得刚上大一时，曾受某位学长邀请，听关于博客搭建的讲座。讲座的具体内容我现在已经不记得了，但是作为纯正的计算机小白，我当时什么也听不懂。听讲座时那种如坐针毡的感觉我至今仍记忆犹新，而这种感觉也一直贯穿到我现在的计算机学习中（后话了，sigh🚬… 但我还是头铁听完了这场讲座。看着会后同年级的大佬和学长谈笑风生，交流技术细节，我倍感自己的渺小。但是从此，我也有了一颗想be strong的心，原来，自己要学的东西是如此之多。</p><blockquote><p><strong>2、出发</strong></p></blockquote><p>   时间就这样来到大一下学期的暑假。这个暑假我私人方面a lot of things happened（以后合适的时候我会在博客中写出来的），我整个人都浑浑噩噩的，每天都很绝望。But 生活毕竟还得继续，我在8月还得完成暑期社会实践。</p><p>   我很感谢5月的自己，狠下心来给8月的自己准备了一场社会实践来折腾。在和队友的忙碌中，我渐渐找回了自己的状态。也因为这场社会实践，接触了一些web开发的知识，开始真正意义上的成为GitHub的经常使用者。也正因为接触了web开发和GitHub，我更加了解到计算机世界的精彩绝妙，以及众多令人钦佩、孜孜不倦的大佬正在各个领域深耕。于是，我决定做点什么。</p><p>   就这样，我想起了一年前听过的那场讲座，那场我当时如听天书的讲座。“欸，不妨试一试，看看现在自己的知识能不能搭一个自己的博客。”</p><p>​        <em><strong>于是，我就开始了我的博客搭建之旅啦！</strong></em></p><blockquote><p><strong>3、实践</strong></p></blockquote><p>   经过搜索大佬博客、b站教程、GitHub开源大佬仓库，我决定采用Hexo框架 + yilia-plus主题搭建我的博客，并采用Github部署。</p><p>   2021年8月28日，我的博客正式部署到我自己的GitHub仓库上~~❀❀❀！！</p><p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/204954/7/10589/62850/61629112E04fb0dc5/728cc76fa499a783.png" alt="avatar"></p><p>   后续博客装修、更新过程我会写在《博客装修日志》中，本文到此结束，感谢阅读！</p><p>​</p><p>​——edited by Peng 2021-10-10 15:44</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎你，每一个到来的人</title>
      <link href="/article/Peng-s-Hello-World/"/>
      <url>/article/Peng-s-Hello-World/</url>
      
        <content type="html"><![CDATA[<h1 id="相信着，明天会更好"><a href="#相信着，明天会更好" class="headerlink" title="相信着，明天会更好"></a>相信着，明天会更好</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

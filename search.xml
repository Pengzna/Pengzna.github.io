<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iPad + RD client 实现 Win10 远程控制</title>
      <link href="/article/iPad-RD-client-%E5%AE%9E%E7%8E%B0-Win10-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/article/iPad-RD-client-%E5%AE%9E%E7%8E%B0-Win10-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="iPad-RD-client-实现-Win10-远程控制"><a href="#iPad-RD-client-实现-Win10-远程控制" class="headerlink" title="iPad + RD client 实现 Win10 远程控制"></a>iPad + RD client 实现 Win10 远程控制</h1><p>由于游戏本不便携 + 续航差；而 ipad 正好完美弥补了上述缺点。某日下午上课正好看到朋友在用远程桌面记笔记，遂请教之，晚上回宿舍后倒腾出了本篇记录。</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027202123527.png" alt="image-20221027202123527" style="zoom:60%;"><hr><span id="more"></span><h2 id="1-开启-Win10-远程桌面功能"><a href="#1-开启-Win10-远程桌面功能" class="headerlink" title="1. 开启 Win10 远程桌面功能"></a>1. 开启 Win10 远程桌面功能</h2><ul><li>前往<a href="https://github.com/stascorp/rdpwrap/releases%E4%B8%8B%E8%BD%BD%E5%8E%8B%E7%BC%A9%E5%8C%85%EF%BC%88%E6%9C%80%E6%96%B0%E7%89%88%E5%8D%B3%E5%8F%AF%EF%BC%89">https://github.com/stascorp/rdpwrap/releases下载压缩包（最新版即可）</a></li><li>解压得到如下文件</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027191109863.png" alt="image-20221027191109863"></p><ul><li><p>管理员权限运行 install.bat 文件，然后双击 RDPConf.exe 。正常应该是全绿，可以看到我这里第三行报错。<img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027191413015.png" alt="image-20221027191413015"></p></li><li><p>找到上图框出版本号的 rdpwrap.ini 文件，下载后将其复制到 C:\Program Files\RDP Wrapper 中。**<em>注意：复制之前一定要先关闭 Remote Desktop Services 服务，复制完成之后在打开 Remote Desktop Services 服务</em>**</p><ul><li>关闭 Remote Desktop Services 方法：右击此电脑-&gt;管理-&gt;服务与应用程序-&gt;服务-&gt;选择 Remote Desktop Services -&gt;关闭</li></ul></li><li><p>随后再次双击 RDPConf.exe 可以看到启动成功</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027191623785.png" alt="image-20221027191623785"></p><h2 id="2-服务器内网穿透"><a href="#2-服务器内网穿透" class="headerlink" title="2. 服务器内网穿透"></a>2. 服务器内网穿透</h2><h3 id="2-1-服务端"><a href="#2-1-服务端" class="headerlink" title="2.1. 服务端"></a>2.1. 服务端</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://ghproxy.com/https://github.com/fatedier/frp/releases/download/v0.45.0/frp_0.45.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf frp_0.45.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">cd frp_0.45.0_linux_amd64</span><br></pre></td></tr></table></figure><ul><li>编辑 frps.ini</li></ul><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_addr</span> = xxx.xxx.xxx.xxx  <span class="comment">##云服务器内网ip</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">auto_token</span> = username</span><br><span class="line"><span class="attr">dashboard_user</span> = admin</span><br><span class="line"><span class="attr">dashboard_pwd</span> = admin</span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br></pre></td></tr></table></figure><ul><li><p>执行如下命令 后台持续运行此任务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure><p>打开浏览器输入<code>xx.xx.xx.xx(云服务器公网ip):7500</code>（需要提前放行 3389、7000、7500 端口）</p><p>出现如下画面即配置成功。</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027194029822.png" alt="image-20221027194029822"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027192439031.png" alt="image-20221027192439031"></p><h3 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2. 客户端"></a>2.2. 客户端</h3><p>进入 <a href="https://github.com/fatedier/frp/releases">Releases · fatedier&#x2F;frp (github.com)</a>下载如下版本</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027194215035.png" alt="image-20221027194215035"></p><p>将刚才 github 上下载的 frp_0.44.0_windows_amd64.zip 解压出来，编辑文件夹中的 frpc.ini，直接用记事本打开即可，复制以下字段保存。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = xxx.xxx.xxx.xxx ##服务器公网ip</span><br><span class="line">bind_port = 7000</span><br><span class="line">auto_token = username</span><br><span class="line"></span><br><span class="line">[username]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 3389</span><br><span class="line">remote_port = 3390</span><br></pre></td></tr></table></figure><p><strong>注意：server_addr 字段为云服务器公网 ip，这里的 bind_port，auto_token 需要与 frps.ini 文件中的 bind_port，auto_token 匹配。</strong></p><p>进入 frp 目录打开 cmd 命令窗口，启动 frp 客户端服务<code>.\frpc.exe -c frpc.ini</code> ，出现如下提示即配置成功！</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027192357724.png" alt="image-20221027192357724"></p><h4 id="2-2-1-脚本启动-frp-客户端服务"><a href="#2-2-1-脚本启动-frp-客户端服务" class="headerlink" title="2.2.1. 脚本启动 frp 客户端服务"></a>2.2.1. 脚本启动 frp 客户端服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%1&quot;</span> == <span class="string">&quot;h&quot;</span> goto begin</span><br><span class="line">mshta vbscript:createobject(<span class="string">&quot;wscript.shell&quot;</span>).run(<span class="string">&quot;&quot;</span><span class="string">&quot;%~nx0&quot;</span><span class="string">&quot; h&quot;</span>,0)(window.close)&amp;&amp;<span class="built_in">exit</span></span><br><span class="line">:begin</span><br><span class="line">REM</span><br><span class="line"><span class="built_in">cd</span> &amp;&#123;你的 frp 安装路径&#125;</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>将以上代码新建为<code>frp.bat</code>文件，双击即可运行。</p><p>如果想关闭进程，就<code>Ctrl + shift + esc</code>打开资源管理器关闭一个叫<code>frpc</code>的进程。</p><hr><h2 id="3-参考资料："><a href="#3-参考资料：" class="headerlink" title="3. 参考资料："></a>3. 参考资料：</h2><p><a href="https://zhuanlan.zhihu.com/p/572216097">iPad 远程登录 windows 主机（内网穿透 RD client 版） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/339089087">利用 iPad 的 RD client 软件远程控制 PC - 知乎 (zhihu.com)</a></p><p><a href="https://www.johng-mit.cn/technology/rdp/">使用 RD Client + frp 内网穿透实现 iPad 远程控制 - 杂项 - 技术 | Feast &#x3D; 身如蘆葦 &#x3D; 人間似夢 (johng-mit.cn)</a></p><p><strong><em>特别感谢：zzb 同学</em></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> RD client </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 7. Join Algorithms</title>
      <link href="/article/CMU-15-445-7-Join-Algorithms/"/>
      <url>/article/CMU-15-445-7-Join-Algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="7-Join-Algorithms"><a href="#7-Join-Algorithms" class="headerlink" title="7. Join Algorithms"></a>7. Join Algorithms</h1><ul><li>为什么需要 join</li></ul><p>由于为消除 table 中信息的冗余，我们会采取<strong>normalize</strong>来使得数据库 table 的设计符合一定范式，但是之后需要使用<strong>join</strong>来重建原来的 tuple</p><p>一般使用<strong>inner equijoin</strong>,<strong>inner equijoin</strong>连接两张表中 key 相同的 tuple。其他 join 算法可以通过该算法调整得到</p><hr><span id="more"></span><h2 id="7-1-Join-operator-output"><a href="#7-1-Join-operator-output" class="headerlink" title="7.1. Join operator output"></a>7.1. Join operator output</h2><ul><li>copy outer 和 inner tuples 的 attributes into a new tuple.</li><li>Subsequent operators in the query plan never need to go back to the base tables to get more data.</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930094703596.png" alt="image-20220930094703596"></p><ul><li><p>两种处理方式</p><ul><li>可以在 Join 的时候将所有非 Join Attributes 都放入新的 tuple 中，这样 Join 之后的操作都不需要从 tables 中重新获取数据</li></ul><p>![image](<a href="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-La5GNw04x8dghkKNnFu%2F-La5KYkuE3zEy5hImXRs%2FScreen">https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-La5GNw04x8dghkKNnFu%2F-La5KYkuE3zEy5hImXRs%2FScreen</a> Shot 2019-03-16 at 7.49.45 PM.jpg?alt&#x3D;media&amp;token&#x3D;5d9c0b76-0bd8-4224-b105-52edd6b2cb79)</p><ul><li>也可以在 Join 的时候只复制 Join Attributes 以及 record id，后续操作自行根据 record id 去 tables 中获取相关数据。对于列存储数据库，这是比较理想的处理方式，被称为 <strong>Late Materialization</strong>。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930095130571.png" alt="image-20220930095130571"></p></li></ul><h2 id="7-2-Cost-analysis"><a href="#7-2-Cost-analysis" class="headerlink" title="7.2. Cost analysis"></a>7.2. Cost analysis</h2><ul><li>由于数据库中的数据量通常较大，无法一次性载入内存，因此 Join Algorithm 的设计目的，在于减少磁盘 I&#x2F;O，因此我们衡量 Join Algorithm 好坏的标准，就是 I&#x2F;O 的数量。此外我们不需要考虑 Join 结果的大小，因为不论使用怎样的 Join Algorithm，结果集的大小都一样。</li><li>用笛卡尔积加谓词筛选实现 join 非常低效</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/1743182-20220227162356973-2142439747.png" alt="image"></p><h2 id="7-3-Nested-Loop-Join"><a href="#7-3-Nested-Loop-Join" class="headerlink" title="7.3. Nested Loop Join"></a>7.3. Nested Loop Join</h2><h3 id="7-3-1-分类"><a href="#7-3-1-分类" class="headerlink" title="7.3.1. 分类"></a>7.3.1. 分类</h3><ul><li>其实就是嵌套 for 循环</li><li>Stupid nested loop join<ul><li>效率极其低下</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930103128904.png" alt="image-20220930103128904"></p><ul><li>Block nested loop join<ul><li>更少的磁盘 IO</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930103647389.png" alt="image-20220930103647389"></p><ul><li>Index nested loop join</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930103932165.png" alt="image-20220930103932165"></p><h3 id="7-3-2-总结"><a href="#7-3-2-总结" class="headerlink" title="7.3.2. 总结"></a>7.3.2. 总结</h3><ul><li>总是选择较小的 table 作为 outer table（因为较小 table 是作为乘数）</li><li>尽可能多的缓存 outer table 到 buffer 里</li><li>扫描 Inner Table 时，尽量使用索引</li></ul><h2 id="7-4-Sort-Merge-Join"><a href="#7-4-Sort-Merge-Join" class="headerlink" title="7.4. Sort-Merge Join"></a>7.4. Sort-Merge Join</h2><h3 id="7-4-1-Sort"><a href="#7-4-1-Sort" class="headerlink" title="7.4.1. Sort"></a>7.4.1. Sort</h3><ul><li>对 join key(s)进行排序</li></ul><h3 id="7-4-2-Merge"><a href="#7-4-2-Merge" class="headerlink" title="7.4.2. Merge"></a>7.4.2. Merge</h3><ul><li>用 cursors 扫描两个排好序的表，然后 emit key(s)匹配的 tuples</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930104754006.png" alt="image-20220930104754006"></p><h2 id="7-5-Hash-Join"><a href="#7-5-Hash-Join" class="headerlink" title="7.5. Hash Join"></a>7.5. Hash Join</h2><h3 id="7-5-1-Build"><a href="#7-5-1-Build" class="headerlink" title="7.5.1. Build"></a>7.5.1. Build</h3><ul><li>扫描外表，然后使用哈希函数<em>h1</em>在 join attributes 上生成一个哈希表</li></ul><h3 id="7-5-2-Probe"><a href="#7-5-2-Probe" class="headerlink" title="7.5.2. Probe"></a>7.5.2. Probe</h3><ul><li>扫描内标，然后在每个 tuple 上使用<em>h1</em>，跳转到哈希表上并找到匹配的 tuple</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930105402810.png" alt="image-20220930105402810"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 6. Query Execution</title>
      <link href="/article/CMU-15-445-6-Query-Execution/"/>
      <url>/article/CMU-15-445-6-Query-Execution/</url>
      
        <content type="html"><![CDATA[<h1 id="6-Query-Execution"><a href="#6-Query-Execution" class="headerlink" title="6. Query Execution"></a>6. Query Execution</h1><ul><li>how to execute queries using table heaps and indexes.</li></ul><hr><span id="more"></span><h2 id="6-1-Query"><a href="#6-1-Query" class="headerlink" title="6.1. Query"></a>6.1. Query</h2><ul><li>Query operators are arranged in a tree.</li><li>数据从底层向根节点流动</li><li>根节点的输出为 query 的输出</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929143456391.png" alt="image-20220929143456391"></p><h2 id="6-2-Sorting"><a href="#6-2-Sorting" class="headerlink" title="6.2. Sorting"></a>6.2. Sorting</h2><ul><li>我们在 query 时，时常需要 retrieve tuples in a specific order</li><li>但是 data 通常 not fit in memory（有时需要向磁盘 IO）。我们需要用一种能考虑到 IO 开销的技术</li><li>需要排序算法的原因：<strong>本质在于 tuples 在 table 中没有顺序</strong>，无论是用户还是 DBMS 本身，在处理某些任务时希望 tuples 能够按一定的顺序排列，如：<ul><li>若 tuples 已经排好序，去重操作将变得很容易（DISTINCT)</li><li>批量将排好序的 tuples 插入到 B+ Tree index 中，速度更快</li><li>Aggregations (GROUP BY)</li></ul></li></ul><h3 id="6-2-1-External-Merge-Sort"><a href="#6-2-1-External-Merge-Sort" class="headerlink" title="6.2.1. External Merge Sort"></a>6.2.1. External Merge Sort</h3><p>思想是分治，就是把大数据分成独立的 <strong>*runs*</strong> 再分别 sort 它们。它们可以写回到硬盘，也可以读出来。这个算法包含两步： <strong>Phase #1 - Sorting：</strong> 首先算法会 sort 可以放在内存的小 chunk，然后写回到硬盘中。 <strong>Phase #2 - Merge：</strong> 然后合并这些子文件到一个大的单独文件中。</p><ul><li>Divide-and-conquer sorting（分治排序）<ul><li>先排序：将数据分为多个 chunk，每个 chunk 可以 fit in main-memory，然后将它们排序，再将排好序的 data 写回 disk</li><li>再合并：将排好的 data 合并成一个 larger file</li></ul></li><li>复杂度：见 ppt</li></ul><h4 id="6-2-1-1-2-Way-External-Merge-Sort"><a href="#6-2-1-1-2-Way-External-Merge-Sort" class="headerlink" title="6.2.1.1. 2-Way External Merge Sort"></a>6.2.1.1. 2-Way External Merge Sort</h4><ul><li><p>“2” represents the number of runs that we are going to merge into a new run for each pass.</p></li><li><p>假设：</p><ul><li>Files 本分成 N 个 pages</li><li>DBMS 有 B 个 fixed-size buffers</li></ul></li><li><p><em>Pass #0</em></p><ul><li>从 table 中读入 B pages tuples</li><li>将这些 tuples 排序后<strong>写回</strong>到 disk 中</li><li>每一轮成为一个 run</li></ul></li><li><p><em>Pass #1,2,3,…</em></p></li><li><p>递归地将一对 runs 合并成一个两倍长度的 run</p></li><li><p>这一操作值需要 3 个 buffer pages ( 2 个用于输入，1 个用于输出)</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929145647966.png" alt="image-20220929145647966"></p><h5 id="6-2-1-1-2-双重-buffering-优化"><a href="#6-2-1-1-2-双重-buffering-优化" class="headerlink" title="6.2.1.1.2. 双重 buffering 优化"></a>6.2.1.1.2. 双重 buffering 优化</h5><ul><li>当系统在处理当前 run 的时候，提前将下一次 run 取进第二个 buffer。<ul><li>通过充分利用 disk，减少等待 IO 的时间。</li></ul></li></ul><h4 id="6-2-1-2-General-External-Merge-Sort"><a href="#6-2-1-2-General-External-Merge-Sort" class="headerlink" title="6.2.1.2. General External Merge Sort"></a>6.2.1.2. General External Merge Sort</h4><ul><li>就是把 2-way 泛化成 N-way，充分利用磁盘空间</li></ul><h3 id="6-2-2-Using-B-Tree"><a href="#6-2-2-Using-B-Tree" class="headerlink" title="6.2.2. Using B+ Tree"></a>6.2.2. Using B+ Tree</h3><ul><li>如果需要排序的属性已经有了 B+树索引，我们可以用 B+树来加速排序</li></ul><h2 id="6-3-Aggregation"><a href="#6-3-Aggregation" class="headerlink" title="6.3. Aggregation"></a>6.3. Aggregation</h2><p>aggregation 就是对一组 tuples 的某些值做统计，转化成一个标量，如平均值、最大值、最小值等，aggregation 的实现通常有两种方案：</p><ul><li>Sorting</li></ul><p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-L_joWM39KHaJfccjyzE%2F-L_kEY93VltutLrspExH%2FScreen%20Shot%202019-03-12%20at%2012.51.50%20PM.jpg?alt=media&token=8f780e68-b277-48d4-93b6-ce7ffb61a217" alt="image"></p><ul><li><h2 id="Hashing-不需要排序-在-DBMS-扫描的时候填冲一个暂时的-hash-table，对于每一个-record，检查它是否已经存在于-hash-table-DISTINCT：丢弃-GROUP-BY：进行聚合计算"><a href="#Hashing-不需要排序-在-DBMS-扫描的时候填冲一个暂时的-hash-table，对于每一个-record，检查它是否已经存在于-hash-table-DISTINCT：丢弃-GROUP-BY：进行聚合计算" class="headerlink" title="Hashing- 不需要排序- 在 DBMS 扫描的时候填冲一个暂时的 hash table，对于每一个 record，检查它是否已经存在于 hash table  - DISTINCT：丢弃  - GROUP BY：进行聚合计算"></a>Hashing<br>- 不需要排序<br>- 在 DBMS 扫描的时候填冲一个暂时的 hash table，对于每一个 record，检查它是否已经存在于 hash table<br>  - DISTINCT：丢弃<br>  - GROUP BY：进行聚合计算</h2></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 5. Index Concurrency Control</title>
      <link href="/article/CMU-15-445-5-Index-Concurrency-Control/"/>
      <url>/article/CMU-15-445-5-Index-Concurrency-Control/</url>
      
        <content type="html"><![CDATA[<h1 id="5-Index-Concurrency-Control"><a href="#5-Index-Concurrency-Control" class="headerlink" title="5. Index Concurrency Control"></a>5. Index Concurrency Control</h1><h2 id="5-1-concurrency（并发）"><a href="#5-1-concurrency（并发）" class="headerlink" title="5.1. concurrency（并发）"></a>5.1. concurrency（并发）</h2><p>A concurrency control protocol 的正确性标准在于：</p><ul><li>logical correctness：线程必须能够完整正确的看到其应该看到的数据</li><li>physical correctness：数据内部是否完整合理，比如一个数据结构指针不会指向非法的内存地址</li></ul><hr><span id="more"></span><h2 id="5-2-Lock-Latches"><a href="#5-2-Lock-Latches" class="headerlink" title="5.2. Lock &amp; Latches"></a>5.2. Lock &amp; Latches</h2><ul><li><p>Lock：</p><p>是一个高层，逻辑上的原语，其在事务之间保护数据库的内容。</p><ul><li><p>保护数据库中的逻辑内容</p><ul><li>逻辑内容可以是 tuple、tuple set、table、db</li></ul></li><li><p>一个 txn(transaction 的简写)会<strong>全程</strong>持有 lock</p></li><li><p>在查询执行时，数据库可以将 lock 暴露给用户</p></li><li><p>lock 需要能够回滚变化，比如说，如果一个被 lock 锁上的 tuple 被修改了，这次修改可以回滚</p></li></ul></li><li><p>Latch(有时又叫 mutex)：</p><p>是一个底层保护原语，在线程之间，其用来保护 DBMS 内部数据结构的关键区域(比如，数据结构，内存区域)</p><ul><li><p>latch 只有在操作执行的时候才会持有</p></li><li><p>latch 并不需要能够回滚数据，因为 latch 所尝试进行的操作本质上是原子性操作</p></li><li><p>存在两种 latch mode</p><ul><li><strong>READ：</strong>多个线程可以同时读，也就是线程可以持有<strong>read latch</strong>，即使是其他线程也持有<strong>read latch</strong></li></ul></li></ul></li><li><p><strong>WRITE：</strong>对于<strong>write latch</strong>，当一个 thread 持有时，其他 thread 就不能持有</p></li></ul><h3 id="5-2-1-Latch-的实现"><a href="#5-2-1-Latch-的实现" class="headerlink" title="5.2.1. Latch 的实现"></a>5.2.1. Latch 的实现</h3><ul><li>Blocking OS Mutex</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929123045453.png" alt="image-20220929123045453"></p><ul><li>Test-and-Set Spin Latch</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929123101195.png" alt="image-20220929123101195"></p><ul><li>Reader-Writer Latches</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929123141190.png" alt="image-20220929123141190"></p><p><a href="https://www.cnblogs.com/mlmz/p/15935749.html">CMU15445 Lecture 9 Index Concurrency Control - 抿了抿嘴丶 - 博客园 (cnblogs.com)</a></p><ul><li>其实正式的读写线程调度取决于上下文和使用策略。不能一昧的读优先，因为这样可能造成写进程 starvation。</li></ul><h3 id="5-2-2-Hash-Table-Latching"><a href="#5-2-2-Hash-Table-Latching" class="headerlink" title="5.2.2. Hash Table Latching"></a>5.2.2. Hash Table Latching</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221022165348816.png" alt="image-20221022165348816"></p><ul><li><p>区别是 latches 的粒度，后者更小。</p><ul><li>前者方便，但减少并行性：因为无法让两个线程同时操作不同的 slot</li><li>后者并行性更高。付出的代价更高：因为扫描每个 slot 都要获取 latch</li></ul></li><li><p>在 hash table 中，由于线程都是从上往下（同方向）扫描，因此不用考虑死锁的问题</p><ul><li>即来自另一个方向的线程在我争抢该处写锁前就将内容修改，无法保证数据一致性，即前一条线程刚修改完，但我之前刚通过读锁读了数据，修改的数据是在原来的数据上进行的，此时，如果不重新读，事务会出现问题，所以就需要做更多考虑了，如果都是从上往下的，那就无须考虑这点</li></ul></li></ul><h3 id="5-2-3-B-Tree-Latching"><a href="#5-2-3-B-Tree-Latching" class="headerlink" title="5.2.3. B+ Tree Latching"></a>5.2.3. B+ Tree Latching</h3><ul><li><p>这里的情况更复杂。比如有一条线程可能正在遍历 B+Tree，接着在它到达叶子结点之前，另一条线程对 B+Tree 进行了修改，这引起了节点间的拆分与合并。使得 B+Tree 中节点的位置可能会有所移动，我所查找的数据可能就并不在原来的位置上了，甚至在最糟糕的情况下，指针指向了内存中的一个无效内存地址，导致 segmentation fault，并且程序崩溃。</p></li><li><p>如何处理？</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221022203308518.png" alt="image-20221022203308518"></p><ul><li>即 latch crabbing 或者 latch doubling<ul><li>一种允许多条线程在同一时间访问 B+ Tree 的技术</li><li>在任何时候，当我们在一个节点中时，我们必须在该节点上挂一个 latch，不管是写模式还是读模式的 latch 都可以。</li><li>接着，在我们跳到我们的孩子节点之前，我们要拿到我们孩子节点上的 latch，以及我们想要到达的下一个节点的 latch。</li><li>然后，当我们落到那个孩子节点上时，我们要对它里面的内容进行测试。如果我们判断出来移到到该孩子节点是安全的话，那么，对我们来说将父节点上的 latch 释放掉是 ok 的。<ul><li>如何判断安全？<ul><li>如果我们要进行一次修改，我们所在的节点无须进行拆分或合并操作，也不用去管在它下面所发生的事情</li></ul></li></ul></li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221022203812729.png" alt="image-20221022203812729"></p><ul><li>例子</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221022204015361.png" alt="image-20221022204015361"></p><ul><li>A -&gt; B：不安全，不释放 A latch</li><li>B -&gt; D：安全，因为 D 已满（相反，如果是 insert 操作，则 D 不满才是安全的），不管 D 下面发生了什么，都不会影响到 B 和 A，可以释放 B 和 A 的 latches</li><li>D -&gt; H：安全，释放 D 的 latch，删除完后，释放 H</li></ul><p>基本上来讲，在 B+Tree 中，当线程往下进行遍历时，线程会通过一个 stack 来保存它一路上所持有的 latch</p><p>在某个时间点，当我在一个安全的节点处时，我就可以释放掉该节点之前所有节点上的 latch</p><ul><li>注意：释放时：想尽量快的先释放更上层的 latch，因为这样可以尽快减小 latch 对其他线程的影响。但是由于是栈结构，所以还是 FILO</li></ul><h3 id="5-2-4-乐观和悲观"><a href="#5-2-4-乐观和悲观" class="headerlink" title="5.2.4. 乐观和悲观"></a>5.2.4. 乐观和悲观</h3><ul><li>但是这样的锁机制存在着一个问题：每个线程访问 B+树时都需要在根节点获得 write latch。但是 W latch 是独占的，会造成并发性的性能瓶颈。</li><li>因此会有乐观锁：<ul><li>乐观地假设我不会去进行任何拆分操作，向下访问 B+Tree 的时候，我所采用的是 read latch，而不是 write latch。然后，我在对叶子节点进行处理时，会使用 write latch。</li><li>如果我判断出我并不需要进行拆分的话，that’s good. 如果我在进行拆分或合并操作时犯错了，那么，我直接终止操作，并在根节点处重启该操作，在向下遍历的时候获取 write latch</li><li>这样可以有效避免，非拆分合并操作占用非叶子结点 W latch 造成性能瓶颈的情况：因为非拆分合并操作不会造成非叶子结点的变化</li></ul></li></ul><h2 id="5-3-Observation"><a href="#5-3-Observation" class="headerlink" title="5.3. Observation"></a>5.3. Observation</h2><ul><li><p>目前所有的遍历都是从上到下。如果有从左到右的遍历呢？</p></li><li><p>如果是 Write 操作，可能会存在死锁问题</p></li><li><p>解决方法：中断其中之一</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 3. Hash Table</title>
      <link href="/article/CMU-15-445-3-Hash-Table/"/>
      <url>/article/CMU-15-445-3-Hash-Table/</url>
      
        <content type="html"><![CDATA[<h1 id="3-Hash-Table"><a href="#3-Hash-Table" class="headerlink" title="3. Hash Table"></a>3. Hash Table</h1><p><a href="https://zhuanlan.zhihu.com/p/455526511">CMU-15-445 Lecture 6 Hash Tables - 知乎 (zhihu.com)</a></p><hr><span id="more"></span><h2 id="3-1-Hash-Function"><a href="#3-1-Hash-Function" class="headerlink" title="3.1. Hash Function"></a>3.1. Hash Function</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="3-2-Hash-Scheme"><a href="#3-2-Hash-Scheme" class="headerlink" title="3.2. Hash Scheme"></a>3.2. Hash Scheme</h2><h3 id="3-2-1-static-hash-scheme"><a href="#3-2-1-static-hash-scheme" class="headerlink" title="3.2.1. static hash scheme"></a>3.2.1. static hash scheme</h3><h4 id="3-2-1-1-线性"><a href="#3-2-1-1-线性" class="headerlink" title="3.2.1.1. 线性"></a>3.2.1.1. 线性</h4><h4 id="3-2-1-2-Robin-Hood-Hashing"><a href="#3-2-1-2-Robin-Hood-Hashing" class="headerlink" title="3.2.1.2. Robin Hood Hashing"></a>3.2.1.2. Robin Hood Hashing</h4><ul><li>不清晰，需要学习一下</li></ul><h4 id="3-2-1-3-Cuckoo-Hashing"><a href="#3-2-1-3-Cuckoo-Hashing" class="headerlink" title="3.2.1.3. Cuckoo Hashing"></a>3.2.1.3. Cuckoo Hashing</h4><ul><li>多个 hash 表，对应不同的 hash function</li></ul><p>上述谈论的 3 种方案都是静态哈希，这就意味着哈希表的大小是固定的，我们必须提前知道我们想要保存的 key 的大概数量，这样才能知道如何分配空间使得其足够容纳并能最小化哈希碰撞。但是现实没有那么理想，一旦超过容量，就要扩容。扩容并非是直接 append 一段内存，一般来说得重建整个哈希表并迁移。当我们谈到分布式数据库时我们还会谈到一致性哈希算法，这个算法无需调整大小（令人期待的算法）。但是对于单机数据库中的哈希表，我们还是得重新构建，这也是动态的哈希所要解决的问题。</p><h3 id="3-2-2-dynamic-hash-scheme"><a href="#3-2-2-dynamic-hash-scheme" class="headerlink" title="3.2.2. dynamic hash scheme"></a>3.2.2. dynamic hash scheme</h3><h4 id="3-2-2-1-Chained-Hashing"><a href="#3-2-2-1-Chained-Hashing" class="headerlink" title="3.2.2.1. Chained Hashing"></a>3.2.2.1. Chained Hashing</h4><h4 id="3-2-2-2-Extendible-Hashing"><a href="#3-2-2-2-Extendible-Hashing" class="headerlink" title="3.2.2.2. Extendible Hashing"></a>3.2.2.2. Extendible Hashing</h4><ul><li>妙，但不好理解。多看看</li></ul><h4 id="3-2-2-3-Linear-Hashing"><a href="#3-2-2-3-Linear-Hashing" class="headerlink" title="3.2.2.3. Linear Hashing"></a>3.2.2.3. Linear Hashing</h4><h3 id="3-2-3-布隆过滤器"><a href="#3-2-3-布隆过滤器" class="headerlink" title="3.2.3. 布隆过滤器"></a>3.2.3. 布隆过滤器</h3><ul><li>这篇文章写的很好</li></ul><p><a href="https://developer.aliyun.com/article/773205">布隆过滤器，这一篇给你讲的明明白白-阿里云开发者社区 (aliyun.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 2. Buffer Pools</title>
      <link href="/article/CMU-15-445-2-Buffer-Pools/"/>
      <url>/article/CMU-15-445-2-Buffer-Pools/</url>
      
        <content type="html"><![CDATA[<h1 id="2-Buffer-Pools"><a href="#2-Buffer-Pools" class="headerlink" title="2. Buffer Pools"></a>2. Buffer Pools</h1><p><a href="https://www.jianshu.com/p/fecd0358cd29">【学习笔记 3】数据库中的 buffer pool - 简书 (jianshu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/364322857">CMU 15445 学习笔记——Buffer Pool - 知乎 (zhihu.com)</a></p><ul><li>这段内存完全是由数据库控制而不是操作系统</li><li>类似于数据库的内存</li></ul><hr><span id="more"></span><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220927172727486.png" alt="image-20220927172727486"></p><h2 id="2-1-Lock-和-Latch"><a href="#2-1-Lock-和-Latch" class="headerlink" title="2.1. Lock 和 Latch"></a>2.1. Lock 和 Latch</h2><ul><li><p>lock 更高级，保护高级内容 from other transaction。</p></li><li><p>事务运行时持有 lock</p></li><li><p>要求能够回滚 changes</p></li><li><p>可以暴露给开发人员</p></li><li><p>latch 是更底层的概念，来保护数据结构和内存</p></li><li><p>不需要能够回滚 changes</p></li><li><p>有点类似 mutex（互斥锁）</p></li></ul><h2 id="2-2-page-table-和-page-directory"><a href="#2-2-page-table-和-page-directory" class="headerlink" title="2.2. page table 和 page directory"></a>2.2. page table 和 page directory</h2><ul><li>page directory<ul><li>page id 到数据库文件中的 page location 的映射</li><li>所有 changes 必须持久化</li></ul></li><li>page table<ul><li>page id 到 buffer pool frames 中 page copy 的银蛇</li><li>内存中的数据，不需要在磁盘中保存</li></ul></li></ul><h2 id="2-3-buffer-pool-optimization"><a href="#2-3-buffer-pool-optimization" class="headerlink" title="2.3. buffer pool optimization"></a>2.3. buffer pool optimization</h2><h3 id="2-3-1-Multiple-Buffer-Pool"><a href="#2-3-1-Multiple-Buffer-Pool" class="headerlink" title="2.3.1. Multiple Buffer Pool"></a>2.3.1. Multiple Buffer Pool</h3><ul><li>有多个 buffer pool</li><li>在每个 buffer pool 有局部策略</li><li>比如对每个表都有一个 buffer pool</li><li>可以一定程度缓解多线程争抢 latch 的场景</li></ul><p>Approach Methods：</p><h4 id="2-3-1-1-Object-Id"><a href="#2-3-1-1-Object-Id" class="headerlink" title="2.3.1.1. Object Id"></a>2.3.1.1. Object Id</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928103255171.png" alt="image-20220928103255171"></p><h4 id="2-3-1-2-Hashing"><a href="#2-3-1-2-Hashing" class="headerlink" title="2.3.1.2. Hashing"></a>2.3.1.2. Hashing</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928103318990.png" alt="image-20220928103318990"></p><h3 id="2-3-2-pre-fetching"><a href="#2-3-2-pre-fetching" class="headerlink" title="2.3.2. pre-fetching"></a>2.3.2. pre-fetching</h3><ul><li><p>为了最小化磁盘 IO 的影响</p></li><li><p>pre-fetching 的方法</p><ul><li>Sequential Scans</li><li>Index Scans</li></ul></li></ul><h3 id="2-3-3-scan-sharing"><a href="#2-3-3-scan-sharing" class="headerlink" title="2.3.3. scan sharing"></a>2.3.3. scan sharing</h3><ul><li>复用某次查询的数据，用于其他的查询<ul><li>不是 caching，caching 指的是完全相同的查询</li><li>但是 scan sharing 只在乎是否取了同一个 page，而不是查询</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928105027699.png" alt="image-20220928105027699"></p><h3 id="2-3-4-buffer-pool-bypass"><a href="#2-3-4-buffer-pool-bypass" class="headerlink" title="2.3.4. buffer pool bypass"></a>2.3.4. buffer pool bypass</h3><ul><li>为了避免从 page table（hash 表）中查询的开销。</li><li>给每个查询线程分配一个本地内存作为该线程的缓存</li></ul><h2 id="2-4-replace-policy"><a href="#2-4-replace-policy" class="headerlink" title="2.4. replace policy"></a>2.4. replace policy</h2><ul><li>lRU（Least Recently Used）<ul><li>单独维护一个 queue，根据 page 的修改顺序排列</li><li>实现<ul><li>每个 page 带一个时间戳</li><li>clock：每个 page 带一个标志位（reference bit）<ul><li>代表我们上次 check 后，该 page 是否被访问</li><li>page 在一个环形队列（like a clock）</li><li>不是严格的 LRU</li><li>其实它的基本假设是：如果一个 page 在一段时间内不被使用，那么它大概率也不会再被使用，即可移除</li></ul></li></ul></li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928143037173.png" alt="image-20220928143037173"></p><ul><li>问题：sequential flooding。</li></ul><h3 id="2-4-1-解决-sequential-flooding"><a href="#2-4-1-解决-sequential-flooding" class="headerlink" title="2.4.1. 解决 sequential flooding"></a>2.4.1. 解决 sequential flooding</h3><h4 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h4><ul><li><p>记录每页的 K 次历史记录</p></li><li><p>不是看哪个 page 的时间戳最老，而是看时间戳之间的间隔</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928145520506.png" alt="image-20220928145520506"></p><h4 id="localization"><a href="#localization" class="headerlink" title="localization"></a>localization</h4><ul><li>从本地的角度移除最少使用的 page，而不是全局的角度</li></ul><h4 id="priority-hints"><a href="#priority-hints" class="headerlink" title="priority hints"></a>priority hints</h4><h4 id="dirty-page"><a href="#dirty-page" class="headerlink" title="dirty page"></a>dirty page</h4><ul><li>每个 page 有一个 dirty bit<ul><li>告诉我们自从上次 page 被放入后，是否被修改</li></ul></li><li>要么每次 drop 掉不 dirty 的 page，但这些 page 可能会被用到</li><li>要么每次写出一个 dirty page 到磁盘（产生一次 IO），再将其替换之（又产生一次 IO）</li><li>数据库一般有一个定时任务线程，负责定时写出 dirty page，然后将其置为 clean</li></ul><p>project 说明在 13：40<a href="https://www.zhihu.com/zvideo/1416128309478862848">(2 封私信) CMU 15-445 18 Buffer Pools 04 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 1. Disk Manager</title>
      <link href="/article/CMU-15-445-1-Disk-Manager/"/>
      <url>/article/CMU-15-445-1-Disk-Manager/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Disk-Manager"><a href="#1-Disk-Manager" class="headerlink" title="1. Disk Manager"></a>1. Disk Manager</h1><ul><li>面向磁盘的数据库系统<ul><li>主要存储放在磁盘上，每次查询时，访问的数据不在内存中</li></ul></li></ul><hr><span id="more"></span><h2 id="1-1-none-volatile-storage"><a href="#1-1-none-volatile-storage" class="headerlink" title="1.1. (none) volatile storage"></a>1.1. (none) volatile storage</h2><ul><li>此部分在计组和 ics 已经学过，不再赘述</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220923152440566.png" alt="image-20220923152440566"></p><h2 id="1-2-总览目标"><a href="#1-2-总览目标" class="headerlink" title="1.2. 总览目标"></a>1.2. 总览目标</h2><ul><li>给应用提供一种假象：它总是拥有足够的内存来处理</li><li>允许 DBMS 来用超过内存的大小处理数据库</li></ul><h2 id="1-3-mmap"><a href="#1-3-mmap" class="headerlink" title="1.3. mmap"></a>1.3. mmap</h2><ul><li>虚存的思想。交给 OS 来处理缺页中断</li><li>但是在数据库系统里，这样会产生问题（read 不会产生问题，但是 write 要谨慎）：有时候页与页之间写有顺序要求（比如日志和并发控制），而 os 并不知道这些事情，导致会出现错误</li><li>因此：慎用 mmap。事实上，数据库总是能够接管 os 能干的事情，并能够比 os 干的更好</li></ul><h2 id="1-4-file-storage"><a href="#1-4-file-storage" class="headerlink" title="1.4. file storage"></a>1.4. file storage</h2><ul><li>DBMS 将数据库存储在磁盘上的一个或多个文件中<ul><li>OS 对它们的内容并无所知</li></ul></li><li>Storage manager 负责维护数据库的文件<ul><li>page 可以保存很多类型，比如 tuples，meta-data 等</li><li>但是一般一个 page 只存储一个类型的</li><li>每个物理 page 有一个实际 id 对应它</li></ul></li><li>不同的 DBMS 通过不同的方式管理磁盘上的页<ul><li>堆文件（Heap File）组织（Organization）</li><li>Sequential &#x2F; Sorted File Organization</li></ul></li></ul><h2 id="1-5-Heap-File"><a href="#1-5-Heap-File" class="headerlink" title="1.5. Heap File"></a>1.5. Heap File</h2><ul><li>无序的 pages 集合。其中 tuples 是无序（随机）的存储于其中</li></ul><h2 id="1-6-Page-Layout"><a href="#1-6-Page-Layout" class="headerlink" title="1.6. Page Layout"></a>1.6. Page Layout</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220924122654927.png" alt="image-20220924122654927"></p><ul><li>通过 fileId + pageId + slotId 来寻找具体的 slot</li></ul><h2 id="1-7-Tuple-Layout"><a href="#1-7-Tuple-Layout" class="headerlink" title="1.7. Tuple Layout"></a>1.7. Tuple Layout</h2><ul><li>tuple is a sequence of bytes</li><li>DBMS 需要解释这些 sequence of byte</li></ul><h3 id="1-7-1-tuple-header"><a href="#1-7-1-tuple-header" class="headerlink" title="1.7.1. tuple header"></a>1.7.1. tuple header</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220924154320372.png" alt="image-20220924154320372"></p><h3 id="1-7-2-tuple-data"><a href="#1-7-2-tuple-data" class="headerlink" title="1.7.2. tuple data"></a>1.7.2. tuple data</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220924154420159.png" alt="image-20220924154420159"></p><h1 id="剩余笔记"><a href="#剩余笔记" class="headerlink" title="剩余笔记"></a>剩余笔记</h1><p><a href="https://zhuanlan.zhihu.com/p/454591350">CMU-15-445 Lecture 4 数据库存储（下） - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS Melodic 安装踩坑</title>
      <link href="/article/ROS%E5%AE%89%E8%A3%85%E8%B8%A9%E5%9D%91/"/>
      <url>/article/ROS%E5%AE%89%E8%A3%85%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS-Melodic"><a href="#ROS-Melodic" class="headerlink" title="ROS Melodic"></a>ROS Melodic</h1><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221006110534808.png" alt="image-20221006110534808" style="zoom:67%;" /><span id="more"></span><hr><h2 id="1-安装过程"><a href="#1-安装过程" class="headerlink" title="1. 安装过程"></a>1. 安装过程</h2><ul><li>安装 amd64 Ubuntu18.04 虚拟机（基于 virtual box）</li><li>配置安装源<code>sudo sh -c &#39;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;</code></li><li>设置密钥<code>sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 </code></li><li><code>sudo apt update</code></li><li>出现报错。输入<code>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F42ED6FBAB17C654</code>解决</li><li>开始安装 ROS Melodic <code>sudo apt-get install ros-melodic-desktop-full</code></li><li>避免后面出现<code>sudo rosdep：找不到命令</code>提示，执行如下命令<code>sudo apt install python-rosdep</code></li><li>初始化 rosdep<code>sudo rosdep init</code><ul><li>此处出现最大问题，由于众所周知的原因，init 失败，无法 hit 到 raw.githubusercontent</li><li><strong><em>解决：</em></strong><ul><li>定位 rosdep 资源下载函数：&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;rosxxx&#x2F;xxxx.py 文件（有若干个文件）</li><li>直接修改源 py 代码，在所有下载 url 地址前添加<a href="https://ghproxy.com/%E5%89%8D%E7%BC%80%E6%9D%A5%E5%BA%94%E7%94%A8%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1">https://ghproxy.com/前缀来应用代理服务</a></li></ul></li></ul></li><li>执行 rosdep 更新<code>rosdep update</code></li><li>添加 ros 环境变量<code>echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrc source ~/.bashrc</code></li><li>安装 rosinstall<code>sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential</code></li><li><strong><em>到此安装完成，可以运行命令启动小海龟</em></strong></li></ul><h2 id="2-运行截图"><a href="#2-运行截图" class="headerlink" title="2. 运行截图"></a>2. 运行截图</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221006110534808.png" alt="image-20221006110534808"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NASM 概念与实战/踩坑记录</title>
      <link href="/article/NASM%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
      <url>/article/NASM%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="NASM-学习笔记与踩坑记录"><a href="#NASM-学习笔记与踩坑记录" class="headerlink" title="NASM 学习笔记与踩坑记录"></a>NASM 学习笔记与踩坑记录</h1><ul><li>OS lab-1</li></ul><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221006001450200.png" alt="image-20221006001450200" style="zoom:50%;" /><hr><span id="more"></span><h1 id="1-NASM-与-GDB-调试"><a href="#1-NASM-与-GDB-调试" class="headerlink" title="1. NASM 与 GDB 调试"></a>1. NASM 与 GDB 调试</h1><h2 id="1-1-安装与运行"><a href="#1-1-安装与运行" class="headerlink" title="1.1. 安装与运行"></a>1.1. 安装与运行</h2><p>在 Ubuntu 下可以通过 apt 安装</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo apt install nasm</span><br></pre></td></tr></table></figure><p>安装后就可以对文件进行汇编了，以<code>big_decimal.asm</code>为例</p><p>在 Ubuntu 下</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nasm -f elf big_decimal.asm -o big_decimal.o</span><br><span class="line">ld -m elf_i386 big_decimal.o -o big_decimal</span><br></pre></td></tr></table></figure><p><code>ld</code>是 GUN 自带的链接工具，可以将目标文件链接起来，我们这里因为只有一个文件因此不需要额外的指令。</p><p>复习一下，我们将一个写好的 C 程序转化为一个可以在 Unix 内核机器上执行的文件，需要经历下面四个步骤：</p><ul><li>预处理：处理 C 中的预处理命令，也就是#开头的那些，默认的生成文件格式为<code>.i</code></li><li>编译：将 C 程序编译为汇编语言， 默认的生成文件格式为<code>.s</code>，这里的<code>.s</code>和我们的<code>.asm</code>没什么区别</li><li>汇编：将汇编语言转化为机器码，默认的生成文件格式为<code>.o</code></li><li>链接：链接动态库和静态库</li></ul><p>因为我们直接在写汇编程序，当然就不需要第一步和第二步了。</p><h2 id="1-2-GDB-调试"><a href="#1-2-GDB-调试" class="headerlink" title="1.2. GDB 调试"></a>1.2. GDB 调试</h2><p>说到 GUN，不得不提今天的另一个主角，那就是 GDB，GNU symbolic debugger，它是一个在 Unix 内核中广受好评的调试工具。</p><p>我们可以使用 GDB 来调试我们的汇编代码</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nasm -f elf big_decimal.asm -o big_decimal.o</span><br><span class="line">ld -m elf_i386 big_decimal.o -o big_decimal</span><br><span class="line">sudo gdb big_decimal</span><br></pre></td></tr></table></figure><p>接下来进入 gdb 界面，开始你的调试工作。</p><p>和前面说到的一样，使用<code>gdb</code> 打开你的文件就好了，因为<code>gdb</code>要控制另一个进程，所以别忘了给它开权限。</p><p>可以在汇编文件中设置断点，并在你想停止的地方<code>call</code>它，比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break_demo:</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>然后只要在<code>gdb</code>中</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">b break_demo</span><br></pre></td></tr></table></figure><p>就可以让它在执行到<code>b</code>的时候中止程序。</p><p>可以使用指令</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">i registers</span><br></pre></td></tr></table></figure><p>查看代码运行的位置和寄存器状态。</p><p>如果你的代码有<code>stdout</code>的输出，可能会破坏这个 layout 的格局，这时候使用<code>refresh</code>指令刷新它。</p><p>最后，可以使用<code>x</code>指令查看你的内存状况，比如查看<code>0x40201c</code>开始的 20 个 bits 的内存</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x/20b 0x40201c</span><br></pre></td></tr></table></figure><h1 id="2-NASM-详解"><a href="#2-NASM-详解" class="headerlink" title="2. NASM 详解"></a>2. NASM 详解</h1><h2 id="2-1-NASM-程序的结构"><a href="#2-1-NASM-程序的结构" class="headerlink" title="2.1. NASM 程序的结构"></a>2.1. NASM 程序的结构</h2><p>NASM 是基于行的。大多数程序由指令后跟一个或多个部分组成。行可以具有可选标签。大多数行都有一条指令,后跟零个或多个操作数。</p><p><a href="https://raw.githubusercontent.com/zhangjunlei26/NASM-Tutorial-CN/master/assets/nasmstructure.png"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221004164300281.png" alt="image-20221004164300281"></a></p><p>通常,您将代码放在的部分中,<code>.text</code>并将常量数据放在的部分中<code>.data</code>。</p><h2 id="2-2-NASM-语法"><a href="#2-2-NASM-语法" class="headerlink" title="2.2. NASM 语法"></a>2.2. NASM 语法</h2><h3 id="2-2-1-基础指令"><a href="#2-2-1-基础指令" class="headerlink" title="2.2.1. 基础指令"></a>2.2.1. 基础指令</h3><p>有数百条指令。您无法一次全部学习它们。从这些 start:</p><table><thead><tr><th><code>mov</code> <em>x</em>,<em>y</em></th><th><em>x</em> ← <em>y</em></th></tr></thead><tbody><tr><td><code>and</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> and <em>y</em></td></tr><tr><td><code>or</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> or <em>y</em></td></tr><tr><td><code>xor</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> xor <em>y</em></td></tr><tr><td><code>add</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> + <em>y</em></td></tr><tr><td><code>sub</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> – <em>y</em></td></tr><tr><td><code>inc</code> <em>x</em></td><td><em>x</em> ← <em>x</em> + 1</td></tr><tr><td><code>dec</code> <em>x</em></td><td><em>x</em> ← <em>x</em> – 1</td></tr><tr><td><code>syscall</code></td><td>调用操作系统例程</td></tr><tr><td><code>db</code></td><td>一个<a href="http://www.nasm.us/xdoc/2.11.02/html/nasmdoc3.html#section-3.2">伪指令</a> 声明字节, 这将是在内存中的程序运行时</td></tr></tbody></table><ul><li><code>cmp</code> 做比较</li><li><code>je</code>如果先前的比较相等则跳转。</li><li><code>jne</code>(如果不等于则跳转)</li><li><code>jl</code>(如果不等于则跳转)</li><li><code>jnl</code>(如果不小于则跳转)</li><li><code>jg</code>(如果大于则跳转)</li><li><code>jng</code>(如果不大于则跳转)</li><li><code>jle</code>(如果小于或等于则跳转)</li><li><code>jnle</code>(如果不小于或等于则跳转)</li><li><code>jge</code>(如果大于或等于则跳转)</li><li><code>jnge</code>(如果不大于或等于则跳转)</li><li><code>equ</code>实际上不是真正的指令。它只是定义了供汇编程序本身使用的缩写。(这是一个意义深远的想法)</li><li>本<code>.bss</code>节适用于<em>可写</em>数据。</li></ul><h3 id="2-2-2-伪指令"><a href="#2-2-2-伪指令" class="headerlink" title="2.2.2. 伪指令"></a>2.2.2. 伪指令</h3><p>伪指令不是 x86&#x2F;x64 机器的真实指令，伪指令是用于给编译器指示如何进行编译。</p><h4 id="2-2-2-1-nasm-定义的-7-种数据-size"><a href="#2-2-2-1-nasm-定义的-7-种数据-size" class="headerlink" title="2.2.2.1. nasm 定义的 7 种数据 size"></a>2.2.2.1. nasm 定义的 7 种数据 size</h4><ul><li>byte ： 8 位</li><li>word ： 16 位</li><li>dword ： 32 位</li><li>qword ： 64 位</li><li>tword ： 80 位</li><li>oword ： 128 位</li><li>yword ： 256 位</li></ul><p>oword 可以对应 Microsoft MASM 的 xmmword 类型，yword 对应 Microsoft MASM 的 ymmword 类型。</p><p>tword, oword 以及 yword 使用在 非整型 数据，使用在 float 和 SSE 型数据。</p><h4 id="2-2-2-2-定义初始化数据：db-家族"><a href="#2-2-2-2-定义初始化数据：db-家族" class="headerlink" title="2.2.2.2. 定义初始化数据：db 家族"></a>2.2.2.2. 定义初始化数据：db 家族</h4><p>nasm 定义了用于初始化上面 7 种 size 的 db 家族，它们用于定义初化常量值。</p><ul><li>db : define byte</li><li>dw ：define word</li><li>dd ：define doubleword</li><li>dq ：define quadword</li><li>dt ：define tword</li><li>do ：define oword</li><li>dy ：define yword</li></ul><p>正如前面所说的：dt , do , dy 不接受整型数值常量，它们被使用在定义 float 或 SSE 数据常量。dt 可以定义 extended-precision float 数据，do 可以定义 quad-precision float，dy 可定义 ymm 数据。而 dq 可以定义 double-precision float 数据，dd 可以定义 single-precision float 数据。</p><h4 id="2-2-2-3-定义非初始化数据：resb-家族"><a href="#2-2-2-3-定义非初始化数据：resb-家族" class="headerlink" title="2.2.2.3. 定义非初始化数据：resb 家族"></a>2.2.2.3. 定义非初始化数据：resb 家族</h4><p>程序中使用到的非初始化数据通常放在 <code>bss section</code> 里，<code>bss</code> 代表 <strong>uninitialized storage space</strong>(如果您试图在一个<code>.text</code>小节中使用它们,将会出现错误)：</p><p>nasm 使用了 resb （reserve byte） 家族来定义非初始化数据。</p><ul><li>resb ：reserve byte</li><li>resw ：reserve word</li><li>resd ：reserve doubword</li><li>resq ：reserve quadword</li><li>rest ：reserve tword</li><li>reso ：reserve oword</li><li>resy ：reserve yword</li></ul><p>resb 相当于 Microsoft MASM 语法中的 db ?</p><p>下面是 NASM Manual 的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buffer:         resb    64              ; reserve 64 bytes</span><br><span class="line">wordvar:        resw    1               ; reserve a word</span><br><span class="line">realarray       resq    10              ; array of ten reals</span><br><span class="line">ymmval:         resy    1               ; one YMM register</span><br></pre></td></tr></table></figure><h3 id="2-3-5-使用-equ-定义常量"><a href="#2-3-5-使用-equ-定义常量" class="headerlink" title="2.3.5 使用 equ 定义常量"></a>2.3.5 使用 equ 定义常量</h3><p>equ 用来为标识符定义一个 整型 常量，它的作用类似 C 语言中的 #define</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a  equ 0                          ; OK</span><br><span class="line">b  equ &#x27;abcd&#x27;                     ; OK! b = 0x64636261</span><br><span class="line">c  equ &#x27;abcdefghi&#x27;                ; warning! c = 0x6867666564636261</span><br><span class="line">d  equ 1.2                        ; error!</span><br><span class="line"></span><br><span class="line">    section .data</span><br><span class="line">string db &#x27;hello,word&#x27;,0</span><br><span class="line">len    equ $-string               ; OK! len = 0x0b</span><br><span class="line"></span><br><span class="line">    section .text</span><br><span class="line">textlen equ  _end - entry         ; OK! textlen = 0x05</span><br><span class="line"></span><br><span class="line">_entry:</span><br><span class="line">    mov ecx, textlen</span><br><span class="line"></span><br><span class="line">_end:</span><br></pre></td></tr></table></figure><p>例子中： b 定义为常量 ‘abcd’ 它将是字符串的 ASCII 码序列，‘abcdefghi’ 常量将会被截断，整型常量最长为 quadword（8 bytes)，而 d 企图被定义为一个 float 常量，这产生会错误。len 和 textlen 被定义为编译期确定的数值。</p><h2 id="2-3-寄存器"><a href="#2-3-寄存器" class="headerlink" title="2.3. 寄存器"></a>2.3. 寄存器</h2><p>您可以将每个寄存器的最低 32 位视为寄存器本身,但可以使用以下名称：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R0D R1D R2D R3D R4D R5D R6D R7D R8D R9D R10D R11D R12D R13D R14D R15D</span><br><span class="line">EAX ECX EDX EBX ESP EBP ESI EDI</span><br></pre></td></tr></table></figure><p>您可以使用以下名称将每个寄存器的最低 16 位看作一个寄存器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R0W R1W R2W R3W R4W R5W R6W R7W R8W R9W R10W R11W R12W R13W R14W R15W</span><br><span class="line">AX CX DX BX SP BP SI DI</span><br></pre></td></tr></table></figure><p>您可以使用以下名称将每个寄存器的最低 8 位看作一个寄存器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R0B R1B R2B R3B R4B R5B R6B R7B R8B R9B R10B R11B R12B R13B R14B R15B</span><br><span class="line">AL CL DL BL SPL BPL SIL DIL</span><br></pre></td></tr></table></figure><p>由于历史原因，<code>R0...R3</code>的第 15 至 8 位被命名为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AH CH DH BH</span><br></pre></td></tr></table></figure><h2 id="2-4-操作数"><a href="#2-4-操作数" class="headerlink" title="2.4. 操作数"></a>2.4. 操作数</h2><h3 id="2-4-1-内存操作数"><a href="#2-4-1-内存操作数" class="headerlink" title="2.4.1. 内存操作数"></a>2.4.1. 内存操作数</h3><ul><li>其实就是几种寻址的方式<ul><li>直接寻址</li><li>寄存器间接寻址</li><li>寄存器相对寻址</li><li>基址加变址</li><li>相对基址加变址</li></ul></li><li>注意：没有立即寻址和寄存器寻址</li></ul><p>这些是寻址的基本形式：</p><ul><li><code>[ number ]</code></li><li><code>[ reg ]</code></li><li><code>[ reg + reg*scale ]</code> <em>小数位数只能是 1、2、4 或 8</em></li><li><code>[ reg + number ]</code></li><li><code>[ reg + reg*scale + number ]</code></li></ul><p>这个数字叫做<strong>位移</strong> ; 普通寄存器称为<strong>基</strong> ; 带有刻度的寄存器称为<strong>索引</strong>。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[750]               ; 仅位移</span><br><span class="line">[rbp]               ; 仅基址寄存器</span><br><span class="line">[rcx + rsi*4]       ; 基数+指数*比例</span><br><span class="line">[rbp + rdx]         ; scale is 1</span><br><span class="line">[rbx-8]             ; 位移-8</span><br><span class="line">[rax + rdi*8 + 500] ; 所有四个组成部分</span><br><span class="line">[rbx + counter]     ; 使用变量&quot;counter&quot;地址作为偏移</span><br></pre></td></tr></table></figure><h3 id="2-4-2-直接操作数"><a href="#2-4-2-直接操作数" class="headerlink" title="2.4.2. 直接操作数"></a>2.4.2. 直接操作数</h3><p>这些可以用多种方式编写。以下是官方文档中的一些示例。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200         ; 十进制数</span><br><span class="line">0200        ; 仍然是十进制-前导0不会使其变为八进制</span><br><span class="line">0200d       ; 显式十进制-d后缀</span><br><span class="line">0d200       ; 也十进制-0d prefex</span><br><span class="line">0c8h        ; 十六进制-h后缀,但是前导0是必需的,因为c8h看起来像var</span><br><span class="line">0xc8        ; hex-经典的0x前缀</span><br><span class="line">0hc8        ; 十六进制-由于某些原因,NASM偏爱0h写法</span><br><span class="line">310q        ; 八进制-q后缀</span><br><span class="line">0q310       ; 八进制-0q前缀</span><br><span class="line">11001000b   ; 二进制-b后缀</span><br><span class="line">0b1100_1000 ; 二进制-0b前缀,顺便说一下,允许使用下划线</span><br></pre></td></tr></table></figure><h2 id="2-5-使用-C-库"><a href="#2-5-使用-C-库" class="headerlink" title="2.5. 使用 C 库"></a>2.5. 使用 C 库</h2><p>仅使用 syscall 编写独立程序就已经很酷了，但很少见。我们想使用 C 库中的好东西。</p><p>为何在 C 语言程序中，看上去都是从 <code>main</code>函数开始执行？这是因为 C library 的内部有<code>_start</code>标签！<code>_start</code>开始处的代码会做一些初始化的工作，然后调用<code>main</code>函数中的代码，最后执行清理工作，最终执行 60 号系统调用以退出。因此，您只需要实现<code>main</code>函数即可，我们可以在汇编语言中实现这么做：</p><p>如果您有 Linux,请尝试以下操作：</p><p>hola.asm</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 使用C库将&quot; Hola,mundo&quot;写入控制台。程序运行在 Linux 或者其他在 C 语言库中不使用下划线的操作系统上。</span><br><span class="line">; 如何编译执行:</span><br><span class="line">; nasm -felf64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span><br><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">global    main</span><br><span class="line">          extern    puts</span><br><span class="line"></span><br><span class="line">          section   .text</span><br><span class="line">main:                                       ; 这里被 C library初始化代码所调用</span><br><span class="line">          mov       rdi, message            ; rdi中的第一个整数(或指针)参数</span><br><span class="line">          call      puts                    ; puts(message)</span><br><span class="line">          ret                               ; 由 main 函数返回 C 语言库例程</span><br><span class="line">message:</span><br><span class="line">          db        &quot;Hola, mundo&quot;, 0        ; 注意字符串必须在C中以0结尾</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nasm -felf64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span><br><span class="line">Hola, mundo</span><br></pre></td></tr></table></figure><h2 id="2-6-字符常量"><a href="#2-6-字符常量" class="headerlink" title="2.6. 字符常量"></a>2.6. 字符常量</h2><p>在 nasm 中，可以使用 3 种引号来提供字符</p><ul><li>’ …’ （单引号）</li><li>” …” （双引号）</li><li><code> …</code> （反引号）</li></ul><p>如下示例，它们的结果是一样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db  &#x27;abcd&#x27;</span><br><span class="line">db  &quot;abcd&quot;</span><br><span class="line">db  `abcd`</span><br></pre></td></tr></table></figure><h1 id="3-实践-OS-lab1"><a href="#3-实践-OS-lab1" class="headerlink" title="3. 实践 - OS lab1"></a>3. 实践 - OS lab1</h1><ul><li>使用 nasm 实现大数加法和乘法</li></ul><h2 id="3-1-思路"><a href="#3-1-思路" class="headerlink" title="3.1. 思路"></a>3.1. 思路</h2><ul><li><p>输入输出</p><ul><li>需要熟悉 Linux 系统调用（ics 教过）</li><li>需要熟悉寄存器的使用</li><li>打印 int 数组需要 itoa</li></ul></li><li><p>加法</p><ul><li>按位加，细节略</li></ul></li><li><p>减法</p><ul><li>找出绝对值较大者，计算<code>dest - src // (abs(dest) &gt; abs(src))</code></li><li>按位减，每次减要考虑借位，其他细节略</li></ul></li><li><p>乘法</p><ul><li><p>$$<br>基本原理：<br>\Sigma_{i+j&#x3D;k}(a_i \times b_j) &#x3D; c_k<br>$$</p></li><li><p>先按位乘，最后再统一 normalize</p></li></ul></li><li><p>技巧</p><ul><li>string 转 int 数组后倒序存储，方便 int 数组正序遍历</li><li>比如<code>&quot;123&quot;</code>，存储为<code>[3, 2, 1]</code></li></ul></li></ul><h2 id="3-2-踩坑"><a href="#3-2-踩坑" class="headerlink" title="3.2. 踩坑"></a>3.2. 踩坑</h2><ul><li>jmp 的函数无须 ret！！！<ul><li>否则即使 push 的已全部 pop，ret 仍会 segmentation fault</li></ul></li><li>调用栈的使用</li><li>ebp 用 leave 弹出</li><li>intel 语法（nasm）的 mov 不接受两个 opcode</li><li>.bss 和.data 定义出的是指针</li><li>区分字符（’1’）和数字（0x1）</li><li>loop 循环不可轻易 jmp 到压栈代码段（除非是设计好的）</li><li>gdb 和 objdump 结合的使用</li><li>每次循环后要清空bss和寄存器</li></ul><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h1><p><a href="https://github.com/zhangjunlei26/NASM-Tutorial-CN">zhangjunlei26&#x2F;NASM-Tutorial-CN: Nasm 指南中文 (NASM Tutorial) (github.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/263102219">NASM 与 GDB 的使用指南：如何编好你的汇编 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/jadeshu/article/details/89159196">(29 条消息) nasm 汇编讲解_jadeshu 的博客-CSDN 博客_nasm</a></p><p>[学习 nasm 语言-阿里云开发者社区 (aliyun.com)](<a href="https://developer.aliyun.com/article/25221#:~:text=%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8">https://developer.aliyun.com/article/25221#:~:text=代码中使用</a> byte 关键字对 memory 操作数进行了修饰，指明 memory 操作数的大小为 byte,语法）有些不同， masm 的语法是： 在 masm 语法中需配合 ptr 指示字。)</p><p><a href="https://zhuanlan.zhihu.com/p/297925056">GDB 使用详解 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/u014470361/article/details/102230583">(29 条消息) GDB 调试查看内存数据_夜风~的博客-CSDN 博客_gdb 查看内存数据</a></p><p><a href="https://blog.csdn.net/weixin_44395686/article/details/104727314">(29 条消息) 使用 GDB 查看和修改寄存器的值_@HDS 的博客-CSDN 博客_gdb 查看寄存器的值</a></p><p><a href="http://www.bytekits.com/nasm/system-callback.html">Nasm 系统调用 - 字节流 (bytekits.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> nasm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coursera: ML04-高级算法与工程</title>
      <link href="/article/Coursera-Machine-Learning-04/"/>
      <url>/article/Coursera-Machine-Learning-04/</url>
      
        <content type="html"><![CDATA[<h1 id="高级算法与工程"><a href="#高级算法与工程" class="headerlink" title="高级算法与工程"></a>高级算法与工程</h1><p>Machine Learning - Android Ng</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221005220433978.png" alt="image-20221005220433978" /><hr><span id="more"></span><h2 id="4-1-评价-ml-系统"><a href="#4-1-评价-ml-系统" class="headerlink" title="4.1. 评价 ml 系统"></a>4.1. 评价 ml 系统</h2><ul><li>计算测试误差的函数就是减去正则化项的损失函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912140823902.png" alt="image-20220912140823902"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912141619989.png" alt="image-20220912141619989"></p><h3 id="4-1-1-选择模型"><a href="#4-1-1-选择模型" class="headerlink" title="4.1.1. 选择模型"></a>4.1.1. 选择模型</h3><ul><li>把数据集分为训练集、测试集和交叉验证集<ul><li>中心思想：更加公平（不是更加准确）</li></ul></li><li>先选择交叉验证误差最小的模型</li><li>可以使用测试集误差来代表泛化误差，评估模型的泛化误差</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912143933334.png" alt="image-20220912143933334"></p><p><em>训练集在不同的模型上拟合出每个模型的最优 WB_，_交叉验证集用来选择不同的模型_，_测试集用来检验该模型的好坏效果（误差）</em></p><h3 id="4-1-2-诊断模型"><a href="#4-1-2-诊断模型" class="headerlink" title="4.1.2. 诊断模型"></a>4.1.2. 诊断模型</h3><ul><li><p>如何决定第二步做什么，以提高学习的效果</p></li><li><p>方法：观察算法的偏差和方差（Bias and Variance）</p></li><li><p>$J_{train}$很高时，往往意味着 Bias 高（欠拟合）</p></li><li><p>$J_{cv}$高时，且$J_{cv}$比$J_{train}$高很多时，往往意味着 Variance 高（过拟合）</p></li></ul><p>$J_{cv}$和$J_{train}$都比较低时，是比较理想的</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912145232640.png" alt="image-20220912145232640"></p><h3 id="4-1-4-选择正则化参数-λ"><a href="#4-1-4-选择正则化参数-λ" class="headerlink" title="4.1.4. 选择正则化参数 λ"></a>4.1.4. 选择正则化参数 λ</h3><p>λ ~ w 的值 ~ J</p><ul><li>测试过程如下，选择$J_{cv}$最小的模型</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912150559968.png" alt="image-20220912150559968"></p><ul><li>λ 和$J$的关系</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912150827232.png" alt="image-20220912150827232"></p><h3 id="4-1-4-如何评价模型错误率"><a href="#4-1-4-如何评价模型错误率" class="headerlink" title="4.1.4. 如何评价模型错误率"></a>4.1.4. 如何评价模型错误率</h3><ul><li>与其直接看误差，不如以人类水平为基准进行评判</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912151316029.png" alt="image-20220912151316029"></p><h4 id="4-1-4-1-性能基准"><a href="#4-1-4-1-性能基准" class="headerlink" title="4.1.4.1. 性能基准"></a>4.1.4.1. 性能基准</h4><ul><li>人类水平（常用于非结构化数据，如图像、语音、文本）</li><li>竞争对手的算法表现</li><li>经验</li></ul><hr><ul><li>基准线水平</li><li>训练误差($J_{train}$)</li><li>交叉验证误差($J_{cv}$)</li><li>前两者之间的差 indicates <strong>bias</strong>，后两者之间的差 indicates <strong>variance</strong></li></ul><p>一般 4%以上的差距就认为很大了</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912151730402.png" alt="image-20220912151730402"></p><h3 id="4-1-5-学习曲线"><a href="#4-1-5-学习曲线" class="headerlink" title="4.1.5. 学习曲线"></a>4.1.5. 学习曲线</h3><h4 id="4-1-5-1-debug-算法的方法"><a href="#4-1-5-1-debug-算法的方法" class="headerlink" title="4.1.5.1. debug 算法的方法"></a>4.1.5.1. debug 算法的方法</h4><table><thead><tr><th>方法</th><th>解决</th></tr></thead><tbody><tr><td>更多训练集</td><td>高方差</td></tr><tr><td>尝试更小的特征集</td><td>高方差</td></tr><tr><td>增加特征</td><td>高偏差</td></tr><tr><td>增加多项式项数</td><td>高偏差</td></tr><tr><td>减少 λ</td><td>高偏差</td></tr><tr><td>增加 λ</td><td>高方差</td></tr></tbody></table><hr><h4 id="4-1-5-2-神经网络应用"><a href="#4-1-5-2-神经网络应用" class="headerlink" title="4.1.5.2. 神经网络应用"></a>4.1.5.2. 神经网络应用</h4><p>我们往往需要在 keep a balance between bias and variance. 但是神经网络给我们提供了一个全新的视角和方法。它可以自动帮我们完成权衡。具体解释如下：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912152954919.png" alt="image-20220912152954919"></p><ul><li>tf 代码</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912153956951.png" alt="image-20220912153956951"></p><h4 id="4-1-5-误差分析"><a href="#4-1-5-误差分析" class="headerlink" title="4.1.5 误差分析"></a>4.1.5 误差分析</h4><ul><li>人工检查 100 个数据集，并将它们按照共同特征分类</li><li>然后进行一些针对性补丁，比如添加一些更加具有针对性的数据集</li></ul><h2 id="4-2-数据增强"><a href="#4-2-数据增强" class="headerlink" title="4.2. 数据增强"></a>4.2. 数据增强</h2><ul><li>Data argumentation</li><li>通过已有的训练集来进行新的训练：比如把训练集 A image 进行一些变化，然后重新进行训练（人为的增大训练集）<ul><li>注意：对数据所作的改变和扭曲，应该是测试集中噪声或变形的代表<ul><li>随机无意义的噪声和扭曲是没有意义的</li></ul></li></ul></li><li>广泛的应用于图像和音频中</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913145331970.png" alt="image-20220913145331970"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913145418719.png" alt="image-20220913145418719"></p><h2 id="4-3-迁移学习"><a href="#4-3-迁移学习" class="headerlink" title="4.3. 迁移学习"></a>4.3. 迁移学习</h2><ul><li>可以用来自不同任务的数据完成学习</li><li>应对数据少或数据难以获取的情况</li></ul><p>以下图为例：先在有 1 million 个数据的训练集上训练出可以识别 1000 个类别的神经网络（比如猫、狗等等…），随后保持上述神经网络除了 output 层外的参数不变（把上述神经网络除了 output 层 copy 一遍），迁移到拟训练的数据集上进行训练。训练有两种选择：</p><ul><li>只训练 output 层的参数</li><li>训练所有参数。但是以 copy 的神经网络参数作为初始值</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913151057762.png" alt="image-20220913151057762"></p><ul><li>先在大型数据集上进行训练，然后在较小的数据集上进一步参数调优，这两个步骤称为<strong>监督预训练</strong>（supervised pretraining）</li><li>然后运行梯度下降等算法在新数据集上，进行<strong>微调</strong>（fine tuning）</li></ul><p>需要注意的是：预训练的神经网络必须和最终需要的神功网络是同一类型的。比如要训练图像相关的神经网络，必须使用图像相关的预训练神经网络</p><h2 id="4-4-构建-ml-系统的周期"><a href="#4-4-构建-ml-系统的周期" class="headerlink" title="4.4. 构建 ml 系统的周期"></a>4.4. 构建 ml 系统的周期</h2><ol><li>确定项目范围</li><li>收集数据</li><li>训练模型</li><li>部署模型</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913152206879.png" alt="image-20220913152206879"></p><h3 id="4-4-1-MLOps"><a href="#4-4-1-MLOps" class="headerlink" title="4.4.1. MLOps"></a>4.4.1. MLOps</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913153544268.png" alt="image-20220913153544268"></p><ul><li>有点类似 DevOps</li></ul><h2 id="4-5-数据倾斜"><a href="#4-5-数据倾斜" class="headerlink" title="4.5. 数据倾斜"></a>4.5. 数据倾斜</h2><ul><li>评价一个罕见类的学习算法性能<ul><li>构造混淆矩阵（2 * 2 矩阵）</li><li>精度（Precision）：评价算法是否准确：当算法诊断有病时，确诊的概率</li><li>召回率（Recall）：评价算法对真正病人是否有用（样本中的正例有多少被预测正确了或找的全）</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913155045987.png" alt="image-20220913155045987"></p><h3 id="4-5-1-Trade-off-between-P-and-R"><a href="#4-5-1-Trade-off-between-P-and-R" class="headerlink" title="4.5.1. Trade off between P and R"></a>4.5.1. Trade off between P and R</h3><p>提高 threshold 会提高 Precision，降低 Recall</p><ul><li>建议根据具体的应用场景进行权衡</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913160656496.png" alt="image-20220913160656496"></p><h4 id="4-5-1-1-F-score"><a href="#4-5-1-1-F-score" class="headerlink" title="4.5.1.1. F score"></a>4.5.1.1. F score</h4><ul><li>权衡 Recall 和 Precision 的参数</li></ul><p>$$<br>F_1 \ scrore &#x3D; \frac{1}{\frac{1}{2}(\frac{1}{P} + \frac{1}{R})} &#x3D; 2\frac{PR}{P+R}<br>$$</p><ul><li>这个式子会关注二者中较小的部分（其实就是 P 和 R 的调和平均值）</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913161128892.png" alt="image-20220913161128892"></p><h2 id="4-6-决策树"><a href="#4-6-决策树" class="headerlink" title="4.6. 决策树"></a>4.6. 决策树</h2><ul><li>Decision Tree</li></ul><h3 id="4-6-1-步骤"><a href="#4-6-1-步骤" class="headerlink" title="4.6.1. 步骤"></a>4.6.1. 步骤</h3><ul><li>选择根节点的特征</li><li>选择在每个节点上区分的特征（为了最大化的分类，保证分类纯度 purity）</li><li>何时停止树的划分（stop splitting）<ul><li>当结点里 100%都是同一类</li><li>当分裂（split）结点会导致树超过最大深度</li><li>当分裂（split）后对纯度产生的增益小于阈值（threshold）</li><li>当结点里 examples 的数量小于阈值（threshold）</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914111707277.png" alt="image-20220914111707277"></p><h3 id="4-6-2-熵"><a href="#4-6-2-熵" class="headerlink" title="4.6.2. 熵"></a>4.6.2. 熵</h3><ul><li>entropy</li><li>度量样本不纯程度</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914112420889.png" alt="image-20220914112420889"></p><p>$$<br>p_0 \ &#x3D; \ 1\ - \ p_1 \<br>H(p_1) &#x3D; -p_1log_2(p_1) - p_0log_2(p_0) \<br>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  &#x3D; -p_1log_2(p_1) - (1-p_1)log_2(1-P_1) \<br>Note: 0log(0) &#x3D; 0<br>$$</p><h4 id="4-6-2-1-如何利用熵度量-node"><a href="#4-6-2-1-如何利用熵度量-node" class="headerlink" title="4.6.2.1. 如何利用熵度量 node"></a>4.6.2.1. 如何利用熵度量 node</h4><ul><li>使用加权平均。因为我们认为分到了较多 examples 的分支的熵是更重要的</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914113505023.png" alt="image-20220914113505023"></p><h4 id="4-6-2-2-信息增益"><a href="#4-6-2-2-信息增益" class="headerlink" title="4.6.2.2. 信息增益"></a>4.6.2.2. 信息增益</h4><p>根节点的熵 - 子节点的加权平均熵</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914113723924.png" alt="image-20220914113723924"></p><ul><li>计算公式</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914113852006.png" alt="image-20220914113852006"></p><h3 id="4-6-4-Decision-Tree-Learning"><a href="#4-6-4-Decision-Tree-Learning" class="headerlink" title="4.6.4. Decision Tree Learning"></a>4.6.4. Decision Tree Learning</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914114051924.png" alt="image-20220914114051924"></p><ul><li>building decision tree 是一个递归过程</li></ul><h3 id="4-6-5-one-hot-编码"><a href="#4-6-5-one-hot-编码" class="headerlink" title="4.6.5. one-hot 编码"></a>4.6.5. one-hot 编码</h3><p>用于处理不止 2 种取值的离散变量</p><ul><li>如果一个分类特征有 k 种可能的取值，那么把这 k 种特征按照 0、1 进行编码取值</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914120302571.png" alt="image-20220914120302571"></p><ul><li><p>如果看任何一行，总有一个特征是 1，因此称之为 one-hot（独热）编码</p></li><li><p>one-hot 编码不仅适用于决策树，还适用于神经网络</p></li></ul><h3 id="4-6-6-处理连续变量"><a href="#4-6-6-处理连续变量" class="headerlink" title="4.6.6. 处理连续变量"></a>4.6.6. 处理连续变量</h3><ul><li><p>对连续变量进行划分处理（分类），即将连续变量区间设置阈值，将其分为 2 个子集</p></li><li><p>分类的标准是谁贡献了更大的信息增益</p></li><li><p>一般划分值的候选方法是：将值 list 排序，然后取所有值之间的中点</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914140944926.png" alt="image-20220914140944926"></p><h2 id="4-7-回归预测中的决策树"><a href="#4-7-回归预测中的决策树" class="headerlink" title="4.7. 回归预测中的决策树"></a>4.7. 回归预测中的决策树</h2><ul><li>决策树会根据叶子结点中样本数据的平均值做出预测</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914141648061.png" alt="image-20220914141648061"></p><ul><li><p>在回归预测中，决定结点选择哪种划分策略的标准不再是熵，而是<strong>带权方差</strong>（variance）</p></li><li><p>就像最终决策树的衡量公式是信息增益，我们在这里计算的也实际上是方差减少量</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914142137648.png" alt="image-20220914142137648"></p><h2 id="4-8-决策树集合"><a href="#4-8-决策树集合" class="headerlink" title="4.8. 决策树集合"></a>4.8. 决策树集合</h2><ul><li><p>使用单个决策树的缺点是：其对数据的微小变化非常敏感。(一旦数据微小变化，那么结点的信息增益可能会变化很多，从而导致决策树变的完全不同)</p><ul><li>解决方法：构建更多的决策树，即决策树集合，使得预测结果更健壮</li></ul></li><li><p>使用树集合，然后都运行数据，进行预测。多数的结果即为预测结果。</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914143400270.png" alt="image-20220914143400270"></p><h3 id="4-8-1-有放回抽样"><a href="#4-8-1-有放回抽样" class="headerlink" title="4.8.1. 有放回抽样"></a>4.8.1. 有放回抽样</h3><ul><li>Sampling with replacement</li></ul><h3 id="4-8-2-随机森林算法"><a href="#4-8-2-随机森林算法" class="headerlink" title="4.8.2. 随机森林算法"></a>4.8.2. 随机森林算法</h3><h4 id="4-8-2-1-袋装决策树算法"><a href="#4-8-2-1-袋装决策树算法" class="headerlink" title="4.8.2.1. 袋装决策树算法"></a>4.8.2.1. 袋装决策树算法</h4><ul><li>对于一个大小为 m 的训练集<ul><li>使用有放回抽样获得同样大小为 m 的训练集，然后训练出一个决策树</li><li>重复以上过程直到训练出需要的决策树数量（一般是 100，记为**<em>B</em>**）</li></ul></li><li>问题<ul><li>根节点及其附近的特征仍然相似</li><li>导致算法不够精确，需要改进</li></ul></li></ul><h4 id="4-8-2-2-改进成随机森林算法"><a href="#4-8-2-2-改进成随机森林算法" class="headerlink" title="4.8.2.2. 改进成随机森林算法"></a>4.8.2.2. 改进成随机森林算法</h4><ul><li>在每个结点中，当需要选择一个特征来 split node 时，如果有 n 个特征可以选择，那么我们每次<strong>随机选择</strong>k（k &lt; n ）个特征构成 n 个特征的子集，让算法在这个子集中进行选择（即计算信息增益然后进行 split）</li><li>比单一决策树更健壮的原因是：随机森林算法探索了更多训练集微小变化的可能，能够对有放回取样过程导致的所有数据变化进行平均，使得训练出来的模型更 robust</li></ul><h3 id="4-8-3-XGBoost-增强决策树算法"><a href="#4-8-3-XGBoost-增强决策树算法" class="headerlink" title="4.8.3. XGBoost 增强决策树算法"></a>4.8.3. XGBoost 增强决策树算法</h3><ul><li>非常类似于针对性训练，比如刻意训练不熟练的一段，而不是总是训练整首曲子</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914150804159.png" alt="image-20220914150804159"></p><ul><li>XGBoost（eXtreme Gradient Boosting）<ul><li>增强决策树的一种开源实现</li><li>高效</li><li>对默认拆分条件有很好的选择</li><li>内置正则化以防止过拟合</li><li>和 dl 一样，是算法竞赛的热门算法</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914151101334.png" alt="image-20220914151101334"></p><h2 id="4-9-决策树和神经网络的使用时机"><a href="#4-9-决策树和神经网络的使用时机" class="headerlink" title="4.9. 决策树和神经网络的使用时机"></a>4.9. 决策树和神经网络的使用时机</h2><ul><li>决策树和树集合<ul><li>对表格化（结构化）tabular（structured）数据表现很好</li><li>不建议在非结构化数据上使用（图像、音频、文本）</li><li>训练迅速</li><li>小的决策树可能是人类可以理解的（可解释性）</li></ul></li><li>神经网络<ul><li>对结构化和非结构化数据都表现良好</li><li>比决策树慢（训练时长等）</li><li>可以使用迁移学习（而决策树不行）</li><li>当构建多个模型共同协作的系统时，神经网络模型更容易串在一起（决策树一次只能训练一个）</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coursera: ML03-深度学习</title>
      <link href="/article/Coursera-Machine-Learning-03/"/>
      <url>/article/Coursera-Machine-Learning-03/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><p>Machine Learning - Android Ng</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221005220433978.png" alt="image-20221005220433978" /><hr><span id="more"></span><h2 id="3-1-神经网络概论"><a href="#3-1-神经网络概论" class="headerlink" title="3.1. 神经网络概论"></a>3.1. 神经网络概论</h2><ul><li><p>尝试模仿（mimic）人脑</p></li><li><p>用处</p><ul><li>speech -&gt; images -&gt; text(NLP) -&gt; …</li></ul></li><li><p>每个神经元接受一些输入，做一些计算，然后将输出送给下一个神经元</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909155125086.png" alt="image-20220909155125086"></p><ul><li>可以将神经元分为不同层（layer），每层接受相似的输入，输出不同的结果</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909164348707.png" alt="image-20220909164348707"></p><ul><li><p>神经网络不需要自己进行特征工程，中间的隐藏层即通过输入初始特征来输出更好的特征</p></li><li><p>需要自己决定的是神经网络的架构：即有多少层，每层有多少神经元</p></li></ul><h3 id="3-1-1-一些-notation"><a href="#3-1-1-一些-notation" class="headerlink" title="3.1.1. 一些 notation"></a>3.1.1. 一些 notation</h3><ul><li>方括号上标代表第 x 层</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220910172611765.png" alt="image-20220910172611765"></p><ul><li>每层接受的输入向量上标是上一层的</li><li>$a^{[0]}$一般表示输入向量</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911170844379.png" alt="image-20220911170844379"></p><h3 id="3-1-2-forward-propagation"><a href="#3-1-2-forward-propagation" class="headerlink" title="3.1.2. forward propagation"></a>3.1.2. forward propagation</h3><ul><li>前向传播</li><li>从神经网络层自左向右传播</li></ul><h2 id="3-2-TensorFlow-介绍"><a href="#3-2-TensorFlow-介绍" class="headerlink" title="3.2. TensorFlow 介绍"></a>3.2. TensorFlow 介绍</h2><h3 id="3-2-1-Demo"><a href="#3-2-1-Demo" class="headerlink" title="3.2.1. Demo"></a>3.2.1. Demo</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">200.0</span>, <span class="number">17.0</span>]])</span><br><span class="line"><span class="comment"># Dense是神经网络一种层的名字</span></span><br><span class="line">layer_1 = Dense(units=<span class="number">3</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line"><span class="comment"># a1是一个1 * 3矩阵（张量），通过a1.numpy()可以把它转换为numpy矩阵</span></span><br><span class="line">a1 = layer_1(x)</span><br><span class="line">layer_2 = Dense(units=<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">a2 = layer_2(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Threshold</span></span><br><span class="line"><span class="keyword">if</span> a2 &gt;= <span class="number">0.5</span></span><br><span class="line">yhat = <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    yhat = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 法2</span></span><br><span class="line">layer_1 = Dense(units=<span class="number">3</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">layer_2 = Dense(units=<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">model = Sequential([layer_1, layer_2 ])</span><br><span class="line">x = np.array([[]])</span><br><span class="line">y = np.array([[]])</span><br><span class="line">model.<span class="built_in">compile</span>(...)</span><br><span class="line">model.fit(x,y)</span><br><span class="line">model.predict(x_new)</span><br></pre></td></tr></table></figure><h3 id="3-2-2-Tf-的数据格式"><a href="#3-2-2-Tf-的数据格式" class="headerlink" title="3.2.2. Tf 的数据格式"></a>3.2.2. Tf 的数据格式</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911175020421.png" alt="image-20220911175020421"></p><h3 id="3-2-3-Tensor（张量）"><a href="#3-2-3-Tensor（张量）" class="headerlink" title="3.2.3. Tensor（张量）"></a>3.2.3. Tensor（张量）</h3><ul><li>可以近似理解为一种矩阵</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911175521941.png" alt="image-20220911175521941"></p><h2 id="3-3-Python-向前传播的原理"><a href="#3-3-Python-向前传播的原理" class="headerlink" title="3.3. Python 向前传播的原理"></a>3.3. Python 向前传播的原理</h2><ul><li>forward prop</li><li>手写全连接层（full connected）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dense</span>(<span class="params">a_in, W, b, g</span>):</span><br><span class="line">    units = W.shape[<span class="number">1</span>]</span><br><span class="line">    a_out = np.zeros(units)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(units):</span><br><span class="line">        <span class="comment"># W[:,j]是提取出W第j列的写法</span></span><br><span class="line">        <span class="comment"># 通常：大写字母用来表示矩阵，小写字母用来表示向量</span></span><br><span class="line">        w = W[:,j]</span><br><span class="line">        z = np.dot(w, a_in) + b[j]</span><br><span class="line">        a_out[j] = g(z)</span><br><span class="line">    <span class="keyword">return</span> a_out</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sequential</span>(<span class="params">x</span>):</span><br><span class="line">    a1 = dense(x, W1, b1)</span><br><span class="line">    a2 = dense(a1, W2, b2)</span><br><span class="line">    a3 = dense(a2, W3, b3)</span><br><span class="line">    a4 = dense(a3, W4, b4)</span><br><span class="line">    f_x = a4</span><br><span class="line">    <span class="keyword">return</span> f_x</span><br></pre></td></tr></table></figure><h2 id="3-4-AI-和神经网络的关系"><a href="#3-4-AI-和神经网络的关系" class="headerlink" title="3.4. AI 和神经网络的关系"></a>3.4. AI 和神经网络的关系</h2><h3 id="3-4-1-ANI-和-AGI"><a href="#3-4-1-ANI-和-AGI" class="headerlink" title="3.4.1. ANI 和 AGI"></a>3.4.1. ANI 和 AGI</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911194524599.png" alt="image-20220911194524599"></p><h3 id="3-4-2-The-“one-learning-algorithm”-hypothesis"><a href="#3-4-2-The-“one-learning-algorithm”-hypothesis" class="headerlink" title="3.4.2. The “one learning algorithm” hypothesis"></a>3.4.2. The “one learning algorithm” hypothesis</h3><p>科学家发现人脑的可塑性非常强：非常小的一片人脑区域就能做很多事情，比如当把图像输给听觉区域时，听觉区域又会学会识别图像。这带来一个假设：存在一种或几种算法，可以使得机器学习&#x2F;神经网络实现非常多的事情</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911195232097.png" alt="image-20220911195232097"></p><h2 id="3-5-算法中的向量化实现"><a href="#3-5-算法中的向量化实现" class="headerlink" title="3.5. 算法中的向量化实现"></a>3.5. 算法中的向量化实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.array([[<span class="number">200</span>, <span class="number">17</span>]])</span><br><span class="line">W = np.array([[<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>],</span><br><span class="line">              [-<span class="number">2</span>, <span class="number">4</span>, -<span class="number">6</span>]])</span><br><span class="line">B = np.array([[-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dense</span>(<span class="params">A_in, W, B, g</span>):</span><br><span class="line">    <span class="comment"># np.matmul = matrix multiplication</span></span><br><span class="line">    Z = np.matmul(A_in, W) + B</span><br><span class="line">    A_out = g(z)</span><br><span class="line">    <span class="keyword">return</span> A_out</span><br></pre></td></tr></table></figure><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911200229967.png" alt="image-20220911200229967"></p><ul><li><p>使用矩阵和向量运算的好处是：可以利用硬件进行并行计算，显著提高运算速度</p></li><li><p>在 TensorFlow 的约定中：一个样本的数据通常在矩阵的行中</p></li></ul><h2 id="3-6-TensorFlow-实现"><a href="#3-6-TensorFlow-实现" class="headerlink" title="3.6. TensorFlow 实现"></a>3.6. TensorFlow 实现</h2><ul><li>tf 编译模型的关键是定义损失函数</li><li>第一步：定义模型</li><li>第二步：使用损失函数编译模型</li><li>第三步：训练模型</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911200855784.png" alt="image-20220911200855784"></p><h3 id="3-6-1-前述基本步骤在-tf-中的对应"><a href="#3-6-1-前述基本步骤在-tf-中的对应" class="headerlink" title="3.6.1. 前述基本步骤在 tf 中的对应"></a>3.6.1. 前述基本步骤在 tf 中的对应</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911201643919.png" alt="image-20220911201643919"></p><ul><li>tf 的 model.fi 通过反向传播实现了梯度下降</li></ul><h2 id="3-7-激活函数详解"><a href="#3-7-激活函数详解" class="headerlink" title="3.7. 激活函数详解"></a>3.7. 激活函数详解</h2><ul><li>一些激活函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911203411855.png" alt="image-20220911203411855"></p><h3 id="3-7-1-ReLU"><a href="#3-7-1-ReLU" class="headerlink" title="3.7.1. ReLU"></a>3.7.1. ReLU</h3><ul><li>Rectified Linear Unit 修正线性单元</li><li>计算速度比 sigmoid 更快</li><li>只有左端是趋于 flat 的，因此在梯度下降时比 sigmoid 更有优势，学习速度更快</li><li>一般作为隐藏层的默认激活函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911203303924.png" alt="image-20220911203303924"></p><h3 id="3-7-2-softmax"><a href="#3-7-2-softmax" class="headerlink" title="3.7.2. softmax"></a>3.7.2. softmax</h3><ul><li>逻辑回归的泛化</li><li>针对多分类环境</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911205212945.png" alt="image-20220911205212945"></p><h4 id="3-7-2-1-softmax-函数的损失函数"><a href="#3-7-2-1-softmax-函数的损失函数" class="headerlink" title="3.7.2.1. softmax 函数的损失函数"></a>3.7.2.1. softmax 函数的损失函数</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911205507260.png" alt="image-20220911205507260"></p><ul><li>可以和 sigmoid 类比，$a_j$越接近 1，损失越小，这会刺激$a_j$不断接近 1</li></ul><h3 id="3-7-3-如何选择激活函数"><a href="#3-7-3-如何选择激活函数" class="headerlink" title="3.7.3. 如何选择激活函数"></a>3.7.3. 如何选择激活函数</h3><ul><li>sigmoid：二元分类问题，因为神经网络在学习 y&#x3D;1 的概率</li><li>linear：回归</li><li>ReLU：回归，且结果是非负值</li></ul><h3 id="3-7-4-为什么我们需要激活函数"><a href="#3-7-4-为什么我们需要激活函数" class="headerlink" title="3.7.4. 为什么我们需要激活函数"></a>3.7.4. 为什么我们需要激活函数</h3><ul><li>简单来说，如果我们不使用激活函数，那么所有神经网络将变成如同线性回归般的简单计算。多层神经网络不能提供提升计算复杂特征的能力，也不能学习任何比线性函数更复杂的东西，违背了我们创造神经网络的初衷</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911204521409.png" alt="image-20220911204521409"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911204532625.png" alt="image-20220911204532625"></p><h2 id="3-8-多分类"><a href="#3-8-多分类" class="headerlink" title="3.8. 多分类"></a>3.8. 多分类</h2><ul><li>y 是离散的，且可能的取值大于 2 种</li><li>使用 softmax 激活函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911210538665.png" alt="image-20220911210538665"></p><ul><li>softmax 函数在这里和其他激活函数的区别是，softmax 函数一次性算出$a_1, a_2, …, a_i$的所有值，并计算出它们的概率。而其他激活函数仅仅只是一次计算出一个。</li></ul><h3 id="3-8-1-使用-tf-实现"><a href="#3-8-1-使用-tf-实现" class="headerlink" title="3.8.1. 使用 tf 实现"></a>3.8.1. 使用 tf 实现</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911210704162.png" alt="image-20220911210704162"></p><ul><li>一种 tf 实现的版本，但是实际上有更好的版本。因此</li></ul><h4 id="3-8-1-1-优化计算精度"><a href="#3-8-1-1-优化计算精度" class="headerlink" title="3.8.1.1. 优化计算精度"></a>3.8.1.1. 优化计算精度</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911211123650.png" alt="image-20220911211123650"></p><ul><li>在输出层使用 linear 激活函数（目的是为了不先计算 a&#x2F;z，而是把整个式子放到最后再统一计算，避免了计算中间值而带来的精度误差），然后在 compile 选项里加上<code>from_logits=True</code></li></ul><h3 id="3-8-2-多标签分类问题"><a href="#3-8-2-多标签分类问题" class="headerlink" title="3.8.2. 多标签分类问题"></a>3.8.2. 多标签分类问题</h3><ul><li>multi-label classification problem</li><li>输出是一个标签向量，表示是否包含某个向量</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911212040447.png" alt="image-20220911212040447"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911212149890.png" alt="image-20220911212149890"></p><h2 id="3-9-Adam-算法"><a href="#3-9-Adam-算法" class="headerlink" title="3.9. Adam 算法"></a>3.9. Adam 算法</h2><ul><li><p>Adaptive Moment estimation，自适应矩估计</p></li><li><p>可以自动调整学习率$\alpha$</p></li><li><p>对于不同模型使用不同$\alpha$</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911212752093.png" alt="image-20220911212752093"></p><h3 id="3-9-1-使用"><a href="#3-9-1-使用" class="headerlink" title="3.9.1. 使用"></a>3.9.1. 使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential([</span><br><span class="line">    Dense(units=<span class="number">25</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">    Dense(units=<span class="number">15</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">    Dense(units=<span class="number">10</span>, activation=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=Adam(learning_rate=le-<span class="number">3</span>),                loss=SparseCategoricalCrossentropy(from_logits=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">model.fit(X,Y,epochs=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>在 compile 里面加一个优化器参数即可，然后设置一个默认的学习率</p><h2 id="3-10-Layer-Types"><a href="#3-10-Layer-Types" class="headerlink" title="3.10. Layer Types"></a>3.10. Layer Types</h2><h3 id="3-10-1-Dense-layer"><a href="#3-10-1-Dense-layer" class="headerlink" title="3.10.1. Dense layer"></a>3.10.1. Dense layer</h3><p>全连接层，接受前一层的所有激活，然后通过一个激活函数得到它自己的输出</p><h3 id="3-10-2-Convolutional-Layer"><a href="#3-10-2-Convolutional-Layer" class="headerlink" title="3.10.2. Convolutional Layer"></a>3.10.2. Convolutional Layer</h3><p>卷积层</p><ul><li><p>每一个神经元只关注**<em>part of</em>**前一层的输出</p></li><li><p>优点：</p><ul><li>计算更快</li><li>所需的训练数据更少，也更不容易过拟合</li></ul></li><li><p>例子<img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911213905765.png" alt="image-20220911213905765"></p></li><li><p>可选择参数：每层的神经元数，每个神经元得到的输入数量</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coursera: ML02-逻辑回归与正则化</title>
      <link href="/article/Coursera-Machine-Learning-02/"/>
      <url>/article/Coursera-Machine-Learning-02/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑回归与正则化"><a href="#逻辑回归与正则化" class="headerlink" title="逻辑回归与正则化"></a>逻辑回归与正则化</h1><p>Machine Learning - Android Ng</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221005220433978.png" alt="image-20221005220433978" /><hr><span id="more"></span><h2 id="2-1-逻辑回归"><a href="#2-1-逻辑回归" class="headerlink" title="2.1. 逻辑回归"></a>2.1. 逻辑回归</h2><ul><li>使用 0 和 1 来代表 negative 和 positive</li></ul><h3 id="2-1-1-Sigmoid-函数"><a href="#2-1-1-Sigmoid-函数" class="headerlink" title="2.1.1. Sigmoid 函数"></a>2.1.1. Sigmoid 函数</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908214617691.png" alt="image-20220908214617691"></p><ul><li>通常将函数作为输入，然后输出[0,1]</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908215053672.png" alt="image-20220908215053672"></p><h3 id="2-1-2-决策边界"><a href="#2-1-2-决策边界" class="headerlink" title="2.1.2. 决策边界"></a>2.1.2. 决策边界</h3><p>当我们把$wx+b$作为自变量输入 sigmoid 函数时，假设我们取 0.5 作为 sigmoid 函数的分界点（大于 0.5 认为是 positive，小于 0.5 认为是 negative），我们可以推导出：</p><p>$$<br>wx + b \gt 0<br>$$</p><p>是 positive，从而我们抽象出</p><p>$$<br>wx + b &#x3D; 0<br>$$</p><p>作为<strong>决策边界</strong></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908220316763.png" alt="image-20220908220316763"></p><p>当然决策边界也可以是非线性（多项的）</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908220441800.png" alt="image-20220908220441800"></p><h3 id="2-1-3-代价函数"><a href="#2-1-3-代价函数" class="headerlink" title="2.1.3. 代价函数"></a>2.1.3. 代价函数</h3><ul><li>关键之处是原来的平方误差损失函数作用在 sigmoid 函数后不再是凸函数了（convex-function），导致梯度下降不好作用。</li><li>因此需要找到一种是凸函数的代价函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908220902583.png" alt="image-20220908220902583"></p><ul><li>因此找到如下损失函数：</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908221515195.png" alt="image-20220908221515195"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908230028302.png" alt="image-20220908230028302"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908230124286.png" alt="image-20220908230124286"></p><h2 id="2-2-实现梯度下降"><a href="#2-2-实现梯度下降" class="headerlink" title="2.2. 实现梯度下降"></a>2.2. 实现梯度下降</h2><ul><li>梯度下降的大公式是一样的，但是求导的细节有不同 👇</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908230531967.png" alt="image-20220908230531967"></p><h2 id="2-3-过拟合"><a href="#2-3-过拟合" class="headerlink" title="2.3. 过拟合"></a>2.3. 过拟合</h2><ul><li><p>overfitting &#x2F; high variance</p></li><li><p>过于贴近训练集，导致实际预测结果的不准确（如下图右三）</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909141900666.png" alt="image-20220909141900666"></p><h3 id="2-3-1-debug-address-methods"><a href="#2-3-1-debug-address-methods" class="headerlink" title="2.3.1. debug &#x2F; address methods"></a>2.3.1. debug &#x2F; address methods</h3><ul><li>收集更多的训练数据</li><li>考虑使用较少的特征<ul><li>选择最相关的特征（最小的特征子集）</li><li>course 2 会学习自动特征的算法</li></ul></li><li>正则化（Regularization）<ul><li>保留所有的特征，但尽量避免它们产生过拟合</li><li>把一些特征的参数调小（接近 0）</li><li>是否正则化 b 对实际模型的影响不大（一般不正则化 b）</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909142655263.png" alt="image-20220909142655263"></p><h2 id="2-4-正则化"><a href="#2-4-正则化" class="headerlink" title="2.4. 正则化"></a>2.4. 正则化</h2><ul><li><p>正则化的思想是：如果有很多特征，我全部使用的话可能会造成过拟合，而我也不知道哪些特征是重要的，哪些是不重要的，那么我就对所有的这些特征进行建模，并对他们进行正则化奖励或惩罚（penalize）。不重要的参数会被惩罚的非常小。从而得到不那么容易过拟合的模型</p></li><li><p>公式</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909143702593.png" alt="image-20220909143702593"></p><ul><li>注意：λ 下面有分母 2m。这样可以保证当 m（训练集样本）增大时，先前的 λ 仍然有用</li><li>加入正则化后的 cost function，前一项是为了让模型拟合数据，而后一项是为了防止模型过拟合。参数 λ 平衡了这两个功能。我们往往需要选择一个权衡两者的 λ</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909144416958.png" alt="image-20220909144416958"></p><h2 id="2-5-加入正则化后的梯度下降"><a href="#2-5-加入正则化后的梯度下降" class="headerlink" title="2.5. 加入正则化后的梯度下降"></a>2.5. 加入正则化后的梯度下降</h2><h3 id="2-5-1-线性回归"><a href="#2-5-1-线性回归" class="headerlink" title="2.5.1. 线性回归"></a>2.5.1. 线性回归</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909144754578.png" alt="image-20220909144754578"></p><ul><li>加上正则化之后，使得每次梯度下降后的$w_j$下降一点点</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909152304619.png" alt="image-20220909152304619"></p><h3 id="2-5-2-逻辑回归"><a href="#2-5-2-逻辑回归" class="headerlink" title="2.5.2. 逻辑回归"></a>2.5.2. 逻辑回归</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909152918725.png" alt="image-20220909152918725"></p><ul><li>求导之后的梯度下降更新项和线性回归一模一样</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909153007372.png" alt="image-20220909153007372"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coursera: ML01-概论与线性回归</title>
      <link href="/article/Coursera-Machine-Learning-01/"/>
      <url>/article/Coursera-Machine-Learning-01/</url>
      
        <content type="html"><![CDATA[<h1 id="概论与线性回归"><a href="#概论与线性回归" class="headerlink" title="概论与线性回归"></a>概论与线性回归</h1><p>Machine Learning - Android Ng</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221005220433978.png" alt="image-20221005220433978" /><hr><span id="more"></span><h2 id="1-1-分类"><a href="#1-1-分类" class="headerlink" title="1.1. 分类"></a>1.1. 分类</h2><ul><li>监督学习</li><li>无监督学习</li><li>增强学习（reinforcement learning）</li></ul><h2 id="1-2-监督学习"><a href="#1-2-监督学习" class="headerlink" title="1.2. 监督学习"></a>1.2. 监督学习</h2><ul><li>supervised learning</li><li>通过给予机器正确的例子（包括答案）让其学习</li></ul><h3 id="1-2-1-回归"><a href="#1-2-1-回归" class="headerlink" title="1.2.1. 回归"></a>1.2.1. 回归</h3><ul><li>regression</li><li>从无限多个可能的 output 中预测一个结果（连续），output 一般是数字</li></ul><h3 id="1-2-2-分类算法"><a href="#1-2-2-分类算法" class="headerlink" title="1.2.2. 分类算法"></a>1.2.2. 分类算法</h3><ul><li>classification</li><li>和回归的区别是：只有两个或有限的可能的输出</li><li>预测类别，而类别不一定是数字</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220906145641543.png" alt="image-20220906145641543"></p><ul><li>上图例子（预测乳腺癌）中，只有肿瘤大小一个输入。但实际上可以有多个输入</li></ul><h2 id="1-3-无监督学习"><a href="#1-3-无监督学习" class="headerlink" title="1.3. 无监督学习"></a>1.3. 无监督学习</h2><ul><li>Unsupervised learning</li><li>在无监督学习中，得到的数据是无 label 的，即无结果</li><li>目的只是找到一些数据中的模式或结构，而不是得到什么具体的结论</li></ul><h3 id="1-3-1-聚类"><a href="#1-3-1-聚类" class="headerlink" title="1.3. 1. 聚类"></a>1.3. 1. 聚类</h3><ul><li>clustering</li><li>获取没有标签的 data，并试图自动将他们分到不同的类别（聚簇）中</li></ul><h3 id="1-3-2-异常检测"><a href="#1-3-2-异常检测" class="headerlink" title="1.3.2. 异常检测"></a>1.3.2. 异常检测</h3><ul><li>Anomaly detection</li></ul><h3 id="1-3-3-降维"><a href="#1-3-3-降维" class="headerlink" title="1.3.3. 降维"></a>1.3.3. 降维</h3><ul><li>Dimensionality reduction</li></ul><h2 id="1-4-线性回归模型"><a href="#1-4-线性回归模型" class="headerlink" title="1.4. 线性回归模型"></a>1.4. 线性回归模型</h2><ul><li>属于监督学习</li></ul><h4 id="1-4-1-数据表"><a href="#1-4-1-数据表" class="headerlink" title="1.4.1. 数据表"></a>1.4.1. 数据表</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220906224237839.png" alt="image-20220906224237839"></p><h4 id="1-4-2-训练集"><a href="#1-4-2-训练集" class="headerlink" title="1.4.2. 训练集"></a>1.4.2. 训练集</h4><p>用来训练模型的数据，包括输入（变量、特征或输入特征）和输出（目标变量）</p><p>一些专业术语<img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220906224737300.png" alt="image-20220906224737300" style="zoom: 50%;" /><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220906225335017.png" alt="image-20220906225335017" style="zoom:50%;" /></p><h2 id="1-5-成本函数"><a href="#1-5-成本函数" class="headerlink" title="1.5. 成本函数"></a>1.5. 成本函数</h2><p>$$<br>J(w,b) &#x3D; \frac{1}{2m} \Sigma_{i&#x3D;1}^m (y_{hat}^{(i)} - y^{(i)})^2<br>$$</p><p>平方残差损失函数常常用于线性回归中。我们希望找到一个模型让损失函数最下</p><h2 id="1-6-梯度下降"><a href="#1-6-梯度下降" class="headerlink" title="1.6. 梯度下降"></a>1.6. 梯度下降</h2><ul><li>gradient descent</li></ul><p>$$<br>min_{w_1,….,w_n,b}J(W_1,W_2,…,W_n,b)<br>$$</p><p>对应多参数的损失函数，可以使用梯度下降找到使其最小的点。</p><p>注意：如果对于一些不是吊床形和碗形的图像，可能存在不止一个极小值</p><ul><li>选择一个 w 和 b 作为起始点</li><li>然后沿着斜率最陡的方向下降</li></ul><p>$$<br>w &#x3D; w - \alpha \frac{\alpha}{\alpha w}J(w,b)<br>$$</p><p>$$<br>b &#x3D; b - \alpha \frac{\alpha}{\alpha b}J(w,b)<br>$$</p><p>$\alpha$叫做学习率</p><ul><li>一个例子</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220907181123570.png" alt="image-20220907181123570"></p><h3 id="1-6-1-学习率"><a href="#1-6-1-学习率" class="headerlink" title="1.6.1. 学习率"></a>1.6.1. 学习率</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908120058580.png" alt="image-20220908120058580"></p><p>学习率太小：梯度下降太慢</p><p>学习率太大：可能无法收敛，反而发散</p><h4 id="1-6-1-1-如何选择好的学习率"><a href="#1-6-1-1-如何选择好的学习率" class="headerlink" title="1.6.1.1. 如何选择好的学习率"></a>1.6.1.1. 如何选择好的学习率</h4><ul><li>debug 梯度下降的方法是：将学习率设定为非常小，然后看迭代后 J 是否收敛（向极小值&#x2F;最小值逼近）</li></ul><h3 id="1-6-2-批量梯度下降"><a href="#1-6-2-批量梯度下降" class="headerlink" title="1.6.2. 批量梯度下降"></a>1.6.2. 批量梯度下降</h3><p>Batch gradient descent</p><p>‘Batch’的意思是梯度下降的每一步都使用所有的训练集</p><h3 id="1-6-3-矢量化"><a href="#1-6-3-矢量化" class="headerlink" title="1.6.3. 矢量化"></a>1.6.3. 矢量化</h3><ul><li>多元线性回归</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908171348625.png" alt="image-20220908171348625"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908172417233.png" alt="image-20220908172417233"></p><ul><li>矢量化快速的原因主要是可以理由计算机的并行硬件进行并行计算，而 for 循环只能在循环中一个个循环的计算。</li></ul><h3 id="1-6-4-多元回归的梯度下降"><a href="#1-6-4-多元回归的梯度下降" class="headerlink" title="1.6.4. 多元回归的梯度下降"></a>1.6.4. 多元回归的梯度下降</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908193206271.png" alt="image-20220908193206271"></p><h2 id="1-7-正规方程法"><a href="#1-7-正规方程法" class="headerlink" title="1.7. 正规方程法"></a>1.7. 正规方程法</h2><ul><li><p>normal equation</p></li><li><p>只针对线性回归，不需要迭代即可求解 w 和 b 的方法</p></li><li><p>不适用其他方法</p></li><li><p>当 features 很大（&gt; 10000）时，处理很慢</p></li></ul><h2 id="1-8-特征缩放"><a href="#1-8-特征缩放" class="headerlink" title="1.8. 特征缩放"></a>1.8. 特征缩放</h2><ul><li>让梯度下降更快</li><li>让多维数据彼此之间的范围变得 comparable</li><li>归一化（mean normalization），让所有参数在[-1, 1]之间</li></ul><p>$$<br>x_i &#x3D; \frac{x_i - μ_i}{max - min}<br>$$</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908195407614.png" alt="image-20220908195407614"></p><ul><li>Z-scroe 归一化（normalization）</li><li>计算每个特征的标准差</li></ul><p>$$<br>X_i &#x3D; \frac{x_i - μ_i}{\sigma_i}<br>$$</p><ul><li>一样可以达到让所有参数在[-1, 1]之间</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908195556934.png" alt="image-20220908195556934"></p><h2 id="1-9-检查梯度下降-work-well"><a href="#1-9-检查梯度下降-work-well" class="headerlink" title="1.9. 检查梯度下降 work well"></a>1.9. 检查梯度下降 work well</h2><ul><li><p>通过学习曲线（绘制 J-iteration 函数图像）观察函数变平的时候</p></li><li><p>通过自动收敛测试。其实很类似微积分证明极限的思想。当 J 每次增减小于 δ（极小）时，认为已经收敛</p></li></ul><h2 id="1-10-特征工程"><a href="#1-10-特征工程" class="headerlink" title="1.10. 特征工程"></a>1.10. 特征工程</h2><ul><li><p>Feature engineering</p></li><li><p>通过直觉来设计一个新特征，通常通过改变或结合已有特征来实现</p></li><li><p>选择正确且适当的特征是机器学习模型 work well 的重要前提</p></li></ul><h2 id="1-11-多项式回归"><a href="#1-11-多项式回归" class="headerlink" title="1.11. 多项式回归"></a>1.11. 多项式回归</h2><ul><li>Polynomial regression</li><li>即使用高次、开根等项进行回归拟合</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学软件学院-云计算第一次作业-OBS展示</title>
      <link href="/article/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A-OBS%E5%B1%95%E7%A4%BA/"/>
      <url>/article/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A-OBS%E5%B1%95%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="云计算第一次实践：网络测试-个人主页"><a href="#云计算第一次实践：网络测试-个人主页" class="headerlink" title="云计算第一次实践：网络测试+个人主页"></a>云计算第一次实践：网络测试+个人主页</h1><p>2022-Fall Cloud Computing</p><p>描述：下图即为 Huawei OBS 存储对象</p><img src="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png"><span id="more"></span><h1 id="一、过程记录"><a href="#一、过程记录" class="headerlink" title="一、过程记录"></a>一、过程记录</h1><h2 id="1-网络测试"><a href="#1-网络测试" class="headerlink" title="1. 网络测试"></a>1. 网络测试</h2><h3 id="1-1-测试过程描述：虚拟机申请过程、测试工具、操作过程"><a href="#1-1-测试过程描述：虚拟机申请过程、测试工具、操作过程" class="headerlink" title="1.1. 测试过程描述：虚拟机申请过程、测试工具、操作过程"></a>1.1. 测试过程描述：虚拟机申请过程、测试工具、操作过程</h3><h3 id="1-2-跨区域公网：虚拟机网络配置情况-测试结果"><a href="#1-2-跨区域公网：虚拟机网络配置情况-测试结果" class="headerlink" title="1.2. 跨区域公网：虚拟机网络配置情况 + 测试结果"></a>1.2. 跨区域公网：虚拟机网络配置情况 + 测试结果</h3><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921205319574.png" alt="image-20220921205319574"></p><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921205336815.png" alt="image-20220921205336815"></p><h3 id="1-3-同区域跨可用区公网：虚拟机网络配置情况-测试结果"><a href="#1-3-同区域跨可用区公网：虚拟机网络配置情况-测试结果" class="headerlink" title="1.3. 同区域跨可用区公网：虚拟机网络配置情况 + 测试结果"></a>1.3. 同区域跨可用区公网：虚拟机网络配置情况 + 测试结果</h3><h3 id="1-3-1-公网"><a href="#1-3-1-公网" class="headerlink" title="1.3.1. 公网"></a>1.3.1. 公网</h3><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921191009640.png" alt="image-20220921191009640"></p><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921191000516.png" alt="image-20220921191000516"></p><h3 id="1-3-2-私网"><a href="#1-3-2-私网" class="headerlink" title="1.3.2. 私网"></a>1.3.2. 私网</h3><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921203324190.png" alt="image-20220921203324190"></p><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921203335678.png" alt="image-20220921203335678"></p><h3 id="1-4-同可用区公网-私网：虚拟机网络配置情况-测试结果"><a href="#1-4-同可用区公网-私网：虚拟机网络配置情况-测试结果" class="headerlink" title="1.4. 同可用区公网+私网：虚拟机网络配置情况 + 测试结果"></a>1.4. 同可用区公网+私网：虚拟机网络配置情况 + 测试结果</h3><h4 id="1-4-1-公网"><a href="#1-4-1-公网" class="headerlink" title="1.4.1. 公网"></a>1.4.1. 公网</h4><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921154258878.png" alt="image-20220921154258878"></p><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921154328161.png" alt="image-20220921154328161"></p><h4 id="1-4-2-私网"><a href="#1-4-2-私网" class="headerlink" title="1.4.2. 私网"></a>1.4.2. 私网</h4><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921154807390.png" alt="image-20220921154807390"></p><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921154817551.png" alt="image-20220921154817551"></p><h2 id="2-个人主页"><a href="#2-个人主页" class="headerlink" title="2. 个人主页"></a>2. 个人主页</h2><p>（1）对应的 OBS 链接</p><ul><li><a href="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/">https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com</a></li></ul><p>（2）上传的 obs 图片链接</p><ul><li><a href="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png">https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png</a></li></ul><p>（3）个人主页地址（公网 IP）</p><ul><li><a href="http://116.204.103.36/">http://116.204.103.36/</a></li></ul><h1 id="二、详细作业叙述"><a href="#二、详细作业叙述" class="headerlink" title="二、详细作业叙述"></a>二、详细作业叙述</h1><ol><li>201250214-彭俊植</li><li>网络测试：</li></ol><ul><li><p><strong>虚拟机申请过程：</strong></p><ul><li>虚拟机 ①<ul><li>华北-乌兰察布一&#x2F;可用区 2</li><li>ID：test0921-wlcb2qu</li><li>配置 1C4G；系统镜像 CentOS 8.2 64bit；按需计费</li><li>带宽：5 Mbit&#x2F;s</li><li>公网 ip：116.204.103.253；私网 ip：192.168.0.173</li></ul></li><li>虚拟机 ②<ul><li>华北-乌兰察布一&#x2F;可用区 2</li><li>ID：test0921-wlcb2qu-02</li><li>配置 1C4G；系统镜像 CentOS 8.2 64bit；按需计费</li><li>带宽：5 Mbit&#x2F;s</li><li>公网 ip：116.204.103.36；私网 ip：192.168.0.83</li></ul></li><li>虚拟机 ③<ul><li>华北-乌兰察布一&#x2F;可用区 3</li><li>ID：test0921-wlcb3qu</li><li>配置 1C4G；系统镜像 CentOS 8.2 64bit；按需计费</li><li>带宽：5 Mbit&#x2F;s</li><li>公网 ip：121.37.97.146；私网 ip：192.168.0.128</li></ul></li><li>虚拟机 ④<ul><li>西南-贵阳一&#x2F;可用区 1</li><li>ID：test0921-guiyang1qu</li><li>配置 1C4G；系统镜像 CentOS 8.2 64bit；按需计费</li><li>带宽：5 Mbit&#x2F;s</li><li>公网 ip：140.210.210.244；私网 ip：192.168.0.109</li></ul></li></ul></li><li><p><strong>测试工具</strong>：iperf 3.1.3</p></li><li><p><strong>操作过程</strong></p><ul><li>先按如上配置申请四台虚拟机，并开放必要的 5000、22、ICMP 等端口，并安装 iperf 3.1.3。随后分别按作业要求所述的三种情况展开测试。</li><li>测试手段如下：同时开启两台虚拟机，一台作为客户端，一台作为服务端。先在服务端运行命令<code>iperf3 –s –i 5 –p 5000</code>，再于客户端运行命令<code>Iperf3 –c $&#123;serverIP&#125; –i 5 –t 100 –p 5000</code>。其中客户端中第二个参数填上服务端的 ip（可视实验情况选择填写公网 ip 或私网 ip）。观察屏幕输出结果，并进行记录。</li></ul></li><li><p><strong>跨区域</strong></p><ul><li>公网：服务端为 wlcb2qu-02，客户端为 guiyang1qu。测试结果为客户端 sender 5.18 Mbits&#x2F;sec，receiver 4.85 Mbits&#x2F;sec，服务端 receiver 4.85 Mbits&#x2F;sec</li><li>私网：ping 不通</li></ul></li><li><p><strong>同区域跨可用区</strong></p><ul><li>公网：服务端为 wlcb3qu ，客户端为 wlcb2qu-02。测试结果为客户端 sender 5.56 Mbits&#x2F;sec，receiver 5.46 Mbits&#x2F;sec，服务端 receiver 5.46 Mbits&#x2F;sec</li><li>私网：可 ping 通，服务端为 wlcb3qu，客户端为 wlcb2qu-02。测试结果为客户端 sender 531 Mbits&#x2F;sec，receiver 531 Mbits&#x2F;sec，服务端 receiver 531 Mbits&#x2F;sec</li></ul></li><li><p><strong>同区域同可用区</strong></p><ul><li><p>公网：服务端为 wlcb2qu-02 ，客户端为 wlcb2qu。测试结果为客户端 sender 5.38 Mbits&#x2F;sec，receiver 5.35 Mbits&#x2F;sec，服务端 receiver 5.34 Mbits&#x2F;sec</p></li><li><p>私网：可 ping 通，服务端为 wlcb2qu，客户端为 wlcb2qu-02。测试结果为客户端 sender 55.4 Gbits&#x2F;sec，receiver 55.4 Gbits&#x2F;sec，服务端 receiver 55.4 Gbits&#x2F;sec</p><p>3.个人主页</p></li></ul></li></ul><p>（1）对应的 OBS 链接</p><ul><li><a href="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/">https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com</a></li></ul><p>（2）上传的 obs 图片链接</p><ul><li><a href="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png">https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png</a></li></ul><p>（3）个人主页地址</p><ul><li><a href="http://116.204.103.36/">http://116.204.103.36/</a> （部署在虚拟机 ② 上）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 整理重点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Redis 发布订阅实现IM消息队列</title>
      <link href="/article/%E5%9F%BA%E4%BA%8ERedis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%AE%9E%E7%8E%B0IM%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/article/%E5%9F%BA%E4%BA%8ERedis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%AE%9E%E7%8E%B0IM%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>使用Redis的发布订阅模式实现即时通讯功能的消息队列中间件，以适应分布式模块中即时通讯服务的需要。</p><p>整合方式：SpringBoot + WebSocket + Redis</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/60047df223d04285afea73d1cacfa688.png" alt="在这里插入图片描述"></p><hr><span id="more"></span><h2 id="1-发布订阅模式"><a href="#1-发布订阅模式" class="headerlink" title="1. 发布订阅模式"></a>1. 发布订阅模式</h2><p>Redis的发布订阅机制是一种消息通信模式，包括三个部分，发布者（pub）发送消息，订阅者（sub）接收信息和<code>Channel</code>，这里的<code>Channel</code>类似于<code>Kafka</code>中的<code>topic</code>的概念。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/20210702104227710.png" alt="img"></p><p>发布者和订阅者都是<code>Redis</code>客户端，<code>Channel</code>则为<code>Redis</code>服务器端，可以理解为一种特殊的数据<a href="https://so.csdn.net/so/search?q=%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">存储结构</a>。发布者将消息发送到某个的频道，订阅了这个频道的订阅者就能接收到这条消息。</p><p>Redis客户端可以订阅任意数量的频道。</p><p><code>Redis</code>的这种发布订阅机制与基于主题的发布订阅类似，<code>Channel</code>相当于主题。</p><p>下图展示频道channel1，以及订阅这个频道的三个客户端–client2，client5和client1之间的关系</p><p><img src="https://img-blog.csdnimg.cn/ae3ee06fde0b4b81ad1278a920dbfcc2.png#pic_center" alt="img"></p><p>当有新消息通过PUBLISH命令发送给频道channel1时，这个消息就会被发送给订阅它的三个客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/ce1bfeef41514ea59745f713fc49d439.png" alt="在这里插入图片描述"></p><h3 id="1-1-相关命令"><a href="#1-1-相关命令" class="headerlink" title="1.1. 相关命令"></a>1.1. 相关命令</h3><h4 id="1-1-1-订阅者-等待接收消息"><a href="#1-1-1-订阅者-等待接收消息" class="headerlink" title="1.1.1. 订阅者&#x2F;等待接收消息"></a>1.1.1. 订阅者&#x2F;等待接收消息</h4><p>首先打开 Redis 客户端，然后订阅了一个名为“bbx”的 channel，使用如下命令:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE bbx</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;bbx&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>使用SUBSCRIBE命令订阅了名为 bbx 的 channel。命令执行后该客户端会出处于等待接收消息的阻塞状态。</p><h4 id="1-1-2-发布者-发送消息"><a href="#1-1-2-发布者-发送消息" class="headerlink" title="1.1.2. 发布者&#x2F;发送消息"></a>1.1.2. 发布者&#x2F;发送消息</h4><p>下面再启动一个 Redis 客户端，输入如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH bbx hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH bbx world</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><h4 id="1-1-3-订阅者-成功接收消息"><a href="#1-1-3-订阅者-成功接收消息" class="headerlink" title="1.1.3. 订阅者&#x2F;成功接收消息"></a>1.1.3. 订阅者&#x2F;成功接收消息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE bbx</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;bbx&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">#等待读取推送消息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span><span class="comment">#消息</span></span><br><span class="line">2) <span class="string">&quot;bbx&quot;</span><span class="comment">#频道</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span><span class="comment">#消息具体内容</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;bbx&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2. 原理"></a>1.2. 原理</h3><blockquote><p>源码：pubsub.c</p></blockquote><p>Redis通过<code>PUBLISH</code>，<code>SUBSCRIBE</code>和<code>PSUBSCRIBE</code>等命令实现发布和订阅功能</p><p>通过<code>SUBSCRIBE</code>命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个频道，字典的值则是一个链表，链表中保存了所有订阅这个频道的客户端。<code>SUBSCRIBE</code>命令的关键，就是将客户端添加到给定频道的订阅链表中。</p><p>通过<code>PUBLISH</code>命令向订阅者发送消息，redis-server会使用给定频道作为键，在它维护的频道字典中查找记录了订阅这个频道的所有客户端的链表，将消息发布给所有订阅者</p><p>Pub和Sub从字面上理解就是发布（Publish）和订阅（Subscribe），在redis中，可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的信息，这一功能最明显的用法就是实时消息系统，比如普通的即时聊天，群聊等功能。</p><h3 id="1-3-缺点"><a href="#1-3-缺点" class="headerlink" title="1.3. 缺点"></a>1.3. 缺点</h3><ul><li>消息无法持久化，存在丢失风险，即消息一经发布，即使没有任何订阅方处理,该条消息就会丢失</li><li>没有类似ACK的机制，即发布方不会确保订阅方成功接收</li><li>广播机制，下游消费能力取决于消费方本身。广播机制无法通过添加多个消费方增强消费能力, 因为这和发布&#x2F;订阅模型本身的目的是不符的。广播机制的目的是一个一个发布者被多个订阅进行不同的处理</li></ul><p>解决方法：</p><blockquote><ol><li>添加持久化层，加入redis缓存和MySQL</li><li>结合WebSocket，实现消息推送、握手、心跳检测和广播等机制</li></ol></blockquote><h2 id="2-和SpringBoot、WebSocket的整合"><a href="#2-和SpringBoot、WebSocket的整合" class="headerlink" title="2. 和SpringBoot、WebSocket的整合"></a>2. 和SpringBoot、WebSocket的整合</h2><h3 id="2-1-依赖"><a href="#2-1-依赖" class="headerlink" title="2.1. 依赖"></a>2.1. 依赖</h3><ul><li><em><strong>spring-boot-starter-web</strong></em>：帮助我们启动一个Web服务器；</li><li><em><strong>spring-boot-starter-data-redis</strong></em>：帮助我们集成Redis；</li><li><em><strong>lombok</strong></em>：方便我们使用 <em><strong>@Slf4j</strong></em>&#x2F;<em><strong>@Data</strong></em> 等，简化代码；</li><li><em><strong>spring-boot-starter-websocket</strong></em>：帮助我们在SpringBoot客户端起WebSocket进程</li></ul><h3 id="2-2-架构"><a href="#2-2-架构" class="headerlink" title="2.2. 架构"></a>2.2. 架构</h3><h4 id="2-2-1-整体架构"><a href="#2-2-1-整体架构" class="headerlink" title="2.2.1. 整体架构"></a>2.2.1. 整体架构</h4><blockquote><p>Redis(消息队列)——&gt; MySQL(持久化) ——&gt; WebSockets(消息转发)——&gt; FrontEnd(客户端)</p></blockquote><h4 id="2-2-2-后端架构"><a href="#2-2-2-后端架构" class="headerlink" title="2.2.2. 后端架构"></a>2.2.2. 后端架构</h4><blockquote><p>Controller——(n,1)——&gt;Redis——(1,n)———&gt;Listener——(1,n)——&gt;WebSockets</p></blockquote><h3 id="2-3-Redis配置"><a href="#2-3-Redis配置" class="headerlink" title="2.3. Redis配置"></a>2.3. Redis配置</h3><h4 id="2-3-1-自定义RedisTemplate"><a href="#2-3-1-自定义RedisTemplate" class="headerlink" title="2.3.1. 自定义RedisTemplate"></a>2.3.1. 自定义RedisTemplate</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTemp</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-发布订阅配置"><a href="#2-3-2-发布订阅配置" class="headerlink" title="2.3.2. 发布订阅配置"></a>2.3.2. 发布订阅配置</h4><p>由于我们在发布者、订阅者的代码中均没有指定要订阅的channel，因此需要在其他地方（发布订阅配置类）指定channel。</p><p>此配置类主要实现了Redis消息监听器容器，这个容器加载了RedisConnectionFactory和消息监听器；可以添加多个监听不同话题的redis监听器，只需要把消息监听器和相应的消息订阅处理器绑定，该消息监听器通过反射技术调用消息订阅处理器的相关方法进行一些业务处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubConfig</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisConnectionFactory = redisConnectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;配置消息监听器&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageListener <span class="title function_">listener</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ConnectionListener.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;配置 发布/订阅 的 Topic&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ChannelTopic <span class="title function_">channelTopic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChannelTopic</span>(<span class="string">&quot;nxb message test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;将消息监听器绑定到消息容器&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * 并进行容器的设置</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisMessageListenerContainer <span class="title function_">messageListenerContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RedisMessageListenerContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisMessageListenerContainer</span>();</span><br><span class="line">        container.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">// 此处可以更换订阅主题</span></span><br><span class="line">        container.addMessageListener(listener(), channelTopic());</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-消费者（sub）"><a href="#2-4-消费者（sub）" class="headerlink" title="2.4. 消费者（sub）"></a>2.4. 消费者（sub）</h3><p>这里需要实现<code>MessageListener</code>接口。目的是利用<code>onMessage</code>方法，监听<code>channel</code>中的消息队列，实现接受消息。</p><p>消费者的核心方法是<code>onMessage</code>，方法传入订阅到的消息，然后进行处理即可。</p><p>这里把redis的消费者方法和websocket进行了整合，redis消费者收到上游消息后，由websocket转发给对应用户，再转发给前端。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负责订阅redis发布的接受器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionListener</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, WebSocket&gt; webSockets = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ConnectionListener</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionListener</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ConnectionListener</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConnectionListener <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收到消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, <span class="type">byte</span>[] pattern)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        <span class="type">MessageVO</span> <span class="variable">messageVO</span> <span class="operator">=</span> JSON.parseObject((String)JSON.parse(message.toString()), MessageVO.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;received message: &quot;</span>+ messageVO);</span><br><span class="line">        sendMessage(messageVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addConnection</span><span class="params">(String userId,WebSocket webSocket)</span>&#123;</span><br><span class="line">        webSockets.put(userId,webSocket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containConnection</span><span class="params">(String userId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webSockets.containsKey(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeConnection</span><span class="params">(String userId)</span>&#123;</span><br><span class="line">        webSockets.remove(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">connectionCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webSockets.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(MessageVO message)</span>&#123;</span><br><span class="line">        <span class="comment">// 优化逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (containConnection(message.getUser()))&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> message.getUser();</span><br><span class="line">            webSockets.get(key).sendMessage(message);</span><br><span class="line">            System.out.println(message + <span class="string">&quot; has been sent to &quot;</span> + key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-生产者（pub）"><a href="#2-5-生产者（pub）" class="headerlink" title="2.5. 生产者（pub）"></a>2.5. 生产者（pub）</h3><p>指定要发布到的channel和要发布的消息。注意这里的channel由配置类进行管理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息发布者服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublishService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入自定义redisTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChannelTopic channelTopic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Publish.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message   the message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(Object message)</span> &#123;</span><br><span class="line">        redisUtil.convertAndSend(channelTopic.getTopic(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>redisUtil</code>封装了转发消息方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向通道发布消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">convertAndSend</span><span class="params">(String channel, Object message)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(channel)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redisTemplate.convertAndSend(channel, message);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息成功，channel：&#123;&#125;，message：&#123;&#125;&quot;</span>, channel, message);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;发送消息失败，channel：&#123;&#125;，message：&#123;&#125;&quot;</span>, channel, message);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><h3 id="3-1-测试类"><a href="#3-1-测试类" class="headerlink" title="3.1. 测试类"></a>3.1. 测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSubPubTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChannelTopic topic;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC</span> <span class="operator">=</span> <span class="string">&quot;TEST_TOPIC1&quot;</span>; <span class="comment">// 订阅主题</span></span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">        <span class="type">MessageVO</span> <span class="variable">messageVO</span> <span class="operator">=</span> MessageVO.builder()</span><br><span class="line">                .user(<span class="string">&quot;pengzna&quot;</span>)</span><br><span class="line">                .msg(<span class="string">&quot;hello world！&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        redisUtil.convertAndSend(topic.getTopic(), messageVO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-测试结果"><a href="#3-2-测试结果" class="headerlink" title="3.2. 测试结果"></a>3.2. 测试结果</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220726182800342.png" alt="image-20220726182800342"></p><hr><p><em>参考资料</em></p><ul><li><a href="https://www.runoob.com/redis/redis-pub-sub.html">Redis 发布订阅 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://www.cnblogs.com/kendoziyu/p/15802698.html">SpringBoot整合Redis实现发布订阅功能实践 - 极客子羽 - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/BBQ__ZXB/article/details/124980860">(26条消息) Spring boot整合Redis实现发布订阅（超详细）_BBQ__XB的博客-CSDN博客_springboot 发布订阅</a></li><li><a href="https://blog.csdn.net/Vector97/article/details/118407461?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-118407461-blog-124980860.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-118407461-blog-124980860.pc_relevant_default&utm_relevant_index=2">(26条消息) Springboot集成Redis实现发布订阅功能（Java Lettuce客户端）_iFence的博客-CSDN博客_lettuce 发布订阅</a></li><li><a href="https://blog.csdn.net/weixin_44874132/article/details/124192307">(26条消息) SpringBoot整合redis实现发布订阅模式_叶枫^_^的博客-CSDN博客_redis发布订阅 springboot</a></li><li>jfy同学代码</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> spring </tag>
            
            <tag> redis </tag>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript ·入门</title>
      <link href="/article/TypeScript%E5%85%A5%E9%97%A8/"/>
      <url>/article/TypeScript%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>参考资料：<a href="https://juejin.cn/post/6844904182843965453">https://juejin.cn/post/6844904182843965453</a></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172916652ec072e3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom: 33%;" /><hr><span id="more"></span><h2 id="1-TypeScript-简介"><a href="#1-TypeScript-简介" class="headerlink" title="1. TypeScript 简介"></a>1. TypeScript 简介</h2><h3 id="1-1-TypeScript-与-JavaScript-的区别"><a href="#1-1-TypeScript-与-JavaScript-的区别" class="headerlink" title="1.1 TypeScript 与 JavaScript 的区别"></a>1.1 TypeScript 与 JavaScript 的区别</h3><table><thead><tr><th>TypeScript</th><th>JavaScript</th></tr></thead><tbody><tr><td>JavaScript 的超集用于解决大型项目的代码复杂性</td><td>一种脚本语言，用于创建动态网页。</td></tr><tr><td>可以在编译期间发现并纠正错误</td><td>作为一种解释型语言，只能在运行时发现错误</td></tr><tr><td>强类型，支持静态和动态类型</td><td>弱类型，没有静态类型选项</td></tr><tr><td>最终被编译成 JavaScript 代码，使浏览器可以理解</td><td>可以直接在浏览器中使用</td></tr><tr><td>支持模块、泛型和接口</td><td>不支持模块，泛型或接口</td></tr><tr><td>支持 ES3，ES4，ES5 和 ES6 等</td><td>不支持编译其他 ES3，ES4，ES5 或 ES6 功能</td></tr><tr><td>社区的支持仍在增长，而且还不是很大</td><td>大量的社区支持以及大量文档和解决问题的支持</td></tr></tbody></table><h3 id="1-2-获取-TypeScript"><a href="#1-2-获取-TypeScript" class="headerlink" title="1.2 获取 TypeScript"></a>1.2 获取 TypeScript</h3><p>命令行的 TypeScript 编译器可以使用 Node.js 包来安装。</p><p><strong>1.安装 TypeScript</strong></p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>npm install -g typescript</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>2.编译 TypeScript 文件</strong></p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>tsc helloworld.ts</span><br><span class="line"><span class="comment"># helloworld.ts =&gt; helloworld.js</span></span><br></pre></td></tr></table></figure><h2 id="2-TypeScript-基础类型"><a href="#2-TypeScript-基础类型" class="headerlink" title="2. TypeScript 基础类型"></a>2. TypeScript 基础类型</h2><h3 id="2-1-Boolean-类型"><a href="#2-1-Boolean-类型" class="headerlink" title="2.1 Boolean 类型"></a>2.1 Boolean 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let isDone: <span class="attr">boolean</span> = <span class="literal">false</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">isDone</span> = <span class="literal">false</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-Number-类型"><a href="#2-2-Number-类型" class="headerlink" title="2.2 Number 类型"></a>2.2 Number 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let count: <span class="attr">number</span> = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">count</span> = <span class="number">10</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-String-类型"><a href="#2-3-String-类型" class="headerlink" title="2.3 String 类型"></a>2.3 String 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let name: <span class="attr">string</span> = <span class="string">&quot;Semliker&quot;</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">name</span> = <span class="string">&#x27;Semlinker&#x27;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-Array-类型"><a href="#2-4-Array-类型" class="headerlink" title="2.4 Array 类型"></a>2.4 Array 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let list: number<span class="section">[]</span> = <span class="section">[1, 2, 3]</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let list: Array&lt;number&gt; = <span class="section">[1, 2, 3]</span><span class="comment">; // Array&lt;number&gt;泛型语法</span></span><br><span class="line">// ES5：var <span class="attr">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-5-Enum-类型"><a href="#2-5-Enum-类型" class="headerlink" title="2.5 Enum 类型"></a>2.5 Enum 类型</h3><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。</p><h4 id="2-5-1-数字枚举"><a href="#2-5-1-数字枚举" class="headerlink" title="2.5.1.数字枚举"></a><strong>2.5.1.数字枚举</strong></h4><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  NORTH,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dir: <span class="attr">Direction</span> = Direction.NORTH<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。上面的枚举示例代码经过编译后会生成以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;NORTH&#x27;</span>] = <span class="number">0</span>)] = <span class="string">&#x27;NORTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;SOUTH&#x27;</span>] = <span class="number">1</span>)] = <span class="string">&#x27;SOUTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;EAST&#x27;</span>] = <span class="number">2</span>)] = <span class="string">&#x27;EAST&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;WEST&#x27;</span>] = <span class="number">3</span>)] = <span class="string">&#x27;WEST&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;))</span><br><span class="line"><span class="keyword">var</span> dir = <span class="title class_">Direction</span>.<span class="property">NORTH</span></span><br></pre></td></tr></table></figure><p>当然我们也可以设置 NORTH 的初始值，比如：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  <span class="attr">NORTH</span> = <span class="number">3</span>,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-字符串枚举"><a href="#2-5-2-字符串枚举" class="headerlink" title="2.5.2.字符串枚举"></a>2.5.<strong>2.字符串枚举</strong></h4><p>在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  <span class="attr">NORTH</span> = <span class="string">&quot;NORTH&quot;</span>,</span><br><span class="line">  <span class="attr">SOUTH</span> = <span class="string">&quot;SOUTH&quot;</span>,</span><br><span class="line">  <span class="attr">EAST</span> = <span class="string">&quot;EAST&quot;</span>,</span><br><span class="line">  <span class="attr">WEST</span> = <span class="string">&quot;WEST&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码对于的 ES5 代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;NORTH&#x27;</span>] = <span class="string">&#x27;NORTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;SOUTH&#x27;</span>] = <span class="string">&#x27;SOUTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;EAST&#x27;</span>] = <span class="string">&#x27;EAST&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;WEST&#x27;</span>] = <span class="string">&#x27;WEST&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2-5-3-异构枚举"><a href="#2-5-3-异构枚举" class="headerlink" title="2.5.3.异构枚举"></a>2.5.<strong>3.异构枚举</strong></h4><p>异构枚举的成员值是数字和字符串的混合：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Enum &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">  <span class="attr">C</span> = <span class="string">&quot;C&quot;</span>,</span><br><span class="line">  <span class="attr">D</span> = <span class="string">&quot;D&quot;</span>,</span><br><span class="line">  <span class="attr">E</span> = <span class="number">8</span>,</span><br><span class="line">  F,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码对于的 ES5 代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Enum</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">Enum</span>) &#123;</span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;A&#x27;</span>] = <span class="number">0</span>)] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;B&#x27;</span>] = <span class="number">1</span>)] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[<span class="string">&#x27;C&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[<span class="string">&#x27;D&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;E&#x27;</span>] = <span class="number">8</span>)] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;F&#x27;</span>] = <span class="number">9</span>)] = <span class="string">&#x27;F&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Enum</span> || (<span class="title class_">Enum</span> = &#123;&#125;))</span><br></pre></td></tr></table></figure><p>通过观察上述生成的 ES5 代码，我们可以发现数字枚举相对字符串枚举多了 “反向映射”：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(Enum.A) <span class="comment">//输出：0</span></span><br><span class="line">console.<span class="built_in">log</span>(Enum[<span class="number">0</span>]) <span class="comment">// 输出：A</span></span><br></pre></td></tr></table></figure><h3 id="2-6-Any-类型"><a href="#2-6-Any-类型" class="headerlink" title="2.6 Any 类型"></a>2.6 Any 类型</h3><p>在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的<strong>顶级类型</strong>（也被称作全局超级类型）。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let notSure: <span class="attr">any</span> = <span class="number">666</span><span class="comment">;</span></span><br><span class="line"><span class="attr">notSure</span> = <span class="string">&quot;Semlinker&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">notSure</span> = <span class="literal">false</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p><code>any</code> 类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由：TypeScript 允许我们对 <code>any</code> 类型的值执行任何操作，而无需事先执行任何形式的检查。比如：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">let value: any;</span><br><span class="line"></span><br><span class="line">value<span class="selector-class">.foo</span><span class="selector-class">.bar</span>; <span class="comment">// OK</span></span><br><span class="line">value<span class="selector-class">.trim</span>(); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">value</span>(); <span class="comment">// OK</span></span><br><span class="line">new <span class="built_in">value</span>(); <span class="comment">// OK</span></span><br><span class="line">value<span class="selector-attr">[0]</span><span class="selector-attr">[1]</span>; <span class="comment">// OK</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在许多场景下，这太宽松了。使用 <code>any</code> 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 <code>any</code> 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 <code>any</code> 带来的问题，TypeScript 3.0 引入了 <code>unknown</code> 类型。</p><h3 id="2-7-Unknown-类型"><a href="#2-7-Unknown-类型" class="headerlink" title="2.7 Unknown 类型"></a>2.7 Unknown 类型</h3><p>就像所有类型都可以赋值给 <code>any</code>，所有类型也都可以赋值给 <code>unknown</code>。这使得 <code>unknown</code> 成为 TypeScript 类型系统的另一种顶级类型（另一种是 <code>any</code>）。下面我们来看一下 <code>unknown</code> 类型的使用示例：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let value: unknown<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">value</span> = <span class="literal">true</span><span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = <span class="number">42</span><span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = <span class="string">&quot;Hello World&quot;</span><span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = []<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = &#123;&#125;<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = Math.random<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = null<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = undefined<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = new TypeError()<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = Symbol(<span class="string">&quot;type&quot;</span>)<span class="comment">; // OK</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对 <code>value</code> 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 <code>unknown</code> 的值赋值给其他类型的变量时会发生什么？</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let value: unknown<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let value1: <span class="attr">unknown</span> = value<span class="comment">; // OK</span></span><br><span class="line">let value2: <span class="attr">any</span> = value<span class="comment">; // OK</span></span><br><span class="line">let value3: <span class="attr">boolean</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value4: <span class="attr">number</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value5: <span class="attr">string</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value6: <span class="attr">object</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value7: any<span class="section">[]</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value8: <span class="attr">Function</span> = value<span class="comment">; // Error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>unknown</code> 类型只能被赋值给 <code>any</code> 类型和 <code>unknown</code> 类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 <code>unknown</code> 类型的值。毕竟我们不知道变量 <code>value</code> 中存储了什么类型的值。</p><p>现在让我们看看当我们尝试对类型为 <code>unknown</code> 的值执行操作时会发生什么。以下是我们在之前 <code>any</code> 章节看过的相同操作：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">let value: unknown;</span><br><span class="line"></span><br><span class="line">value<span class="selector-class">.foo</span><span class="selector-class">.bar</span>; <span class="comment">// Error</span></span><br><span class="line">value<span class="selector-class">.trim</span>(); <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">value</span>(); <span class="comment">// Error</span></span><br><span class="line">new <span class="built_in">value</span>(); <span class="comment">// Error</span></span><br><span class="line">value<span class="selector-attr">[0]</span><span class="selector-attr">[1]</span>; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>将 <code>value</code> 变量类型设置为 <code>unknown</code> 后，这些操作都不再被认为是类型正确的。通过将 <code>any</code> 类型改变为 <code>unknown</code> 类型，我们已将允许所有更改的默认设置，更改为<strong>禁止任何更改</strong>。</p><h3 id="2-8-Tuple-类型"><a href="#2-8-Tuple-类型" class="headerlink" title="2.8 Tuple 类型"></a>2.8 Tuple 类型</h3><p>众所周知，数组一般由同种类型的值组成，<strong>但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组</strong>。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。</p><p>元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值。为了更直观地理解元组的概念，我们来看一个具体的例子：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let tupleType: <span class="section">[string, boolean]</span><span class="comment">;</span></span><br><span class="line"><span class="attr">tupleType</span> = [<span class="string">&quot;Semlinker&quot;</span>, <span class="literal">true</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>在上面代码中，我们定义了一个名为 <code>tupleType</code> 的变量，它的类型是一个类型数组 <code>[string, boolean]</code>，然后我们按照正确的类型依次初始化 tupleType 变量。与数组一样，我们可以通过下标来访问元组中的元素：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(tupleType[<span class="number">0</span>]); <span class="comment">// Semlinker</span></span><br><span class="line">console.<span class="built_in">log</span>(tupleType[<span class="number">1</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在元组初始化的时候，如果出现类型不匹配的话，比如：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">tupleType</span> = [<span class="literal">true</span>, <span class="string">&quot;Semlinker&quot;</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>此时，TypeScript 编译器会提示以下错误信息：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>]: <span class="type">Type</span> <span class="string">&#x27;true&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> assignable to <span class="built_in">type</span> <span class="string">&#x27;string&#x27;</span>.</span><br><span class="line">[<span class="number">1</span>]: <span class="type">Type</span> <span class="string">&#x27;string&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> assignable to <span class="built_in">type</span> <span class="string">&#x27;boolean&#x27;</span>.</span><br></pre></td></tr></table></figure><p>很明显是因为类型不匹配导致的。在元组初始化的时候，我们还必须提供<strong>每个属性的值</strong>，不然也会出现错误，比如：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">tupleType</span> = [<span class="string">&quot;Semlinker&quot;</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>此时，TypeScript 编译器会提示以下错误信息：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Property <span class="string">&#x27;1&#x27;</span> <span class="keyword">is</span> missing <span class="keyword">in</span> <span class="built_in">type</span> <span class="string">&#x27;[string]&#x27;</span> but required <span class="keyword">in</span> <span class="built_in">type</span> <span class="string">&#x27;[string, boolean]&#x27;</span>.</span><br></pre></td></tr></table></figure><h3 id="2-9-Void-类型"><a href="#2-9-Void-类型" class="headerlink" title="2.9 Void 类型"></a>2.9 Void 类型</h3><p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数返回值为void</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is my warning message&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码编译生成的 ES5 代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is my warning message&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，声明一个 void 类型的变量没有什么作用，因为它的值只能为 <code>undefined</code> 或 <code>null</code>：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let unusable: <span class="attr">void</span> = undefined<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-10-Null-和-Undefined-类型"><a href="#2-10-Null-和-Undefined-类型" class="headerlink" title="2.10 Null 和 Undefined 类型"></a>2.10 Null 和 Undefined 类型</h3><p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者有各自的类型分别为 <code>undefined</code> 和 <code>null</code>。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let u: <span class="attr">undefined</span> = undefined<span class="comment">;</span></span><br><span class="line">let n: <span class="attr">null</span> = null<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。<strong>然而，如果你指定了<code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自的类型。</strong></p><h3 id="2-11-Never-类型"><a href="#2-11-Never-类型" class="headerlink" title="2.11 Never 类型"></a>2.11 Never 类型</h3><p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如，<code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">controlFlowAnalysisWithNever</span>(<span class="params">foo: Foo</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里 foo 被收窄为 string 类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里 foo 被收窄为 number 类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// foo 在这里是 never</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">check</span>: <span class="built_in">never</span> = foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然而他忘记同时修改 <code>controlFlowAnalysisWithNever</code> 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 <code>boolean</code> 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保</p><p><code>controlFlowAnalysisWithNever</code> 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：<strong>使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。</strong></p><h2 id="3-TypeScript-断言"><a href="#3-TypeScript-断言" class="headerlink" title="3. TypeScript 断言"></a>3. TypeScript 断言</h2><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p><p>类型断言有两种形式：</p><h3 id="3-1-“尖括号”-语法"><a href="#3-1-“尖括号”-语法" class="headerlink" title="3.1. “尖括号” 语法"></a>3.1. “尖括号” 语法</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let someValue: <span class="attr">any</span> = <span class="string">&quot;this is a string&quot;</span><span class="comment">;</span></span><br><span class="line">let strLength: <span class="attr">number</span> = (&lt;string&gt;someValue).length<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-as-语法"><a href="#3-2-as-语法" class="headerlink" title="3.2. as 语法"></a>3.2. as 语法</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let someValue: <span class="attr">any</span> = <span class="string">&quot;this is a string&quot;</span><span class="comment">;</span></span><br><span class="line">let strLength: <span class="attr">number</span> = (someValue as string).length<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="4-类型守卫"><a href="#4-类型守卫" class="headerlink" title="4. 类型守卫"></a>4. 类型守卫</h2><blockquote><p>A type guard is some expression that performs a runtime check that guarantees the type in some scope. —— TypeScript 官方文档</p></blockquote><p>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。目前主要有四种的方式来实现类型保护：</p><h3 id="4-1-in-关键字"><a href="#4-1-in-关键字" class="headerlink" title="4.1 in 关键字"></a>4.1 in 关键字</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Admin</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">privileges</span>: <span class="built_in">string</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">startDate</span>: <span class="title class_">Date</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnknownEmployee</span> = <span class="title class_">Employee</span> | <span class="title class_">Admin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printEmployeeInformation</span>(<span class="params">emp: UnknownEmployee</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Name: &#x27;</span> + emp.<span class="property">name</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;privileges&#x27;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Privileges: &#x27;</span> + emp.<span class="property">privileges</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;startDate&#x27;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Start Date: &#x27;</span> + emp.<span class="property">startDate</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-typeof-关键字"><a href="#4-2-typeof-关键字" class="headerlink" title="4.2 typeof 关键字"></a>4.2 typeof 关键字</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>(padding + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>) + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typeof</code> 类型保护只支持两种形式：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== typename</code>，<code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>， <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</p><h3 id="4-3-instanceof-关键字"><a href="#4-3-instanceof-关键字" class="headerlink" title="4.3 instanceof 关键字"></a>4.3 instanceof 关键字</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Padder</span> &#123;</span><br><span class="line">  <span class="title function_">getPaddingString</span>(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceRepeatingPadder</span> <span class="keyword">implements</span> <span class="title class_">Padder</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">getPaddingString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>(<span class="variable language_">this</span>.<span class="property">numSpaces</span> + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringPadder</span> <span class="keyword">implements</span> <span class="title class_">Padder</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">getPaddingString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">padder</span>: <span class="title class_">Padder</span> = <span class="keyword">new</span> <span class="title class_">SpaceRepeatingPadder</span>(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> <span class="title class_">SpaceRepeatingPadder</span>) &#123;</span><br><span class="line">  <span class="comment">// padder的类型收窄为 &#x27;SpaceRepeatingPadder&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-自定义类型保护的类型谓词"><a href="#4-4-自定义类型保护的类型谓词" class="headerlink" title="4.4 自定义类型保护的类型谓词"></a>4.4 自定义类型保护的类型谓词</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): x is <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">x: <span class="built_in">any</span></span>): x is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-联合类型和类型别名"><a href="#5-联合类型和类型别名" class="headerlink" title="5. 联合类型和类型别名"></a>5. 联合类型和类型别名</h2><h3 id="5-1-联合类型"><a href="#5-1-联合类型" class="headerlink" title="5.1 联合类型"></a>5.1 联合类型</h3><p>联合类型通常与 <code>null</code> 或 <code>undefined</code> 一起使用：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sayHello</span> = (<span class="params">name: <span class="built_in">string</span> | <span class="literal">undefined</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，这里 <code>name</code> 的类型是 <code>string | undefined</code> 意味着可以将 <code>string</code> 或 <code>undefined</code> 的值传递给<code>sayHello</code> 函数。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sayHello</span>(&quot;Semlinker&quot;);</span><br><span class="line"><span class="built_in">sayHello</span>(undefined);</span><br></pre></td></tr></table></figure><p>通过这个示例，你可以凭直觉知道类型 A 和类型 B 联合后的类型是同时接受 A 和 B 值的类型。</p><h3 id="5-2-可辨识联合"><a href="#5-2-可辨识联合" class="headerlink" title="5.2 可辨识联合"></a>5.2 可辨识联合</h3><p>TypeScript 可辨识联合（Discriminated Unions）类型，也称为代数数据类型或标签联合类型。<strong>它包含 3 个要点：可辨识、联合类型和类型守卫。</strong></p><p>这种类型的本质是结合联合类型和字面量类型的一种类型保护方法。<strong>如果一个类型是多个类型的联合类型，且多个类型含有一个公共属性，那么就可以利用这个公共属性，来创建不同的类型保护区块。</strong></p><p><strong>1.可辨识</strong></p><p>可辨识要求联合类型中的每个元素都含有一个单例类型属性，比如：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">enum CarTransmission &#123;</span><br><span class="line">  Automatic = <span class="number">200</span>,</span><br><span class="line">  Manual = <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Motorcycle &#123;</span><br><span class="line">  vType: <span class="string">&quot;motorcycle&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  make: number; <span class="comment">// year</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Car &#123;</span><br><span class="line">  vType: <span class="string">&quot;car&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  transmission: CarTransmission</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Truck &#123;</span><br><span class="line">  vType: <span class="string">&quot;truck&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  capacity: number; <span class="comment">// in tons</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们分别定义了 <code>Motorcycle</code>、 <code>Car</code> 和 <code>Truck</code> 三个接口，在这些接口中都包含一个 <code>vType</code> 属性，该属性被称为可辨识的属性，而其它的属性只跟特性的接口相关。</p><p><strong>2.联合类型</strong></p><p>基于前面定义了三个接口，我们可以创建一个 <code>Vehicle</code> 联合类型：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">type <span class="attr">Vehicle</span> = Motorcycle | Car | Truck<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>现在我们就可以开始使用 <code>Vehicle</code> 联合类型，对于 <code>Vehicle</code> 类型的变量，它可以表示不同类型的车辆。</p><p><strong>3.类型守卫</strong></p><p>下面我们来定义一个 <code>evaluatePrice</code> 方法，该方法用于根据车辆的类型、容量和评估因子来计算价格，具体实现如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">const <span class="attr">EVALUATION_FACTOR</span> = Math.PI<span class="comment">;</span></span><br><span class="line">function evaluatePrice(vehicle: Vehicle) &#123;</span><br><span class="line">  return vehicle.capacity * EVALUATION_FACTOR<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myTruck: <span class="attr">Truck</span> = &#123; vType: <span class="string">&quot;truck&quot;</span>, capacity: <span class="number">9.5</span> &#125;<span class="comment">;</span></span><br><span class="line">evaluatePrice(myTruck)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>对于以上代码，TypeScript 编译器将会提示以下错误信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Property <span class="string">&#x27;capacity&#x27;</span> does not exist on <span class="built_in">type</span> <span class="string">&#x27;Vehicle&#x27;</span>.</span><br><span class="line">Property <span class="string">&#x27;capacity&#x27;</span> does not exist on <span class="built_in">type</span> <span class="string">&#x27;Motorcycle&#x27;</span>.</span><br></pre></td></tr></table></figure><p>原因是在 Motorcycle 接口中，并不存在 <code>capacity</code> 属性，而对于 Car 接口来说，它也不存在 <code>capacity</code> 属性。那么，现在我们应该如何解决以上问题呢？这时，我们可以使用类型守卫。下面我们来重构一下前面定义的 <code>evaluatePrice</code> 方法，重构后的代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">evaluatePrice</span>(<span class="params">vehicle: Vehicle</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (vehicle.<span class="property">vType</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;car&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.<span class="property">transmission</span> * <span class="variable constant_">EVALUATION_FACTOR</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;truck&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.<span class="property">capacity</span> * <span class="variable constant_">EVALUATION_FACTOR</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;motorcycle&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.<span class="property">make</span> * <span class="variable constant_">EVALUATION_FACTOR</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们使用 <code>switch</code> 和 <code>case</code> 运算符来实现类型守卫，从而确保在 <code>evaluatePrice</code> 方法中，我们可以安全地访问 <code>vehicle</code> 对象中的所包含的属性，来正确的计算该车辆类型所对应的价格。</p><h3 id="5-3-类型别名"><a href="#5-3-类型别名" class="headerlink" title="5.3 类型别名"></a>5.3 类型别名</h3><p>类型别名用来给一个类型起个新名字。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">type <span class="attr">Message</span> = string | string[]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">greet</span> = (message: Message) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="6-交叉类型"><a href="#6-交叉类型" class="headerlink" title="6. 交叉类型"></a>6. 交叉类型</h2><p>TypeScript 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它<strong>包含了所需的所有类型的特性</strong>。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IWorker</span> &#123;</span><br><span class="line">  <span class="attr">companyId</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IStaff</span> = <span class="title class_">IPerson</span> &amp; <span class="title class_">IWorker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">staff</span>: <span class="title class_">IStaff</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;E1006&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">33</span>,</span><br><span class="line">  <span class="attr">companyId</span>: <span class="string">&#x27;EFT&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(staff)</span><br></pre></td></tr></table></figure><p>在上面示例中，我们首先为 IPerson 和 IWorker 类型定义了不同的成员，然后通过 <code>&amp;</code> 运算符定义了 IStaff 交叉类型，所以该类型同时拥有 IPerson 和 IWorker 这两种类型的成员。</p><h2 id="7-TypeScript-函数"><a href="#7-TypeScript-函数" class="headerlink" title="7. TypeScript 函数"></a>7. TypeScript 函数</h2><h3 id="7-1-TypeScript-函数与-JavaScript-函数的区别"><a href="#7-1-TypeScript-函数与-JavaScript-函数的区别" class="headerlink" title="7.1 TypeScript 函数与 JavaScript 函数的区别"></a>7.1 TypeScript 函数与 JavaScript 函数的区别</h3><table><thead><tr><th>TypeScript</th><th>JavaScript</th></tr></thead><tbody><tr><td>含有类型</td><td>无类型</td></tr><tr><td>箭头函数</td><td>箭头函数（ES2015）</td></tr><tr><td>函数类型</td><td>无函数类型</td></tr><tr><td>必填和可选参数</td><td>所有参数都是可选的</td></tr><tr><td>默认参数</td><td>默认参数</td></tr><tr><td>剩余参数</td><td>剩余参数</td></tr><tr><td>函数重载</td><td>无函数重载</td></tr></tbody></table><h3 id="7-2-箭头函数"><a href="#7-2-箭头函数" class="headerlink" title="7.2 箭头函数"></a>7.2 箭头函数</h3><p><strong>1.常见语法</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reading&#x27;</span>));</span><br><span class="line"></span><br><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function"><span class="params">title</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(title));</span><br><span class="line"></span><br><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">title, idx, arr</span>) =&gt;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(idx + <span class="string">&#x27;-&#x27;</span> + title);</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">title, idx, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(idx + <span class="string">&#x27;-&#x27;</span> + title);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>2.使用示例</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未使用箭头函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span></span><br><span class="line">  self.<span class="property">publishDate</span> = <span class="number">2016</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(self.<span class="property">publishDate</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">publishDate</span> = <span class="number">2016</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">publishDate</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-参数类型和返回类型"><a href="#7-3-参数类型和返回类型" class="headerlink" title="7.3 参数类型和返回类型"></a>7.3 参数类型和返回类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-函数类型"><a href="#7-4-函数类型" class="headerlink" title="7.4 函数类型"></a>7.4 函数类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数类型，然后再赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">IdGenerator</span>: <span class="function">(<span class="params">chars: <span class="built_in">string</span>, nums: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">IdGenerator</span> = createUserId</span><br></pre></td></tr></table></figure><h3 id="7-5-可选参数及默认参数"><a href="#7-5-可选参数及默认参数" class="headerlink" title="7.5 可选参数及默认参数"></a>7.5 可选参数及默认参数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可选参数：加个问号即可</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span>, age?: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name: <span class="built_in">string</span> = <span class="string">&#x27;Semlinker&#x27;</span>,</span></span><br><span class="line"><span class="params">  id: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  age?: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在声明函数时，可以通过 <code>?</code> 号来定义可选参数，比如 <code>age?: number</code> 这种形式。在实际使用时，需要注意的是可选参数要放在普通参数的后面，不然会导致编译错误。</p><h3 id="7-6-剩余参数"><a href="#7-6-剩余参数" class="headerlink" title="7.6 剩余参数"></a>7.6 剩余参数</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加...表示剩余参数</span></span><br><span class="line">function <span class="built_in">push</span>(array, ...items) &#123;</span><br><span class="line">  items<span class="selector-class">.forEach</span>(function (item) &#123;</span><br><span class="line">    array<span class="selector-class">.push</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="selector-tag">a</span> = <span class="selector-attr">[]</span>;</span><br><span class="line"><span class="built_in">push</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="7-7-函数重载"><a href="#7-7-函数重载" class="headerlink" title="7.7 函数重载"></a>7.7 函数重载</h3><p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: Combinable, b: Combinable</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">toString</span>() + b.<span class="title function_">toString</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们为 add 函数提供了多个函数类型定义，从而实现函数的重载。之后，可恶的错误消息又消失了，因为这时 result 变量的类型是 <code>string</code> 类型。在 TypeScript 中除了可以重载普通函数之外，我们还可以重载类中的成员方法。</p><p>方法重载是指在同一个类中方法同名，参数不同（参数类型不同、参数个数不同或参数个数相同时参数的先后顺序不同），调用时根据实参的形式，选择与它匹配的方法执行操作的一种技术。所以类中成员方法满足重载的条件是：在同一个类中，方法名相同且参数列表不同。下面我们来举一个成员方法重载的例子：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: number, <span class="attr">b</span>: number): number;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: <span class="keyword">string</span>, <span class="attr">b</span>: <span class="keyword">string</span>): <span class="keyword">string</span>;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: <span class="keyword">string</span>, <span class="attr">b</span>: number): <span class="keyword">string</span>;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: number, <span class="attr">b</span>: <span class="keyword">string</span>): <span class="keyword">string</span>;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: Combinable, <span class="attr">b</span>: Combinable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof a === <span class="string">&quot;string&quot;</span> || typeof b === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.<span class="title function_ invoke__">toString</span>() + b.<span class="title function_ invoke__">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">calculator</span> = <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">result</span> = calculator.<span class="title function_ invoke__">add</span>(<span class="string">&quot;Semlinker&quot;</span>, <span class="string">&quot; Kakuqo&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里需要注意的是，当 TypeScript 编译器处理函数重载时，它会查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。另外在 Calculator 类中，<code>add(a: Combinable, b: Combinable)&#123; &#125;</code> 并不是重载列表的一部分，因此对于 add 成员方法来说，我们只定义了四个重载方法。</p><h2 id="8-TypeScript-数组"><a href="#8-TypeScript-数组" class="headerlink" title="8. TypeScript 数组"></a>8. TypeScript 数组</h2><h3 id="8-1-数组解构"><a href="#8-1-数组解构" class="headerlink" title="8.1 数组解构"></a>8.1 数组解构</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> five_array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">;[x, y, z] = five_array</span><br></pre></td></tr></table></figure><h3 id="8-2-数组展开运算符"><a href="#8-2-数组展开运算符" class="headerlink" title="8.2 数组展开运算符"></a>8.2 数组展开运算符</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let <span class="attr">two_array</span> = [<span class="number">0</span>, <span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">let <span class="attr">five_array</span> = [...two_array, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="8-3-数组遍历"><a href="#8-3-数组遍历" class="headerlink" title="8.3 数组遍历"></a>8.3 数组遍历</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">colors</span>: <span class="built_in">string</span>[] = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> colors) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-TypeScript-对象"><a href="#9-TypeScript-对象" class="headerlink" title="9. TypeScript 对象"></a>9. TypeScript 对象</h2><h3 id="9-1-对象解构"><a href="#9-1-对象解构" class="headerlink" title="9.1 对象解构"></a>9.1 对象解构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Semlinker&quot;</span>,</span><br><span class="line">  gender: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; name, gender &#125; = person;</span><br></pre></td></tr></table></figure><h3 id="9-2-对象展开运算符"><a href="#9-2-对象展开运算符" class="headerlink" title="9.2 对象展开运算符"></a>9.2 对象展开运算符</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Semlinker&quot;</span>,</span><br><span class="line">  gender: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line">  address: <span class="string">&quot;Xiamen&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装对象</span></span><br><span class="line"><span class="keyword">let</span> personWithAge = &#123; ...person, age: <span class="number">33</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取除了某些项外的其它项</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, ...rest &#125; = person;</span><br></pre></td></tr></table></figure><h2 id="10-TypeScript-接口"><a href="#10-TypeScript-接口" class="headerlink" title="10. TypeScript 接口"></a>10. TypeScript 接口</h2><p>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。</p><p>TypeScript 中的接口是一个非常灵活的概念，除了可用于<a href="https://link.juejin.cn/?target=https://ts.xcatliu.com/advanced/class-and-interfaces.html%23%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状（Shape）」进行描述。</p><h3 id="10-1-对象的形状"><a href="#10-1-对象的形状" class="headerlink" title="10.1 对象的形状"></a>10.1 对象的形状</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let Semlinker: Person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Semlinker&quot;</span>,</span><br><span class="line">  age: <span class="number">33</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-2-可选-只读属性"><a href="#10-2-可选-只读属性" class="headerlink" title="10.2 可选 | 只读属性"></a>10.2 可选 | 只读属性</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只读属性用于限制只能在<strong>对象刚刚创建的时候修改其值</strong>。此外 TypeScript 还提供了 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let a: number<span class="section">[]</span> = <span class="section">[1, 2, 3, 4]</span><span class="comment">;</span></span><br><span class="line">let ro: ReadonlyArray&lt;number&gt; = a<span class="comment">;</span></span><br><span class="line">ro<span class="section">[0]</span> = 12<span class="comment">; // error!</span></span><br><span class="line">ro.push(5)<span class="comment">; // error!</span></span><br><span class="line"><span class="attr">ro.length</span> = <span class="number">100</span><span class="comment">; // error!</span></span><br><span class="line"><span class="attr">a</span> = ro<span class="comment">; // error!</span></span><br></pre></td></tr></table></figure><h2 id="11-TypeScript-类"><a href="#11-TypeScript-类" class="headerlink" title="11. TypeScript 类"></a>11. TypeScript 类</h2><h3 id="11-1-类的属性与方法"><a href="#11-1-类的属性与方法" class="headerlink" title="11.1 类的属性与方法"></a>11.1 类的属性与方法</h3><p>在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。</p><p>在 TypeScript 中，我们可以通过 <code>Class</code> 关键字来定义一个类：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="keyword">static</span> <span class="attr">cname</span>: <span class="built_in">string</span> = <span class="string">&#x27;Greeter&#x27;</span></span><br><span class="line">  <span class="comment">// 成员属性</span></span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数 - 执行初始化操作</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getClassName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Class name is Greeter&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成员方法</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那么成员属性与静态属性，成员方法与静态方法有什么区别呢？这里无需过多解释，我们直接看一下以下编译生成的 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Greeter</span> = <span class="comment">/** <span class="doctag">@class</span> */</span> (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 构造函数 - 执行初始化操作</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Greeter</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="title class_">Greeter</span>.<span class="property">getClassName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Class name is Greeter&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 成员方法</span></span><br><span class="line">  <span class="title class_">Greeter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="title class_">Greeter</span>.<span class="property">cname</span> = <span class="string">&#x27;Greeter&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Greeter</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">var</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="11-2-访问器"><a href="#11-2-访问器" class="headerlink" title="11.2 访问器"></a>11.2 访问器</h3><p>在 TypeScript 中，我们可以通过 <code>getter</code> 和 <code>setter</code> 方法来实现数据的封装和有效性校验，防止出现异常数据。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">&#x27;Hello TypeScript&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_fullName</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_fullName</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">newName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">&#x27;Hello TypeScript&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_fullName</span> = newName</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error: Unauthorized update of employee!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>()</span><br><span class="line">employee.<span class="property">fullName</span> = <span class="string">&#x27;Semlinker&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (employee.<span class="property">fullName</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(employee.<span class="property">fullName</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-类的继承"><a href="#11-3-类的继承" class="headerlink" title="11.3 类的继承"></a>11.3 类的继承</h3><p>继承 (Inheritance) 是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。</p><p>继承是一种 <a href="https://link.juejin.cn/?target=https://zh.wikipedia.org/wiki/Is-a">is-a </a>关系：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172916651d29ba48~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>在 TypeScript 中，我们可以通过 <code>extends</code> 关键字来实现继承：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = theName</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snake</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distanceInMeters = <span class="number">5</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Slithering...&#x27;</span>)</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">move</span>(distanceInMeters)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> <span class="title class_">Snake</span>(<span class="string">&#x27;Sammy the Python&#x27;</span>)</span><br><span class="line">sam.<span class="title function_">move</span>()</span><br></pre></td></tr></table></figure><h3 id="11-4-ECMAScript-私有字段"><a href="#11-4-ECMAScript-私有字段" class="headerlink" title="11.4 ECMAScript 私有字段"></a>11.4 ECMAScript 私有字段</h3><p>在 TypeScript 3.8 版本就开始支持<strong>ECMAScript 私有字段</strong>，使用方式如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  #<span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.#name&#125;</span>!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> semlinker = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Semlinker&#x27;</span>)</span><br><span class="line"></span><br><span class="line">semlinker.#name</span><br><span class="line"><span class="comment">//     ~~~~~</span></span><br><span class="line"><span class="comment">// Property &#x27;#name&#x27; is not accessible outside class &#x27;Person&#x27;</span></span><br><span class="line"><span class="comment">// because it has a private identifier.</span></span><br></pre></td></tr></table></figure><p>与常规属性（甚至使用 <code>private</code> 修饰符声明的属性）不同，私有字段要牢记以下规则：</p><ul><li>私有字段以 <code>#</code> 字符开头，有时我们称之为私有名称；</li><li>每个私有字段名称都唯一地限定于其包含的类；</li><li>不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；</li><li>私有字段不能在包含的类之外访问，甚至不能被检测到。</li></ul><h2 id="12-TypeScript-泛型"><a href="#12-TypeScript-泛型" class="headerlink" title="12. TypeScript 泛型"></a>12. TypeScript 泛型</h2><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p><p><strong>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</strong></p><p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p><p>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p><h3 id="12-1-泛型接口"><a href="#12-1-泛型接口" class="headerlink" title="12.1 泛型接口"></a>12.1 泛型接口</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">interface GenericIdentityFn<span class="operator">&lt;</span><span class="built_in">T</span><span class="operator">&gt;</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">(</span>arg<span class="operator">:</span> <span class="built_in">T</span><span class="punctuation">)</span><span class="operator">:</span> <span class="built_in">T</span>;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="12-2-泛型类"><a href="#12-2-泛型类" class="headerlink" title="12.2 泛型类"></a>12.2 泛型类</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">  zeroValue: T<span class="comment">;</span></span><br><span class="line">  add: (x: T, y: T) =&gt; T<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="attr">myGenericNumber</span> = new GenericNumber&lt;number&gt;()<span class="comment">;</span></span><br><span class="line"><span class="attr">myGenericNumber.zeroValue</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="attr">myGenericNumber.add</span> = function (x, y) &#123;</span><br><span class="line">  return x + y<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="12-3-泛型变量"><a href="#12-3-泛型变量" class="headerlink" title="12.3 泛型变量"></a>12.3 泛型变量</h3><p>对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：</p><ul><li>T（Type）：表示一个 TypeScript 类型</li><li>K（Key）：表示对象中的键类型</li><li>V（Value）：表示对象中的值类型</li><li>E（Element）：表示元素类型</li></ul><h3 id="12-4-泛型工具类型"><a href="#12-4-泛型工具类型" class="headerlink" title="12.4 泛型工具类型"></a>12.4 泛型工具类型</h3><p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍 Partial 工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。</p><h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a><strong>1.typeof</strong></h4><p>在 TypeScript 中，<code>typeof</code> 操作符可以用来获取一个变量声明或对象的类型。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">sem</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;semlinker&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sem</span> = <span class="keyword">typeof</span> sem <span class="comment">// -&gt; Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toArray</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [x]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Func</span> = <span class="keyword">typeof</span> toArray <span class="comment">// -&gt; (x: number) =&gt; number[]</span></span><br></pre></td></tr></table></figure><h4 id="2-keyof"><a href="#2-keyof" class="headerlink" title="2.keyof"></a><strong>2.keyof</strong></h4><p><code>keyof</code> 操作符可以用来一个对象中的所有 key 值：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> K1 = keyof Person; // <span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="built_in">type</span> K2 = keyof Person[]; // <span class="string">&quot;length&quot;</span> | <span class="string">&quot;toString&quot;</span> | <span class="string">&quot;pop&quot;</span> | <span class="string">&quot;push&quot;</span> | <span class="string">&quot;concat&quot;</span> | <span class="string">&quot;join&quot;</span></span><br><span class="line"><span class="built_in">type</span> K3 = keyof &#123; [x: <span class="built_in">string</span>]: Person &#125;;  // <span class="built_in">string</span> | number</span><br></pre></td></tr></table></figure><h4 id="3-in"><a href="#3-in" class="headerlink" title="3.in"></a><strong>3.in</strong></h4><p><code>in</code> 用来遍历枚举类型：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Keys = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Obj =  &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: <span class="built_in">any</span></span><br><span class="line">&#125; // -&gt; &#123; a: <span class="built_in">any</span>, b: <span class="built_in">any</span>, c: <span class="built_in">any</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="4-infer"><a href="#4-infer" class="headerlink" title="4.infer"></a><strong>4.infer</strong></h4><p>在条件类型语句中，可以用 <code>infer</code> 声明一个类型变量并且对它进行使用。</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">type ReturnType<span class="operator">&lt;</span><span class="built_in">T</span><span class="operator">&gt;</span> <span class="operator">=</span> <span class="built_in">T</span> extends <span class="punctuation">(</span></span><br><span class="line">  ...args<span class="operator">:</span> <span class="built_in">any</span><span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">)</span> <span class="operator">=</span><span class="operator">&gt;</span> infer R <span class="operator">?</span> R <span class="operator">:</span> <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><p>以上代码中 <code>infer R</code> 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p><p><strong>5.extends</strong></p><p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">interface ILengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ILengthwise</span>&gt;<span class="params">(arg: T)</span></span>: T &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">arg</span>.length);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arg</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">loggingIdentity</span>(<span class="number">3</span>);  <span class="comment">// Error, number doesn&#x27;t have a .length property</span></span><br></pre></td></tr></table></figure><p>这时我们需要传入符合约束类型的值，必须包含必须的属性：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">loggingIdentity</span>(&#123;<span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>6.Partial</strong></p><p><code>Partial&lt;T&gt;</code> 的作用就是将某个类型里的属性全部变为可选项 <code>?</code>。</p><p><strong>定义：</strong></p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"> <span class="operator">*</span> node_modules<span class="operator">/</span>typescript<span class="operator">/</span>lib<span class="operator">/</span>lib.es5.d.ts</span><br><span class="line"> <span class="operator">*</span> Make <span class="built_in">all</span> properties <span class="keyword">in</span> <span class="built_in">T</span> optional</span><br><span class="line"> <span class="operator">*</span><span class="operator">/</span></span><br><span class="line">type Partial<span class="operator">&lt;</span><span class="built_in">T</span><span class="operator">&gt;</span> <span class="operator">=</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">[</span>P <span class="keyword">in</span> keyof <span class="built_in">T</span><span class="punctuation">]</span><span class="operator">?</span><span class="operator">:</span> <span class="built_in">T</span><span class="punctuation">[</span>P<span class="punctuation">]</span>;</span><br><span class="line"><span class="punctuation">&#125;</span>;</span><br></pre></td></tr></table></figure><p>在以上代码中，首先通过 <code>keyof T</code> 拿到 <code>T</code> 的所有属性名，然后使用 <code>in</code> 进行遍历，将值赋给 <code>P</code>，最后通过 <code>T[P]</code> 取得相应的属性值。中间的 <code>?</code> 号，用于将所有属性变为可选。</p><p><strong>示例：</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line">  title: <span class="keyword">string</span>;</span><br><span class="line">  description: <span class="keyword">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTodo</span>(<span class="params">todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">todo1</span> = &#123;</span><br><span class="line">  title: <span class="string">&quot;organize desk&quot;</span>,</span><br><span class="line">  description: <span class="string">&quot;clear clutter&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">todo2</span> = <span class="title function_ invoke__">updateTodo</span>(todo1, &#123;</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&quot;throw out trash&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的 <code>updateTodo</code> 方法中，我们利用 <code>Partial&lt;T&gt;</code> 工具类型，定义 <code>fieldsToUpdate</code> 的类型为 <code>Partial&lt;Todo&gt;</code>，即：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   title?: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">   description?: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> front-end </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM 复习及前端架构</title>
      <link href="/article/DOM%E5%A4%8D%E4%B9%A0%E5%8F%8A%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
      <url>/article/DOM%E5%A4%8D%E4%B9%A0%E5%8F%8A%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="1-DOM基础"><a href="#1-DOM基础" class="headerlink" title="1. DOM基础"></a>1. DOM基础</h2><ul><li>DOM是Document Object Model的简写，文档对象模型</li><li>DOM是HTML的编程接口</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714162844731.png" alt="image-20220714162844731"></p><p>HTML文件和DOM树是一一对应的关系</p><h3 id="1-1-DOM基本操作"><a href="#1-1-DOM基本操作" class="headerlink" title="1.1. DOM基本操作"></a>1.1. DOM基本操作</h3><h4 id="1-1-1-查"><a href="#1-1-1-查" class="headerlink" title="1.1.1. 查"></a>1.1.1. 查</h4><ol><li><p>通过id查找</p><p><code>document.getElementById(&#39;&#39;)</code></p></li><li><p>通过标签名查找</p><p><code>document.getElementsByTagName(&#39;&#39;)</code></p><p>返回的是NodeList（类数组的对象）</p></li><li><p>通过class查找</p><p><code>document.getElementsByClass(&#39;&#39;)</code></p></li><li><p>根据传入的css选择器，查找匹配的DOM结点</p><ol><li><code>document.querySelector(&quot;p&quot;)</code> 只返回第一个匹配到的DOM结点</li><li><code>document.querySelectorAll(&quot;.detail&quot;)</code> 返回类为detail的所有DOM结点的集合<ol><li>eg: <code>document.querySelectorAll(&quot;ul &gt; li&quot;)</code>; 匹配嵌套在ul中的所有li元素</li><li><code>document.querySelectorAll(&quot;img+h3&quot;)</code>；匹配所有紧邻在img后的h3元素</li><li><code>document.querySelectorAll(&#39;[data-index]&#39;)</code>; 匹配所有有data-index属性的元素</li></ol></li></ol></li><li><p>根据已获取的结点，拿到该节点的子节点或父节点</p><ol><li><code>document.getElementById(&#39;&#39;).parentNode / nextElementSibling / [0]</code></li></ol></li></ol><h4 id="1-1-2-改"><a href="#1-1-2-改" class="headerlink" title="1.1.2. 改"></a>1.1.2. 改</h4><ol><li><p>改innerHTML</p><p><code>dom.innerHTML = &quot;&lt;strong&gt;修改内容&lt;strong&gt;&quot;</code></p></li><li><p>改textContent</p><p><code>dom.textContent = &quot;修改text内容&quot;</code></p></li><li><p>修改style值</p><p><code>dom.style = &quot;color: blue&quot;</code></p></li><li><p>修改指定属性值</p><p><code>dom.setAttribute(&quot;some-attribute&quot;, &quot;666&quot;)</code></p></li></ol><h4 id="1-1-3-增"><a href="#1-1-3-增" class="headerlink" title="1.1.3. 增"></a>1.1.3. 增</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCurrentTimeStr</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">const</span> hour = date.<span class="title function_">getHours</span>();</span><br><span class="line">    <span class="keyword">const</span> minutes = date.<span class="title function_">getMinutes</span>();</span><br><span class="line">    <span class="keyword">const</span> second = date.<span class="title function_">getSeconds</span>();</span><br><span class="line">    <span class="keyword">return</span> [hour, minutes, second].<span class="title function_">join</span>(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建元素</span></span><br><span class="line"><span class="keyword">let</span> newDom = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>)</span><br><span class="line">newDom.<span class="property">textContent</span> = <span class="string">&quot;页面加载时间为&quot;</span> + <span class="title function_">getCurrentTimeStr</span>();</span><br><span class="line"><span class="comment">// 将新创建的结点添加到body的子节点列表的末尾处</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(newDom) <span class="comment">// or ParentNode.appendChild(newDom)</span></span><br></pre></td></tr></table></figure><h4 id="1-1-4-删"><a href="#1-1-4-删" class="headerlink" title="1.1.4. 删"></a>1.1.4. 删</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> liToRemove = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">liToRemove.<span class="title function_">remove</span>();</span><br></pre></td></tr></table></figure><h2 id="2-DOM事件"><a href="#2-DOM事件" class="headerlink" title="2. DOM事件"></a>2. DOM事件</h2><h3 id="2-1-什么是DOM事件"><a href="#2-1-什么是DOM事件" class="headerlink" title="2.1. 什么是DOM事件"></a>2.1. 什么是DOM事件</h3><ul><li>Demo</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> liDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;something&quot;</span>)</span><br><span class="line"><span class="comment">// DOM 0级</span></span><br><span class="line">liDom.<span class="property">onclick</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exe!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>页面上的DOM之间是嵌套的结构，如果给内层DOM绑定了事件监听函数，则外层的DOM也会相应触发点击事件</li></ul><h3 id="2-2-DOM事件传播"><a href="#2-2-DOM事件传播" class="headerlink" title="2.2. DOM事件传播"></a>2.2. DOM事件传播</h3><ul><li>事件捕获阶段 –&gt; 目标事件阶段 –&gt; 事件冒泡阶段</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714170409071.png" alt="image-20220714170409071"></p><h3 id="2-2-addEventListener"><a href="#2-2-addEventListener" class="headerlink" title="2.2. addEventListener"></a>2.2. addEventListener</h3><p>DOM 2级</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> liDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;something&quot;</span>)</span><br><span class="line">liDom.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exe!(回调1)&#x27;</span>)</span><br><span class="line">&#125;); <span class="comment">// 其实还有第三个参数，once：是否只响应一次；capture：是否在捕获阶段触发（默认是false：即在冒泡阶段触发）</span></span><br><span class="line">liDom.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exe!(回调2)&#x27;</span>)</span><br><span class="line">&#125;, &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">liDom.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exe!(回调3)&#x27;</span>)</span><br><span class="line">&#125;, &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><ul><li>和直接onClick相比，可以给一个DOM绑定多个事件</li></ul><h2 id="3-BOM"><a href="#3-BOM" class="headerlink" title="3. BOM"></a>3. BOM</h2><p>Browser Object Model，控制浏览器的行为的接口</p><h3 id="3-1-通过window访问"><a href="#3-1-通过window访问" class="headerlink" title="3.1. 通过window访问"></a>3.1. 通过window访问</h3><ul><li>通过window可以访问浏览器提供的BOM对象<ul><li>location</li><li>navigator</li><li>screen</li><li>alert、prompt、confirm</li><li>localStorage</li><li>…</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;welcome!&quot;</span>) <span class="comment">// 提示框</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="variable language_">window</span>,<span class="title function_">prompt</span>(<span class="string">&quot;请输入...&quot;</span>, <span class="string">&quot;张三&quot;</span>) <span class="comment">// 输入提示框，用户可以输入内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iinfo = <span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span> <span class="comment">// 获取浏览器和系统信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&quot;是否跳转？&quot;</span>) <span class="comment">// 弹出确认框 </span></span><br><span class="line"><span class="keyword">if</span>(res) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;http://www.baidu.com&quot;</span> <span class="comment">// 跳转到百度首页</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以省window</span></span><br><span class="line">location.<span class="property">href</span> <span class="comment">// 完整url</span></span><br><span class="line">location.<span class="property">protocol</span> <span class="comment">// 协议头</span></span><br><span class="line">location.<span class="property">host</span> <span class="comment">// 域名</span></span><br><span class="line">location.<span class="property">pathname</span> <span class="comment">// 路径</span></span><br><span class="line">location.<span class="property">search</span> <span class="comment">// 参数</span></span><br><span class="line">location.<span class="property">hash</span> <span class="comment">// 哈希值</span></span><br></pre></td></tr></table></figure><h2 id="4-AJAX"><a href="#4-AJAX" class="headerlink" title="4. AJAX"></a>4. AJAX</h2><p>AJAX是异步的Javascript和XML，可以请求服务端数据，并将数据更新到页面上，且是异步的</p><h3 id="4-1-XMLHttpRequest"><a href="#4-1-XMLHttpRequest" class="headerlink" title="4.1. XMLHttpRequest"></a>4.1. XMLHttpRequest</h3><p>使用XMLHttpRequest对象与服务器通信</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> httpRequest = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="keyword">if</span>(!httpRequest) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;浏览器不支持XMLHttpRequest，如IE！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    httpRequest.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 服务器响应时触发此回调函数</span></span><br><span class="line">        <span class="keyword">if</span> (httpRequest.<span class="property">readyState</span> === httpRequest.<span class="property">DONE</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (httpRequest.<span class="property">status</span> === <span class="number">200</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(httpRequest.<span class="property">responseText</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error!&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;readyState change: &quot;</span> + httpRequest.<span class="property">readyState</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    httpRequest.<span class="title function_">open</span>(</span><br><span class="line">        <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;url&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    httpRequest.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-Fetch"><a href="#4-2-Fetch" class="headerlink" title="4.2. Fetch"></a>4.2. Fetch</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;url&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">myJson</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myJson)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-架构模式"><a href="#5-架构模式" class="headerlink" title="5. 架构模式"></a>5. 架构模式</h2><p>从一个例子开始…</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714173054756.png" alt="image-20220714173054756"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;save&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;age&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> listHtml = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;tr&gt;</span></span><br><span class="line"><span class="string">    &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">    &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">    &lt;/tr&gt;`</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> tableElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="property">innerHTML</span> += listHtml</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;upload&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> listElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> lineElement = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;tr&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    lineElement.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tds = item.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;td&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> name = tds[<span class="number">0</span>].<span class="property">innerText</span>;</span><br><span class="line">        <span class="keyword">let</span> age = tds[<span class="number">1</span>].<span class="property">innerText</span>;</span><br><span class="line">        result.<span class="title function_">push</span>(&#123;name, age&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714173909347.png" alt="image-20220714173909347"></p><p>修改：维护一个全局result，然后每次增加时添加数据到result，最后导出的时候就不需要从dom中取，直接取result即可</p><h2 id="6-MVC"><a href="#6-MVC" class="headerlink" title="6. MVC"></a>6. MVC</h2><h3 id="6-1-架构"><a href="#6-1-架构" class="headerlink" title="6.1. 架构"></a>6.1. 架构</h3><ul><li>Model ：比如前文中提到的result全局数组</li><li>View</li><li>Controller</li></ul><h3 id="6-2-基于MVC的代码重构"><a href="#6-2-基于MVC的代码重构" class="headerlink" title="6.2. 基于MVC的代码重构"></a>6.2. 基于MVC的代码重构</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> model = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller = &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> name = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;age&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">        model.<span class="title function_">push</span>(&#123; name, age &#125;);</span><br><span class="line">        view.<span class="title function_">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">upload</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(model)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> view = &#123;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = model;</span><br><span class="line">        <span class="keyword">let</span> listHtml = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123;name, age&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            listHtml += <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;tr&gt;</span></span><br><span class="line"><span class="string">                &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">                &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;/tr&gt;</span></span><br><span class="line"><span class="string">            `</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> tableElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="property">innerHTML</span> = listHtml</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;save&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    controller.<span class="title function_">add</span>();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;upload&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    controller.<span class="title function_">upload</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714174712763.png" alt="image-20220714174712763"></p><ul><li><p>再优化：单一职责</p></li><li><p>如何监听model变化？</p><ul><li><p>观察者模式</p><ul><li><code>addEventListener</code>就是一个观察者模式</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">target.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line">target.<span class="title function_">dispatchEvent</span>(<span class="string">&#x27;click&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>现在我们自己引入一个类似的事件监听器</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line">event.<span class="title function_">on</span>(<span class="string">&#x27;addItem&#x27;</span>, showList); <span class="comment">// 注册一个addItem方法，并传showList方法</span></span><br><span class="line">event.<span class="title function_">emit</span>(<span class="string">&#x27;addItem&#x27;</span>)；</span><br></pre></td></tr></table></figure></li><li><p>用观察者模式改写model层</p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_events</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">on</span>(<span class="params">evt, listener</span>) &#123;</span><br><span class="line">        (<span class="variable language_">this</span>.<span class="property">_event</span>[evt] || (<span class="variable language_">this</span>.<span class="property">_events</span>[evt] = [])).<span class="title function_">push</span>(listen)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> event = <span class="title class_">EventEmmitter</span>();</span><br><span class="line">event.<span class="title function_">on</span>(<span class="string">&#x27;add&#x27;</span>, view.<span class="property">update</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> model = &#123;</span><br><span class="line">    _value = [],</span><br><span class="line"><span class="title function_">push</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span>.<span class="title function_">push</span>(value);</span><br><span class="line">        event.<span class="title function_">emit</span>(<span class="string">&#x27;add&#x27;</span>); <span class="comment">// 每次push之后触发add方法（即view.update方法）</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller = &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> name = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;age&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">        model.<span class="title function_">push</span>(&#123; name, age &#125;);</span><br><span class="line">        <span class="comment">// view.update();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">upload</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(model.<span class="title function_">get</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> view = &#123;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = model.<span class="title function_">get</span>();</span><br><span class="line">        <span class="keyword">let</span> listHtml = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123;name, age&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            listHtml += <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;tr&gt;</span></span><br><span class="line"><span class="string">                &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">                &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;/tr&gt;</span></span><br><span class="line"><span class="string">            `</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> tableElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="property">innerHTML</span> = listHtml</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714175834918.png" alt="image-20220714175834918"></p><h2 id="7-MVVM"><a href="#7-MVVM" class="headerlink" title="7. MVVM"></a>7. MVVM</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714175940359.png" alt="image-20220714175940359"></p><p>修改ViewModel可以同步更新到View上</p><p>MVC：如何更新Model …&amp; 能够观察到Model更新的方法</p><p>MVVM：包含数据驱动视图更新的机制 &amp; 渲染视图的模板引擎</p><h3 id="7-1-如何绑定视图和数据的关系"><a href="#7-1-如何绑定视图和数据的关系" class="headerlink" title="7.1. 如何绑定视图和数据的关系"></a>7.1. 如何绑定视图和数据的关系</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714182522507.png" alt="image-20220714182522507"></p><h3 id="7-2-Vue实现MVVM的思路"><a href="#7-2-Vue实现MVVM的思路" class="headerlink" title="7.2. Vue实现MVVM的思路"></a>7.2. Vue实现MVVM的思路</h3><h4 id="7-2-1-数据劫持"><a href="#7-2-1-数据劫持" class="headerlink" title="7.2.1. 数据劫持"></a>7.2.1. 数据劫持</h4><blockquote><p>数据劫持 为什么要数据劫持？带着这个问题我们先来看下如何实现数据劫持，在vue2的源码中有个名为defineReactive$$1的方法，该方法就是用来实现数据劫持的，但该方法也只是个壳子，最终实现数据劫持的还是靠的<strong>js原生的Object.defineProperty方法</strong>，这也是vue2死活不支持ie8的原因之一。</p></blockquote><p>Object.defineProperty方法接受三个参数：</p><ul><li>第一个参数是被劫持的对象</li><li>第二个参数是被劫持的对象中的属性（key）</li><li>第三个参数是一个配置项对象（包括：value、enumerable、configurable、get和set等几个属性），如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,key,&#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们在做数据劫持时主要用到的就是get和set两个属性。</p><p>通过该方法，被劫持的对象属性，只要在外界获取或者修改属性值都会触发get或set方法，这样我们就可以在get或set中对属性做一些额外对操作。</p><p>了解了数据劫持的实现，也就知道了我们为什么要做数据劫持。是因为我们可以通过数据劫持对数据做一些额外对操作从而实现响应式数据。下面我们以vue的data为例实现一个简单的数据劫持。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="comment">// data必须是一个对象</span></span><br><span class="line">    <span class="comment">// &#123;&#125;.toString.call(): 判断类型</span></span><br><span class="line">    <span class="keyword">if</span>( (&#123;&#125;).<span class="property">toString</span>.<span class="title function_">call</span>(data) !== <span class="string">&#x27;[object Object]&#x27;</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//获取data中所有的属性</span></span><br><span class="line">    <span class="comment">// ES5 引入了Object.keys方法，成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的键名。</span></span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data); </span><br><span class="line">    <span class="comment">//循环遍历keys为data中的每个属性做数据劫持</span></span><br><span class="line">    keys.<span class="title function_">foreach</span>(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">defineReactive$$1</span>(data, key, data[key]);</span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive$$1</span>(<span class="params">obj, key, val</span>)&#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newV</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newV !== val)&#123;</span><br><span class="line">                val = newV;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-2-模板编译"><a href="#7-2-2-模板编译" class="headerlink" title="7.2.2. 模板编译"></a>7.2.2. 模板编译</h4><blockquote><p>为什么要模板编译？ 我们知道在vue中是通过一些指令或者小胡子语法来实现数据绑定的，而浏览器并不认识这些指令或者小胡子语法，因此在页面加载后需要将这些语法转换成真正的数据呈现给用户。</p></blockquote><p>下面我们以input元素和v-model指令为例来实现一个简单的模板编译。 本案例中实现模板编译的流程：</p><blockquote><ul><li>遍历#app下所有的节点，然后根据节点的类型做相应的操作<ul><li>如果是元素节点，获取该节点中所有的属性（attributes）并遍历看是否有v-model指令<ul><li>如果有v-model指令，则根据该指令绑定的属性名（data中的属性名）获取到对应到值，并赋值给节点的value属性</li></ul></li><li>如果是文本节点，则看该文本内容中是否包含小胡子语法<ul><li>如果有小胡子语法，同样需要解析出小胡子中绑定的属性名（data中的属性名）并获取到对应到值替换该文本内容</li></ul></li></ul></li><li>遍历完每个节点后再将该节点作为子节点添加到html到文档碎片中</li><li>最后再将整个文档碎片添加到dom中 需要说明到是：在vue中实现是借助虚拟dom实现的，而这里为了简单就借助文档碎片来模拟虚拟dom实现，另外为什么一定要用文档碎片，不能直接遍历节点吗？直接遍历也是可以的但是这样一来由于不停的修改节点势必会造成大量的性能消耗，而通过文档碎片在所有节点遍历完成后只需要一次消耗，这样就大大降低了回流重汇带来的性能损耗。</li></ul></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nodeTofragment</span>(<span class="params">el, vm</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">    <span class="keyword">let</span> child;</span><br><span class="line">    <span class="keyword">while</span>(child = el.<span class="property">firstChild</span>)&#123;</span><br><span class="line">        <span class="title function_">compile</span>(child, vm);<span class="comment">//模板编译</span></span><br><span class="line">        fragment.<span class="title function_">appendChild</span>(child);<span class="comment">//将节点添加到文档碎片中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compile</span>(<span class="params">node, vm</span>)&#123;</span><br><span class="line">    <span class="comment">// 每个节点都有个节点类型属性（nodeType）对应的值分别是：1元素、2文本、8注释和9根节点</span></span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">nodeType</span> === <span class="number">1</span>)&#123;<span class="comment">//  如果是元素节点</span></span><br><span class="line">        <span class="comment">// 遍历所有的属性，看是否有v-model指令</span></span><br><span class="line">        [...node.<span class="property">attributes</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="regexp">/^v-/</span>.<span class="title function_">test</span>(item.<span class="property">nodeName</span>))&#123;<span class="comment">//nodeName就是属性名，如：class、type、v-model等</span></span><br><span class="line">                node.<span class="property">value</span> = vm.<span class="property">$data</span>[item.<span class="property">nodeValue</span>]; <span class="comment">//nodeValue就是属性名中对应的值，如v-model=&quot;name&quot;中的name</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 元素节点还可能有很多子节点或孙子节点等，因此还需递归处理</span></span><br><span class="line">        [...node.<span class="property">childNodes</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">compile</span>(item, vm);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.<span class="property">nodeType</span> === <span class="number">3</span>)&#123; <span class="comment">// 如果是文本节点</span></span><br><span class="line">        <span class="comment">// 检测该文本中是否包含小胡子语法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/\&#123;\&#123;\w+\&#125;\&#125;/</span>.<span class="title function_">test</span>(node.<span class="property">textContent</span>))&#123;</span><br><span class="line">            <span class="comment">// 将小胡子替换为真正的数据</span></span><br><span class="line">            node.<span class="property">textContent</span> = node.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>, <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">                <span class="comment">// 参数a是匹配到到大的正则内容</span></span><br><span class="line">                <span class="comment">// 参数b是小分组中匹配到到内容 所以b就对应的data中定义的属性</span></span><br><span class="line">                <span class="keyword">return</span> vm.<span class="property">$data</span>[b];</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-3-双向绑定"><a href="#7-2-3-双向绑定" class="headerlink" title="7.2.3. 双向绑定"></a>7.2.3. 双向绑定</h4><p>vue主要是利用数据劫持加发布订阅模式来实现数据的双向绑定的。</p><p>在前面数据劫持的时候我们提到，数据劫持的目的就是为了在获取数据或给数据赋值之前对数据做一些额外的操作，那么这些额外的操作其实就是利用发布订阅模式对数据属性进行监控，比如说data中的name属性，首先需要知道这个name属性都在哪里用到了，以便后面如果name值发生改变时及时通知用到name的地方同步更新，这个在vue中叫做依赖收集。怎么才能知道name属性都在哪里用到了呢，这个时候数据劫持就派上用场了，前面说过只要外界对name进行访问都会触发Object.defineProperty中的get函数，那么我们就可以利用这个特点在get函数中对name属性进行监听收集。大概实现思路如下：</p><blockquote><ul><li>首先我们需要定义一个Dep类，用于对属性进行依赖收集和通知用到属性到地方进行同步更新</li><li>然后再定义一个Watcher类，用于对属性进行监听，并实现属性值的同步更新</li><li>在模板编译的时候，通过watcher来监听属性</li><li>在数据劫持的get函数中进行依赖收集</li><li>在数据劫持的set函数中通知各个watcher进行数据更新</li></ul></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span> = [];<span class="comment">//事件池 存储watcher实例对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addSub</span>(<span class="params">sub</span>)&#123;</span><br><span class="line">        <span class="comment">//sub就是watcher的实例</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">notify</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            item.<span class="title function_">update</span>();<span class="comment">//调用watcher的update</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">node, key, vm</span>)&#123;</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;<span class="comment">//用于标识只用通过Watcher监听过的属性才会进行依赖收集</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span> = node;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getValue</span>();</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getValue</span>();<span class="comment">//首先获取下最新值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeType</span> === <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeType</span> === <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">key</span>];</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-3-完整代码"><a href="#7-3-完整代码" class="headerlink" title="7.3.  完整代码"></a>7.3.  完整代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向绑定</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addSubs</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">update</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">node, key, vm</span>) &#123;</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getValue</span>();</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getValue</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">key</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">observe</span>(<span class="variable language_">this</span>.<span class="property">$data</span>)</span><br><span class="line">  <span class="title function_">nodeTofragment</span>(<span class="variable language_">this</span>.<span class="property">$el</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;西瓜watermelon&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据劫持</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((&#123;&#125;).<span class="property">toString</span>.<span class="title function_">call</span>(data) !== <span class="string">&#x27;[object Object]&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data);</span><br><span class="line">  keys.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">defineReactive$$1</span>(data, key, data[key]);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive$$1</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">addSubs</span>(<span class="title class_">Dep</span>.<span class="property">target</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newV</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newV !== val) &#123;</span><br><span class="line">        val = newV</span><br><span class="line">        dep.<span class="title function_">notify</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板编译</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nodeTofragment</span>(<span class="params">el, vm</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line">  <span class="keyword">while</span> (child = el.<span class="property">firstChild</span>) &#123;</span><br><span class="line">    <span class="title function_">compiler</span>(child, vm);</span><br><span class="line">    fragment.<span class="title function_">appendChild</span>(child);</span><br><span class="line">  &#125;</span><br><span class="line">  el.<span class="title function_">appendChild</span>(fragment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compiler</span>(<span class="params">node, vm</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;<span class="comment">//元素节点</span></span><br><span class="line">    [...node.<span class="property">attributes</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/^v-/</span>.<span class="title function_">test</span>(item.<span class="property">nodeName</span>)) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(node, item.<span class="property">nodeValue</span>, vm)</span><br><span class="line">        node.<span class="property">value</span> = vm.<span class="property">$data</span>[item.<span class="property">nodeValue</span>];</span><br><span class="line">        node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          vm.<span class="property">$data</span>[item.<span class="property">nodeValue</span>] = node.<span class="property">value</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [...node.<span class="property">childNodes</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">compiler</span>(item, vm);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/\&#123;\&#123;\w+\&#125;\&#125;/</span>.<span class="title function_">test</span>(node.<span class="property">textContent</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      node.<span class="property">textContent</span> = node.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>, <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(node, b, vm)</span><br><span class="line">        <span class="keyword">return</span> vm.<span class="property">$data</span>[b]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>我自己个的vue - mvvm<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-设计模式"><a href="#8-设计模式" class="headerlink" title="8. 设计模式"></a>8. 设计模式</h2><h3 id="8-1-观察者模式"><a href="#8-1-观察者模式" class="headerlink" title="8.1. 观察者模式"></a>8.1. 观察者模式</h3><p>当对象之间存在一对多的依赖关系时，其中一个对象的状态发生改变，所有依赖它的对象都会收到通知，这就是观察者模式。</p><p>在观察者模式中，只有两种主体：目标对象 (<code>Object</code>) 和 观察者 (<code>Observer</code>)。宗门任务大殿就是目标对象，弟子们就是观察者。</p><ul><li>目标对象 <code>Subject</code>：<ul><li>维护观察者列表 <code>observerList</code> ———— 维护拥有订阅权限的弟子列表</li><li>定义添加观察者的方法 ———— 提供弟子购买订阅权限的功能</li><li>当自身发生变化后，通过调用自己的 <code>notify</code> 方法依次通知每个观察者执行 <code>update</code> 方法 ———— 发布对应任务后通知有订阅权限的弟子</li></ul></li><li>观察者 <code>Observer</code> 需要实现 <code>update</code> 方法，供目标对象调用。<code>update</code>方法中可以执行自定义的业务逻辑 ———— 弟子们需要定义接收任务通知后的方法，例如去抢任务或任务不适合，继续等待下一个任务</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220715000730818.png" alt="image-20220715000730818"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params">&#123;taskType, taskInfo&#125;</span>) &#123;</span><br><span class="line">        <span class="comment">// 假设任务分为日常route和战斗war</span></span><br><span class="line">        <span class="keyword">if</span> (taskType === <span class="string">&quot;route&quot;</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>不需要日常任务`</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">goToTaskHome</span>(taskInfo);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">goToTaskHome</span>(<span class="params">info</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>去任务大殿抢<span class="subst">$&#123;info&#125;</span>任务`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observerList</span> = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addObserver</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">push</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">notify</span>(<span class="params">task</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发布五星任务&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> observer.<span class="title function_">update</span>(task))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line"><span class="keyword">const</span> stu1 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&quot;弟子1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> stu2 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&quot;弟子2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stu1 stu2 购买五星任务通知权限</span></span><br><span class="line">subject.<span class="title function_">addObserver</span>(stu1);</span><br><span class="line">subject.<span class="title function_">addObserver</span>(stu2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务殿发布五星战斗任务</span></span><br><span class="line"><span class="keyword">const</span> warTask = &#123;</span><br><span class="line">    <span class="attr">taskType</span>: <span class="string">&#x27;war&#x27;</span>,</span><br><span class="line">    <span class="attr">taskInfo</span>: <span class="string">&quot;猎杀时刻&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务大殿通知购买权限弟子</span></span><br><span class="line">subject.<span class="title function_">notify</span>(warTask);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务殿发布五星日常任务</span></span><br><span class="line"><span class="keyword">const</span> routeTask = &#123;</span><br><span class="line">    <span class="attr">taskType</span>: <span class="string">&#x27;route&#x27;</span>,</span><br><span class="line">    <span class="attr">taskInfo</span>: <span class="string">&quot;种树浇水&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.<span class="title function_">notify</span>(routeTask);</span><br></pre></td></tr></table></figure><h3 id="8-2-发布订阅模式"><a href="#8-2-发布订阅模式" class="headerlink" title="8.2. 发布订阅模式"></a>8.2. 发布订阅模式</h3><ul><li>基本概念</li></ul><blockquote><p>基于一个事件（主题）通道，希望接收通知的对象 <code>Subscriber</code> 通过自定义事件订阅主题，被激活事件的对象 <code>Publisher</code> 通过发布主题事件的方式通知各个订阅该主题的 <code>Subscriber</code> 对象。</p></blockquote><p>因此发布订阅模式与观察者模式相比，发布订阅模式中有三个角色，发布者 <code>Publisher</code> ，事件调度中心 <code>Event Channel</code> ，订阅者 <code>Subscriber</code> 。</p><p>我们继续以弟子领取任务为栗子，宗门感觉把任务订阅放在任务大殿中有些繁琐，于是决定在任务大殿和弟子中间添加<strong>中介</strong>。弟子在中介中订阅其需要的任务类型，当任务大殿发布任务后，中介会将发布任务给对应的订阅者。</p><ul><li><p>宗门任务大殿: 任务发布者 —— <code>Publisher</code></p></li><li><p>中介功能 —— <code>Event Channel</code></p><ul><li><p>维护任务类型，以及每种任务下的订阅情况</p></li><li><p>给订阅者提供订阅功能 —— <code>subscribe</code> 功能</p></li><li><p>当宗门发布任务后，中介会给所有的订阅者发布任务 —— <code>publish</code> 功能</p></li></ul></li><li><p>弟子: 任务接受者 —— <code>Subscriber</code></p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220715000719802.png" alt="image-20220715000719802"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PubSub</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 事件中心</span></span><br><span class="line">        <span class="comment">// 存储格式: warTask: [], routeTask: []</span></span><br><span class="line">        <span class="comment">// 每种事件(任务)下存放其订阅者的回调函数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 订阅方法</span></span><br><span class="line">    <span class="title function_">subscribe</span>(<span class="params">type, cb</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">events</span>[type] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">push</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发布方法</span></span><br><span class="line">    <span class="title function_">publish</span>(<span class="params">type, ...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">forEach</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(...args))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消订阅方法</span></span><br><span class="line">    <span class="title function_">unsubscribe</span>(<span class="params">type, cb</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="keyword">const</span> cbIndex = <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">findIndex</span>(<span class="function"><span class="params">e</span>=&gt;</span> e === cb)</span><br><span class="line">            <span class="keyword">if</span> (cbIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">splice</span>(cbIndex, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">events</span>[type];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">unsubscribeAll</span>(<span class="params">type</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">events</span>[type];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个中介公司</span></span><br><span class="line"><span class="keyword">let</span> pubsub = <span class="keyword">new</span> <span class="title class_">PubSub</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弟子一订阅战斗任务</span></span><br><span class="line">pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;warTask&#x27;</span>, <span class="keyword">function</span> (<span class="params">taskInfo</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;宗门殿发布战斗任务，任务信息:&quot;</span> + taskInfo);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 弟子一订阅战斗任务</span></span><br><span class="line">pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;routeTask&#x27;</span>, <span class="keyword">function</span> (<span class="params">taskInfo</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;宗门殿发布日常任务，任务信息:&quot;</span> + taskInfo);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 弟子三订阅全类型任务</span></span><br><span class="line">pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;allTask&#x27;</span>, <span class="keyword">function</span> (<span class="params">taskInfo</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;宗门殿发布五星任务，任务信息:&quot;</span> + taskInfo);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布战斗任务</span></span><br><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;warTask&#x27;</span>, <span class="string">&quot;猎杀时刻&quot;</span>);</span><br><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;allTask&#x27;</span>, <span class="string">&quot;猎杀时刻&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布日常任务</span></span><br><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;routeTask&#x27;</span>, <span class="string">&quot;种树浇水&quot;</span>);</span><br><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;allTask&#x27;</span>, <span class="string">&quot;种树浇水&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在发布订阅模式中，发布者和订阅者不知道对方的存在。需要第三方中介，将订阅者和发布者串联起来，利用中介过滤和分配所有输入的消息。也就是说，<strong>发布-订阅模式用来处理不同系统组件的信息交流，即使这些组件不知道对方的存在</strong>。</p></blockquote><h4 id="8-3-观察者模式和发布订阅模式的差异"><a href="#8-3-观察者模式和发布订阅模式的差异" class="headerlink" title="8.3. 观察者模式和发布订阅模式的差异"></a>8.3. 观察者模式和发布订阅模式的差异</h4><table><thead><tr><th>设计模式</th><th>观察者模式</th><th>发布订阅模式</th></tr></thead><tbody><tr><td>主体</td><td>Object观察者、Subject目标对象</td><td>Publisher发布者、Event Channel事件中心、Subscribe订阅者</td></tr><tr><td>主体关系</td><td>Subject中通过observerList记录ObServer</td><td>Publisher和Subscribe不想不知道对方，通过中介联系</td></tr><tr><td>优点</td><td>角色明确，Subject和Object要遵循约定的成员方法</td><td>松散耦合，灵活度高，通常应用在异步编程中</td></tr><tr><td>缺点</td><td>紧耦合</td><td>当事件类型变多时，会增加维护成本</td></tr><tr><td>使用案例</td><td>双向数据绑定</td><td>事件总线EventBus</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学2022春-黄骏老师史纲重点整理</title>
      <link href="/article/%E9%BB%84%E9%AA%8F%E8%80%81%E5%B8%88%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%812022%E9%87%8D%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/article/%E9%BB%84%E9%AA%8F%E8%80%81%E5%B8%88%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%812022%E9%87%8D%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>2022年春 黄骏老师班</p><p>参考：2018版教材、2021版教材、黄骏老师重点、腿姐背诵手册、xqh同学总结重点、2021年春同学总结重点、2020年学长学姐总结重点</p><p>考试体验</p><ul><li>重点外的内容：戊戌变法的时间、南昌起义、抗日战争中的国际援助</li><li>大约20分重点外，80分重点内。书写量大，前面的题目给的空少、字多</li><li>90+不多，大部分同学在85 - 90之间。</li></ul><p>建议</p><ul><li>黄骏老师最近几年考题均有重点外内容，如有条件可以平时听课，黄骏老师讲课很有意思。如果平时没有听课，考前复习务必把课本过一遍，对重大历史事件和基本历史常识要有宏观把握。</li><li>背诵类课程建议画思维导图复习，本人同样整理有史纲思维导图，但由于格式受限便不放此，有需要的同学可以联系我</li><li>本人记忆力算平均水平，考试周用了4整天背诵、巩固、强化本重点的所有内容。此复习时间和强度供大家参考</li><li>黄骏老师的课有考勤，务必做好签到</li></ul><p><em><strong>整理不易，如果觉得有用，请支持公益</strong></em></p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220725222848913.png" alt="image-20220725222848913" style="zoom:50%;" /><hr><span id="more"></span><p>思维导图（不完全、无内容版，需要整版请联系我）</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220725223756857.png" alt="image-20220725223756857"></p><h2 id="1-列强的入侵"><a href="#1-列强的入侵" class="headerlink" title="1. 列强的入侵"></a>1. 列强的入侵</h2><h3 id="方式方法"><a href="#方式方法" class="headerlink" title="方式方法"></a>方式方法</h3><p>（1）<strong>军事</strong>侵略：首先和主要的侵略方式<br>（2）<strong>政治</strong>控制： 控制中国政府或培植代理人，操纵中国的内政、外交。<br>（3）<strong>经济</strong>掠夺： 强迫中国支付巨额的战争赔款，利用其与清政府签订的不平等条约赋予的特权，进一步扩大对中国的商品倾销和资本输出<br>（4）<strong>文化</strong>渗透： 如目的是宣扬殖民主义奴化思想。</p><h3 id="几场重要的中外战争"><a href="#几场重要的中外战争" class="headerlink" title="几场重要的中外战争"></a>几场重要的中外战争</h3><ol><li><strong>鸦片战争( 1840 )</strong><ul><li><strong>名词解释：</strong>1840年至1842年英国对中国发动的一场非正义的侵略战争，也是中国近代屈辱史的开端。鸦片战争以中国失败并赔款割地告终。中英双方签订了中国历史上第一个丧权辱国不平等条约《南京条约》。中国开始失去了领土、领海、关税、司法主权，开始沦为半殖民地半封建社会。同时，鸦片战争也揭开了近代中国人民反抗外来侵略的历史新篇章。</li></ul></li></ol><ul><li><p>1840 年 4 月，英国国会通过对华战争的决定。同年 6 月，英国侵华舰队封锁了珠江海口和广东海面。鸦片战争正式爆发。</p></li><li><p><strong>开始沦为半殖民地半封建社会</strong>， 社会性质、主要矛盾、历史任务阶级关系开始变化</p></li><li><p><strong>第一个不平等条约（ 南京条约，1842）</strong>，之后还有中英（ 虎门条约，1843）、中美（望厦条约，1844）、中法（ 黄埔条约，1844）</p></li><li><p>已经开始失去了领土、领海、关税、司法主权</p><ul><li>割占香港岛，破坏了中国的主权和领土完整；外国船舰可在中国领海自由航行，破坏了中国的领海主权；外国人在华不受中国法律管束，享受领事裁判权，破坏了中国的司法主权；协定关税，则破坏了中国的关税主权</li></ul></li><li><p>民族意识开始在少数人中觉醒。</p></li><li><p>引起的反抗： 太平天国起义，而镇压太平天国起义又是洋务运动的首要原因。</p></li></ul><ol start="2"><li><p><strong>第二次鸦片战争（1856）</strong></p><ul><li><p><strong>名词解释：</strong>英、法两国在美、俄支持下联合发动的侵华战争。其目的是英、法为了进一步打开中国市场，扩大在华侵略利益。第二次鸦片战争期间，英法联军在强迫清政府签订《天津条约》《北京条约》的同时，表示愿意帮助清政府镇压太平天国，终于使清政府基本屈服。</p></li><li><p>第二次鸦片战争后，英、法各得赔款800万两白银。</p></li></ul></li><li><p><strong>甲午战争(1894一1895)</strong></p><ul><li><strong>名词解释：</strong>日本侵略中国和朝鲜的战争。最终中国战败，战后签订了《马关条约》，甲午战争标志着洋务运动的失败，给<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E6%B0%91%E6%97%8F/1186">中华民族</a>带来空前严重的民族危机，使中国进一步沦为半殖民地半封建社会，使得中国民族意识普遍觉醒；另一方面则使日本国力更为强大，为其跻身列强奠定了重要基础。</li></ul></li></ol><ul><li>进一步沦为半殖民地半封建社会</li><li>中日（ 马关条约〉，中国失去了台湾，列强以竞相租借港湾为起点，掀起了瓜分中国的狂潮</li><li>民族意识普遍觉醒（中日甲午战争以后，当中华民族面临生死存亡的关头时，中国人才开始有了普遍的民族意识的觉醒。）</li><li>标志着洋务运动的失败</li><li>引起的反抗：民族危亡、救亡， 维新运动(1898) 兴起</li></ul><ol start="3"><li>八国联军侵华(1900)<ul><li><strong>名词解释：</strong>1900年5月28日以英、俄、日、法、意、美、德、奥为首的八个主要国家组成的对中国的武装侵略战争。侵略军制造了众多惨案，并最终与中国签订《辛丑条约》，从此中国完全沦为半殖民地半封建社会。</li></ul></li></ol><ul><li><p>侵略军制造众多惨案：1900 年 8 月，八国联军侵占北京后，皇宫以及北海、中南海、颐和园等禁苑里的无数金银财宝、珍贵文物古籍遭到他们的肆意劫掠。日本侵略军还从户部银库掠去300万两库银。八国联军总司令、德国元帅瓦德西承认：“所有中国此次所受毁损及抢劫之损失，其详数将永远不能查出，但为数必极重大无疑。”1900 年，俄国入侵中国东北时，先后制造了海兰泡惨案和江东六十四屯惨案。同年8 月，八国联军侵占北京后，仅在庄王府一处，就烧死和杀死义和团团民与平民 1700 多人。</p></li><li><p>1900年八国联军侵华战争期间，欧美报刊纷纷公开讨论如何瓜分中国。</p></li><li><p>签订《辛丑条约》，中国完全沦为半殖民地半封建社会。</p></li><li><p>引起的反抗： 辛亥革命。</p></li></ul><h3 id="一系列不平等条约"><a href="#一系列不平等条约" class="headerlink" title="一系列不平等条约"></a>一系列不平等条约</h3><h4 id="中英《南京条约》"><a href="#中英《南京条约》" class="headerlink" title="中英《南京条约》"></a>中英《南京条约》</h4><ul><li><p>1842年</p></li><li><p>内容</p><ol><li>把香港岛割让给英国</li><li>向英国赔偿鸦片烟价、商欠、军费共二千一百万银元</li><li>五口通商，开放广州、福州、厦门、宁波、上海五处为通商口岸，允许英人居<br>住并设派领事</li><li>协定关税，英商应纳进出口货税、饷费，中国海关无权自主</li><li>废除公行制度，准许英商在华自由贸易等</li></ol></li><li><p>签订原因</p><ul><li>第一次鸦片战争失败</li></ul></li><li><p>后果</p><ul><li>中国开始沦为半殖民地半封建社会；破坏了原有的自给自足的自然经济体系，促进了资本主义的发展——半殖民地半封建经济体系</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611151709794.png" alt="image-20220611151709794"></p><h4 id="中俄边境诸约"><a href="#中俄边境诸约" class="headerlink" title="中俄边境诸约"></a>中俄边境诸约</h4><ol><li>1858 年俄国胁迫黑龙江将军奕山与之签订《瑷珲条约》，割去黑龙江以北 60<br>万平方公里领土</li><li>1860 年，俄国通过签订中俄《北京条约》，割去乌苏里江以东40万平方公里领<br>土</li><li>1864 年，俄国强迫清政府签订《勘分西北界约记》，割去中国西北 44 万平方<br>公里领土</li><li>1881年，通过《改订伊犁条约》和 5 个勘界议定书，割去中国西北 7 万多平方<br>公里领土</li><li>通过这一系列不平等条约，俄国共侵占中国领土 150 多万平方公里</li></ol><h4 id="中俄、美、英、法《天津条约》"><a href="#中俄、美、英、法《天津条约》" class="headerlink" title="中俄、美、英、法《天津条约》"></a>中俄、美、英、法《天津条约》</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611152353606.png" alt="image-20220611152353606"></p><h4 id="中英、中法《北京条约》"><a href="#中英、中法《北京条约》" class="headerlink" title="中英、中法《北京条约》"></a>中英、中法《北京条约》</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611152328498.png" alt="image-20220611152328498"></p><h4 id="中日《马关条约》"><a href="#中日《马关条约》" class="headerlink" title="中日《马关条约》"></a>中日《马关条约》</h4><p>1895年</p><ul><li><p>内容</p><ul><li>中国割让辽东半岛（后因三国干涉还辽而未能得逞）、台湾岛及其附属各岛<br>屿、澎湖列岛给日本</li><li>中国赔偿 2 亿两白银，加上“赎辽费”3000 万两，威海卫日军“守备费”150<br>万两，共 23150 万两</li><li>增开沙市、重庆、苏州、杭州为商埠，并允许日本在中国的通商口岸投资办厂</li></ul></li><li><p>签订原因</p><ul><li>甲午中日战争失败（1894年）</li></ul></li><li><p>后果</p><p>①台湾等大片领土的割让，进一步破坏了中国主权的完整，刺激了列强瓜分中国的野心，民族危机进一步加深。而且还造成了台湾和大陆难以弥补的隔阂，遗患至今。</p><p>②巨额赔款，加重了中国人民的负担。同时，加速了日本军国主义的发展，刺激其侵略野心。清朝因此大借外债，致使列强控制了中国的经济命脉。</p><p>③通商口岸开放，使帝国主义侵略势力深入到中国内地，中国民族危机空前严重，半殖民地化程度大大加深。</p><p>④该条约适应了帝国主义列强对华资本输出的需要，随后列强掀起了瓜分中国的狂潮。允许在华投资办厂，其他列强引用“利益均沾”的条款，争先恐后地在中国开设工厂，严重阻碍了中国民族资本主义的发展。同时也反映出列强对华经济侵略由商品输出到资本输出的过程。</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611152145246.png" alt="image-20220611152145246"></p><h4 id="《辛丑条约》"><a href="#《辛丑条约》" class="headerlink" title="《辛丑条约》"></a>《辛丑条约》</h4><p>1901年</p><ul><li><p>内容</p><ul><li>中国应支付赔款额 4.5 亿两白银，分 39 年还清，本息共计 10 亿两，并以关税<br>和盐税等作抵押</li></ul><ol start="2"><li>划定北京东交民巷为使馆界，允许各国驻兵保护，不准中国人在界内居住</li><li>拆毁天津大沽口到北京沿线设防的炮台，允许列强各国派驻兵驻扎北京到山海<br>关铁路沿线要地</li><li>清政府保证严禁人民参加反帝运动</li><li>外国认为各个通商章程中应修之处或其他应办的通商事项，清政府概允商议</li><li>惩办“首祸诸臣”</li><li>改总理各国事务衙门为外务部，班列六部之前</li><li>清政府对德、日道歉</li></ol></li><li><p>签订原因</p><ul><li>八国联军侵华（1900年）</li></ul></li><li><p>后果</p><ul><li>《辛丑条约》的签订，进一步加强了帝国主义对中国的全面控制和掠夺， 表明清政府已完全成为帝国主义统治中国的工具，标志着中国已完全沦为半殖民地半封建社会。</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611152153485.png" alt="image-20220611152153485"></p><h2 id="2-早期的维新思想"><a href="#2-早期的维新思想" class="headerlink" title="2. 早期的维新思想"></a>2. 早期的维新思想</h2><p>P40</p><h3 id="鸦片战争前后"><a href="#鸦片战争前后" class="headerlink" title="鸦片战争前后"></a>鸦片战争前后</h3><p>(1) <strong>林则徐</strong>： 他组织翻译西方书刊，编成<strong>《四洲志》</strong>， 睁眼看世界第一人。<br>(2) <strong>魏源</strong>： 《海国图志》，<strong>师夷长技以制夷</strong>。主张学习外国先进的<strong>军事和科学</strong>技术。<br>(3) <strong>郑观应</strong>(19世纪70年代后）： 不仅主张学习西方的科学技术．同时<strong>也要求吸纳西方的政治、经济学说</strong>。（具有比较强烈的反对外国侵略、希望中国独立富强的爱国思想以及具有一定程度反对封建专制的民主思想；在《盛世危言》中提出大力发展民族工商业，同西方国家进行“商战”，设立议院，实行“君民共主”制度等主张。这些主张具有重要的思想启蒙的意义。）</p><h3 id="甲午战争后：-救亡思想"><a href="#甲午战争后：-救亡思想" class="headerlink" title="甲午战争后： 救亡思想"></a>甲午战争后： 救亡思想</h3><p>(1) <strong>严复</strong>： 喊出<strong>“救亡”</strong>口号。用“物竞天择“ “适者生存”的社会进化论思想，为这种危机意识和民族意识提供了理论根据。<br>(2) <strong>孙中山</strong>喊出了“<strong>振兴中华</strong>”的时代最强音</p><p>(3) <strong>梁启超，康有为</strong>: <strong>救亡图存和振兴中华</strong></p><h2 id="3-太平天国运动失败的原因"><a href="#3-太平天国运动失败的原因" class="headerlink" title="3. 太平天国运动失败的原因"></a>3. 太平天国运动失败的原因</h2><p>P47</p><p>(1) <strong>农民不是先进生产力的代表，具有小农局限性</strong>（根本原因） ，因而无法从根本上<br>提出完整的、正确的政治纲领和社会改革方案。<br>(2) 后期领导集团腐败分裂，领导集团的一些人在生活上追求享乐，在政治上争权夺利。<br>(3) 太平天国在<em><em>军事战略上出现了巨大失误</em><br>(4) <strong>没有科学指导思想</strong>。指导思想即</em>*拜上帝教教义**不能指导甚至误导斗争</p><p>(5) <strong>未能正确对待儒学</strong>，笼统排斥或保留糟粕</p><p>(6) <strong>对西方侵略者没有达到理性认识</strong>。对资本主义侵略性认识不足</p><ul><li>太平天国起义及其失败表明，在半殖民地半封建的中国，农民具有伟大的革命潜力；但它自身不能担负起领导反帝反封建斗争取得胜利的重任。单纯的农民战争不可能完成争取民族独立和人民解放的历史任务。</li></ul><blockquote><ol><li>阶级限制，缺少理论和纲领</li><li>领导集团腐败分裂</li><li>军事战略失误</li><li>宗教限制性，不能指导甚至误导斗争</li><li>未能正确对待传统儒学，笼统排斥或保留糟粕</li><li>未能正确分析敌我态势，对资本主义侵略性认识不足</li></ol></blockquote><h2 id="4-洋务运动的历史作用"><a href="#4-洋务运动的历史作用" class="headerlink" title="4. 洋务运动的历史作用"></a>4. 洋务运动的历史作用</h2><p>P50</p><p>(1) <strong>促进早期工业和民族资本主义发展</strong>。（提出自强求富的主张，集中力量优先发展军事工业。发展民用企业）<br>(2)<strong>开启中国近代教育</strong>，开阔视野和眼界。（开办新式学堂，官派留学生，翻译自然科学书籍）</p><p>(3) <strong>使社会风气和价值观念开始变化</strong>。有利于资本主义经济发展和社会风气的改变。</p><p>(4) <strong>是中国近代化的开端</strong>。</p><blockquote><ol><li>促进早期工业和民族资本主义发展</li><li>开启中国近代教育，利用近代自然科学开阔眼界</li><li>冲击传统观念，有利于资本主义经济发展，改变社会风气</li></ol></blockquote><h2 id="5-戊戌变法的内容和意义"><a href="#5-戊戌变法的内容和意义" class="headerlink" title="5. 戊戌变法的内容和意义"></a>5. 戊戌变法的内容和意义</h2><p>P55</p><p>1898年</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ol><li>政治方面：改革行政机构，裁撤闲散、重叠机构；裁汰冗员，澄清吏治，提倡<br>廉政；提倡向皇帝上书言事；准许旗人自谋生计，取消他们享受国家供养的特<br>权。（但是，<strong>在光绪皇帝发布的新政诏令中，并没有采纳维新派多次提出的开</strong><br><strong>国会等政治主张。这些政令和措施并未触及封建制度的根本，所要推行的是一</strong><br><strong>种十分温和的不彻底的改革方案。</strong>）</li><li>经济方面：保护、奖励农工商业和交通采矿业，中央设立农工商总局与铁路矿<br>务总局，各省设立商务局；提倡开办实业，奖励发明创造；注重农业发展，提<br>倡西法垦殖，建立新式农场；广办邮政，修筑铁路；开办商学、商报，设立商<br>会等各类组织；改革财政，编制国家预决算。</li><li>军事方面：裁减旧式绿营兵，改练新式陆军；采用西洋兵制，练洋操，习洋枪<br>等。</li><li>文化教育方面：创设京师大学堂，各省书院改为高等学堂，在各设立中、小<br>学堂；提倡西学，废除八股，改试策论，开经济特科；设立译书局，翻译外国<br>书籍，派人出国留学；奖励新著，奖励创办报刊，准许自由组织学会。</li></ol><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>P56</p><p>(1) 戊戌维新运动是一次<strong>爱国救亡运动</strong>，推动了中华民族的觉醒。<br>(2) 戊戌维新运动是一场<strong>资产阶级性质的政治改革运动</strong>， 在政治、经济等领域一定程度上<strong>冲击了封建制度</strong>。<br>(3) 戊戌维新运动是一场<strong>思想启蒙运动</strong>。 宣传自由平等、社会进化观念、批判封建君权以及封建伦理、促进了民主思想的传播；</p><p>(4)对中国近代教育的发展起了积极的推动作用。维新派主张采用西方近代教育制度，兴办新式学堂。</p><p>(5) 戊戌变法在<strong>改革社会风习方面也提出新的主张</strong>。比如主张废除各处吸食鸦片及妇女裹足等恶俗陋习</p><h2 id="6-（清末）革命和改良的辩论"><a href="#6-（清末）革命和改良的辩论" class="headerlink" title="6. （清末）革命和改良的辩论"></a>6. （清末）革命和改良的辩论</h2><p>P66</p><h3 id="为什么辩"><a href="#为什么辩" class="headerlink" title="为什么辩"></a>为什么辩</h3><p>20世纪初我国民族危机加深，社会矛盾激化，清政府已陷入无法照旧统治下去的境地，以孙中山等为首的资产阶级革命派迅速发展壮大。在资产阶级民主革命思潮广泛传播、革命形势日益成熟的时候，<strong>康有为、梁启超</strong>等人坚持走改良道路，反对用革命手段推翻清朝统治。&#x2F;&#x2F; <strong>1905 年至 1907 年</strong>间，围绕中国究竟是采用革命手段还是改良方式这个问题，革命派与改良派展开了一场大论战。</p><h3 id="辩什么"><a href="#辩什么" class="headerlink" title="辩什么"></a>辩什么</h3><ul><li><strong>要不要以革命手段推翻清王朝（ 核心）</strong><ul><li>改良派：革命会引起下层社会暴乱，招致外国的干涉、瓜分。不能革命，只能改良、立宪。</li><li>革命派：<ol><li>清政府是帝国主义的“鹰犬”，只有通过革命，才能“免瓜分之祸”，获得民族独立和社会进步。</li><li>与革命的牺牲相比，不革命下，清王朝统治给人民带来的牺牲更大</li><li>人们在革命过程中的付出，是以换取历史的进步作为补偿的。革命本身正是为了建设，破坏与建设是革命的两个方面。</li></ol></li></ul></li><li><strong>要不要推翻帝制，实行共和。</strong><ul><li>改良派：中国“国民恶劣”“智力低下”，没有实行民主共和政治的能力。因此，只能实行君主立宪。</li><li>革命派：不是“国民恶劣”，而是“政府恶劣”。民主共和是大势所趋，人心所向。只有“兴民权改民主”，才是中国的唯一出路。</li></ul></li><li><strong>要不要进行社会革命。</strong><ul><li>改良派：反对土地国有，反对平均地权。他们认为土地问题不是中国最重要的问题，不存在社会革命的可能。社会革命只会导致中国的大动乱。主张土地国有是危害国本，并表示在这个问题上“宁死不让”。</li><li>革命派：中国存在着严重的“地主强权”“地权失平”的现象。必须通过平均地权以实现土地国有，在进行政治革命的同时实现社会革命，才能避免贫富不均等社会问题的岀现。</li></ul></li></ul><h3 id="什么人在辩"><a href="#什么人在辩" class="headerlink" title="什么人在辩"></a>什么人在辩</h3><ul><li><p><strong>资产阶级革命派（孙中山等人）</strong>和<strong>资产阶级改良派（康、梁等坚持走改良道路的人）</strong>。是<strong>同一阶级内部不同派别的论战</strong>。</p></li><li><p>注意与维新运动的第一次论战相比较。</p><ul><li>两次论战相同点是内容都为3 个方面，维新派都参与了论战。</li><li>两次论战的不同点是第一次为不同阶级的论战，即资产阶级思想与封这主义思想在中国的笫一次正面交锋；第二次为同一阶级内部不同派别的论战。记住“革命派“永远是主张民主、革命、共和即可。</li></ul></li></ul><h2 id="7-同盟会"><a href="#7-同盟会" class="headerlink" title="7. 同盟会"></a>7. 同盟会</h2><p>P64</p><h3 id="兴起"><a href="#兴起" class="headerlink" title="兴起"></a>兴起</h3><ul><li><strong>名词解释</strong>：于<strong>1905年</strong>、孙中山、黄兴等人以<strong>兴中会</strong>和<strong>华兴会</strong>为基础在日本成立，同盟会以<strong>《民报》为机关报</strong>，是近代中国第一个领导<strong>资产阶级革命的全国性政党</strong>，标志着中国资产阶级民主革命进入新阶段。政治纲领是<strong>“驱除鞑虏，恢复中华，创立民国，平均地权”</strong>。孙将纲领概括为三民主义：民族，民权，民生</li></ul><blockquote><p>但是，同盟会纲领中的民族主义没有从正面鲜明地提出反对帝国主义的主张。当时的革命派对于帝国主义的本质认识不清，害怕帝国主义干涉，甚至幻想以承认不平等条约“继续有效”为条件来换取列强对自己的支持。同时，他们也没有明确地把汉族军阀、官僚、地主作为革命对象，从而给了这部分人后来从内部和外部破坏革命以可乘之机。</p></blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>1894年11月，孙在檀香山组建了第一个革命团体兴中会</li><li>1895年，孙在广州策划武装起义，失败后流亡海外，继续从事反清革命活动</li><li>在资产阶级革命思想的传播过程中，资产阶级革命团体也在各地次第成立。从1904年开始，出现了十多个革命团体，其中最重要的有华兴会、科学补习所、光复会、岳王会等。</li></ul><h2 id="8-辛亥革命"><a href="#8-辛亥革命" class="headerlink" title="8. 辛亥革命"></a>8. 辛亥革命</h2><p>P68</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li>爆发于1911年，辛亥革命是<strong>资产阶级领导</strong>的以<strong>反对封建君主专制制度、建立资产阶级共和国为目的的革命</strong>，是一次比较完全意义上的资产阶级民主革命。</li><li>在近代历史上，辛亥革命是中国人民为救亡图存、振兴中华而奋起革命的一个里程<br>碑，它使中国发生了历史性的巨变，具有伟大的历史意义。</li><li>1911 年 10 月 10 日晚，<strong>武昌首义</strong>取得胜利，之后，清王朝迅速土崩瓦解。1912 年 2 月 12 日，清帝被迫退位。在中国延续了两千多年的封建帝制终于覆灭。、</li><li>中华民国临时政府宣告成立 1911 年底，孙中山被选举为临时大总统。1912 年 1 月 1 日，孙中山在南京宣誓就职，改国号为中华民国，定 1912 年为民国元年，并成立中华民国临时政府。</li><li>1912 年 3 月，临时参议院颁布《中华民国临时约法》（以下简称《临时约法》）。<br>这是中国历史上第一部具有资产阶级共和国宪法性质的法典。</li></ul><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><ul><li><strong>民族危机加深，社会矛盾激化。</strong>20世纪初，帝国主义列强在迫使中国签订《辛丑条约》，中国彻底沦为半殖民半封建社会。中国人民为救亡图存而前赴后继的顽强斗争</li><li>清末“新政“破产预备立宪并没有能够挽救清王朝，反而激化了社会矛盾，加重了危机。主要原因在于，清政府改革的根本目的是延续其反动统治。</li><li><strong>民族资本主义初步发展，形成了资产阶级革命派</strong>， 其骨干是一批资产阶级、小资产阶级知识分子</li></ul><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li>民主、共和、革命</li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>民族资产阶级领导的、比较完整的、真正意义上的资产阶级民主革命</li></ul><h3 id="意义-1"><a href="#意义-1" class="headerlink" title="意义"></a>意义</h3><p>(1) 是中国人民<strong>为救亡图存、振兴中华</strong>而奋起革命的一个里程碑，它使中国发生了历史性的巨变，具有伟大的历史意义。<br>(2) <strong>推翻了</strong>封建势力的政治代表、帝国主义在中国的代理人清王朝的统治，沉重打击了中外反动势力。<br>(3) <strong>结束了中国两千多年封建杜会的君主专制制度</strong>，建立了中国历史上第一个资产阶级共和政府，使民主共和的观念开始深入人心<br>(4)推动了中国人民的<strong>思想解放</strong>，激发了人民的爱国热悄和民族觉醒，打开了思想进步的闸门。<br>(5)推动了中国的<strong>社会变革</strong>， 促使中国的社会经济、思想习惯和社会风俗等方面发生了新的积极变化。<br>(6)不仅在一定程度上打击了帝国主义的侵略势力，而且推动了亚洲各国民族解放运动的高涨。</p><h3 id="失败原因"><a href="#失败原因" class="headerlink" title="失败原因"></a>失败原因</h3><p>(1) 从根本上说：在帝国主义时代．在半殖民地半封建的中国，<strong>资本主义的建国方案是行不通的</strong><br>(2) 主观方面来说：<strong>资产阶级革命派本身有许多弱点和错误</strong>（根源于民族资产阶级的软弱性． 妥协性）</p><h2 id="9-五四运动"><a href="#9-五四运动" class="headerlink" title="9. 五四运动"></a>9. 五四运动</h2><p>P106，108</p><p><strong>名词解释</strong>：是1<strong>919年5月4日</strong>发生在北京的一场以青年学生为主，广大群众、市民、工商人士等阶层共同参与的，通过<strong>示威游行、罢工等多种形式进行的爱国运动</strong>。五四运动的直接导火索是巴黎和会的外交失利，1919年5月4日北京学生在天安门前游行示威，1919年6月5日起，上海工人开始罢工抗议。最终迫于人民群众的压力，北洋政府不得不罢免亲日派官僚曹汝霖等的职务。中国政府代表也没有出席巴黎和约的签字仪式。五四运动的直接斗争目标得到了实现。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li><strong>巴黎和会的外交失利（直接导火线）</strong>——<strong>北京学生游行示威</strong>（<strong>1919年5月4日</strong>，北京大学等十几所学校的学生在天安门前示威游行）——<strong>上海工人罢工抗议</strong>（1919年6月5日起）—— 迫于人民群众的压力，北洋政府不得不于 6 月 10 日宣布罢免亲日派官僚曹汝霖、章宗祥、陆宗舆的职务。6 月 28 日，中国政府代表也没有出席巴黎和约的签字仪式。五四运动的直接斗争目标得到了实现。</li><li>(1) 参与人： 学生群众，后来发展为有工人阶级、小资产阶级和资产阶级参加的全国范割的革命运动。<br>(2) 两个转向：斗争的主力由学生转向了工人，运动的中心由北京转到了上海。</li></ul><h3 id="意义-2"><a href="#意义-2" class="headerlink" title="意义"></a>意义</h3><ul><li><p>1.一次彻底的<strong>反帝反封建运动</strong></p><p>2.一次真正的<strong>群众运动</strong></p><p>3.促进了<strong>马克思主义在中国的传播</strong>以及与工人运动的结合——为共产党的成立作了思想以及干部上的准备</p><p>4.<strong>新民主主义革命的开端</strong></p></li></ul><h2 id="10-中国共产主义革命"><a href="#10-中国共产主义革命" class="headerlink" title="10. 中国共产主义革命"></a>10. 中国共产主义革命</h2><ul><li><p>（重点）</p></li><li><p>国民大革命（1925 - 1927） </p></li><li><p>土地革命时期（1927 - 1937）</p><ul><li>1927 - 南昌起义<ul><li>打响了武装反抗国民党反动统治的第一枪。建军的开始，党指挥枪原则的发端。</li></ul></li><li>1927 - 秋收起义<ul><li>第一次公开打出“工农革命军”的旗帜，之后创建井冈山革命根据地</li></ul></li><li>1927 - 广州起义<ul><li>对国民党屠杀政策的英勇反击</li></ul></li></ul></li><li><p>八七会议（1927年）</p><p>(1) 彻底清算了陈独秀右倾机会主义错误。<br>(2) 确定了土地革命和武装反抗国民党反动统治的总方针， 会议还提<br>出了“整顿改编自己的队伍，纠正过去严重的错误，而找着新的道路”的<br>任务。<br>(3) 会议选出了以撒秋白为首的中央临时政治局（毛泽东在会上提<br>出：枪杆子里出政权）</p></li><li><p>古田会议（1929年）</p><p>(1) 确立了思想建党、政治建军原则． 必须绝对服从共产党的领导，必须担负打仗、筹款和做群众工作的任务，必须加强政治工作。<br>(2) 强调必须加强思想和政治路线的教育．纠正党内的错误思想<br>(3) 古田会议决议创造性地解决了在农村环境中、在党组织和军队以农民为主要成分的环境下，如何从加强思想建设入手，保待党的无产阶级先锋队性质和建设党领导的新型人民军队的问题｀这是人民军队完全区别与一切旧军队的政治特质和根本优势， 对于中国革命新道路的开辟和坚持具有重要的意义。</p></li><li><p>中国共产党建立政权：</p><ul><li>1931 年11 月成立了中华苏维埃共和国临时中央政府，毛泽东当选为主席。中华苏维埃共和国实行工农兵代表大会制度。</li></ul></li><li><p>遵义会议</p><p>(1) 解决了当时具有决定意义的军事问题和组织问题。由张闻天代替博古负总的责任，成立了由周恩来、毛泽东、王稼祥组成的新的“ 三人团”，全权负责红军的军事行动。<br>(2) 标志着中国共产党在政治上走向成熟： 同共产国际的联系中断的情况下独立自主地作出的决策。<br>(3) 开始确立以毛泽东为代表的马克思主义的正确路线在中共中央的领导地位<br>(4) 挽救了中国共产党、挽救了中国工农红军、挽救了中国革命，是中国共产党历史上一个生死攸关的转折点。</p></li></ul><h3 id="长征"><a href="#长征" class="headerlink" title="长征"></a>长征</h3><p>P143</p><p><strong>名词解释</strong>：土地革命战争时期，<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E5%B7%A5%E5%86%9C%E7%BA%A2%E5%86%9B/425591">中国工农红军</a>主力撤离长江南北各苏区，转战两年，到达陕甘苏区的战略转移行动。</p><p><strong>1934年10月</strong>，第五次反“围剿”失败后，中央主力红军为摆脱国民党军队的包围追击，被迫实行战略性转移，退出中央根据地，进行长征。</p><ul><li><p>缘起</p><ul><li>国民党从1930 年起， 下令＂困剿”革命根据地。前四次反“ 围剿”在毛泽东指挥下，取得了胜利。<strong>但是第五次反“围剿”由于执行了以王明为代表的“左”倾教条主义路线而失败，最后不得不进行战略转移——长征。</strong></li></ul></li><li><p>经过</p><ul><li>1934年10月，第五次反“围剿”失败后，中央主力红军为摆脱国民党军队的包围追击，被迫实行战略性转移，退出中央根据地，进行长征。</li><li>长征的两次会师<br>( 1 ) 1935年11 月初，中央红军在陕北吴起镇同红十五军团会合，中国共产党所领导的革命力县有了新的落脚点和战略基地。至此，中央红军的<strong>二万五千里</strong>长征胜利结束。<br>( 2) 1936年10月，红二、四方面军先后同红一方面军在甘肃会宁、静宁将台堡（今屈宁夏回族自治区）会师。至此， 三大主力红军的长征胜利结束。</li></ul></li><li><p><strong>长征的意义</strong><br>(1) 宣告了国民党反动派消灭中国共产党和红军的图谋彻底失败。<br>(2) 宣告了中国共产党和红军肩负着民族希望顺利实现了北上抗日的战略转移。<br>(3) 实现了中国共产党和中国革命事业从挫折走向胜利的伟大转折。</p></li><li><p>为什么叫长征</p><ul><li><strong>二万五千里</strong>长征</li></ul></li></ul><h2 id="11-抗日战争中日本方面"><a href="#11-抗日战争中日本方面" class="headerlink" title="11. 抗日战争中日本方面"></a>11. 抗日战争中日本方面</h2><ul><li>（重点）</li></ul><h3 id="918事变"><a href="#918事变" class="headerlink" title="918事变"></a>918事变</h3><p><strong>名词解释</strong>：1931年9月18日日本关东军突然袭击沈阳，以武力侵占东北的事件。是日本帝国主义侵华的开端。九·一八事变也标志着世界反法西斯战争的起点，揭开了第二次世界大战东方战场的序幕</p><p>1931年9月18日——关东军——柳条湖——炮轰北大营（炸毁沈阳柳条湖附近日本修筑的南满铁路路轨，并嫁祸于中国军队，日军以此为借口，炮轰中国东北军北大营）</p><p>蒋介石——攘外必先安内——使得日本侵略者更加肆无忌惮地进攻中国</p><h3 id="华北事变"><a href="#华北事变" class="headerlink" title="华北事变"></a>华北事变</h3><p><strong>名词解释</strong>：1935 年日本侵略军蚕食侵犯华北地区的一系列事件的统称，日本在华北制造一系列事端，向中国政府提出使华北政权“特殊化”的要求。中国政府在<strong>河北、察哈尔</strong>两省的主权大部丧失，华北成为日军可以自由岀人的“真空地带”。接着，日方又策动<strong>华北五省</strong>（河北、察哈尔、绥远、山西、山东）<strong>两市</strong>（北平、天津）“防共自治运动”，制造傀儡政权。</p><h3 id="卢沟桥事变"><a href="#卢沟桥事变" class="headerlink" title="卢沟桥事变"></a>卢沟桥事变</h3><ul><li><p><strong>名词解释</strong>：1937 年 7 月 7 日，驻丰台日军一个中队在卢沟桥以北举行军事演习。日军借口一名士兵失踪，要求进入宛平县城搜查，遭到拒绝后，即炮轰宛平城，向卢沟桥的中国驻军进攻。日本全面侵华战争由此开始。</p></li><li><p>1937年7月7日——宛平，驻丰台日军</p><p>“七七事变”是全民族抗战的开始，在东方开辟了世界第一个大规模的反法西斯战场</p><p>（1937.7.7夜，驻丰台日军一中队在卢沟桥以北举行军事演习。日军借口一名士兵失踪，要求进入宛平县城搜查，遭拒后，炮轰宛平城，进攻中国驻军。日本全面侵华战争由此开始。）</p></li></ul><h2 id="12-抗日战争中中国方面"><a href="#12-抗日战争中中国方面" class="headerlink" title="12. 抗日战争中中国方面"></a>12. 抗日战争中中国方面</h2><h3 id="抗日民族统一战线"><a href="#抗日民族统一战线" class="headerlink" title="抗日民族统一战线"></a>抗日民族统一战线</h3><p>P157</p><ul><li>形成过程<ul><li>1.<strong>九一八事变</strong>后，抗日救亡运动在全国兴起。</li><li>（华北事变后，中日民族矛盾进一步激化。在中国共产党关于救亡图存、全民抗战的号召和中共地下党组织的领导下，1935 年 12 月 9 日，北平学生举行声势浩大的抗日游行，喊出“反对华北自治”、“打倒日本帝国主义”、“停止内战，一致对外”等口号，遭到国民党军警镇压。12 月 16 日，北平学生和市民一万多人在天桥召开市民大会。会后，举行了更大规模的示威游行。）</li><li>2.<strong>华北事变后</strong>，中日民族矛盾进一步激化，<strong>1935年</strong>爆发<strong>一二·九</strong>运动。它促进了中华民族的觉醒，标志着中国人民抗日救亡运动新高潮的到来。</li><li>3.<strong>1935年12月</strong>，中共中央在<strong>瓦窑堡会议</strong>中，提出了在抗日的条件下与民族资产阶级重建统一战线的新政策。抗日民族统一战线正式被提出</li><li>4.<strong>1936年12月</strong>，<strong>西安事变的和平解决</strong>： 成为时局转换的枢纽。十年内战的局面由此结束，国内和平基本实现</li><li>5.<strong>1937年2月</strong> 中共中央致电<strong>国民党五届三中全会</strong>， 提出停止内战、一致对外等五项要求。全会表示同意国共两党进行谈判， 并在会议文件上第一次写上了“抗日”的字样。</li><li>6.<strong>1937年 七七事变</strong>爆发第二天，中国共产党通电全国，号召全中国同胞团结起来抵抗日本侵略。8月，国共两党达成将红军主力改编成国民革命军<strong>第八路军</strong>（简称八路军，不久改称第十八集团军）等协议。</li><li>7.<strong>1937年9月</strong>，<strong>《中共中央为公布国共合作宣言》</strong>发表；蒋介石发表实际承认共产党合法地位的谈话，以国共两党第二次合作为基础的抗日民族统 一战线正式形成</li></ul></li></ul><h3 id="西安事变"><a href="#西安事变" class="headerlink" title="西安事变"></a>西安事变</h3><ul><li>缘起和过程<ul><li>蒋介石他于 <strong>1936 年 12 月</strong>初到达西安，逼迫张学良、杨虎城攻打陕甘的红军。12 日凌晨，<strong>张学良、杨虎城</strong>（在对蒋介石“哭谏”无效的情况下，）为了实现停止内战、共同抗日，（毅然实行“兵谏”，）<strong>扣留了蒋介石</strong>。这就是西安事变。</li><li>中国共产党派周恩来等到西安，并参加张、杨同南京方面代表宋美龄、宋子文的和平谈判。蒋介石被迫作出了<strong>停止“剿共”、联合红军抗日</strong>等六项承诺。</li></ul></li><li>历史作用<ul><li>西安事变的和平解决成为<strong>时局转换的枢纽</strong>，十年内战的局面由此结束，<strong>国内和平基本实现</strong>。</li></ul></li></ul><h2 id="13-论持久战"><a href="#13-论持久战" class="headerlink" title="13. 论持久战"></a>13. 论持久战</h2><p>P162</p><ul><li>什么背景下写作<ul><li>抗日战争是一场弱国对强国的战争，战争的基本走势怎样？应当坚持什么样的战略方针？这是必须首先回答的一个重要问题</li><li><strong>1938 年</strong> 5 月至 6 月间，毛泽东发表《论持久战》的讲演，总结抗战 10 个月来的经验，系统地阐明了持久抗战的总方针。</li></ul></li><li>内容<ul><li>日本强，中国弱，<strong>强弱对比决定了抗战只能是持久战</strong></li><li>日本是<strong>小国</strong>，发动的是<strong>退步、野蛮</strong>的侵略战争，中国是<strong>大国</strong>，进行的是<strong>进步的、正义</strong>的反侵略战争，中国已经有了代表中华民族和中国人民根本利益的、在政治上成熟的中国共产党及其领导的抗日根据地和人民军队，<strong>最后胜利将属于中国</strong></li><li>强调“<strong>兵民是胜利之本</strong>”，战胜日本的侵略，必须进行人民战争</li><li>科学<strong>预测</strong>了抗日战争的<strong>发展进程</strong>：战略防御——战略相持——战略反攻<strong>三个阶段</strong></li><li>揭示了抗战的<strong>发展规律</strong>和<strong>坚持抗战争取胜利必须实行</strong>的战略方针，对全国抗战的战略指导起到了积极作用</li></ul></li></ul><h2 id="14-重庆谈判"><a href="#14-重庆谈判" class="headerlink" title="14. 重庆谈判"></a>14. 重庆谈判</h2><p>P183 P185</p><ul><li><p>缘起</p><ul><li>战后的政治形势，总的说来，对中国人民实现建设新中国的目标是有利的。在国际上，帝国主义遭到削弱，社会主义国家、民族解放运动的力量有了新的发展，世界反动势力已经难以集中起来干涉中国革命。在国内，中国人民的觉悟程度、组织程度空前提高，经过整风学习，中国共产党在毛泽东思想的基础上达到了高度的团结。中国人民克服一切困难，实现其基本历史要求的时机已经到来。</li><li>国民党统治集团作为大地主、大资产阶级的政治代表，其根本目标是使战后的中国回复到战前的状态，即坚持蒋介石的独裁统治，继续走半殖民地半封建社会的老路。由于中国共产党及其领导的人民革命力量的存在和发展，是它实现上述目标的主要障碍，还在抗战的中期、后期，蒋介石就开始采取避战观战以便保存实力、准备发动反共内战的方针。抗战刚胜利，中国就面临着内战的危险。</li><li>以武力消灭共产党及其领导的人民军队和解放区政权，是蒋介石集团的既定方针。由于全国人民强烈要求和平、反对内战，由于国民党的军队大部分远在西南、西北后方，要把它们运往内战前线、完成内战部署需要相当的时间，由于国际上苏联、美国等都表示希望中国能够实行和平建国，因此，蒋介石在积极准备内战的同时，又表示愿意与中共进行和平谈判。（其目的，一是以此敷衍国内外舆论，掩盖其正在进行的内战准备；二是诱使中共交出人民军队和解放区政权，以期不战而控制全中国；三是如果谈判不成，即放手发动内战，并把战争责任转嫁给中国共产党。）</li><li>国民党的反共方针得到了美国政府的支持。</li><li>中国共产党争取和平民主的方针<ul><li>中国共产党曾经希望通过和平的途径对中国进行政治社会的改革，逐步向建设新中国这个目标迈进。因为，中国人民在经历了长期的战争之后，有和平建国的强烈要求，中国共产党应当充分考虑人民群众的这种愿望。同时，由于人民力量强大，加上其他条件，中国共产党估计，造成国共两党合作（加上民主同盟等）、和平发展的新阶段的可能性是存在的。中国共产党应当努力争取中国出现这种局面。</li><li>还在 1945 年 5 月中共召开七大时，毛泽东就提出，对蒋介石拟采取“洗脸”政策而不是“砍头”政策。8 月 24 日，毛泽东根据时局变化进一步指岀，抗战结束，和平建设阶段开始。中央正考虑同国民党进行谈判，避免内战，实现和平建国。8 月 25 日，中共中央在对时局的宣言中明确提岀<strong>“和平、民主、团结”</strong>的口号。</li></ul></li></ul></li></ul><hr><p>  精简版缘起：</p><ul><li><p>蒋介石保存实力，准备发动反共内战的方针；国民党军队远在后方，蒋希望争取完成军队内战部署的实践；全国人民渴望和平反对内战，美苏希望中国和平建国。故蒋一边积极备战，一边表示愿意和中共和谈</p></li><li><p>蒋介石希望：敷衍舆论，掩盖内战准备；诱使共产党交出军队和解放区政权；谈判不成即发动内战，让共产党承担责任</p></li><li><p>美国希望：让蒋成为其在亚洲的主要支持者以稳定亚洲战线；遏制苏联；维护美国在中国的殖民主义利益</p></li><li><p>共产党希望：和平建国；国共合作、和平发展的新阶段存在可能（和平、民主、团结的口号）</p></li><li><p>经过</p><ul><li><p><strong>1945.5</strong>，召开<strong>七大</strong>时，毛提出对蒋介石采取“洗脸”而不是“砍头”政策。<strong>8.24</strong>，毛指出抗战结束，和平建设阶段开始。中央正<strong>考虑同国民党进行谈判，实现和平建国</strong>。<strong>8.25</strong>，中共中央在对时局的宣言中明确提出“<strong>和平、民主、团结</strong>”的口号。</p><p><strong>1945.8.14&#x2F;20&#x2F;23</strong>，蒋介石<strong>3次电邀</strong>毛到重庆共商“国际国内各种重要问题”。<strong>8.28</strong>，毛与周恩来，王若飞<strong>赴重庆谈判</strong>。<strong>10.10</strong>，双方签署<strong>《政府与中共代表会谈纪要》，即“双十协定”</strong>，确认和平建国基本方针，同意“长期合作，坚决避免内战”。<strong>1946.1.10</strong>，国共双方<strong>下达停战令</strong>，同一天，<strong>政治协商会议</strong>在重庆开幕。中共推动政协会议达成了政府组织、国民大会、和平建国纲领、宪法草案、军事问题五项协议。</p></li></ul></li><li><p>内容</p><ul><li>1945 年10月10日“ 双十协定”， 确认和平建国的方针。同意“长期合作，坚决避免内战” 。</li><li>1946年1月， 中共推动政协会议达成了政府组织、国民大会、和平建国纲领、宪法草案、军事问题五项协议。这些决议贯彻了和平民主原则，勋认了和平建国方针，确定了国会制、内阁制和省自治的政治制度。</li><li>不过， 政协的上述协议及其他协议，还不是新民主主义性质的。但它有利于冲破蒋介石的独裁统治和实行民主政治．有利千和平建国、因而在相当程度上是有利千人民的</li></ul></li></ul><h2 id="15-三大战役"><a href="#15-三大战役" class="headerlink" title="15. 三大战役"></a>15. 三大战役</h2><ul><li>在毛泽东和中共中央军委的领导和指挥下，在人民群众的热烈支援下，中国人民解放军先后发动了辽沈、淮海、平津三大战役。</li><li><strong>辽沈战役</strong>自 1948 年 9 月 12 日开始至 11 月 2 日结束，历时 52 天。东北野战军<br>（第四野战军）主力 70 万人在林彪（司令员）、罗荣桓（政委）领导下，共歼敌 47.2万人。</li><li><strong>淮海战役</strong>自 1948 年 11 月 6 日开始至 1949 年 1 月 10 日结束，历时 66 天。华<br>东野战军（第三野战军）、中原野战军（第二野战军）以及地方武装共 60 万人，在由刘伯承（二野总司令）、陈毅（三野司令员兼政委）、邓小平（二野政委）、粟裕（三野副司令员兼第二副政委）、谭震林（三野第一副政委）组成的总前委（邓小平为书记）领导下，歼敌 55.5 万人。</li><li><strong>平津战役</strong>自 1948 年 11 月 29 日开始至 1949 年 1 月 31 日结束，历时 64 天。人<br>关作战的东北野战军、华北解放军主力与地方武装共 100 万人，在由林彪、罗荣桓、聂荣臻（司令员）组成的平津前线总前委领导下，歼灭和改编国民党军队 52 万余人。</li><li><strong>意义</strong>：三大战役基本摧毁国民党赖以维持反动统治的主要军事力量。三大战役，无论是战争的规模还是取得的成果，在中国战争史上是空前的，在世界战争史上也是罕见的。这是人民战争的胜利，是毛泽东军事思想的胜利。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611174307800.png" alt="image-20220611174307800"></p><h2 id="16-毛泽东论十大关系"><a href="#16-毛泽东论十大关系" class="headerlink" title="16. 毛泽东论十大关系"></a>16. 毛泽东论十大关系</h2><ul><li>（重点），以21年为准&#x2F; 2021 P215</li></ul><ol><li>在<strong>重工业和轻工业、农业</strong>的关系问题上，要用多发展一些农业、轻工业的办法<br>来发展重工业（重工业仍是重点）</li><li>在<strong>沿海工业</strong>和<strong>内地工业</strong>的关系问题上，要充分利用和发展沿海的工业基地，以<br>便更有力量来发展和支持内地工业；新建工业放内地，一是平衡布局，二是利<br>于备战。</li><li>在<strong>经济建设</strong>和<strong>国防建设</strong>的关系问题上，在强调加强国防建设的重要性时，提出<br>把军政费用降到一个适当的比例，增加经济建设费用。只有把经济建设发展得<br>更快了，国防建设才能够有更大的进步；</li><li>在<strong>国家、生产单位</strong>和<strong>生产者个人</strong>的关系问题上，三者的利益必须兼顾，不能只<br>顾一头，既要提倡艰苦奋斗，又要关心群众生活；变苏联的“义务交售制”为<br>缩小工农业剪刀差和等价交换。</li><li>在<strong>中央和地方</strong>的关系问题上，要在巩固中央统一领导的前提下，扩大地方的权<br>力，让地方办更多的事情，发挥中央和地方两个积极性。（中央不同地方商量<br>不冒下命令）</li><li>在<strong>汉族与少数民族</strong>的关系问题上，要着重反对大汉族主义，也要反对地方民族<br>主义，要诚心诚意地积极帮助少数民族发展经济建设和文化建设；（汉族“人<br>口众多”，少数民族“地大物博”）</li><li>在<strong>党和非党</strong>的关系问题上，共产党和民主党派要长期共存，互相监督；（民主<br>党派中的很多人是不同程度的反对派）</li><li>在<strong>革命和反革命</strong>的关系问题上，必须分清敌我，化消极因素为积极因素；（给<br>反革命分子以自新的机会）</li><li>在<strong>是非关系问题</strong>上，对犯错误的同志要实行“惩前毖后，治病救人”的方针，<br>要允许人家犯错误，允许并帮助他们改正错误；</li><li>在<strong>中国和外国</strong>的关系问题上，要学习一切民族、一切国家的长处，包括资本主<br>义国家先进的科学技术和科学管理方法，要反对不加分析地一概排斥或一概照<br>搬。</li></ol><ul><li>一个基本方针： 调动一切积极因素为社会主义事业服务。</li></ul><p>《论十大关系》是中国开始探索自己的社会主义建设道路的标志，它在新的历史条件下从经济方面和政治方面提出了新的指导方针，为中共八大的召开作了理论准备。</p><h2 id="17-7000人大会"><a href="#17-7000人大会" class="headerlink" title="17. 7000人大会"></a>17. 7000人大会</h2><p>2018 P261 &#x2F; 2021 P222</p><ul><li><strong>1962年1、2月间，扩大的中共中央工作会议（即“七千人大会”）</strong>在北京召开。<strong>刘少奇</strong>代表中央提出的书<strong>面报告草稿</strong>，总结了 <strong>“大跃进”</strong>以来经济建设工作的经验教训，分析了产生<strong>缺点错误</strong>的原因。</li><li><strong>毛泽东</strong>着重阐述了民主集中制的极端重要性，并带头做了自我批评（，特别强调在社会主义建设上，我们还有很大的<strong>盲目性</strong>，今后要下苦功夫调查研究，弄清楚社会主义经济的规律。要使中国赶上和超过世界上最先进的资本主义国家，没有一百多年的时间是不行的。这是党中央和毛泽东对社会主义建设长期性的进一步认识。）</li><li><strong>邓小平、周恩来</strong>分别代表中央书记处和国务院在大会上作自我批评，并提出恢复党的优良传统和克服目前困难的主要办法。</li><li>意义：这次会议发扬了党内的<strong>民主</strong>和<strong>自我批评</strong>精神，统一了全党的认识，对动员全党团结奋斗战胜困难起了极其重要的作用。</li></ul><h2 id="18-四个现代化目标"><a href="#18-四个现代化目标" class="headerlink" title="18. 四个现代化目标"></a>18. 四个现代化目标</h2><p>2021 P223</p><ul><li>背景：当国民经济调整工作取得巨大成就的时候，党适时提出了新的奋斗目标。</li><li>内容：<strong>1964年</strong>底，<strong>周恩来</strong>在<strong>三届全国人大一次会议上</strong>郑重提出实现“四个现代化”的历史任务，即“在不太长的历史时期内，把我国建设成为一个具<strong>有现代农业、现代工业、现代国防和现代科学技术</strong>的社会主义强国，赶上和超过世界先进水平”</li><li><strong>分两步走实现现代化的战略构想</strong>，即从第三个五年计划开始，<strong>第一步</strong>，经过二个五年计划时期，建立一个独立的比较完整的工业体系和国民经济体系；<strong>第二步</strong>，全面实现农业、工业、国防和科学技术的现代化，使中国经济走在世界前列</li><li>意义：“四个现代化”从此成为党和全国各族人民的共同奋斗目标，成为凝聚和团结全国各族人民不懈奋斗的强大精神力量。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 整理重点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 学习-2</title>
      <link href="/article/Spring%E5%AD%A6%E4%B9%A02/"/>
      <url>/article/Spring%E5%AD%A6%E4%B9%A02/</url>
      
        <content type="html"><![CDATA[<h1 id="2-SpringBoot-集成-NoSQL"><a href="#2-SpringBoot-集成-NoSQL" class="headerlink" title="2. SpringBoot 集成 NoSQL"></a>2. SpringBoot 集成 NoSQL</h1><hr><span id="more"></span><h2 id="2-1-Redis"><a href="#2-1-Redis" class="headerlink" title="2.1. Redis"></a>2.1. Redis</h2><p>使用 <code>spring-boot-starter-data-redis</code> starter 可方便地引入相关依赖。默认情况下，它使用 <a href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>。该 starter 可处理传统应用程序和响应式应用程序。</p><h3 id="2-1-1-连接"><a href="#2-1-1-连接" class="headerlink" title="2.1.1. 连接"></a>2.1.1. 连接</h3><p>您可以像所有 Spring Bean 一样注入自动配置的 <code>RedisConnectionFactory</code>、<code>StringRedisTemplate</code> 或普通的 <code>RedisTemplate</code> 实例。默认情况下，实例将尝试在 <code>localhost:6379</code> 上连接 Redis 服务器，以下是 bean 示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">(StringRedisTemplate template)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><blockquote><p>您还可以注册任意数量个实现了 <code>LettuceClientConfigurationBuilderCustomizer</code> 的 bean，以进行更高级的自定义。如果你使用 Jedis，则可以使用 <code>JedisClientConfigurationBuilderCustomizer</code>。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 学习-1</title>
      <link href="/article/Spring%E5%AD%A6%E4%B9%A0/"/>
      <url>/article/Spring%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-IoC-容器"><a href="#1-IoC-容器" class="headerlink" title="1. IoC 容器"></a>1. IoC 容器</h1><ul><li>Inversion of Control （IoC）</li></ul><span id="more"></span><h2 id="1-1-Spring-IoC-Container-Bean"><a href="#1-1-Spring-IoC-Container-Bean" class="headerlink" title="1.1. Spring IoC Container &amp; Bean"></a>1.1. Spring IoC Container &amp; Bean</h2><blockquote><p>IoC 也成为依赖注入，是对象仅通过<strong>*构造函数参数、工厂方法的参数 或在对象实例被构造 或从工厂方法返回后在对象实例上设置的属性来定义它们的依赖项</strong>。*</p></blockquote><ul><li>容器在创建 Bean 时注入这些依赖性。这个过程是 Bean 本身的逆过程，因此得名控制反转<ul><li><a href="https://blog.csdn.net/sinat_36817189/article/details/123410280">(26 条消息) 浅谈控制反转（IoC）<em>米碎师兄的博客-CSDN 博客</em>控制反转</a></li></ul></li><li>在 Spring 中，构成应用程序主干并由 Spring IoC 容器管理的对象称为 bean。</li><li>bean 是由 Spring IoC 容器实例化、组装和管理的对象。 否则，bean 只是应用程序中众多对象之一。 Bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。</li></ul><h2 id="1-2-容器概述"><a href="#1-2-容器概述" class="headerlink" title="1.2. 容器概述"></a>1.2. 容器概述</h2><blockquote><p><code>org.springframework.context.ApplicationContext</code> 接口代表 Spring IoC 容器，负责实例化、配置和组装 bean。 容器通过读取配置元数据来获取有关要实例化、配置和组装哪些对象的指令。 配置元数据以 XML、**<em>Java 注解</em>**或 Java 代码表示。 它可以让您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。</p></blockquote><ul><li>一般来说，创建并初始化了<code>ApplicationContext</code>后，就有了一个完全配置且可执行的系统或应用程序</li></ul><h3 id="1-2-1-配置元数据"><a href="#1-2-1-配置元数据" class="headerlink" title="1.2.1. 配置元数据"></a>1.2.1. 配置元数据</h3><p>方式主要有三</p><ul><li>基于 XML（基本用不到，不详述）</li><li>基于注解（后文提到）</li><li>基于 Java（后文提到）</li></ul><h3 id="1-2-2-实例化容器"><a href="#1-2-2-实例化容器" class="headerlink" title="1.2.2. 实例化容器"></a>1.2.2. 实例化容器</h3><ul><li>Spring 的实例化用的比较少了，略</li></ul><h3 id="1-2-3-使用容器"><a href="#1-2-3-使用容器" class="headerlink" title="1.2.3. 使用容器"></a>1.2.3. 使用容器</h3><ul><li>Spring 的实例化用的比较少了，略</li></ul><h2 id="1-3-Bean-概述"><a href="#1-3-Bean-概述" class="headerlink" title="1.3. Bean 概述"></a>1.3. Bean 概述</h2><ul><li>略</li></ul><h2 id="1-4-依赖关系"><a href="#1-4-依赖关系" class="headerlink" title="1.4. 依赖关系"></a>1.4. 依赖关系</h2><h3 id="1-4-1-依赖注入"><a href="#1-4-1-依赖注入" class="headerlink" title="1.4.1. 依赖注入"></a>1.4.1. 依赖注入</h3><ul><li>基于构造函数的依赖注入<ul><li>基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数代表一个依赖项。 调用带有特定参数的 <code>static</code> 工厂方法来构造 bean 几乎是等效的，本讨论将类似地处理构造函数和 <code>static</code> 工厂方法的参数。 以下示例显示了一个只能使用构造函数注入进行依赖注入的类</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot 中多用注解结合构造函数进行 DI</p><ul><li>构造函数参数解析<ul><li>构造函数参数解析匹配通过使用参数的类型发生。 如果 bean 定义的构造函数参数中不存在潜在的歧义，那么在 bean 定义中定义构造函数参数的顺序就是在实例化 bean 时将这些参数提供给适当的构造函数的顺序。</li></ul></li><li>Spring 中构造函数消歧义的问题<ul><li>略，SpringBoot 中很少碰到</li></ul></li><li>依赖解析流程<ul><li>容器执行 bean 依赖解析如下：<ul><li><code>ApplicationContext</code> 是用描述所有 bean 的配置元数据创建和初始化的。 配置元数据可以由 XML、Java 代码或注解指定。</li><li>对于每个 bean，它的依赖关系以属性、构造函数参数或静态工厂方法的参数（如果您使用它而不是普通构造函数）的形式表示。 在实际创建 bean 时，将这些依赖关系提供给 bean。</li><li>每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个 bean 的引用。</li><li>作为值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型。 默认情况下，Spring 可以将字符串格式提供的值转换为所有内置类型，例如 <code>int</code>、<code>long</code>、<code>String</code>、<code>boolean</code> 等等。</li></ul></li></ul></li></ul><h2 id="1-5-基于注解的容器配置"><a href="#1-5-基于注解的容器配置" class="headerlink" title="1.5. 基于注解的容器配置"></a>1.5. 基于注解的容器配置</h2><h3 id="1-5-1-Required"><a href="#1-5-1-Required" class="headerlink" title="1.5.1. @Required"></a>1.5.1. @Required</h3><p><code>@Required</code> 注解适用于 bean 属性 setter 方法，如下例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此注解表明必须在配置时通过 bean 定义中的显式属性值或通过自动装配来填充受影响的 bean 属性。 如果尚未填充受影响的 bean 属性，则容器将引发异常。 避免以后出现 <code>NullPointerException</code> 实例等。</p><blockquote><p><code>@Required</code> 注解和 <code>RequiredAnnotationBeanPostProcessor</code> 从 Spring Framework 5.1 开始正式弃用，赞成使用构造函数注入进行所需设置（或 <code>InitializingBean.afterPropertiesSet 的自定义实现 ()</code> 或自定义 <code>@PostConstruct</code> 方法以及 bean 属性 setter 方法）</p></blockquote><h3 id="1-5-2-Autowired"><a href="#1-5-2-Autowired" class="headerlink" title="1.5.2. @Autowired"></a>1.5.2. @Autowired</h3><p>您可以将 <code>@Autowired</code> 注解应用于构造函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从 Spring Framework 4.3 开始，如果目标 bean 只定义了一个构造函数，则不再需要在这样的构造函数上添加 <code>@Autowired</code> 注解。 但是，如果有多个构造函数可用且没有主&#x2F;默认构造函数，则必须至少用 <code>@Autowired</code> 注解其中一个构造函数，以便指示容器使用哪一个。</p></blockquote><p>您还可以将 <code>@Autowired</code> 注解应用于 <em>传统</em> setter 方法，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以将注解应用于具有任意名称和多个参数的方法，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span><br><span class="line"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您也可以将 <code>@Autowired</code> 应用于字段，甚至将其与构造函数混合，如下例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以通过将 <code>@Autowired</code> 注解添加到需要该类型数组的字段或方法来指示 Spring 从 <code>ApplicationContext</code> 提供特定类型的所有 bean，如 以下示例显示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，当给定注入点没有匹配的候选 bean 可用时，自动装配失败。 对于声明的数组、集合或映射，至少需要一个匹配元素。</p><p>默认行为是将带注解的方法和字段视为指示所需的依赖项。 您可以更改此行为，如下例所示，通过将不可满足的注入点标记为非必需（即，通过在 <code>@ 自动连线</code>到<code>false</code>）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-Primary"><a href="#1-5-3-Primary" class="headerlink" title="1.5.3. @Primary"></a>1.5.3. @Primary</h3><ul><li><code>@Primary</code> 表示当多个 bean 是自动装配到单值依赖项的候选者时，应优先考虑特定 bean。 如果候选中恰好存在一个主要 bean，则它成为自动装配的值。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> MovieCatalog <span class="title function_">firstMovieCatalog</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MovieCatalog <span class="title function_">secondMovieCatalog</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-4-使用泛型作为自动装配限定符"><a href="#1-5-4-使用泛型作为自动装配限定符" class="headerlink" title="1.5.4. 使用泛型作为自动装配限定符"></a>1.5.4. 使用泛型作为自动装配限定符</h3><ul><li>可以用泛型和<code>@Autowired</code>搭配装配</li></ul><h3 id="1-5-5-Resource"><a href="#1-5-5-Resource" class="headerlink" title="1.5.5. @Resource"></a>1.5.5. @Resource</h3><p>Spring 还通过在字段或 bean 属性 setter 方法上使用 JSR-250 <code>@Resource</code> 注解 (<code>javax.annotation.Resource</code>) 来支持注入。</p><p>在没有指定显式名称的 <code>@Resource</code> 用法的唯一情况下，与 <code>@Autowired</code> 类似，<code>@Resource</code> 找到主要类型匹配而不是 一个特定的命名 bean 并解析众所周知的可解析依赖项：<code>BeanFactory</code>、<code>ApplicationContext</code>、<code>ResourceLoader</code>、<code>ApplicationEventPublisher</code> 和 <code>MessageSource</code> 接口。</p><h3 id="1-5-6-Value"><a href="#1-5-6-Value" class="headerlink" title="1.5.6. @Value"></a>1.5.6. @Value</h3><p><code>@Value</code> 通常用于注入外化属性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String catalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(<span class="meta">@Value(&quot;$&#123;catalog.name&#125;&quot;)</span> String catalog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.catalog = catalog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用以下配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>以及以下 <code>application.properties</code> 文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">catalog.name=MovieCatalog</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>catalog</code> 参数和字段将等于 <code>MovieCatalog</code> 值。</p><p>Spring 提供了一个默认的宽松嵌入值解析器。 它将尝试解析属性值，如果无法解析，则属性名称（例如 <code>$&#123;catalog.name&#125;</code>）将作为值注入。 如果你想对不存在的值保持严格的控制，你应该声明一个 <code>PropertySourcesPlaceholderConfigurer</code> bean，如下例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PropertySourcesPlaceholderConfigurer <span class="title function_">propertyPlaceholderConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertySourcesPlaceholderConfigurer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Spring Boot 默认配置一个 <code>PropertySourcesPlaceholderConfigurer</code> bean，它将从 <code>application.properties</code> 和 <code>application.yml</code> 文件中获取属性。</p></blockquote><p>当 <code>@Value</code> 包含 <a href="https://geekdoc.top/docs/languages/java/spring-framework/5.3.11/reference/html/core.html#expressions"><code>SpEL</code> 表达式</a> 时，该值将在运行时动态计算，如下例所示：</p><ul><li>注：SpEL 表达式是 Spring 表达式语言</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String catalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(<span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;user.catalog&#x27;] + &#x27;Catalog&#x27; &#125;&quot;)</span> String catalog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.catalog = catalog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-7-Component-和进一步的定型注解"><a href="#1-5-7-Component-和进一步的定型注解" class="headerlink" title="1.5.7. @Component 和进一步的定型注解"></a>1.5.7. @Component 和进一步的定型注解</h3><p><code>@Repository</code> 注解是任何实现存储库角色或构造型（也称为数据访问对象或 DAO）的类的标记。 此标记的用途之一是自动转换异常。</p><p>Spring 提供了更多构造型注解：<code>@Component</code>、<code>@Service</code> 和 <code>@Controller</code>。 <code>@Component</code> 是任何 Spring 管理的组件的通用构造型。</p><p><code>@Repository</code>、<code>@Service</code> 和 <code>@Controller</code> 是 <code>@Component</code> 的特化，用于更具体的用例（在分别为持久层、服务层和表示层）。因此，您可以使用 <code>@Component</code> 注解您的组件类，但是，通过使用 <code>@Repository</code>、<code>@Service</code> 或 <code>@ 注解它们Controller</code> 相反，您的类更适合由工具处理或与切面相关联。例如，这些构造型注解是切入点的理想目标。 <code>@Repository</code>、<code>@Service</code> 和 <code>@Controller</code> 还可以在 Spring Framework 的未来版本中携带额外的语义。因此，如果您在服务层使用 <code>@Component</code> 或 <code>@Service</code> 之间做出选择，<code>@Service</code> 显然是更好的选择。同样，如前所述，<code>@Repository</code> 已经被支持作为持久层中自动异常转换的标记。</p><h2 id="1-6-基于-Java-的容器配置"><a href="#1-6-基于-Java-的容器配置" class="headerlink" title="1.6. 基于 Java 的容器配置"></a>1.6. 基于 Java 的容器配置</h2><h3 id="1-6-1-Bean-和-Component"><a href="#1-6-1-Bean-和-Component" class="headerlink" title="1.6.1. @Bean 和@Component"></a>1.6.1. @Bean 和@Component</h3><p>Spring 的新 Java 配置支持中的核心工件是 <code>@Configuration</code> 注解类和 <code>@Bean</code> 注解方法。</p><p><code>@Bean</code> 注解用于指示一个方法实例化、配置和初始化一个由 Spring IoC 容器管理的新对象。 对于熟悉 Spring 的 &#96;&#96;XML 配置的人来说，<code> </code>@Bean<code>注解与元素扮演着相同的角色。 您可以将带有</code>@Bean<code>注解的方法与任何 Spring</code>@Component<code>一起使用。 然而，它们最常与</code>@Configuration&#96; bean 一起使用。</p><p>用 <code>@Configuration</code> 注解一个类表明它的主要目的是作为 bean 定义的来源。 此外，<code>@Configuration</code> 类允许通过调用同一类中的其他 <code>@Bean</code> 方法来定义 bean 间的依赖关系。 最简单的 <code>@Configuration</code> 类如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-Component-注解"><a href="#使用-Component-注解" class="headerlink" title="使用 Component 注解"></a>使用 Component 注解</h5><p><code>@Configuration</code> 是一个类级别的注解，表明一个对象是 bean 定义的来源。 <code>@Configuration</code> 类通过带有 <code>@Bean</code> 注解的方法来声明 bean。 对 <code>@Configuration</code> 类上的 <code>@Bean</code> 方法的调用也可用于定义 bean 间的依赖关系。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Typescript 实现的简易 MVVM 框架</title>
      <link href="/article/a-MVVM-toy-with-TypeScript/"/>
      <url>/article/a-MVVM-toy-with-TypeScript/</url>
      
        <content type="html"><![CDATA[<p>2022年秋季百度暑期课程的大作业，用typescript实现的简易MVVM框架。</p><p>实现了数据劫持、单向绑定、双向绑定、发布订阅模式等</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714175940359.png" alt="image-20220714175940359" style="zoom:50%;" /><hr><span id="more"></span><h1 id="1-核心原理"><a href="#1-核心原理" class="headerlink" title="1. 核心原理"></a>1. 核心原理</h1><p>与 MVC 相比，MVVM 包含数据驱动视图更新的机制 &amp; 渲染视图的模板引擎。总的来说 MVVM 框架的核心原理如下：</p><h2 id="1-1-数据劫持"><a href="#1-1-数据劫持" class="headerlink" title="1.1. 数据劫持"></a>1.1. 数据劫持</h2><blockquote><p>通过 js 原生的<code>Object.defineProperty</code>方法，可以进行数据劫持。而做数据劫持时主要用到的就是 get 和 set 两个属性。通过该方法，被劫持的对象属性，只要在外界获取或者修改属性值都会触发 get 或 set 方法，这样我们就可以在 get 或 set 中对属性做一些额外对操作。</p></blockquote><p>由此，可以通过数据劫持对数据做一些额外的操作从而实现响应式数据。</p><h2 id="1-2-模板编译"><a href="#1-2-模板编译" class="headerlink" title="1.2. 模板编译"></a>1.2. 模板编译</h2><blockquote><p>为什么要模板编译？ 我们知道在 vue 中是通过一些指令或者小胡子语法来实现数据绑定的，而浏览器并不认识这些指令或者小胡子语法，因此在页面加载后需要将这些语法转换成真正的数据呈现给用户。</p></blockquote><p><strong>本次大作业中</strong>，我实现模板编译的主要流程如下：</p><ul><li><p>遍历#app 下所有的节点，然后根据节点的类型做相应的操作</p><ul><li>如果是元素节点，获取该节点中所有的属性（attributes）并遍历看是否有 v-model、v-bind、v-on 指令<ul><li>如果有相应指令，则根据该指令绑定的属性名（data 中的属性名）获取到对应到值，并赋值给节点的 value 属性</li></ul></li><li>如果是文本节点，则看该文本内容中是否包含小胡子语法<ul><li>如果有小胡子语法，同样需要解析出小胡子中绑定的属性名（data 中的属性名）并获取到对应到值替换该文本内容</li></ul></li></ul></li><li><p>遍历完每个节点后再将该节点作为子节点添加到 html 到文档碎片中</p></li><li><p>最后再将整个文档碎片添加到 dom 中。</p><blockquote><p>说明：这里借鉴了虚拟 dom 的思路，本次大作业借助文档碎片来模拟虚拟 dom 实现。</p><p>使用虚拟 dom 思路可以避免直接遍历由于不停的修改节点而带来的性能消耗，通过文档碎片在所有节点遍历完成后只需要一次消耗，可以降低了回流重汇带来的性能损耗。</p></blockquote></li></ul><h2 id="1-3-双向绑定"><a href="#1-3-双向绑定" class="headerlink" title="1.3. 双向绑定"></a>1.3. 双向绑定</h2><blockquote><p>本次大作业主要是利用数据劫持加发布订阅模式来实现数据的双向绑定的。</p></blockquote><p>数据劫持的目的是为了在获取数据或给数据赋值之前对数据做一些额外的操作，那么这些额外的操作其实就是利用发布订阅模式对数据属性进行监控。大概实现思路如下：</p><ul><li>定义一个 Watcher 类，用于对属性进行监听，并实现属性值的同步更新</li><li>在模板编译的时候，通过 watcher 来监听属性</li><li>在数据劫持的 get 函数中进行依赖收集</li><li>在数据劫持的 set 函数中通知各个 watcher 进行数据更新</li></ul><h1 id="2-代码架构"><a href="#2-代码架构" class="headerlink" title="2. 代码架构"></a>2. 代码架构</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MVVM</span><br><span class="line">│</span><br><span class="line">├─ src</span><br><span class="line">│  ├─ compile</span><br><span class="line">│  │  └─ compile.ts // compile模块</span><br><span class="line">│  ├─ const</span><br><span class="line">│  │  └─ regex.ts // 正则表达式枚举</span><br><span class="line">│  ├─ observer</span><br><span class="line">│  │  └─ observer.ts // observer模块</span><br><span class="line">│  ├─ watcher</span><br><span class="line">│  │  └─ watcher.ts // wather类</span><br><span class="line">│  └─ index.ts // 主入口文件</span><br><span class="line">├─ test</span><br><span class="line">│  ├─ unitTest // 单元测试文件</span><br><span class="line">│  │  ├─ vBind.test.js</span><br><span class="line">│  │  ├─ vModel.test.js</span><br><span class="line">│  │  └─ vOn.test.js</span><br><span class="line">│  ├─ index.html // 集成测试html</span><br><span class="line">│  └─ mock.js // mock</span><br><span class="line">├─ .gitignore</span><br><span class="line">├─ package-lock.json</span><br><span class="line">├─ package.json</span><br><span class="line">├─ README.md</span><br><span class="line">├─ tsconfig.json</span><br><span class="line">└─ webpack.config.js</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-1-MVVM"><a href="#2-1-MVVM" class="headerlink" title="2.1. MVVM"></a>2.1. MVVM</h2><p>入口文件，在这里对 vue 当中的<code>$el、$methods、$data</code>进行初始化，调用 <code>observer</code> 遍历<code>$data</code>的数据并进行挟持，调用<code>compile</code>遍历<code>$el</code>下的所有节点，解析之类和取值操作。遍历<code>$data</code>的数据，通过<code>Object.defineProperty</code>的<code>getter</code>和<code>setter</code>实现对<code>$data</code> 的代理。</p><h2 id="2-2-Observer"><a href="#2-2-Observer" class="headerlink" title="2.2. Observer"></a>2.2. Observer</h2><p>遍历 <code>$data</code>，通过 <code>Object.defineProperty</code> 设置 <code>getter</code> 和 <code>setter</code>，在 <code>setter</code> 知道数据发生了改变，然后通知 <code>Wacher</code> 去更新 <code>view</code>。</p><h2 id="2-3-Compile"><a href="#2-3-Compile" class="headerlink" title="2.3. Compile"></a>2.3. Compile</h2><p>遍历<code>$el</code> 下的所有节点，解析指令和取值操作等，为每个节点绑定更新函数（在这里），绑定事件和 <code>method</code> 的关系，同时也添加订阅者，当接受到视图更新的订阅消息后，调用更新函数，实现视图更新。同时在添加订阅者的时候，初始化渲染视图。</p><h2 id="2-4-Watcher"><a href="#2-4-Watcher" class="headerlink" title="2.4. Watcher"></a>2.4. Watcher</h2><p><code>Watcher</code> 作为订阅者，充当 <code>Observer</code> 和 <code>Compile</code> 的中间桥梁，包含 <code>update</code> 方法，<code>update</code> 方法调用 <code>Compile</code> 中绑定的事件更新函数，实现对视图的初始化和更新操作。</p><h1 id="3-实例"><a href="#3-实例" class="headerlink" title="3. 实例"></a>3. 实例</h1><blockquote><p>实现功能：</p><ul><li>v-on（事件绑定）</li><li>v-bind（单向绑定）</li><li>v-model（双向绑定）</li><li>小胡子语法（插值表达式，双向绑定）</li></ul></blockquote><h2 id="3-1-HTML"><a href="#3-1-HTML" class="headerlink" title="3.1. HTML"></a>3.1. HTML</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;id&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>获取输入值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title function_">MVVM</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">message</span>: <span class="string">&#x27;测试&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&#x27;百度前端&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">id</span>: <span class="string">&#x27;1234&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">handleClick</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">message</span> + <span class="string">&#x27;:&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;, 点击确定会修改值&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;修改了值为此~&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="number">1234</span>))</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-效果展示"><a href="#3-2-效果展示" class="headerlink" title="3.2. 效果展示"></a>3.2. 效果展示</h2><p><strong><em>v-model</em></strong><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220719232943560.png" alt="image-20220719232943560"></p><p><strong><em>v-on &#x2F; v-bind</em></strong><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220719232957753.png" alt="image-20220719232957753"></p><h1 id="4-单元测试"><a href="#4-单元测试" class="headerlink" title="4. 单元测试"></a>4. 单元测试</h1><blockquote><p>考虑到我编写的都是类，在<code>MVVM</code>类构造的时候即调用所有模块，进行绑定、注册、监听、订阅等工作。因此选择构造 dom 对 v-on（事件绑定）、v-model（双向绑定）、v-bind（数据单向绑定）进行测试</p></blockquote><h2 id="4-1-测试配置"><a href="#4-1-测试配置" class="headerlink" title="4.1. 测试配置"></a>4.1. 测试配置</h2><ul><li><p>测试工具：<code>&quot;jest&quot;: &quot;^28.1.3&quot;</code></p></li><li><p>测试环境：<code>&quot;node.js&quot;: &quot;^v16.13.2&quot;</code></p></li><li><p><code>package.json</code>配置</p><ul><li><pre><code class="json">&#123;  &quot;dependencies&quot;: &#123;    &quot;http&quot;: &quot;^0.0.1-security&quot;,    &quot;jest-environment-jsdom&quot;: &quot;^28.1.3&quot;,    &quot;jsdom&quot;: &quot;^20.0.0&quot;,    &quot;text-encoding&quot;: &quot;^0.7.0&quot;  &#125;,  &quot;name&quot;: &quot;mvvm&quot;,  &quot;description&quot;: &quot;简易的MVVM框架，用typescript实现&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;directories&quot;: &#123;    &quot;test&quot;: &quot;test&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@babel/core&quot;: &quot;^7.18.9&quot;,    &quot;@babel/preset-env&quot;: &quot;^7.18.9&quot;,    &quot;@babel/preset-typescript&quot;: &quot;^7.18.6&quot;,    &quot;@types/chai&quot;: &quot;^4.3.1&quot;,    &quot;@types/jest&quot;: &quot;^28.1.6&quot;,    &quot;@types/mocha&quot;: &quot;^9.1.1&quot;,    &quot;babel-jest&quot;: &quot;^28.1.3&quot;,    &quot;chai&quot;: &quot;^4.3.6&quot;,    &quot;jest&quot;: &quot;^28.1.3&quot;,    &quot;mocha&quot;: &quot;^10.0.0&quot;,    &quot;ts-loader&quot;: &quot;^9.3.1&quot;,    &quot;ts-node&quot;: &quot;^10.9.1&quot;,    &quot;typescript&quot;: &quot;^4.7.4&quot;,    &quot;webpack&quot;: &quot;^5.73.0&quot;,    &quot;webpack-cli&quot;: &quot;^4.10.0&quot;  &#125;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;jest&quot;,    &quot;build&quot;: &quot;webpack&quot;,    &quot;coverage&quot;: &quot;jest --coverage&quot;  &#125;,  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git+https://github.com/Pengzna/MVVM-toy.git&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;bugs&quot;: &#123;    &quot;url&quot;: &quot;https://github.com/Pengzna/MVVM-toy/issues&quot;  &#125;,  &quot;homepage&quot;: &quot;https://github.com/Pengzna/MVVM-toy#readme&quot;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `jest.config.js`配置</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">      transform: &#123;</span><br><span class="line">        &#x27;^.+\\.js$&#x27;: &#x27;babel-jest&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      testEnvironment: &#x27;jsdom&#x27;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h2 id="4-2-测试代码"><a href="#4-2-测试代码" class="headerlink" title="4.2. 测试代码"></a>4.2. 测试代码</h2><h3 id="4-2-1-vBind-test-js"><a href="#4-2-1-vBind-test-js" class="headerlink" title="4.2.1. vBind.test.js"></a>4.2.1. vBind.test.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">MVVM</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../../src/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;v-bind test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div v-bind:id=&quot;id&quot;&gt;&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;button v-on:click=&quot;handleClick&quot;&gt;获取输入值&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title function_">MVVM</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;测试&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;百度前端&#x27;</span>,</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> testNode = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;1234&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> actualValue = <span class="string">&#x27;&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;&#x27;</span></span><br><span class="line">  <span class="title function_">expect</span>(testNode.<span class="property">textContent</span>).<span class="title function_">toBe</span>(actualValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-2-2-vModel-test-js"><a href="#4-2-2-vModel-test-js" class="headerlink" title="4.2.2. vModel.test.js"></a>4.2.2. vModel.test.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">MVVM</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../../src/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;v-model test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div v-bind:id=&quot;id&quot;&gt;&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;button v-on:click=&quot;handleClick&quot;&gt;获取输入值&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title function_">MVVM</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;测试&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;百度前端&#x27;</span>,</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> actualValue = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>].<span class="property">value</span></span><br><span class="line">  <span class="title function_">expect</span>(vue.<span class="property">name</span>).<span class="title function_">toBe</span>(actualValue)</span><br><span class="line">  <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="comment">// 触发v-model需要触发事件。</span></span><br><span class="line">  input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    vue.<span class="property">name</span> = <span class="string">&#x27;修改后&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> inputEvent = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">  input.<span class="title function_">dispatchEvent</span>(inputEvent)</span><br><span class="line">  <span class="keyword">const</span> modifiedValue = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>].<span class="property">value</span></span><br><span class="line">  <span class="title function_">expect</span>(vue.<span class="property">name</span>).<span class="title function_">toBe</span>(modifiedValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-2-3-vOn-test-js"><a href="#4-2-3-vOn-test-js" class="headerlink" title="4.2.3. vOn.test.js"></a>4.2.3. vOn.test.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">MVVM</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../../src/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;v-on test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div v-bind:id=&quot;id&quot;&gt;&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;button v-on:click=&quot;handleClick&quot; id=&quot;bt&quot;&gt;获取输入值&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title function_">MVVM</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;测试&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;百度前端&#x27;</span>,</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="attr">handleClick</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;修改了值为此~&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;bt&#x27;</span>).<span class="title function_">click</span>()</span><br><span class="line">  <span class="keyword">const</span> actualValue = <span class="string">&#x27;修改了值为此~&#x27;</span></span><br><span class="line">  <span class="title function_">expect</span>(vue.<span class="property">name</span>).<span class="title function_">toBe</span>(actualValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-3-测试结果"><a href="#4-3-测试结果" class="headerlink" title="4.3. 测试结果"></a>4.3. 测试结果</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220720123743581.png" alt="image-20220720123743581"></p><h2 id="4-4-测试覆盖率"><a href="#4-4-测试覆盖率" class="headerlink" title="4.4. 测试覆盖率"></a>4.4. 测试覆盖率</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220722113152793.png" alt="image-20220722113152793"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220722113218413.png" alt="image-20220722113218413"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学软件学院-软工Ⅱ大作业心得</title>
      <link href="/article/%E8%BD%AF%E5%B7%A5%E2%85%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%BF%83%E5%BE%97/"/>
      <url>/article/%E8%BD%AF%E5%B7%A5%E2%85%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="1-面向接口编程"><a href="#1-面向接口编程" class="headerlink" title="1. 面向接口编程"></a>1. 面向接口编程</h3><ul><li>主要用于代码复用、消除循环依赖、实现拓展等</li><li>方法：抽象公共父类（最低阶）、<strong>泛型编程</strong>（更灵活，根据具体类注入，可以实现参数和实现的多态）。下面以个人项目实践中的根据泛型实现面向接口编程举出实例：</li></ul><hr><span id="more"></span><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口类，通过泛型注入具体参数，实现每个方法的参数多态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SheetService</span> &lt;SheetVO, SheetState&gt;&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建单据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userVO 操作用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetVO 单据VO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSheet</span><span class="params">(UserVO userVO, SheetVO sheetVO)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据状态获取单据(state == null 则获取所有单据)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state 单据状态</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 符合条件的所有单据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;SheetVO&gt; <span class="title function_">getSheetByState</span><span class="params">(SheetState state)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据进货单id进行审批(state == 审批完成&quot;/&quot;审批失败&quot;)</span></span><br><span class="line"><span class="comment">     * 在controller层进行权限控制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetId 单据id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state 单据修改后的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">approval</span><span class="params">(String sheetId, SheetState state)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据单据Id搜索单据信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetId 单据Id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SheetVO <span class="title function_">getSheetById</span><span class="params">(String sheetId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxSheetServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SheetService</span>&lt;xxxSheetVO, xxxSheetState&gt;</span><br></pre></td></tr></table></figure><h3 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h3><ul><li>策略模式：<ul><li>将策略方法抽象成接口，用不同的实现类实现它。</li><li>在调用 service 里组合接口类（而不是具体的实现类），根据情况向接口中注入具体的类。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PromotionStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据type制定不同的促销策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">makePromotionStrategy</span><span class="params">(PromotionStrategyVO promotionStrategyVO)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// service类（调用strategy）</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">makePromotionStrategy</span><span class="params">(PromotionStrategyVO promotionStrategyVO)</span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;制定促销策略&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    PromotionStrategy promotionStrategy;</span><br><span class="line">    <span class="comment">// 策略模式</span></span><br><span class="line">    <span class="keyword">switch</span> (promotionStrategyVO.getType())&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            promotionStrategy = <span class="keyword">new</span> <span class="title class_">UserPromotionStrategy</span>(promotionStrategyDao, customerDao);</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;对不同级别用户制定促销策略...&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            promotionStrategy = <span class="keyword">new</span> <span class="title class_">SpecialPricePromotionStrategy</span>(promotionStrategyDao);</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;制定特价包（组合商品降价）...&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            promotionStrategy = <span class="keyword">new</span> <span class="title class_">TotalAmountPromotionStrategy</span>(promotionStrategyDao);</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;针对不同总价制定促销策略...&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;错误：未指定促销策略类型！&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;完成促销策略制定&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> promotionStrategy.makePromotionStrategy(promotionStrategyVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-定时任务"><a href="#3-定时任务" class="headerlink" title="3. 定时任务"></a>3. 定时任务</h3><ul><li><p>比较简单，主要通过 SpringBoot 的<code>org.springframework.scheduling.annotation.Scheduled</code> 包实现</p></li><li><p>需要书写<code>cron</code> 表达式，跟 Linux 系统的 cron 定时任务语法相似</p></li></ul><h3 id="4-AOP（面向切面编程）"><a href="#4-AOP（面向切面编程）" class="headerlink" title="4. AOP（面向切面编程）"></a>4. AOP（面向切面编程）</h3><ul><li><p>思想：通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。</p><ul><li><p>所谓的切面（Aspect），可以简单理解为程序中的共性功能。AOP 通过关注程序中的共性功能（面），将其通过一些技术（预编译、代理等）进行统一处理，从而减少代码重复，提高效率。</p></li><li><p>一般认为切面 &#x3D; 通知 + 切入点</p><ul><li><blockquote><p>切入点是指我们要对哪些 Joinpoint 进行拦截的定义，通俗的说就是<code>被增强类中的被增强的方法</code>，即切入的地方。注意，被增强类中并不是所有的方法都被代理了</p></blockquote></li><li><blockquote><p>所谓通知是指拦截到 Joinpoint （被增强的方法）之后所要做的事情就是通知，通俗的说就是<code>对被增强的方法进行增强的代码</code>，即要做的事情</p></blockquote></li></ul></li><li><p>典型的 AOP 应用场景有：HTTP request 的鉴权授权、日志记录等</p></li></ul></li><li><p>使用：</p></li></ul><blockquote><p>Spring Boot 使用 AOP 需要添加 spring-boot-starter-aop 依赖，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;` `&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;` `&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;` `&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></blockquote><p>代码实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示当前的类是一个配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//该注解只能用在类上，作用：代表当前类是一个切面类</span></span><br><span class="line"><span class="comment">// 切面 == 通知 +　切入点</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdviceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Before</span>：前置通知</span></span><br><span class="line"><span class="comment">     * value：切入点表达式  二者加起来构建成为一个切面</span></span><br><span class="line"><span class="comment">     * JoinPoint：连接点：可以理解为两个圆形的切点，从这个切点就可以获取到当前执行的目标类及方法</span></span><br><span class="line"><span class="comment">     * 前置通知和后置通知的参数的都是 JoinPoint， 前置后置通知都没有返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 方法级别：具体到某个具体的方法</span></span><br><span class="line">    <span class="comment">// @Before(value = &quot;execution(* com.xxx.xxx.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="comment">// value值里可以加权限控制，比如public * com.xxx.xxx等</span></span><br><span class="line">    <span class="comment">// 表示service包下的所有类所有方法都执行该前置通知</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;within(com.xxx.xxx.service.*)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before开始执行查询.......&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行的目标类是: &quot;</span> + joinPoint.getTarget());</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行的目标方法是: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行的目标方法参数是: &quot;</span> + joinPoint.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知，属性参数同上面的前置通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 前置通知和后置通知独有的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(value = &quot;execution(* com.xxx.xxx.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after查询结束.......&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取执行目标类和方法名等等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proceedingJoinPoint 环绕通知的正在执行中的连接点（这是环绕通知独有的参数）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标方法执行的返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Around</span>: 环绕通知，有返回值，环绕通知必须进行放行方法（就相当于拦截器），否则目标方法无法执行)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;execution(* com.xxx.xxx.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroud</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aroud环绕通知开始.......&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;执行的目标类 = &quot;</span> + proceedingJoinPoint.getTarget());</span><br><span class="line">        System.out.println(<span class="string">&quot;执行的目标方法 = &quot;</span> + proceedingJoinPoint.getSignature().getName());</span><br><span class="line">        <span class="comment">// 必须方法目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;aroud环绕通知结束.......&quot;</span>);</span><br><span class="line">        <span class="comment">// 将目标方法的返回值进行返回，否则调用目标方法的方法无法获取到返回值</span></span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Bean-的装配"><a href="#5-Bean-的装配" class="headerlink" title="5. Bean 的装配"></a>5. Bean 的装配</h3><ul><li><p>这里主要记录踩到的坑，具体的知识点较为庞杂，在本周的学习中进行具体的记录</p></li><li><p>主要是装配时发生了空指针异常，而异常类已经标上了相关注解。百思不得其解，最后发现 SpringBoot 对 bean 的装配是自动管理，即不需要程序员手动 new。而一旦程序员手动 new，SpringBoot 即认为程序员接管了装配，不再进行自动配置。而本人的异常即为手动 new 了对象造成。</p></li></ul><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><ul><li>resultType &#x2F; resultMap<ul><li>用于指定返回类，用途相似，一般用 resultType 更方便。详细的知识点在之后的文档学习中具体记录。</li></ul></li></ul><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><ul><li><p>Agent</p><ul><li>可以简单理解为执行 pipeline 的环境。一般选择代码构建所需的环境。</li><li><blockquote><p>在配置前端 Jenkins 时，曾遇到 npm: not found 错误。原因是 Jenkins 所在容器未安装 nodejs，也并未挂载宿主机的 nodejs 脚本。解决方法是配置 node 某个版本（我用的是 node: 14)的 agent。在 agent 中执行 npm</p></blockquote></li></ul></li><li><p>Pipeline</p><ul><li>简单的说就是 Jenkins 执行的一个个任务。可以按照环境清理（Image clear）、环境准备（Prepare）、构建（Build）、测试（Test）、打包（Deploy）等步骤细分</li></ul></li><li><p>Docker in docker</p><ul><li>由于我的 Jenkins 部署在 docker 中，而有时需要在 Jenkins 环境下执行 docker 命令，即（Docker in docker），我是通过挂载宿主机的 docker 脚本和 docker.sock 实现的</li></ul></li></ul><h2 id="Gitlab-runner"><a href="#Gitlab-runner" class="headerlink" title="Gitlab-runner"></a>Gitlab-runner</h2><ul><li><p>基本配置</p><ul><li>基本照着网上的教程一路走下来即可。踩的一个大坑是需要手动在配置文件里指定<code>clone_url</code> （仓库的地址）。并且这个地址亲测不能是 ci&#x2F;cd 页面给的 http 地址，必须与仓库 url 一致（如果是 https 必须是 https）。但是由此在设置<code>artifact</code> 时可能会带来请求拦截问题，目前尚未解决。</li></ul></li><li><p>Volumes</p><ul><li>与上述 Jenkins 同样，需要挂载宿主机的 docker 脚本和 docker.sock 来实现 Docker in docker</li></ul></li><li><p>Type</p><ul><li>我用的是 docker，没试过 shell 等其他类型</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 整理重点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客维护日志</title>
      <link href="/article/%E5%8D%9A%E5%AE%A2%E8%A3%85%E4%BF%AE%E6%97%A5%E5%BF%97/"/>
      <url>/article/%E5%8D%9A%E5%AE%A2%E8%A3%85%E4%BF%AE%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="春天里，努力奔跑"><a href="#春天里，努力奔跑" class="headerlink" title="春天里，努力奔跑"></a>春天里，努力奔跑</h1><hr><div align="center"><img src=https://img12.360buyimg.com/ddimg/jfs/t1/205592/38/11526/1148329/616c41eaEa542980b/a42d6ab6bb99f65b.jpg width="90%" height="auto" align="center"/></div><hr><span id="more"></span><h2 id="2021-08-28"><a href="#2021-08-28" class="headerlink" title="2021.08.28"></a>2021.08.28</h2><ul><li>参考教程和大佬博客，配置hexo</li><li>将hexo博客部署到[GitHub Page](<a href="https://github.com/Pengzna/Pengzna.github.io">Pengzna&#x2F;Pengzna.github.io: My personal blog</a>)上</li><li>发表第一篇博客《Peng’s Hello World!》</li></ul><h2 id="2021-08-29-2021-09-13"><a href="#2021-08-29-2021-09-13" class="headerlink" title="2021.08.29 - 2021.09.13"></a>2021.08.29 - 2021.09.13</h2><ul><li>尝试搭配主题（下按时间顺序列出）<ul><li>fluid</li><li>yilia</li><li>butterfly</li><li>yilia-plus</li></ul></li></ul><h2 id="2021-10-09"><a href="#2021-10-09" class="headerlink" title="2021.10.09"></a>2021.10.09</h2><ul><li>最终决定采用yilia-plus主题</li><li>完成头像、关于我、GitHub&#x2F;知乎&#x2F;bilibili等配置</li><li>踩了个坑，在blog根目录修改_config.yilia-plus.yml配置文件虽然会生效，但是会和themes目录下的 _config.yml配置文件冲突</li><li>又踩了个坑，直接修改html、css文件在hexo g是没用的，因为hexo g会自动生成静态网页代码覆盖原有修改</li><li>博客大体搭建完成</li></ul><h2 id="2021-10-10"><a href="#2021-10-10" class="headerlink" title="2021.10.10"></a>2021.10.10</h2><ul><li><p>完成“随笔”、“生活”标签栏配置</p><ul><li>要用hexo new page &lt;&gt;命令来创建新menu单</li><li>在yilia-plus主题里，新menu单并不是一个独立的页面，而是通过博客的tag完成自动分类配置</li></ul></li><li><p>添加Nanyi友链</p></li><li><p>发表第二篇博客《我的博客之旅》</p></li><li><p>发表第三篇博客《却道天凉好个秋》</p></li><li><p>发表第四篇博客《博客维护日志》</p></li><li><p>购买域名<a href="http://www.pengzna.top/">www.pengzna.top</a> ，并将其绑定到GitHub Page上</p></li><li><div align="center"><img src="https://img13.360buyimg.com/ddimg/jfs/t1/196861/13/12355/1365619/6162c9f6Effa90e15/97b35eeeb602b55f.png" alt="图片替换文本" width="90%" height="auto" align="center" /></div></li></ul><h2 id="2021-10-11"><a href="#2021-10-11" class="headerlink" title="2021.10.11"></a>2021.10.11</h2><ul><li>发表第五篇博客《走向共享型对话》</li></ul><h2 id="2021-10-13"><a href="#2021-10-13" class="headerlink" title="2021.10.13"></a>2021.10.13</h2><ul><li>修改网站图标</li></ul><h2 id="2021-10-14"><a href="#2021-10-14" class="headerlink" title="2021.10.14"></a>2021.10.14</h2><ul><li>多次尝试配置基于gitment的评论功能，失败<ul><li>卡在无法登录GitHub账号进行初始化操作</li><li>Error: Bad credentials</li></ul></li><li>头大</li></ul><div align="center"><img src=https://img12.360buyimg.com/ddimg/jfs/t1/204649/38/11208/214683/6167fdd3E46302051/0af3c7b67f672e8d.png /></div><h2 id="2023-11-15"><a href="#2023-11-15" class="headerlink" title="2023.11.15"></a>2023.11.15</h2><p>❗️博客重大更新！🫣</p><p>🐦了两年的博客终于更新了！由于个人审美等因素的成长，以前的主题不再适合我</p><ul><li><p>精挑细选，最终决定使用 <a href="https://github.com/leedom92/hexo-theme-leedom">leedom</a> 作为新主题，理由有三</p><ol><li><p>简洁</p></li><li><p>js、css 代码完善，可定制化空间大</p></li><li><p>markdown 渲染效果令人满意</p></li></ol></li></ul><p>同时，为了满足个人需求，将字体改为 <a href="https://tonyxu.io/blog/recommending-lxgw-font/">霞飞文楷</a>。这也是我目前 typora 所在用的字体，非常舒服。</p><p>也调整了首页标题、footer、右侧搜索栏的位置&#x2F;大小等参数</p><p>唯一美中不足是缺少 about 页面，不过瑕不掩瑜，个人非常喜欢新主题！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 维护日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的博客之旅</title>
      <link href="/article/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/"/>
      <url>/article/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h1 id="We-‘re-all-dream-catchers"><a href="#We-‘re-all-dream-catchers" class="headerlink" title="We ‘re all dream catchers"></a>We ‘re all dream catchers</h1><hr><div align="center"><img src="https://img12.360buyimg.com/ddimg/jfs/t1/211882/23/840/1275331/616c428cE344ef7a9/75747b1c2a7151c3.jpg" alt="图片替换文本" width="90%" height="auto" align="center" /></div><hr><blockquote><p><strong>1、缘起</strong></p></blockquote><span id="more"></span><div align="center"><img src="https://img14.360buyimg.com/ddimg/jfs/t1/211102/13/4596/3483452/616294f3E062d1039/173e374926c19dc3.jpg" alt="图片替换文本" width="400" height="240" align="center" /></div><p>   我还记得刚上大一时，曾受某位学长邀请，听关于博客搭建的讲座。讲座的具体内容我现在已经不记得了，但是作为纯正的计算机小白，我当时什么也听不懂。听讲座时那种如坐针毡的感觉我至今仍记忆犹新，而这种感觉也一直贯穿到我现在的计算机学习中（后话了，sigh🚬… 但我还是头铁听完了这场讲座。看着会后同年级的大佬和学长谈笑风生，交流技术细节，我倍感自己的渺小。但是从此，我也有了一颗想be strong的心，原来，自己要学的东西是如此之多。</p><blockquote><p><strong>2、出发</strong></p></blockquote><p>   时间就这样来到大一下学期的暑假。这个暑假我私人方面a lot of things happened（以后合适的时候我会在博客中写出来的），我整个人都浑浑噩噩的，每天都很绝望。But 生活毕竟还得继续，我在8月还得完成暑期社会实践。</p><p>   我很感谢5月的自己，狠下心来给8月的自己准备了一场社会实践来折腾。在和队友的忙碌中，我渐渐找回了自己的状态。也因为这场社会实践，接触了一些web开发的知识，开始真正意义上的成为GitHub的经常使用者。也正因为接触了web开发和GitHub，我更加了解到计算机世界的精彩绝妙，以及众多令人钦佩、孜孜不倦的大佬正在各个领域深耕。于是，我决定做点什么。</p><p>   就这样，我想起了一年前听过的那场讲座，那场我当时如听天书的讲座。“欸，不妨试一试，看看现在自己的知识能不能搭一个自己的博客。”</p><p>​        <em><strong>于是，我就开始了我的博客搭建之旅啦！</strong></em></p><blockquote><p><strong>3、实践</strong></p></blockquote><p>   经过搜索大佬博客、b站教程、GitHub开源大佬仓库，我决定采用Hexo框架 + yilia-plus主题搭建我的博客，并采用Github部署。</p><p>   2021年8月28日，我的博客正式部署到我自己的GitHub仓库上~~❀❀❀！！</p><p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/204954/7/10589/62850/61629112E04fb0dc5/728cc76fa499a783.png" alt="avatar"></p><p>   后续博客装修、更新过程我会写在《博客装修日志》中，本文到此结束，感谢阅读！</p><p>​</p><p>​——edited by Peng 2021-10-10 15:44</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎你，每一个到来的人</title>
      <link href="/article/Peng-s-Hello-World/"/>
      <url>/article/Peng-s-Hello-World/</url>
      
        <content type="html"><![CDATA[<h1 id="相信着，明天会更好"><a href="#相信着，明天会更好" class="headerlink" title="相信着，明天会更好"></a>相信着，明天会更好</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>About &amp; 博客维护日志</title>
      <link href="/article/Blog-building-log/"/>
      <url>/article/Blog-building-log/</url>
      
        <content type="html"><![CDATA[<p>👋 Hi，我叫彭俊植（Pengzna），南京大学软件学院大四（清华大学软件学院 IoTDB 组研0）在读。我目前对分布式数据库系统比较感兴趣，是 Apache IoTDB Contributor。</p><p>博客分享一些日常技术调研、总结，也分享一些校园资料和生活见闻。</p><p>页面上方有我的 Github、邮箱和微信，欢迎朋友们和我一起交流和讨论！</p><div align="center"><img src=https://img12.360buyimg.com/ddimg/jfs/t1/205592/38/11526/1148329/616c41eaEa542980b/a42d6ab6bb99f65b.jpg width="90%" height="auto" align="center"/></div><div align="center" style="font-size: 30px; font-weight: bold; margin-top: 30px">春天里，努力奔跑</div><h2 id="2021-08-28"><a href="#2021-08-28" class="headerlink" title="2021.08.28"></a>2021.08.28</h2><ul><li>参考教程和大佬博客，配置 hexo</li><li>将 hexo 博客部署到 [GitHub Page](<a href="https://github.com/Pengzna/Pengzna.github.io">Pengzna&#x2F;Pengzna.github.io: My personal blog</a>) 上</li><li>发表第一篇博客《Peng’s Hello World!》</li></ul><h2 id="2021-08-29-2021-09-13"><a href="#2021-08-29-2021-09-13" class="headerlink" title="2021.08.29 - 2021.09.13"></a>2021.08.29 - 2021.09.13</h2><ul><li>尝试搭配主题（下按时间顺序列出）<ul><li>fluid</li><li>yilia</li><li>butterfly</li><li>yilia-plus</li></ul></li></ul><h2 id="2021-10-09"><a href="#2021-10-09" class="headerlink" title="2021.10.09"></a>2021.10.09</h2><ul><li>最终决定采用 yilia-plus 主题</li><li>完成头像、关于我、GitHub&#x2F;知乎&#x2F;bilibili 等配置</li><li>踩了个坑，在 blog 根目录修改 _config.yilia-plus.yml 配置文件虽然会生效，但是会和 themes 目录下的 _config.yml 配置文件冲突</li><li>又踩了个坑，直接修改 html、css 文件在 hexo g 是没用的，因为 hexo g 会自动生成静态网页代码覆盖原有修改</li><li>博客大体搭建完成</li></ul><h2 id="2021-10-10"><a href="#2021-10-10" class="headerlink" title="2021.10.10"></a>2021.10.10</h2><ul><li><p>完成“随笔”、“生活”标签栏配置</p><ul><li>要用 hexo new page &lt;&gt; 命令来创建新 menu 单</li><li>在 yilia-plus 主题里，新 menu 单并不是一个独立的页面，而是通过博客的 tag 完成自动分类配置</li></ul></li><li><p>添加 Nanyi 友链</p></li><li><p>购买域名 <a href="http://www.pengzna.top/">www.pengzna.top</a> ，并将其绑定到 GitHub Page 上</p></li><li><div align="center"><img src="https://img13.360buyimg.com/ddimg/jfs/t1/196861/13/12355/1365619/6162c9f6Effa90e15/97b35eeeb602b55f.png" alt="图片替换文本" width="90%" height="auto" align="center" /></div></li></ul><h2 id="2021-10-13"><a href="#2021-10-13" class="headerlink" title="2021.10.13"></a>2021.10.13</h2><ul><li>修改网站图标</li></ul><h2 id="2021-10-14"><a href="#2021-10-14" class="headerlink" title="2021.10.14"></a>2021.10.14</h2><blockquote><p>2023.11.15： <strong>典。</strong></p></blockquote><ul><li>多次尝试配置基于 gitment 的评论功能，失败<ul><li>卡在无法登录 GitHub 账号进行初始化操作</li><li>Error: Bad credentials</li></ul></li><li>头大</li></ul><div align="center"><img src=https://img12.360buyimg.com/ddimg/jfs/t1/204649/38/11208/214683/6167fdd3E46302051/0af3c7b67f672e8d.png /></div><h2 id="2023-11-15"><a href="#2023-11-15" class="headerlink" title="2023.11.15"></a>2023.11.15</h2><p>❗️博客重大更新</p><p>🐦了两年的博客终于更新了！由于个人审美的变化、前端水平的长进，以前的主题不再适合我，因此我决定另起炉灶。</p><p><strong>我的需求：</strong></p><ol><li>简洁，不要花里胡哨的</li><li>良好支持 markdown</li><li>文章流阅读体验良好</li><li>代码可读性高，遵循软件工程规范，方便我魔改🫣</li></ol><p>精挑细选，最终决定使用 <a href="https://github.com/leedom92/hexo-theme-leedom">leedom</a> 作为新主题，<strong>理由有三</strong></p><ol><li><p>简洁</p></li><li><p>js、css 代码完善，可定制化空间大</p></li><li><p>markdown 渲染效果令人满意</p></li></ol><p>同时，为了满足个人需求，<strong>我做了如下改进</strong>：</p><ol><li><p>将字体改为 <a href="https://tonyxu.io/blog/recommending-lxgw-font/">霞飞文楷</a>。这也是我目前 typora 所在用的字体，非常舒服。</p></li><li><p>调整了首页标题、footer、右侧搜索栏的位置&#x2F;大小等 css。</p></li></ol><p>博客也有<strong>美中不足</strong>：</p><ol><li>markdown 缺少目录</li><li>缺少 About 页面，因此我只能在博文里介绍自己</li></ol><p>不过总体瑕不掩瑜～ 后续有空琢磨琢磨怎么魔改🤕</p>]]></content>
      
      
      
        <tags>
            
            <tag> 维护日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源 Metric 框架调研与 IoTDB Metric 系统性能优化</title>
      <link href="/article/Metric-System/"/>
      <url>/article/Metric-System/</url>
      
        <content type="html"><![CDATA[<p>DropWizard-Metric 和 MicroMeter 项目是 IoTDB Metric 系统的两大 baseline 之一。目前 IoTDB 在启动时分别提供基于 DropWizard-Metric 和 MicroMeter 实现的监控系统供用户选择。</p><p>本文基于 DropWizard-Metric 和 MicroMeter 的系统实现，对比二者实现性能优劣，期望能整合实现出 IoTDB 内部的最优监控系统，对于用户屏蔽算法库选择的参数，探究 IoTDB Metric 性能优化的可能。</p><h1 id="1-系统设计"><a href="#1-系统设计" class="headerlink" title="1. 系统设计"></a>1. 系统设计</h1><ul><li>DropWizard</li></ul><p>DropWizard 组件类型不复杂，核心组件类图如下。后文会对其一一解析。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115143242599.png" alt="image-20231115143242599"></p><ul><li>Micrometer</li></ul><p>在 Micrometer 中，所有监控指标都继承名为<code>Meter</code>的接口。Micrometer 有一组包含各种监控系统实现的模块，其中的每一种实现被称为<code>registry</code>。</p><ol><li>Micrometer提供了与供应商无关的接口，包括 <strong>timers（计时器）</strong>， <strong>gauges（量规）</strong>， <strong>counters（计数器）</strong>， <strong>distribution summaries（分布式摘要）</strong>， <strong>long task timers（长任务定时器）</strong>。它具有维度数据模型，当与维度监视系统结合使用时，可以高效地访问特定的命名度量，并能够跨维度深入研究。</li><li>可以看到，Micrometer 的核心组件、概念等与 DropWizard 类似。但是 Micrometer 组件非常丰富（提供了很多实现），因此类图过于复杂，此处不作赘述，后文将展开分析。</li></ol><h2 id="1-1-核心组件"><a href="#1-1-核心组件" class="headerlink" title="1.1. 核心组件"></a>1.1. 核心组件</h2><h3 id="1-1-1-MetricsRegistry-MeterRegistry"><a href="#1-1-1-MetricsRegistry-MeterRegistry" class="headerlink" title="1.1.1. MetricsRegistry &#x2F; MeterRegistry"></a>1.1.1. MetricsRegistry &#x2F; MeterRegistry</h3><h4 id="DropWizard"><a href="#DropWizard" class="headerlink" title="DropWizard"></a>DropWizard</h4><p>维护所有 Metric 的集合，在 DropWizard 中表现为 <code>MetricSet</code>。</p><p>核心是使用了 <code>private final ConcurrentMap&lt;String, Metric&gt; metrics</code> 维护所有的 Metric，key 是 metric 的 tag 或者 name</p><ol><li>提供了 <code>MetricRegistryListener</code>，目的是为了在子 registry 增加注册 metric 时，通知父 registry，同步添加到 registry 的 <code>ConcurrentHashMap</code> 中</li></ol><blockquote><p>特别设计：所有类型的 metric 共同放在一个 map 里。在 get 具体类型的 map 时，用到了 klass 进行类型判断，同时使用 MetricFilter 封装 name 匹配操作</p></blockquote><ol start="2"><li><p>提供对下面所有 Metric 的增删改查接口；类似 IoTDB 的 MetricService</p></li><li><p>提供了一些 Util 内部类，比如 MetricBuilder、MetricFilter，用来满足面向对象设计，与性能优化关系不大，暂时按下不表。</p></li><li><p>通常，每个应用程序只需要一个 MetricRegistry 实例，但如果想在特定报告组中组织指标，则可以选择使用更多实例。</p></li></ol><h4 id="Micrometer"><a href="#Micrometer" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>Meter 是收集应用的一系列指标的接口。Meter 是由 MeterRegistry 创建的。每个支持的监控系统都必须实现MeterRegistry。 </p><p>Micrometer 中包含一个 <code>SimpleMeterRegistry</code>，它在内存中维护每个 meter 的最新值，并且不将数据导出到任何地方。这是 Micrometer 最简单的注册表形式。 </p><p>但是，在大多数情况下，Micrometer 有专门为各种监控系统设计的 MeterRegistry：如对于 Promethus 来说，它是 <code>PromethusMeterRegistry</code>。</p><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115143317005.png" alt="image-20231115143317005" style="zoom: 25%;" align="center" /></div><p>甚至，我们可以自行继承 MeterRegistry 接口，定制我们需要的 Registry。定制主要出于以下几点考虑：</p><ol><li>重写创建指标组件（Gauge 等）的方法，对于不同的监控场景，自定义创建我们需要的指标组件类型。</li><li>与 Reporter 集成。这样启动 Registry 的同时自动 report，用户无需再特地使用 Report，符合面向对象行为和状态结合的思想。<ol><li>对 IoTDB 意义不大。因为 IoTDB 本来就是单独启动 Reporter 的，并且 IoTDB 的 Reporter 和 Registry 解耦。</li></ol></li></ol><p>Micrometer 还提供一种 <code>CompositeMeterRegistry</code> ，允许添加多个注册表。 它提供了一种将应用程序指标同时发布到各种受支持的监控系统的解决方案。</p><p>IoTDB 原本用的是 <code>globalRegistry</code>（本质上是一个<code>CompositeMeterRegistry</code>），里面套用 <code>SimpleMeterRegistry</code>。实际上可以认为 IoTDB 用的就是 <code>SimpleMeterRegistry</code>。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181326889.png" alt="image-20231115181326889"></p><p>但是由于 globalRegistry 本质上是 CompositeMeterRegistry，它创建具体的指标项时都是创建 CompositeXXX，CompositeXXX 在具体 api 调用时存在额外的调用开销。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181336375.png" alt="image-20231115181336375"></p><p>咨询 IoTDB Metric 系统的负责大佬 hy 后，得知 IoTDB 使用 CompositeRegistry 的初衷是保留后续为不同 MetricSet 分配不同 Registry 的可能，以提高并发度。</p><p>对于这个问题，考虑到 Registry 的功能仅作为 create 具体的指标项，create 动作本身不具有较高的并发，因此认为可以只有一个 Registry。而将不同 MetricSet 进行存储维度上的不同分配可以通过对 Map 进行更细划分实现。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181345900.png" alt="image-20231115181345900"></p><p>因此，考虑将 IoTDB 的 MetricRegistry 简化成 SimpleRegistry，减少每次记录指标时多出来的函数调用开销。</p><p><strong>此外，也可以考虑直接删除对 Micrometer Registry 的依赖</strong>（需要重写 JMX Reporter），因为 IoTDB 已经有一套 metrics 的增删改查和命名系统，与 Registry 的功能重复。删掉 Registry 后能对每个 metric 都避免重复的存储动作，节省一倍内存。代码可读性、可维护性也更好。</p><ul><li><strong>最终采用此种方案，详细实施可见后文</strong></li></ul><h3 id="1-1-2-Gauges"><a href="#1-1-2-Gauges" class="headerlink" title="1.1.2. Gauges"></a>1.1.2. Gauges</h3><h4 id="DropWizard-1"><a href="#DropWizard-1" class="headerlink" title="DropWizard"></a>DropWizard</h4><p>DropWizard 中的 gauge 的默认实现使用：<code>DefaultSettableGauge</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MetricBuilder&lt;Gauge&gt; GAUGES = <span class="keyword">new</span> <span class="title class_">MetricBuilder</span>&lt;Gauge&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Gauge <span class="title function_">newMetric</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSettableGauge</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInstance</span><span class="params">(Metric metric)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Gauge.class.isInstance(metric);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其他类型的 gauge 主要需要关注 <code>CachedGauge</code>，它缓存了 Gauge 中的值，并设置了过期时间。只有当值过期时，才会 reload 值。</p><p>其他的 Gauge 基本都是存取某个对象计算值的方法引用，其效率取决于具体的<code>getValue()</code>方法。</p><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181356236.png" alt="image-20231115181356236" style="zoom:50%;" /></div><h4 id="Micrometer-1"><a href="#Micrometer-1" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>种类比较多，主要用到的是 <code>DefaultGauge</code> 和 <code>CompositeGauge</code></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181423309.png" alt="image-20231115181423309"></p><p>Micrometer 的 gauge 不是将值的计算委托给具体的对象，而是将<strong>获取具体对象和计算值的方法解耦</strong>。如此，gauge 寄存的值不局限于某个对象的某个方法，对象和方法可以解耦，增强了可拓展性。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181433511.png" alt="image-20231115181433511"></p><p><strong>至于性能上</strong>，由于 Micrometer 没有提供缓存版 gauge，因此在涉及读密集且重计算的场景时会有性能问题，预期不如 Dropwizard。<strong>考虑在 IoTDB 实现时加一层缓存进行优化。</strong></p><h3 id="1-1-3-Rate"><a href="#1-1-3-Rate" class="headerlink" title="1.1.3. Rate"></a>1.1.3. Rate</h3><h4 id="DropWizard-2"><a href="#DropWizard-2" class="headerlink" title="DropWizard"></a>DropWizard</h4><p>相当于 Meter，用于度量事件响应的平均速率，它表示的是应用程序整个运行生命周期内的总速率（总请求响应量&#x2F;处理请求的总毫秒数，即每秒请求数）。</p><p>除此之外，Meter 还提供了1分钟、5分钟以及15分钟的动态平均响应速率。</p><p>其实现借助了 <code>MovingAverage</code>。</p><h4 id="Micrometer-2"><a href="#Micrometer-2" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>没有找到 Rate 语义的实现。</p><h3 id="1-1-4-Counter"><a href="#1-1-4-Counter" class="headerlink" title="1.1.4. Counter"></a>1.1.4. Counter</h3><p>Counter 是一个常规计数器，用于对某项指标值进行累加或者递减操作。</p><h4 id="DropWizard-3"><a href="#DropWizard-3" class="headerlink" title="DropWizard"></a>DropWizard</h4><p>Counter 本质是一个 <code>java.util.concurrent.atomic.LongAdder</code>，在多线程同时更新计数器的场景下，当并发量较大时，LongAdder 比 AtomicLong 具有更高的吞吐量，当然空间资源消耗也更大一些。</p><h4 id="Micrometer-3"><a href="#Micrometer-3" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>Micrometer 提供了更多种类的 Counter，基本功能都类似 <code>CumulativeCounter</code>，其他 Counter 的主要区别是拓展了一些和监控系统相关的功能，具体使用哪种与 Registry 有关。IoTDB 目前使用的 <code>SimpleMeterRegistry</code> 使 用 <code>CumulativeCounter</code>。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181503300.png" alt="image-20231115181503300"></p><p>其与 DropWizard 的实现大同小异，**唯一区别是前者使用 <code>DoubleAdder</code>，后者使用 <code>LongAdder</code>**。但是前者最终接口是 long，因此涉及一些转化开销，double 本身的运算开销也较大。因此 DropWizard 性能更好。</p><p><strong>考虑使用</strong> <strong><code>LongAdder</code></strong> <strong>实现 Counter。</strong></p><h3 id="1-1-5-Histogram-DistributionSummary"><a href="#1-1-5-Histogram-DistributionSummary" class="headerlink" title="1.1.5. Histogram &#x2F; DistributionSummary"></a>1.1.5. Histogram &#x2F; DistributionSummary</h3><h4 id="DropWizard-4"><a href="#DropWizard-4" class="headerlink" title="DropWizard"></a>DropWizard</h4><p>Histogram 反应的是数据流中的值的分布情况。包含最小值、最大值、平均值、中位数、p75、p90、p95、p98、p99以及p999数据分布情况。</p><blockquote><p>节选自参考资料：</p><p>传统 Histogram 计算分位数的方法是先对整个数据集进行排序，然后取排序后的数据集中特定位置的值（比如p99就是取倒序1%位置的值）。这种方式适合于小数据集或者批处理系统，不适用于要求高吞吐量、低延时的服务。</p><p>但这样方式保留全部数据后 sort 的方式明显对内存和运算不友好。因此 Dropwizard 使用了另外的随机性算法。</p></blockquote><p>对于数据量较大，系统对吞吐量、时延要求较大的场景，我们可以采用抽样的方式获取数据。（大意是通过保证概率相等的情况下，仅保留一定量的数据）</p><p>上述这种通过动态地抽取程序运行过程中的能够代表系统真实运行情况的一小部分数据来实现对整个系统运行指标的近似度量，这种方法叫做**<a href="https://zhuanlan.zhihu.com/p/29178293">蓄水池算法（reservoir sampling）</a>**。</p><p>DropWizard 中有三种 reservoir，分别简单介绍下：</p><ol><li><strong>UniformReservoir</strong></li></ol><p>内部为<code>DEFAULT_SIZE = 1028</code>的一个数组</p><p>超过大小了则随机丢弃或者不加入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">long</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> count.incrementAndGet();</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= values.length()) &#123;</span><br><span class="line">        values.set((<span class="type">int</span>) c - <span class="number">1</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> ThreadLocalRandom.current().nextLong(c);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; values.length()) &#123;</span><br><span class="line">            values.set((<span class="type">int</span>) r, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来源于这篇论文：**<a href="http://www.cs.umd.edu/~samir/498/vitter.pdf">Vitter’s R</a>**</p><ol start="2"><li><strong>SlidingWindowReservoir</strong></li></ol><p>保留最近的 N 个值，N 可以在构造函数指定</p><p>简单的滑动窗口逻辑，可以理解为用一个 ring buffer 来存储数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">long</span> value)</span> &#123;</span><br><span class="line">    measurements[(<span class="type">int</span>) (count++ % measurements.length)] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>SlidingTimeWindowReservoir</strong></li></ol><p>保留最近 N 秒的数据，N 可以在构造函数指定</p><p>用时间而不是长度来作为滑动窗口的 window size</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">long</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count.incrementAndGet() % TRIM_THRESHOLD == <span class="number">0</span>) &#123;</span><br><span class="line">        trim();</span><br><span class="line">    &#125;</span><br><span class="line">    measurements.put(getTick(), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点是如果瞬间流量很大，该数据结构内存不可控（因为短时间内存入大量数据，且这些数据都在 window 内，短期内不会被丢弃），因此还提供了<code>SlidingTimeWindowArrayReservoir</code>这个替代的基础结构。</p><ol start="4"><li><strong>ExponentiallyDecayingReservoir</strong></li></ol><p><code>MetericRegistry::histogram</code>默认创建为该类型，内部为<code>DEFAULT_SIZE = 1028</code>的一个跳表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MetricBuilder&lt;Histogram&gt; HISTOGRAMS = <span class="keyword">new</span> <span class="title class_">MetricBuilder</span>&lt;Histogram&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Histogram <span class="title function_">newMetric</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Histogram</span>(<span class="keyword">new</span> <span class="title class_">ExponentiallyDecayingReservoir</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInstance</span><span class="params">(Metric metric)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Histogram.class.isInstance(metric);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它基于指数级别的抽样算法，根据更新时间与开始时间的差值转化为权重值，权重越大数据被保留的几率越大。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds an old value with a fixed timestamp to the reservoir.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value     the value to be added</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp the epoch timestamp of &#123;<span class="doctag">@code</span> value&#125; in seconds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">long</span> value, <span class="type">long</span> timestamp)</span> &#123;</span><br><span class="line">        rescaleIfNeeded();</span><br><span class="line">        lockForRegularUsage();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">double</span> <span class="variable">itemWeight</span> <span class="operator">=</span> weight(timestamp - startTime);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">WeightedSample</span> <span class="variable">sample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeightedSample</span>(value, itemWeight);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">double</span> <span class="variable">priority</span> <span class="operator">=</span> itemWeight / ThreadLocalRandom.current().nextDouble();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">newCount</span> <span class="operator">=</span> count.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (newCount &lt;= size || values.isEmpty()) &#123;</span><br><span class="line">                values.put(priority, sample);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Double</span> <span class="variable">first</span> <span class="operator">=</span> values.firstKey();</span><br><span class="line">                <span class="keyword">if</span> (first &lt; priority &amp;&amp; values.putIfAbsent(priority, sample) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// ensure we always remove an item</span></span><br><span class="line">                    <span class="keyword">while</span> (values.remove(first) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        first = values.firstKey();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlockForRegularUsage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体来说，<code>ExponentiallyDecayingReservoir</code> 会定期执行重定标（rescale）操作，以清理旧数据并降低数据的权重，从而达到淘汰数据的目的。</p><p>Rescale 的大致过程是：基于指数衰减公式 <code>exp(-alpha * (startTime - oldStartTime))</code>计算缩放因子，如果缩放因子等于零，说明时间差距太大，直接清空所有的样本数据；否则，遍历所有样本数据，根据缩放因子将每个样本的权重进行缩放，然后将缩放后的样本数据重新插入到数据结构中。</p><p>来源于这篇论文：**<a href="http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf">forward-decaying priority reservoir</a>**</p><h4 id="Micrometer-4"><a href="#Micrometer-4" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>Micrometer 拥有 Histogram 类，然而 IoTDB 使用的是 Micrometer 的 DistributionSummary。</p><ol><li><strong>Histogram 和 DistributionSummary 有什么功能区别？</strong></li></ol><p>实际代码可以看出：Histogram 在 Micrometer 中是作为一种基础组件，而不是一种监控指标。DistributionSummary 集成了 Histogram</p><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181523661.png" alt="image-20231115181523661" style="zoom:50%;"/></div><p>因此使用 DistributionSummary 即可。</p><ol start="2"><li><strong>DistributionSummary 是怎么实现的？</strong></li></ol><p>根据官网我们知道：DistributionSummary 跟 Timer 的实现结构几乎完全一样，只不过记录的不是 time unit 的值。因此可以参考本文 1.2.5 节。</p><p>值得一提的是，Micrometer 的实现借助了 <a href="https://github.com/HdrHistogram/HdrHistogram">HdrHistogram</a> 这款开源 histogram 库，后文会详细介绍。</p><h4 id="HdrHistogram"><a href="#HdrHistogram" class="headerlink" title="HdrHistogram"></a>HdrHistogram</h4><p>HdrHistogram 是一款高性能、高精度 histogram 库。在 Micrometer 的 Histogram 中使用了 HdrHistogram 作为 baseline。</p><h5 id="1-Micrometer-是怎么使用-HdrHistogram-的？"><a href="#1-Micrometer-是怎么使用-HdrHistogram-的？" class="headerlink" title="1.  Micrometer 是怎么使用 HdrHistogram 的？"></a>1.  Micrometer 是怎么使用 HdrHistogram 的？</h5><p>Micrometer 的 Histogram 分为 Abstract 基类和实现类。基类实现了写路径、淘汰旧数据等基本逻辑；实现类实现了读、记录新数据等 api。</p><ul><li>实现类：实际上就是 wrap 了 HdrHistogram 的 DoubleHistogram，在读路径中用到，作为暴露给外界的结果变量使用。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181543798.png" alt="image-20231115181543798"></p><ul><li>基类：有一个 ringBuffer，ringBuffer 的每一项都是一个 Histogram。写路径更新 ringBuffer（下一节将详细描述）， 有一个函数在 takeSnapshot 时把 <code>ringBuffer[currentBucket]</code> 的值 copy 给实现类的 <code>intervalHistogram</code>（见上图），并做后续处理。</li></ul><h5 id="2-Micrometer-是如何结合-HdrHistogram-实现淘汰旧数据的？"><a href="#2-Micrometer-是如何结合-HdrHistogram-实现淘汰旧数据的？" class="headerlink" title="2. Micrometer 是如何结合 HdrHistogram 实现淘汰旧数据的？"></a>2. Micrometer 是如何结合 HdrHistogram 实现淘汰旧数据的？</h5><ul><li>首先，Micrometer 用一个 ringBuffer 来存储数据。ringBuffer 的每一项就是一个 HdrHistogram（<code>org.HdrHistogram.DoubleRecorder</code>）</li><li>当导出 Snapshot 的时候，用到的是 <code>currrentBucket</code> 指针指向的 buffer。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181608771.png" alt="image-20231115181608771"></p><ul><li>Micrometer 每次插入数据的时候，会往 ringBuffer 中的所有 buffer 插入数据（后文会解释「为什么要向所有的 buffer 插入数据」）</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181619688.png" alt="image-20231115181619688"></p><ul><li>Micrometer 在每次插入新数据前，会调用 <code>rotate()</code> 方法。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181630199.png" alt="image-20231115181630199"></p><ul><li><p><strong>rotate() 方法实现了淘汰旧数据</strong>。逻辑如下：</p></li><li><p>如果上一次淘汰数据到现在的累积时间超过了阈值（该阈值可以通过 config 设置，即 IoTDB metric core 代码里设置的 expiry，默认 1 分钟），那么即实行淘汰策略：reset（清空）  <code>currrentBucket</code> 指向的 buffer，并将 buffer 指针（ <code>currrentBucket</code> ）后移。</p></li><li><p>之后新数据到来时，Micrometer 会向 ringBuffer 中的所有 buffer 插入新数据。但由于某些 buffer 已经被清空过了，因此它们就会只保存后面插入的新数据</p></li><li><p>由于 Micrometer 真正用到的 histogram 是 <code>currrentBucket</code> 指针指向的 buffer，而每次 rotate 会将 <code>currrentBucket</code> 指针后移，因此相当于不断给予保存新数据 buffer 更高的权重。</p></li><li><p>综上，如此就巧妙的达到了淘汰旧数据的目标。可以看出：相比于 DropWizard 每次淘汰旧数据时对跳表的复杂操作，Micrometer 的 rotate 开销不大，再配合 HdrHistogram 本身静态分桶的高写入速度（后文会提到），Micrometer 就实现了比 DropWizard 更好的（写）性能。</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181650099.png" alt="image-20231115181650099"></p><ul><li><strong>可优化点思考：</strong>从前面分析可以看到，Micrometer 在每次写入数据时，对 ringBuffer 的所有 bucket 都进行了写入操作。那么是否可以通过缩小 ringBuffer 的 size，从而减少写 bucket 次数，来提高 Micrometer Histogram 的写入效率？需要研究下 ringBuffer.length 的设置原理。<ul><li>ringBuffer.length 默认设置为 3。根据上文，只要保证 ringBuffer.length 大于 1 既能保证淘汰旧数据的目的。因此考虑将 ringBuffer.length 设为 2（<strong>PR</strong>: <a href="https://github.com/apache/iotdb/pull/11500%EF%BC%89">https://github.com/apache/iotdb/pull/11500）</a></li></ul></li></ul><h5 id="3-HdrHistogram-的设计思路和算法有哪些？"><a href="#3-HdrHistogram-的设计思路和算法有哪些？" class="headerlink" title="3. HdrHistogram 的设计思路和算法有哪些？"></a>3. HdrHistogram 的设计思路和算法有哪些？</h5><p>不同于前文提到 DropWizard 使用的随机性算法实现（淘汰旧数据），HdrHistogram 使用的是<strong>确定性算法</strong>。</p><p>确定性算法本质上就是静态分桶，有点类似压缩存储的思想。<strong>用容器将所有遇到的数据全部保存起来</strong>，<strong>实际上不需要将每个值都存下来，但结果也不是精确解。</strong>以达到 Histogram 所需要的计算分位数等功能。但 HdrHistogram 不是一个数字一个桶，而是一个区间一个桶。该区间的范围可以是线性增长，也可指数增长。<strong>通过一个区间分一个桶</strong>的方式， 就能通过牺牲一小部分精度，从而达到减小空间占用，并且数据大致准确的结果。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181702444.png" alt="image-20231115181702444"></p><h5 id="4-HdrHistogram-具体是如何分割区间的？"><a href="#4-HdrHistogram-具体是如何分割区间的？" class="headerlink" title="4. HdrHistogram 具体是如何分割区间的？"></a>4. HdrHistogram 具体是如何分割区间的？</h5><p>前面提到，HdrHistogram 不是一个数字一个桶，而是一个区间一个桶。该区间的范围可以是线性增长，也可指数增长。现在假设有值域为 [0..R] 的区间</p><ul><li>对于线性分桶：也就是对于 0..R 如果用 B 分隔， 那么总共可以分隔 R&#x2F;B 个格子，数组的size也是 R&#x2F;B</li><li>对于指数分桶，也就是基于指数分隔（2 的幂次），第一个桶有 2^0 个数，第二个桶有 2^1 个数… 第 n 个桶有 2^(n-1) 个数。</li></ul><p>举个例子，比如 10w 个数字：</p><p>采用线性的分桶方法，假设每个 bucket 可以表示100个值，那么需要 1000 个 buckets, : <code>[1..100][101..200]...[99,901..100,000]</code></p><p>采用指数的分桶方式，只需要 17 个 buckets， <code>[2^K..(2^(K+1)-1)]</code> e.g. <code>[1..1][2..3][4..7]...[65,536..131,071]</code></p><p>这里 HdrHistogram 用了一个 trick：</p><p>对于分隔 buckets，HdrHistogram 同时采用了线性和指数，HdrHistogram 内部有2个 index，<code>bucketsIdx</code> 和 <code>subBucketIndex</code>. 前者是指数的，后者是线性的。可以根据业务精度需求控制后面的线性的大小。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181715521.png" alt="image-20231115181715521"></p><p>首先，所谓「分桶」就是一个 long 数组。数组的每一项就是一个桶，其意义是：统计某个区间内数据出现的次数。分桶策略决定了数组的每一项统计的区间范围是多少。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181730237.png" alt="image-20231115181730237"></p><p>具体来说，HdrHistogram 的分桶策略是<strong>指数和线性结合</strong>：</p><p>HdrHistogram 先将需要统计的总区间通过 2 的幂次指数分成 n 个桶<em>（如果区间长度为 l，即保证 2^(n-1) &gt;&#x3D; l）</em>，此时标识这些桶的 index 就叫 <code>bucketIndex</code>。而每个桶又分为 <code>subBucketCount</code> 个子桶（<code>subBucketCount</code> 是可间接配置的），这些子桶的下标就叫做 <code>subBucketIndex</code>。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181756401.png" alt="image-20231115181756401"></p><p><strong>举个例子，</strong>每个桶有 <code>subBucketCount</code> 个子桶，这里假设为 2048 ，那么第 1 个桶可以以 2^0 的精度表示 2^0 * 0 ~ 2^0 * 2048，即第 1 个桶可以覆盖区间 [0, 2048]，且每个子桶可以覆盖 1 个值（精度是 2^0 &#x3D; 1）。</p><p>这里就有一个<strong>「桶重叠」(bucket overlap)</strong> 的问题。首先我们给出结论：</p><ul><li>第 0 个桶以 2^0 &#x3D; 1 的精度覆盖 0…2047，使用所有 2048 个子桶</li><li>第 1 个桶以 2^1 &#x3D; 2 的精度，理论上能覆盖 0… 4095，但仅使用顶部 1024 个子桶，实际上覆盖 2048..4095</li><li>第 2 个桶以 2^2 &#x3D; 4 的精度，理论上能覆盖 0… 8191，但仅使用顶部 1024 个子桶，实际上覆盖 4096..8191</li></ul><p>为什么 Bucket 0 是唯一使用 2048 个子桶的，而其余桶都只使用 1024 个子桶呢？</p><ul><li>因为它们的下半部分与前面所有的存储桶重叠并且已经被覆盖：<ul><li>举个例子，第 k 个桶可以以 2^k 精度表示 2048 个子桶，覆盖区间为 0 * 2^k 到 2048 * 2^k</li><li>但是第 k 个桶的中点：1024 * 2^k &#x3D; 2048 * 2^(k-1) &#x3D; 第 k-1 个存储桶的末尾，因此我们将使用前一个存储桶（第 k-1 个桶）来存储第 k 个桶起点 ～ 第 k 个桶中点的值，<strong>因为它具有更好的精度（即子桶存储的区间范围更小）</strong>。</li></ul></li></ul><p>那么当一个数据被插入，实际计算其下标时，就是结合上述分桶原理，计算它所在的桶（bucketIndex）和子桶（subBucketIndex），二者经过一些简单组合运算后得到最终下标，可以参考代码：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181812492.png" alt="image-20231115181812492"></p><p><strong>这样分桶的好处是：</strong></p><ul><li>如果纯线性分桶，那么显然空间占用过大；如果纯指数分桶，又会有精度的问题。二者结合，可以较好的解决线性分桶空间占用的问题，一定程度上优化指数分桶精度的问题。整个分桶思想有点类似压缩存储，将所有数据保存起来，但是不保存具体的值。在舍弃一点精度的情况下省下大量内存。</li><li>前文提到，<code>subBucketCount</code> 是可配置的。因此我们可以根据业务精度需求，控制线性分桶的精度大小，比较灵活。（线性分桶数越大，精度越大，所占内存越大）<ul><li>这也就是 Histogram 构造函数第二个参数的含义：它与 <code>subBucketCount</code> 有关。<ul><li><p>该参数与 <code>subBucketCount</code> 的转换逻辑如下</p></li><li><pre><code class="Java">static int numberOfSubBuckets(final int numberOfSignificantValueDigits) &#123;    final long largestValueWithSingleUnitResolution = 2 * (long) Math.pow(10, numberOfSignificantValueDigits);    // We need to maintain power-of-two subBucketCount (for clean direct indexing) that is large enough to    // provide unit resolution to at least largestValueWithSingleUnitResolution. So figure out    // largestValueWithSingleUnitResolution&#39;s nearest power-of-two (rounded up), and use that:    int subBucketCountMagnitude = (int) Math.ceil(Math.log(largestValueWithSingleUnitResolution)/Math.log(2));    int subBucketCount = (int) Math.pow(2, subBucketCountMagnitude);    return subBucketCount;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 该参数值域为 0-5，分别对应 `subBucketCount` 为：</span><br><span class="line">- ```Plain</span><br><span class="line">  0 - 2</span><br><span class="line">  1 - 32</span><br><span class="line">  2 - 256</span><br><span class="line">  3 - 2048</span><br><span class="line">  4 - 32768</span><br><span class="line">  5 - 262144</span><br></pre></td></tr></table></figure></code></pre></li><li><p>该参数 IoTDB metric core 里默认配置的是 1（值域为 0 - 5，数字越大，<code>subBucketCount</code> 越大），最终会导致 <code>subBucketCount</code> 为 32</p></li></ul></li><li><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181825941.png" alt="image-20231115181825941"></li></ul></li></ul><h5 id="5-HdrHistogram-的-resize-机制"><a href="#5-HdrHistogram-的-resize-机制" class="headerlink" title="5. HdrHistogram 的 resize 机制"></a>5. HdrHistogram 的 resize 机制</h5><p>当然以上都有个缺点，需要一个可预估的最大值（可以理解为 HdrHistogram 统计区间的最大值）。如果有超过最大值的数字（即数据大小超过了 HdrHistogram 的统计区间）</p><ol><li>如果没有设置 <code>autoResize</code>，将抛出异常，存入失败。</li><li>如果设置了 <code>autoResize</code>，将 resize 区间（重新设置区间范围并重新分桶）</li><li>默认 <code>autoSize</code> 为 true</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115181836431-20231115181956661.png"></p><ul><li><code>autoResize</code> 是 Histogram 类里面的一个可设置参数</li></ul><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182017944.png" alt="image-20231115182017944" style="zoom: 33%;" /><h5 id="6-HdrHistogram-如何确定统计区间的上下界？"><a href="#6-HdrHistogram-如何确定统计区间的上下界？" class="headerlink" title="6. HdrHistogram 如何确定统计区间的上下界？"></a>6. HdrHistogram 如何确定统计区间的上下界？</h5><p>答案：通过构造函数设定。</p><p>可以清晰的看到 Histogram 类的构造函数参数含义</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182041701.png" alt="image-20231115182041701"></p><p>但 Micrometer（IoTDB）中不是直接调用该构造函数，跟进发现调用的构造函数是：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182051030.png" alt="image-20231115182051030"></p><p>其中，<code>highestToLowestValueRatio</code> 和 <code>numberOfSignificantValueDigits</code> 共同确定了 hdrHistogram 的上下界。跟进发现最终上下界为 <strong>[1, 127]</strong></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182059931.png" alt="image-20231115182059931"></p><ul><li><strong>可优化点思考：</strong>从前面分析可以看到，当数据超过 hdrHistogram 范围时，会发生 resize，该操作有时间开销。目前的上下界 [1, 127] 显然范围有点小了，在大值数据场景下显然要 resize，甚至多次 resize。我们是否可以对每一个 timer&#x2F;histogram 的使用场景预估数据区间，为每一个 timer&#x2F;histogram 定制数据上下界，尽量避免 resize 操作。<ul><li>由于 Micrometer 没有暴露定制化 hdrHistogram 区间范围的 API，该改动阻塞。已向他们提 issue（<a href="https://github.com/micrometer-metrics/micrometer/issues/4327%EF%BC%89">https://github.com/micrometer-metrics/micrometer/issues/4327）</a></li></ul></li></ul><h5 id="7-HdrHistogram-和-DropWizard-优劣分析"><a href="#7-HdrHistogram-和-DropWizard-优劣分析" class="headerlink" title="7. HdrHistogram 和 DropWizard 优劣分析"></a>7. HdrHistogram 和 DropWizard 优劣分析</h5><ul><li>写入速度：Hdr 远优于 DropWizard<ul><li>正是因为 HdrHistogram 是静态分桶实现，所以写入友好（不需要淘汰旧数据），在<a href="https://apache-iotdb.feishu.cn/docx/P5svdKZTxoVtqax0mgvcCeYInQe#OglwdZfPEoTKbmx11ywcLMS5nhf"> record</a> 性能测试中比 DropWizard 表现要好。</li><li>HdrHistogram 底层是数组，而 DropWizard 底层是跳表，数组肯定比跳表写入快。</li><li>DropWizard 默认设置是每隔一段时间要 rescale 一下，而 rescale 是要锁写的。</li></ul></li><li>读取速度：二者差不多<ul><li>因为都是给定了分位数，相当于给定数组下标&#x2F;跳表 key 了，直接读取基本都是 O(1)</li></ul></li><li>空间占用：需要具体分析。因为 HdrHistogram 可以通过指数分桶减少空间占用，而 DropWizard 的空间占用也和用户指定的容器大小有关，所以直观上不太好说谁空间占用更好，需要结合具体场景分析。</li></ul><h3 id="1-1-6-Timer"><a href="#1-1-6-Timer" class="headerlink" title="1.1.6. Timer"></a>1.1.6. Timer</h3><h4 id="DropWizard-5"><a href="#DropWizard-5" class="headerlink" title="DropWizard"></a>DropWizard</h4><p>Timer 相当于 Meter + Histogram（默认使用 <code>ExponentiallyDecayingReservoir</code>）。可以统计接口请求速率和响应时长。会度量服务的响应速率，同时也会统计服务响应时长的分布情况。</p><blockquote><p>可以说，Timer 能兼容 Meter + Histogram 的所有接口。</p></blockquote><p>因此 Timer 底层的 update 主要也就是更新 Histogram 和 Meter。</p><h4 id="Micrometer-5"><a href="#Micrometer-5" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>Timer 用于度量短时间内的事件时延和响应频率。所有的 Timer 实现都记录了事件响应总耗时和事件总数。Timer 不支持负数，此外如果使用它来记录大批量、长时延事件的话，容易导致指标值数据越界（超过<code>Long.MAX_VALUE</code>）。</p><p>同样，Micrometer 为每种监控系统设计了不同的 Timer，主要用的是 <code>CumulativeTimer</code>。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182117259.png" alt="image-20231115182117259"></p><p>Micrometer 的 Timer 相当于 Histogram + 自己实现的计时器（用 AtomicLong 累计 nanoTime 等）。每次 Record 时会更新 Histogram 并更新自己实现的计时器。</p><h2 id="1-2-Reporter"><a href="#1-2-Reporter" class="headerlink" title="1.2. Reporter"></a>1.2. Reporter</h2><p>用于将 metric 指标数据导出到具体的某个介质。</p><p>IoTDB 主要使用了 IoTDBReporter、PrometheusReporter、JMXReporter 三种。因此本文主要探究 DropWizard 中对应的 InfluxDBReporter、GraphiteReporter、JMXReporter 三种 Reporter</p><h3 id="1-2-1-InfluxDBReporter"><a href="#1-2-1-InfluxDBReporter" class="headerlink" title="1.2.1. InfluxDBReporter"></a>1.2.1. InfluxDBReporter</h3><ul><li><strong>设计思想：</strong> InfluxDB 报告器的设计思想是将度量数据发送到 InfluxDB，以便进行高性能的存储和查询。</li><li><strong>具体实现：</strong> InfluxDB 报告器使用 HTTP 协议将度量数据发送到 InfluxDB 服务器。它将度量名称、值和标签（tags）映射到 InfluxDB 中的数据点，并将其存储在数据库中。</li></ul><h3 id="1-2-2-GraphiteReporter"><a href="#1-2-2-GraphiteReporter" class="headerlink" title="1.2.2. GraphiteReporter"></a>1.2.2. GraphiteReporter</h3><ul><li><strong>设计思想：</strong> Graphite报告器的设计思想是将度量数据发送到Graphite，一个可扩展的度量数据存储和可视化工具，以便长期存储和绘制度量图表。</li><li><strong>具体实现：</strong> Graphite报告器使用TCP或UDP协议将度量数据发送到Graphite服务器。它将度量名称和值映射到Graphite中的度量路径，并定期将数据发送到服务器。</li></ul><h3 id="1-2-3-JMXReporter"><a href="#1-2-3-JMXReporter" class="headerlink" title="1.2.3. JMXReporter"></a>1.2.3. JMXReporter</h3><ul><li><strong>设计思想：</strong> 将 Metric 注册为 MBean，随后将度量数据以Java管理扩展（JMX）的方式导出，以便通过JMX客户端监视和管理应用程序。</li><li><strong>具体实现：</strong> 将度量数据注册到JMX服务器中，然后可以使用JMX客户端连接到服务器，查看和管理度量数据。实现了 JMXListener（本质上也是个 MetricRegistry，监听主 Registry）<ul><li>每次 registry 创建了一个 metric 对象后，在 JMX 中深 clone 一份 JMXMetric，并将其注册为 MBean</li></ul></li></ul><h1 id="2-性能测试"><a href="#2-性能测试" class="headerlink" title="2. 性能测试"></a>2. 性能测试</h1><p>本节主要目的是全面测试对比 Micrometer 和 DropWizard 的性能优劣，从而在算法库参数上做出取舍。</p><p>By JMH benchmark</p><h2 id="2-1-Counter"><a href="#2-1-Counter" class="headerlink" title="2.1. Counter"></a>2.1. Counter</h2><p><strong>测试代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.codahale.metrics.MetricRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.Counter;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.MeterRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.dropwizard.DropwizardCounter;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.prometheus.PrometheusConfig;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.prometheus.PrometheusMeterRegistry;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 Benchmark，测试多线程性能</span></span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterBenchmark</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">            .include(CounterBenchmark.class.getSimpleName())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MeterRegistry micrometerRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MetricRegistry dropwizardRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Counter micrometerCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> com.codahale.metrics.Counter dropwizardCounter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        micrometerRegistry = <span class="keyword">new</span> <span class="title class_">SimpleMeterRegistry</span>();;</span><br><span class="line">        micrometerCounter = micrometerRegistry.counter(<span class="string">&quot;micrometerCounter&quot;</span>);</span><br><span class="line"></span><br><span class="line">        dropwizardRegistry = <span class="keyword">new</span> <span class="title class_">MetricRegistry</span>();</span><br><span class="line">        dropwizardCounter = dropwizardRegistry.counter(<span class="string">&quot;dropwizardCounter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dropwizardCountSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            dropwizardCounter.inc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">micrometerCountSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            micrometerCounter.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; Task :micrometer-benchmarks-core:CounterBenchmark.main()</span><br><span class="line"><span class="comment"># JMH version: 1.37</span></span><br><span class="line"><span class="comment"># VM version: JDK 17.0.8.1, OpenJDK 64-Bit Server VM, 17.0.8.1+8-LTS</span></span><br><span class="line"><span class="comment"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-17.0.8.1/Contents/Home/bin/java</span></span><br><span class="line"><span class="comment"># VM options: -Dfile.encoding=UTF-8 -Duser.country=CN -Duser.language=zh -Duser.variant</span></span><br><span class="line"><span class="comment"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)</span></span><br><span class="line"><span class="comment"># Warmup: 1 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Measurement: 2 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Timeout: 10 min per iteration</span></span><br><span class="line"><span class="comment"># Threads: 1 thread, will synchronize iterations</span></span><br><span class="line"><span class="comment"># Benchmark mode: Average time, time/op</span></span><br><span class="line"><span class="comment"># Benchmark: io.micrometer.benchmark.core.CounterBenchmark.dropwizardCountSum</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 0.00% complete, ETA 00:05:00</span></span><br><span class="line"><span class="comment"># Fork: 1 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 504.794 ns/op</span></span><br><span class="line">Iteration   1: 506.459 ns/op</span><br><span class="line">Iteration   2: 506.261 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 10.00% complete, ETA 00:04:31</span></span><br><span class="line"><span class="comment"># Fork: 2 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 506.972 ns/op</span></span><br><span class="line">Iteration   1: 505.873 ns/op</span><br><span class="line">Iteration   2: 498.922 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 20.00% complete, ETA 00:04:01</span></span><br><span class="line"><span class="comment"># Fork: 3 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 506.325 ns/op</span></span><br><span class="line">Iteration   1: 506.829 ns/op</span><br><span class="line">Iteration   2: 504.362 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 30.00% complete, ETA 00:03:32</span></span><br><span class="line"><span class="comment"># Fork: 4 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 503.179 ns/op</span></span><br><span class="line">Iteration   1: 503.631 ns/op</span><br><span class="line">Iteration   2: 518.545 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 40.00% complete, ETA 00:03:01</span></span><br><span class="line"><span class="comment"># Fork: 5 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 509.092 ns/op</span></span><br><span class="line">Iteration   1: 509.741 ns/op</span><br><span class="line">Iteration   2: 505.743 ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.CounterBenchmark.dropwizardCountSum&quot;</span>:</span><br><span class="line">  506.637 ±(99.9%) 7.589 ns/op [Average]</span><br><span class="line">  (min, avg, max) = (498.922, 506.637, 518.545), stdev = 5.020</span><br><span class="line">  CI (99.9%): [499.048, 514.225] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># JMH version: 1.37</span></span><br><span class="line"><span class="comment"># VM version: JDK 17.0.8.1, OpenJDK 64-Bit Server VM, 17.0.8.1+8-LTS</span></span><br><span class="line"><span class="comment"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-17.0.8.1/Contents/Home/bin/java</span></span><br><span class="line"><span class="comment"># VM options: -Dfile.encoding=UTF-8 -Duser.country=CN -Duser.language=zh -Duser.variant</span></span><br><span class="line"><span class="comment"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)</span></span><br><span class="line"><span class="comment"># Warmup: 1 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Measurement: 2 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Timeout: 10 min per iteration</span></span><br><span class="line"><span class="comment"># Threads: 1 thread, will synchronize iterations</span></span><br><span class="line"><span class="comment"># Benchmark mode: Average time, time/op</span></span><br><span class="line"><span class="comment"># Benchmark: io.micrometer.benchmark.core.CounterBenchmark.micrometerCountSum</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 50.00% complete, ETA 00:02:31</span></span><br><span class="line"><span class="comment"># Fork: 1 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 761.443 ns/op</span></span><br><span class="line">Iteration   1: 750.091 ns/op</span><br><span class="line">Iteration   2: 717.163 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 60.00% complete, ETA 00:02:01</span></span><br><span class="line"><span class="comment"># Fork: 2 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 730.985 ns/op</span></span><br><span class="line">Iteration   1: 786.655 ns/op</span><br><span class="line">Iteration   2: 583.315 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 70.00% complete, ETA 00:01:30</span></span><br><span class="line"><span class="comment"># Fork: 3 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 564.985 ns/op</span></span><br><span class="line">Iteration   1: 567.606 ns/op</span><br><span class="line">Iteration   2: 675.625 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 80.00% complete, ETA 00:01:00</span></span><br><span class="line"><span class="comment"># Fork: 4 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 626.955 ns/op</span></span><br><span class="line">Iteration   1: 560.499 ns/op</span><br><span class="line">Iteration   2: 692.164 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 90.00% complete, ETA 00:00:30</span></span><br><span class="line"><span class="comment"># Fork: 5 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 720.045 ns/op</span></span><br><span class="line">Iteration   1: 733.850 ns/op</span><br><span class="line">Iteration   2: 753.365 ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.CounterBenchmark.micrometerCountSum&quot;</span>:</span><br><span class="line">  682.033 ±(99.9%) 125.825 ns/op [Average]</span><br><span class="line">  (min, avg, max) = (560.499, 682.033, 786.655), stdev = 83.225</span><br><span class="line">  CI (99.9%): [556.208, 807.858] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run complete. Total time: 00:05:02</span></span><br><span class="line"></span><br><span class="line">REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on</span><br><span class="line">why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial</span><br><span class="line">experiments, perform baseline and negative tests that provide experimental control, make sure</span><br><span class="line">the benchmarking environment is safe on JVM/OS/HW level, ask <span class="keyword">for</span> reviews from the domain experts.</span><br><span class="line">Do not assume the numbers tell you what you want them to tell.</span><br><span class="line"></span><br><span class="line">NOTE: Current JVM experimentally supports Compiler Blackholes, and they are <span class="keyword">in</span> use. Please exercise</span><br><span class="line">extra caution when trusting the results, look into the generated code to check the benchmark still</span><br><span class="line">works, and <span class="built_in">factor</span> <span class="keyword">in</span> a small probability of new VM bugs. Additionally, <span class="keyword">while</span> comparisons between</span><br><span class="line">different JVMs are already problematic, the performance difference caused by different Blackhole</span><br><span class="line">modes can be very significant. Please make sure you use the consistent Blackhole mode <span class="keyword">for</span> comparisons.</span><br><span class="line"></span><br><span class="line">Benchmark                            Mode  Cnt    Score     Error  Units</span><br><span class="line">CounterBenchmark.dropwizardCountSum  avgt   10  506.637 ±   7.589  ns/op</span><br><span class="line">CounterBenchmark.micrometerCountSum  avgt   10  682.033 ± 125.825  ns/op</span><br></pre></td></tr></table></figure><p>结论：Dropwizard 性能优于 Micrometer，比例约为20%</p><h2 id="2-2-Gauge"><a href="#2-2-Gauge" class="headerlink" title="2.2. Gauge"></a>2.2. Gauge</h2><p>二者都是寄存某个对象值，在需要取的时候进行更新。其性能取决于具体的 <code>get()</code> 函数，故此处不做测试。</p><p>PS：DropWizard 使用了 CachedGauge，在计算密集的场景下会拥有更好的性能</p><h2 id="2-3-Histogram"><a href="#2-3-Histogram" class="headerlink" title="2.3. Histogram"></a>2.3. Histogram</h2><p><strong>测试代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.codahale.metrics.Histogram;</span><br><span class="line"><span class="keyword">import</span> com.codahale.metrics.MetricRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.DistributionSummary;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.MeterRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.Tag;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.Tags;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.simple.SimpleMeterRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.prometheus.PrometheusConfig;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.prometheus.PrometheusMeterRegistry;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 Benchmark，测试多线程性能</span></span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HistogramBenchmark</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">            .include(HistogramBenchmark.class.getSimpleName())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MeterRegistry micrometerRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MetricRegistry dropwizardRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Histogram dropwizardHistogram;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DistributionSummary micrometerHistogram;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Tags</span> <span class="variable">tags</span> <span class="operator">=</span> Tags.of(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>, <span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>, <span class="string">&quot;key5&quot;</span>, <span class="string">&quot;value5&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        micrometerRegistry = <span class="keyword">new</span> <span class="title class_">SimpleMeterRegistry</span>();</span><br><span class="line">        micrometerHistogram =</span><br><span class="line">            io.micrometer.core.instrument.DistributionSummary.builder(<span class="string">&quot;micrometerHistogram&quot;</span>)</span><br><span class="line">                .tags(tags)</span><br><span class="line">                .publishPercentiles(<span class="number">0.5</span>, <span class="number">0.99</span>)</span><br><span class="line">                .register(micrometerRegistry);</span><br><span class="line"></span><br><span class="line">        dropwizardRegistry = <span class="keyword">new</span> <span class="title class_">MetricRegistry</span>();</span><br><span class="line">        dropwizardHistogram = dropwizardRegistry.histogram(<span class="string">&quot;dropwizardHistogram&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dropwizardRecord</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            dropwizardHistogram.update(i);</span><br><span class="line">            dropwizardHistogram.getCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">micrometerRecord</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            micrometerHistogram.record(i);</span><br><span class="line">            micrometerHistogram.count();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># JMH version: 1.37</span></span><br><span class="line"><span class="comment"># VM version: JDK 17.0.8.1, OpenJDK 64-Bit Server VM, 17.0.8.1+8-LTS</span></span><br><span class="line"><span class="comment"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-17.0.8.1/Contents/Home/bin/java</span></span><br><span class="line"><span class="comment"># VM options: -Dfile.encoding=UTF-8 -Duser.country=CN -Duser.language=zh -Duser.variant</span></span><br><span class="line"><span class="comment"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)</span></span><br><span class="line"><span class="comment"># Warmup: 1 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Measurement: 2 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Timeout: 10 min per iteration</span></span><br><span class="line"><span class="comment"># Threads: 1 thread, will synchronize iterations</span></span><br><span class="line"><span class="comment"># Benchmark mode: Average time, time/op</span></span><br><span class="line"><span class="comment"># Benchmark: io.micrometer.benchmark.core.HistogramBenchmark.dropwizardRecord</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 0.00% complete, ETA 00:05:00</span></span><br><span class="line"><span class="comment"># Fork: 1 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:22:52.331 [io.micrometer.benchmark.core.HistogramBenchmark.dropwizardRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">10174.613 ns/op</span><br><span class="line">Iteration   1: 9998.056 ns/op</span><br><span class="line">Iteration   2: 10828.580 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 10.00% complete, ETA 00:04:32</span></span><br><span class="line"><span class="comment"># Fork: 2 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:23:22.545 [io.micrometer.benchmark.core.HistogramBenchmark.dropwizardRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">10024.374 ns/op</span><br><span class="line">Iteration   1: 9990.595 ns/op</span><br><span class="line">Iteration   2: 10488.892 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 20.00% complete, ETA 00:04:01</span></span><br><span class="line"><span class="comment"># Fork: 3 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:23:52.910 [io.micrometer.benchmark.core.HistogramBenchmark.dropwizardRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">10204.101 ns/op</span><br><span class="line">Iteration   1: 10101.247 ns/op</span><br><span class="line">Iteration   2: 10982.767 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 30.00% complete, ETA 00:03:31</span></span><br><span class="line"><span class="comment"># Fork: 4 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:24:23.120 [io.micrometer.benchmark.core.HistogramBenchmark.dropwizardRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">9942.547 ns/op</span><br><span class="line">Iteration   1: 10305.283 ns/op</span><br><span class="line">Iteration   2: 10703.590 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 40.00% complete, ETA 00:03:01</span></span><br><span class="line"><span class="comment"># Fork: 5 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:24:53.335 [io.micrometer.benchmark.core.HistogramBenchmark.dropwizardRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">9863.582 ns/op</span><br><span class="line">Iteration   1: 9955.748 ns/op</span><br><span class="line">Iteration   2: 10482.406 ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.HistogramBenchmark.dropwizardRecord&quot;</span>:</span><br><span class="line">  10383.716 ±(99.9%) 563.945 ns/op [Average]</span><br><span class="line">  (min, avg, max) = (9955.748, 10383.716, 10982.767), stdev = 373.015</span><br><span class="line">  CI (99.9%): [9819.771, 10947.662] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># JMH version: 1.37</span></span><br><span class="line"><span class="comment"># VM version: JDK 17.0.8.1, OpenJDK 64-Bit Server VM, 17.0.8.1+8-LTS</span></span><br><span class="line"><span class="comment"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-17.0.8.1/Contents/Home/bin/java</span></span><br><span class="line"><span class="comment"># VM options: -Dfile.encoding=UTF-8 -Duser.country=CN -Duser.language=zh -Duser.variant</span></span><br><span class="line"><span class="comment"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)</span></span><br><span class="line"><span class="comment"># Warmup: 1 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Measurement: 2 iterations, 10 s each</span></span><br><span class="line"><span class="comment"># Timeout: 10 min per iteration</span></span><br><span class="line"><span class="comment"># Threads: 1 thread, will synchronize iterations</span></span><br><span class="line"><span class="comment"># Benchmark mode: Average time, time/op</span></span><br><span class="line"><span class="comment"># Benchmark: io.micrometer.benchmark.core.HistogramBenchmark.micrometerRecord</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 50.00% complete, ETA 00:02:31</span></span><br><span class="line"><span class="comment"># Fork: 1 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:25:23.556 [io.micrometer.benchmark.core.HistogramBenchmark.micrometerRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">6960.654 ns/op</span><br><span class="line">Iteration   1: 6775.768 ns/op</span><br><span class="line">Iteration   2: 6614.436 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 60.00% complete, ETA 00:02:00</span></span><br><span class="line"><span class="comment"># Fork: 2 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:25:53.835 [io.micrometer.benchmark.core.HistogramBenchmark.micrometerRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">6919.224 ns/op</span><br><span class="line">Iteration   1: 6918.534 ns/op</span><br><span class="line">Iteration   2: 6843.185 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 70.00% complete, ETA 00:01:30</span></span><br><span class="line"><span class="comment"># Fork: 3 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:26:24.055 [io.micrometer.benchmark.core.HistogramBenchmark.micrometerRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">6957.126 ns/op</span><br><span class="line">Iteration   1: 6853.690 ns/op</span><br><span class="line">Iteration   2: 6840.857 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 80.00% complete, ETA 00:01:00</span></span><br><span class="line"><span class="comment"># Fork: 4 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:26:54.287 [io.micrometer.benchmark.core.HistogramBenchmark.micrometerRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">6924.513 ns/op</span><br><span class="line">Iteration   1: 6958.296 ns/op</span><br><span class="line">Iteration   2: 6813.379 ns/op</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run progress: 90.00% complete, ETA 00:00:30</span></span><br><span class="line"><span class="comment"># Fork: 5 of 5</span></span><br><span class="line"><span class="comment"># Warmup Iteration   1: 15:27:24.499 [io.micrometer.benchmark.core.HistogramBenchmark.micrometerRecord-jmh-worker-1] DEBUG io.micrometer.common.util.internal.logging.InternalLoggerFactory - Using SLF4J as the default logging framework</span></span><br><span class="line">7021.623 ns/op</span><br><span class="line">Iteration   1: 6887.827 ns/op</span><br><span class="line">Iteration   2: 6698.237 ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.HistogramBenchmark.micrometerRecord&quot;</span>:</span><br><span class="line">  6820.421 ±(99.9%) 155.021 ns/op [Average]</span><br><span class="line">  (min, avg, max) = (6614.436, 6820.421, 6958.296), stdev = 102.537</span><br><span class="line">  CI (99.9%): [6665.400, 6975.442] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run complete. Total time: 00:05:02</span></span><br><span class="line"></span><br><span class="line">REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on</span><br><span class="line">why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial</span><br><span class="line">experiments, perform baseline and negative tests that provide experimental control, make sure</span><br><span class="line">the benchmarking environment is safe on JVM/OS/HW level, ask <span class="keyword">for</span> reviews from the domain experts.</span><br><span class="line">Do not assume the numbers tell you what you want them to tell.</span><br><span class="line"></span><br><span class="line">NOTE: Current JVM experimentally supports Compiler Blackholes, and they are <span class="keyword">in</span> use. Please exercise</span><br><span class="line">extra caution when trusting the results, look into the generated code to check the benchmark still</span><br><span class="line">works, and <span class="built_in">factor</span> <span class="keyword">in</span> a small probability of new VM bugs. Additionally, <span class="keyword">while</span> comparisons between</span><br><span class="line">different JVMs are already problematic, the performance difference caused by different Blackhole</span><br><span class="line">modes can be very significant. Please make sure you use the consistent Blackhole mode <span class="keyword">for</span> comparisons.</span><br><span class="line"></span><br><span class="line">Benchmark                            Mode  Cnt      Score     Error  Units</span><br><span class="line">HistogramBenchmark.dropwizardRecord  avgt   10  10383.716 ± 563.945  ns/op</span><br><span class="line">HistogramBenchmark.micrometerRecord  avgt   10   6820.421 ± 155.021  ns/op</span><br><span class="line"></span><br><span class="line">Deprecated Gradle features were used <span class="keyword">in</span> this build, making it incompatible with Gradle 9.0.</span><br><span class="line"></span><br><span class="line">You can use <span class="string">&#x27;--warning-mode all&#x27;</span> to show the individual deprecation warnings and determine <span class="keyword">if</span> they come from your own scripts or plugins.</span><br><span class="line"></span><br><span class="line">For more on this, please refer to https://docs.gradle.org/8.3/userguide/command_line_interface.html<span class="comment">#sec:command_line_warnings in the Gradle documentation.</span></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> 5m 6s</span><br><span class="line">23 actionable tasks: 2 executed, 21 up-to-date</span><br><span class="line">15:27:54: Execution finished <span class="string">&#x27;:micrometer-benchmarks-core:HistogramBenchmark.main()&#x27;</span>.</span><br></pre></td></tr></table></figure><p><strong>结论：</strong>MicroMeter 优于 DropWizard，大约比例为 40%</p><h2 id="2-4-Timer"><a href="#2-4-Timer" class="headerlink" title="2.4. Timer"></a>2.4. Timer</h2><p>测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.codahale.metrics.MetricRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.MeterRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.Timer;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.core.instrument.simple.SimpleMeterRegistry;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.prometheus.PrometheusConfig;</span><br><span class="line"><span class="keyword">import</span> io.micrometer.prometheus.PrometheusMeterRegistry;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 Benchmark，测试多线程性能</span></span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerBenchmark</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">            .include(TimerBenchmark.class.getSimpleName())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MeterRegistry micrometerRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MetricRegistry dropwizardRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Timer micrometerTimer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> com.codahale.metrics.Timer dropwizardTimer;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">923</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        micrometerRegistry = <span class="keyword">new</span> <span class="title class_">SimpleMeterRegistry</span>();</span><br><span class="line">        micrometerTimer = micrometerRegistry.timer(<span class="string">&quot;micrometerTimer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        dropwizardRegistry = <span class="keyword">new</span> <span class="title class_">MetricRegistry</span>();</span><br><span class="line">        dropwizardTimer = dropwizardRegistry.timer(<span class="string">&quot;dropwizardTimer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">micrometerSumTimedWithSupplier</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            micrometerTimer.record(x + y, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dropwizardSumTimedWithSupplier</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            dropwizardTimer.update(x + y, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">micrometerSumTimedWithSample</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Timer.<span class="type">Sample</span> <span class="variable">sample</span> <span class="operator">=</span> Timer.start(micrometerRegistry);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sum();</span><br><span class="line">            sample.stop(micrometerTimer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dropwizardSumTimedWithSample</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            dropwizardTimer.time(<span class="built_in">this</span>::sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; Task :micrometer-benchmarks-core:TimerBenchmark.main()</span><br><span class="line"># JMH version: <span class="number">1.37</span></span><br><span class="line"># VM version: JDK <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>, OpenJDK <span class="number">64</span>-Bit Server VM, <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>+<span class="number">8</span>-LTS</span><br><span class="line"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-<span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>/Contents/Home/bin/java</span><br><span class="line"># VM options: -Dfile.encoding=UTF-<span class="number">8</span> -Duser.country=CN -Duser.language=zh -Duser.variant</span><br><span class="line"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=<span class="literal">false</span> to disable)</span><br><span class="line"># Warmup: <span class="number">1</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Measurement: <span class="number">2</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Timeout: <span class="number">10</span> min per iteration</span><br><span class="line"># Threads: <span class="number">1</span> thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Average time, time/op</span><br><span class="line"># Benchmark: io.micrometer.benchmark.core.TimerBenchmark.dropwizardSumTimedWithSample</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">0.00</span>% complete, ETA <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span></span><br><span class="line"># Fork: <span class="number">1</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">1516.590</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">1530.353</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">1605.669</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">5.00</span>% complete, ETA <span class="number">00</span>:09:<span class="number">33</span></span><br><span class="line"># Fork: <span class="number">2</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">1507.719</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">1488.804</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">1576.604</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">10.00</span>% complete, ETA <span class="number">00</span>:09:<span class="number">03</span></span><br><span class="line"># Fork: <span class="number">3</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">1502.103</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">1497.555</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">1555.023</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">15.00</span>% complete, ETA <span class="number">00</span>:08:<span class="number">32</span></span><br><span class="line"># Fork: <span class="number">4</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">1556.940</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">1458.053</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">1505.888</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">20.00</span>% complete, ETA <span class="number">00</span>:08:<span class="number">02</span></span><br><span class="line"># Fork: <span class="number">5</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">1505.264</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">1516.316</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">1580.754</span> ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.TimerBenchmark.dropwizardSumTimedWithSample&quot;</span>:</span><br><span class="line">  <span class="number">1531.502</span> ±(<span class="number">99.9</span>%) <span class="number">70.863</span> ns/op [Average]</span><br><span class="line">  (min, avg, max) = (<span class="number">1458.053</span>, <span class="number">1531.502</span>, <span class="number">1605.669</span>), stdev = <span class="number">46.871</span></span><br><span class="line">  CI (<span class="number">99.9</span>%): [<span class="number">1460.639</span>, <span class="number">1602.365</span>] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># JMH version: <span class="number">1.37</span></span><br><span class="line"># VM version: JDK <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>, OpenJDK <span class="number">64</span>-Bit Server VM, <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>+<span class="number">8</span>-LTS</span><br><span class="line"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-<span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>/Contents/Home/bin/java</span><br><span class="line"># VM options: -Dfile.encoding=UTF-<span class="number">8</span> -Duser.country=CN -Duser.language=zh -Duser.variant</span><br><span class="line"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=<span class="literal">false</span> to disable)</span><br><span class="line"># Warmup: <span class="number">1</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Measurement: <span class="number">2</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Timeout: <span class="number">10</span> min per iteration</span><br><span class="line"># Threads: <span class="number">1</span> thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Average time, time/op</span><br><span class="line"># Benchmark: io.micrometer.benchmark.core.TimerBenchmark.dropwizardSumTimedWithSupplier</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">25.00</span>% complete, ETA <span class="number">00</span>:<span class="number">07</span>:<span class="number">32</span></span><br><span class="line"># Fork: <span class="number">1</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">12358.755</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">12309.136</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">12922.583</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">30.00</span>% complete, ETA <span class="number">00</span>:<span class="number">07</span>:<span class="number">02</span></span><br><span class="line"># Fork: <span class="number">2</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">12072.889</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">11971.788</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">12708.188</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">35.00</span>% complete, ETA <span class="number">00</span>:<span class="number">06</span>:<span class="number">32</span></span><br><span class="line"># Fork: <span class="number">3</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">12240.725</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">12189.390</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">12794.850</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">40.00</span>% complete, ETA <span class="number">00</span>:<span class="number">06</span>:<span class="number">02</span></span><br><span class="line"># Fork: <span class="number">4</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">11909.155</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">12186.550</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">13181.730</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">45.00</span>% complete, ETA <span class="number">00</span>:<span class="number">05</span>:<span class="number">31</span></span><br><span class="line"># Fork: <span class="number">5</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">12192.867</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">12209.921</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">12930.563</span> ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.TimerBenchmark.dropwizardSumTimedWithSupplier&quot;</span>:</span><br><span class="line">  <span class="number">12540.470</span> ±(<span class="number">99.9</span>%) <span class="number">624.765</span> ns/op [Average]</span><br><span class="line">  (min, avg, max) = (<span class="number">11971.788</span>, <span class="number">12540.470</span>, <span class="number">13181.730</span>), stdev = <span class="number">413.243</span></span><br><span class="line">  CI (<span class="number">99.9</span>%): [<span class="number">11915.705</span>, <span class="number">13165.235</span>] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># JMH version: <span class="number">1.37</span></span><br><span class="line"># VM version: JDK <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>, OpenJDK <span class="number">64</span>-Bit Server VM, <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>+<span class="number">8</span>-LTS</span><br><span class="line"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-<span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>/Contents/Home/bin/java</span><br><span class="line"># VM options: -Dfile.encoding=UTF-<span class="number">8</span> -Duser.country=CN -Duser.language=zh -Duser.variant</span><br><span class="line"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=<span class="literal">false</span> to disable)</span><br><span class="line"># Warmup: <span class="number">1</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Measurement: <span class="number">2</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Timeout: <span class="number">10</span> min per iteration</span><br><span class="line"># Threads: <span class="number">1</span> thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Average time, time/op</span><br><span class="line"># Benchmark: io.micrometer.benchmark.core.TimerBenchmark.micrometerSumTimedWithSample</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">50.00</span>% complete, ETA <span class="number">00</span>:<span class="number">05</span>:<span class="number">01</span></span><br><span class="line"># Fork: <span class="number">1</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">520.268</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">520.347</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">515.323</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">55.00</span>% complete, ETA <span class="number">00</span>:<span class="number">04</span>:<span class="number">31</span></span><br><span class="line"># Fork: <span class="number">2</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">516.566</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">520.164</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">509.640</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">60.00</span>% complete, ETA <span class="number">00</span>:<span class="number">04</span>:<span class="number">01</span></span><br><span class="line"># Fork: <span class="number">3</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">509.843</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">507.147</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">506.309</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">65.00</span>% complete, ETA <span class="number">00</span>:<span class="number">03</span>:<span class="number">31</span></span><br><span class="line"># Fork: <span class="number">4</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">510.824</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">504.709</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">505.124</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">70.00</span>% complete, ETA <span class="number">00</span>:<span class="number">03</span>:<span class="number">00</span></span><br><span class="line"># Fork: <span class="number">5</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">509.629</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">516.369</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">501.427</span> ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.TimerBenchmark.micrometerSumTimedWithSample&quot;</span>:</span><br><span class="line">  <span class="number">510.656</span> ±(<span class="number">99.9</span>%) <span class="number">10.354</span> ns/op [Average]</span><br><span class="line">  (min, avg, max) = (<span class="number">501.427</span>, <span class="number">510.656</span>, <span class="number">520.347</span>), stdev = <span class="number">6.849</span></span><br><span class="line">  CI (<span class="number">99.9</span>%): [<span class="number">500.302</span>, <span class="number">521.010</span>] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># JMH version: <span class="number">1.37</span></span><br><span class="line"># VM version: JDK <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>, OpenJDK <span class="number">64</span>-Bit Server VM, <span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>+<span class="number">8</span>-LTS</span><br><span class="line"># VM invoker: /Users/pengjunzhi/Library/Java/JavaVirtualMachines/corretto-<span class="number">17.0</span><span class="number">.8</span><span class="number">.1</span>/Contents/Home/bin/java</span><br><span class="line"># VM options: -Dfile.encoding=UTF-<span class="number">8</span> -Duser.country=CN -Duser.language=zh -Duser.variant</span><br><span class="line"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=<span class="literal">false</span> to disable)</span><br><span class="line"># Warmup: <span class="number">1</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Measurement: <span class="number">2</span> iterations, <span class="number">10</span> s each</span><br><span class="line"># Timeout: <span class="number">10</span> min per iteration</span><br><span class="line"># Threads: <span class="number">1</span> thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Average time, time/op</span><br><span class="line"># Benchmark: io.micrometer.benchmark.core.TimerBenchmark.micrometerSumTimedWithSupplier</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">75.00</span>% complete, ETA <span class="number">00</span>:<span class="number">02</span>:<span class="number">30</span></span><br><span class="line"># Fork: <span class="number">1</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">2741.534</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">2716.235</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">2762.197</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">80.00</span>% complete, ETA <span class="number">00</span>:<span class="number">02</span>:<span class="number">00</span></span><br><span class="line"># Fork: <span class="number">2</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">2764.662</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">2788.028</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">2801.328</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">85.00</span>% complete, ETA <span class="number">00</span>:<span class="number">01</span>:<span class="number">30</span></span><br><span class="line"># Fork: <span class="number">3</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">2775.788</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">2794.196</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">2833.326</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">90.00</span>% complete, ETA <span class="number">00</span>:<span class="number">01</span>:<span class="number">00</span></span><br><span class="line"># Fork: <span class="number">4</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">2793.570</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">2774.927</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">2818.794</span> ns/op</span><br><span class="line"></span><br><span class="line"># Run progress: <span class="number">95.00</span>% complete, ETA <span class="number">00</span>:<span class="number">00</span>:<span class="number">30</span></span><br><span class="line"># Fork: <span class="number">5</span> of <span class="number">5</span></span><br><span class="line"># Warmup Iteration   <span class="number">1</span>: <span class="number">2773.815</span> ns/op</span><br><span class="line">Iteration   <span class="number">1</span>: <span class="number">2752.855</span> ns/op</span><br><span class="line">Iteration   <span class="number">2</span>: <span class="number">2816.498</span> ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result <span class="string">&quot;io.micrometer.benchmark.core.TimerBenchmark.micrometerSumTimedWithSupplier&quot;</span>:</span><br><span class="line">  <span class="number">2785.839</span> ±(<span class="number">99.9</span>%) <span class="number">53.348</span> ns/op [Average]</span><br><span class="line">  (min, avg, max) = (<span class="number">2716.235</span>, <span class="number">2785.839</span>, <span class="number">2833.326</span>), stdev = <span class="number">35.287</span></span><br><span class="line">  CI (<span class="number">99.9</span>%): [<span class="number">2732.490</span>, <span class="number">2839.187</span>] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Run complete. Total time: <span class="number">00</span>:<span class="number">10</span>:<span class="number">03</span></span><br><span class="line"></span><br><span class="line">REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on</span><br><span class="line">why the numbers are the way they are. Use <span class="title function_">profilers</span> <span class="params">(see -prof, -lprof)</span>, design factorial</span><br><span class="line">experiments, perform baseline and negative tests that provide experimental control, make sure</span><br><span class="line">the benchmarking environment is safe on JVM/OS/HW level, ask <span class="keyword">for</span> reviews from the domain experts.</span><br><span class="line">Do not assume the numbers tell you what you want them to tell.</span><br><span class="line"></span><br><span class="line">NOTE: Current JVM experimentally supports Compiler Blackholes, and they are in use. Please exercise</span><br><span class="line">extra caution when trusting the results, look into the generated code to check the benchmark still</span><br><span class="line">works, and factor in a small probability of <span class="keyword">new</span> <span class="title class_">VM</span> bugs. Additionally, <span class="keyword">while</span> comparisons between</span><br><span class="line">different JVMs are already problematic, the performance difference caused by different Blackhole</span><br><span class="line">modes can be very significant. Please make sure you use the consistent Blackhole mode <span class="keyword">for</span> comparisons.</span><br><span class="line"></span><br><span class="line">Benchmark                                      Mode  Cnt      Score     Error  Units</span><br><span class="line">TimerBenchmark.dropwizardSumTimedWithSample    avgt   <span class="number">10</span>   <span class="number">1531.502</span> ±  <span class="number">70.863</span>  ns/op</span><br><span class="line">TimerBenchmark.dropwizardSumTimedWithSupplier  avgt   <span class="number">10</span>  <span class="number">12540.470</span> ± <span class="number">624.765</span>  ns/op</span><br><span class="line">TimerBenchmark.micrometerSumTimedWithSample    avgt   <span class="number">10</span>    <span class="number">510.656</span> ±  <span class="number">10.354</span>  ns/op</span><br><span class="line">TimerBenchmark.micrometerSumTimedWithSupplier  avgt   <span class="number">10</span>   <span class="number">2785.839</span> ±  <span class="number">53.348</span>  ns/op</span><br></pre></td></tr></table></figure><p>结论：无论是直接更新抑或是通过 Sample 记录时间更新，Micrometer 均明显优于 DropWizard，大约比例为 300%；</p><h2 id="2-5-Rate"><a href="#2-5-Rate" class="headerlink" title="2.5. Rate"></a>2.5. Rate</h2><p>MicroMeter 没有提供 Rate 语义的实现，目前 IoTDB 都使用的是 DropWizard base</p><h1 id="3-优化方案"><a href="#3-优化方案" class="headerlink" title="3. 优化方案"></a>3. 优化方案</h1><h2 id="3-1-监控项选择参数"><a href="#3-1-监控项选择参数" class="headerlink" title="3.1. 监控项选择参数"></a>3.1. 监控项选择参数</h2><p>经过测试，决定<strong>选择 Micrometer 为 IoTDB Metric 系统的 baseline，在参数上舍弃 DropWizard 。</strong>理由如下<strong>：</strong></p><ol><li><p>Micrometer 在实现时基于 DropWizard ，可以理解为是 DropWizard 的扩展。因此 Micrometer <strong>在功能上</strong>可以完全覆盖 DropWizard，<strong>在可拓展性上</strong>比 DropWizard 更好。</p></li><li><p>经过性能测试，除了 Counter 和 Gauge，IoTDB 现有的 Micrometer base 监控指标<strong>性能均优于</strong> DropWizard base 监控指标（M 比 D 普遍性能优越40%以上）</p><ol><li>而 Micrometer base 的 Counter 和 Gauge 优化项也比较清晰，经过优化后，可以达到 DropWizard base 的性能表现。</li></ol></li><li><p>截止 2023.10.23，无论是 issue 数还是 commit 数 Micrometer 均大于 DropWizard，说明前者<strong>社区更活跃。</strong></p></li></ol><h2 id="3-2-【优化一】MetricType"><a href="#3-2-【优化一】MetricType" class="headerlink" title="3.2. 【优化一】MetricType"></a>3.2. 【优化一】MetricType</h2><h3 id="3-2-1-Gauge"><a href="#3-2-1-Gauge" class="headerlink" title="3.2.1 Gauge"></a>3.2.1 Gauge</h3><ol><li><strong>问题：</strong></li></ol><p>由于 Micrometer 没有提供缓存版 gauge，因此在涉及读密集且重计算的场景时会有性能问题，预期不如 Dropwizard。<strong>考虑在 IoTDB 实现时加一层缓存进行优化。</strong></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182140973.png" alt="image-20231115182140973"></p><ol start="2"><li><strong>优化：</strong></li></ol><p>加一个 cache，在失效时间内，如果反复读 gauge，直接返回 cache 的值。如果超过超时时间，重新调用计算函数 <code>ref.get()</code>，并更新 cache。</p><blockquote><p>组内大佬 review：由于主要调用是 promethus，15s 一次，并发性不高。该优化意义不是特别大，考虑作为写个新类，作为用户的 option</p></blockquote><h3 id="3-2-2-Rate"><a href="#3-2-2-Rate" class="headerlink" title="3.2.2. Rate"></a>3.2.2. Rate</h3><ol><li><strong>问题：</strong></li></ol><p>原生 Rate 的更新和计算有大量冗余逻辑。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182211527.png" alt="image-20231115182211527"></p><ol start="2"><li><strong>优化：</strong></li></ol><p>考虑从 m1、m5、m15 中删去其二。</p><h3 id="3-2-3-Counter"><a href="#3-2-3-Counter" class="headerlink" title="3.2.3. Counter"></a>3.2.3. Counter</h3><ol><li><strong>问题：</strong></li></ol><p>使用 DoubleAdder 作为 value 的容器<strong>，</strong>但是 IoTDB 的最终接口是 long，而 double 本身的运算开销也较大，因此涉及一些转化和计算开销</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182222612.png" alt="image-20231115182222612"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182231480.png" alt="image-20231115182231480"></p><ol start="2"><li><strong>优化：</strong></li></ol><p><strong>考虑使用 LongAdder 实现 Counter。</strong></p><h3 id="3-2-4-DistributionSummary-IoTDB-Histogram"><a href="#3-2-4-DistributionSummary-IoTDB-Histogram" class="headerlink" title="3.2.4. DistributionSummary &#x2F; IoTDB Histogram"></a>3.2.4. DistributionSummary &#x2F; IoTDB Histogram</h3><ol><li><strong>问题：</strong><ol><li>从前面分析可以看到，Micrometer 在每次写入数据时，对 ringBuffer 的所有 bucket 都进行了写入操作。</li><li>从前面分析可以看到，当数据超过 hdrHistogram 范围时，会发生 resize，该操作有时间开销。目前的上下界 [1, 127] 显然范围有点小了，在大值数据场景下显然要 resize，甚至多次 resize。</li></ol></li><li><strong>优化：</strong><ol><li><strong>可以通过缩小 ringBuffer 的 size，从而减少写 bucket 次数</strong>，来提高 Micrometer Histogram 的写入效率<ol><li>ringBuffer.length 默认设置为 3。根据上文，只要保证 ringBuffer.length 大于 1 既能保证淘汰旧数据的目的。因此考虑将 ringBuffer.length 设为 2（<strong>PR</strong>: <a href="https://github.com/apache/iotdb/pull/11500%EF%BC%89">https://github.com/apache/iotdb/pull/11500）</a></li></ol></li><li>可以对每一个 timer&#x2F;histogram 的使用场景预估数据区间，<strong>提前为每一个 timer&#x2F;histogram 定制数据上下界</strong>，尽量避免 resize 操作。<ol><li>由于 Micrometer 没有暴露定制化 hdrHistogram 区间范围的 API，该改动阻塞。已向他们提 issue（<a href="https://github.com/micrometer-metrics/micrometer/issues/4327%EF%BC%89">https://github.com/micrometer-metrics/micrometer/issues/4327）</a></li></ol></li></ol></li></ol><h3 id="3-2-5-Timer"><a href="#3-2-5-Timer" class="headerlink" title="3.2.5. Timer"></a>3.2.5. Timer</h3><p>从火焰图和上文的分析中可以看出，Timer 主要耗时由 histogram 的更新和自己实现计时器的更新组成。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182245840.png" alt="image-20231115182245840"></p><p>由于 Timer 底层使用 Histogram（前文分析过），因此优化 Histogram 也可以优化 Timer，此处不再赘述。</p><h2 id="3-3-【优化二】架构"><a href="#3-3-【优化二】架构" class="headerlink" title="3.3. 【优化二】架构"></a>3.3. 【优化二】架构</h2><h3 id="3-3-1-IoTDBManager"><a href="#3-3-1-IoTDBManager" class="headerlink" title="3.3.1. IoTDBManager"></a>3.3.1. IoTDBManager</h3><p>完全删去原有的 io.micrometer.core.instrument.simple.SimpleMeterRegistry，将各项 Metric 的创建由 Registry 接管过来。<strong>这样优化的好处如下</strong>：</p><ol><li><p>完全适配 IoTDB 自己的命名系统，舍弃 Micrometer 的命名系统</p></li><li><p>由于不再借助 io.micrometer.core.instrument.simple.SimpleMeterRegistry 创建、管理、存储各项 Metric，使得不用再在 io.micrometer.core.instrument.simple.SimpleMeterRegistry 中创建 MetricMap，<strong>节省一倍内存</strong></p></li><li><p>舍弃原有的 JmxReporter，自己实现一套 JmxReporter，<strong>节省一倍内存</strong>。本文 3.4.2 会详细介绍设计以及优化点）</p></li></ol><h4 id="3-3-1-1-各指标的自主创建流程"><a href="#3-3-1-1-各指标的自主创建流程" class="headerlink" title="3.3.1.1. 各指标的自主创建流程"></a>3.3.1.1. 各指标的自主创建流程</h4><ol><li><strong>Gauge</strong></li></ol><p><code>IoTDBGauge</code> 的核心就是 <code>AtomicLong</code>。由于舍弃了 Micrometer 的命名系统，因此创建 <code>IoTDBGauge</code> 只需<code> new AtomicLong()</code> 即可。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182308733.png" alt="image-20231115182308733"></p><ol start="2"><li><strong>AutoGauge</strong></li></ol><p><code>IoTDBAutoGauge</code> 主要修改了 <code>WeakReference</code> 的引用。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182325099.png" alt="image-20231115182325099"></p><p>在原本实现中传入 <code>WeakReference</code> 的 <code>meterRegistry.gauge(...)</code> 中， <code>meterRegistry.gauge(...)</code> 返回的仅仅就是参数中的 <code>object</code>。因此这里直接将<code>WeakReference</code> 的参数改为了 <code>object</code>。</p><p>至于在 <code>meterRegistry.gauge</code> 中创建的 <code>gauge</code>，<code>IoTDBAutoGauge</code> 并没有用到，原来的实现只是为了在 <code>Micrometer</code> 的命名系统中创建一个同名 <code>gauge</code>。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182339161.png" alt="image-20231115182339161"></p><ol start="3"><li><strong>Counter</strong></li></ol><p>完全舍弃掉 Micrometer 的实现，只保留 <code>LongAdder</code></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182349453.png" alt="image-20231115182349453"></p><ol start="4"><li><strong>Rate</strong></li></ol><p>IoTDB 的实现在 Micrometer 的基础上砍去了 m5、m15 等统计点，因此传入 IoTDB 定制的 <code>IoTDBMovingAverage</code> 即可</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182401836.png" alt="image-20231115182401836"></p><ol start="5"><li><strong>Timer</strong></li></ol><p>参考 SimpleMeterRegistry 的创建流程。经验证，创建后的 CumulativeTimer 与原来的实现属性一致，符合预期。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182414059.png" alt="image-20231115182414059"></p><ol start="6"><li><strong>Histogram</strong></li></ol><p>参考 SimpleMeterRegistry 的创建流程。经验证，创建后的 CumulativeDistributionSummary 与原来的实现属性一致，符合预期。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182423894.png" alt="image-20231115182423894"></p><h3 id="3-3-2-JmxReporter"><a href="#3-3-2-JmxReporter" class="headerlink" title="3.3.2. JmxReporter"></a>3.3.2. JmxReporter</h3><p>舍弃 <code>io.micrometer.jmx.JmxMeterRegistry</code> 的实现，自己实现 <code>JmxReporter</code>。<strong>这样优化的好处主要是节省一倍内存</strong>，原因如下：</p><p><code>io.micrometer.jmx.JmxMeterRegistry</code> 的实现是将 <code>JmxReporter</code> 监听 Registry，每次 Registry 创建新指标项时，<code>JmxReporter</code> 也创建一份实现了 MBean 接口的指标对象，相当于<strong>一个监控项创建了两个对象</strong>。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182434178.png" alt="image-20231115182434178"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182441959.png" alt="image-20231115182441959"></p><p><code>IoTDBJmxReporter</code> 的设计思路是：</p><ol><li>所有指标项天然实现 MBean 接口</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182457114.png" alt="image-20231115182457114"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182508237.png" alt="image-20231115182508237"></p><ol start="2"><li><code>IoTDBJmxReporter</code> 的作用仅为监听 <code>IoTDBMetricManager</code>，当有新指标创建时，将其注册到 JMX 中。当 <code>ReporterType</code> 不为 JMX 时，所有指标项不会被注册到 JMX 中。<ol><li>该实现在不开启 JmxReporter 时不会有额外性能开销；在开启 JmxReporter 时，由于 JmxReporter 只需完成注册操作，相比 Micrometer 的实现少了创建对象的性能开销。</li></ol></li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182518746.png" alt="image-20231115182518746"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182529865.png" alt="image-20231115182529865"></p><p><strong>踩坑：</strong>MBean 的接口需要和实现类在同一个包下，且类名、接口名必须严格对应，且 objectName 必须符合 <a href="https://blog.csdn.net/qq_21383435/article/details/111051784">MBean 规范</a></p><ol start="3"><li><strong>实现效果：</strong></li></ol><p>在 org.apache.iotdb.metrics 下有各指标的 jmx 预览项。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182542803.png" alt="image-20231115182542803"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182553360.png" alt="image-20231115182553360"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182604536.png"></p><h1 id="4-优化效果"><a href="#4-优化效果" class="headerlink" title="4. 优化效果"></a>4. 优化效果</h1><ol><li><strong>环境</strong></li></ol><p>在某环境负载下，1C1D (IoTDB 1 ConfigNode + 1 DataNode） 测试。</p><ul><li>baseline：<a href="https://github.com/apache/iotdb/commit/1dd5a200281aff1f42a9d7abdbde9d172445d4f6">1dd5a200281aff1f42a9d7abdbde9d172445d4f6</a></li><li>对比优化后：<a href="https://github.com/apache/iotdb/commit/a4510266fdb74e95f0cfabec36ad3f16155eaa60">a4510266fdb74e95f0cfabec36ad3f16155eaa60</a></li></ul><ol start="2"><li><strong>火焰图实测</strong></li></ol><p>图中浅紫色高亮的是 metrics 部分的开销</p><ul><li>优化前（1dd5a200281aff1f42a9d7abdbde9d172445d4f6）：metrics 整体占比大约在 <strong>9.79%</strong></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182623578.png" alt="image-20231115182623578"></p><p>优化后（a4510266fdb74e95f0cfabec36ad3f16155eaa60）：metrics 整体占比大约在 **5.81%<strong>，优化了</strong>41%**的性能</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182634791.png" alt="image-20231115182634791"></p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><ol><li><p><strong>CPU 开销</strong>：9.79% -&gt; 5.81%，优化了 41%。</p></li><li><p><strong>空间：</strong>由于架构上的优化，metrics 在空间占用上降低了一倍开销。</p></li><li><p><strong>可用性：</strong>对于用户，去掉了算法库参数的选择；对于开发者，统一了原有的 Micrometer 和 DropWizard 内部实现为 metric-core，形成了 IoTDB 自己的实现方案。</p></li></ol><h1 id="6-心得"><a href="#6-心得" class="headerlink" title="6. 心得"></a>6. 心得</h1><p>本次性能优化的流程是：</p><ol><li>调研 baseline（花了一周）</li><li>对比 iotdb 和 baseline，找出冗余点（花了半周）</li><li>性能测试，对比 baseline（花了半周）</li><li>跑火焰图，分析目标函数瓶颈（花了一天）</li><li>结合上述资料，尝试代码改造。改造的<strong>思路</strong>如下：<ol><li>能不能串行改并行？（no）</li><li>能不能同步改异步？（no）</li><li>有没有冗余逻辑，能不能删掉？（yes）</li><li>有没有计算密集场景，能不能加缓存？（yes）</li><li>其他杂项开销（如 double 和 long 的转化，CompositeMeterRegistry 等）</li><li>补充：批处理；拆锁；</li></ol></li></ol><p>其中在火焰图上有一个 trick 的积累：idea 可以继承 async-profiler 进行火焰图分析，并可以很方便的查看结果、统计各阶段耗时比例、查看调用树等。</p><ol><li><strong>配置</strong></li></ol><p>打开 setting，新增 CPU profiler。options 经个人测试，填写<code>event=cpu,interval=1ms</code>的实际体验比较好</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182705428.png" alt="image-20231115182705428"></p><ol start="2"><li><strong>使用</strong></li></ol><p>在 run 项目时选中 profiler 即可</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182714816.png" alt="image-20231115182714816"></p><ol start="3"><li><strong>查看结果</strong></li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115182725287.png" alt="image-20231115182725287"></p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ol><li><a href="https://izualzhy.cn/dropwizard-metrics#14-histograms">https://izualzhy.cn/dropwizard-metrics#14-histograms</a></li><li><a href="https://metrics.dropwizard.io/4.1.1">https://metrics.dropwizard.io/4.1.1</a></li><li><a href="https://www.fortra.com/resources/guides/unix-load-average-part-1-how-it-works">https://www.fortra.com/resources/guides/unix-load-average-part-1-how-it-works</a></li><li><a href="https://www.cnblogs.com/mindforward/p/15792132.html">https://www.cnblogs.com/mindforward/p/15792132.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/29178293">https://zhuanlan.zhihu.com/p/29178293</a></li><li><a href="https://metrics.dropwizard.io/4.2.0/manual/core.html#">https://metrics.dropwizard.io/4.2.0/manual/core.html#</a></li><li><a href="https://micrometer.io/docs/observation">https://micrometer.io/docs/observation</a></li><li><a href="https://www.baeldung.com/dropwizard-metrics">https://www.baeldung.com/dropwizard-metrics</a></li><li><a href="https://caorong.github.io/2020/08/03/quartile-%20algorithm/">https://caorong.github.io/2020/08/03/quartile-%20algorithm/</a></li><li><a href="https://zhuanlan.zhihu.com/p/568777601">https://zhuanlan.zhihu.com/p/568777601</a></li><li><a href="https://cxybb.com/article/superice_/121311005">https://cxybb.com/article/superice_/121311005</a></li><li><a href="https://caorong.github.io/2016/07/31/hdrhistogram/">https://caorong.github.io/2016/07/31/hdrhistogram/</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM GC 调研与基于 Apache IoTDB 的 GC 监控设计</title>
      <link href="/article/JVM-GC/"/>
      <url>/article/JVM-GC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>本文是作者在调研改进 IoTDB JVM GC 监控板块时产出的相关 wiki，主要包含 GC 基本知识、不同 JDK 下的 GC 算法细节，以及设计改进 IoTDB JVM GC 监控板块时的思路等内容。本文旨在优化 IoTDB 现有 GC 监控系统，结合实际生产需要，扩充现有 metric 指标，使其针对不同 JDK 的 GC Collector 能更精准、高效的进行监控。</p><blockquote><ol><li><p>JVM GC 是一个浩瀚的系统领域，本文仅于皮毛处探讨，起抛砖引玉之效。如有错误，敬请指出，欢迎各位大佬通过邮件或微信与我进一步交流！</p></li><li><p>本文引用、整合了大量互联网资料（文字、图片），同时也有自己的探究、实验和思考。感谢所有互联网大佬的无私分享，结尾给出了所有的 Reference 链接。</p></li></ol></blockquote><p>在系统工程设计之外，为了更好地帮助理解，<strong>本文涉及以下相关概念</strong>，读者可提前<strong>按需浏览：</strong></p><ul><li>GC 基本知识，具体可参见【2. GC 基础】</li><li>常见的 GC 收集器以及它们的基本特点，具体可参见【3. GC 收集器、10. 其他】</li><li>如何判断 GC 异常，具体可参见【4. GC 异常的判断】</li></ul><h2 id="2-GC-基础"><a href="#2-GC-基础" class="headerlink" title="2. GC 基础"></a>2. GC 基础</h2><h3 id="2-1-JVM-内存划分"><a href="#2-1-JVM-内存划分" class="headerlink" title="2.1. JVM 内存划分"></a>2.1. JVM 内存划分</h3><p>此部分是后续监控指标设计的依据，因此详细介绍：</p><p>JVM 内存中的对象，大致可以分为两大类：一类对象，他们的生命周期很短暂，比如局部变量、临时对象等。另一类对象则会存活很久，比如用户应用程序中 DB 长连接中的 Connection 对象。为了对这两类对象分别高效回收，JVM 的内存使用<strong>分代思想</strong>进行划分。</p><p>以 Java 8 的内存结构为例：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115174532651.png" alt="image-20231115174532651"></p><p>可以看到，JVM 的内存被分为了不同的区域。GC 主要工作在 Heap 区和 MetaSpace 区（上图蓝色部分），而在 GC 的主要工作区，<strong>内存又被分为了不同的代际</strong>。下面这张表格简单描述了我们主要需要关注的区域：</p><table><thead><tr><th><strong>分代名</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Young Generation（Eden + Survivor）</td><td>新生代主要分为两个部分：<strong>Eden 区</strong>和 <strong>Survivor 区</strong>，其中 Survivor 区又可以分为两个部分，<strong>S0 和S1</strong>。该区域中，相对于老年代空间较小，对象的生存周期短，GC 频繁。</td></tr><tr><td>Old Generation（Tenured）</td><td>老年代整体空间较大，对象的生命周期长，存活率高，回收不频繁。</td></tr><tr><td><em><strong>@Deprecated</strong></em>Permanent</td><td>永久代又称为方法区，存储着类和接口的元信息以及 interned 的字符串信息。在 JDK8 中被元空间取代。</td></tr><tr><td>MetaSpace</td><td>JDK8 以后引入，方法区也存在于元空间。</td></tr></tbody></table><p>在 Java 程序中，常见的垃圾回收器，打印内存区域结果如下：</p><ul><li>G1</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">G1 Eden Space <span class="comment">// young</span></span><br><span class="line">G1 Old Gen <span class="comment">// old</span></span><br><span class="line">G1 Survivor Space <span class="comment">// young</span></span><br></pre></td></tr></table></figure><ul><li>ParNewGC + CMS</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Par Eden Space <span class="comment">// young</span></span><br><span class="line">Par Survivor Space <span class="comment">// young</span></span><br><span class="line">CMS Old Gen <span class="comment">// old</span></span><br></pre></td></tr></table></figure><ul><li>SerialGC</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Tenured Gen <span class="comment">// old</span></span><br><span class="line">Eden Space <span class="comment">// young</span></span><br><span class="line">Survivor Space <span class="comment">// young</span></span><br></pre></td></tr></table></figure><ul><li>ParallelGC + ParallelOldGC</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PS Old Gen <span class="comment">// old</span></span><br><span class="line">PS Survivor Space <span class="comment">// young</span></span><br><span class="line">PS Eden Space <span class="comment">// young</span></span><br></pre></td></tr></table></figure><ul><li>Shenandoah</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shenandoah <span class="comment">// non-generational</span></span><br></pre></td></tr></table></figure><ul><li>ZGC</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ZHeap <span class="comment">// non-generational</span></span><br></pre></td></tr></table></figure><h3 id="2-2-GC-收集过程"><a href="#2-2-GC-收集过程" class="headerlink" title="2.2. GC 收集过程"></a>2.2. GC 收集过程</h3><p>基于上述分代内存，JVM 使用<strong>分代垃圾回收算法</strong>（当然，JDK 11 以后的某些新收集器使用非代际垃圾回收算法，这些会在后文中提到），其大致执行过程如下：</p><ul><li>初始态：对象分配在 Eden 区，S0、S1 区几乎为空。</li><li>随着程序的运行，越来越多的对象被分配在 Eden 区。</li><li>当 Eden 放不下时，就会发生 <strong>MinorGC</strong>（即 YoungGC），此时，会先标识出不可达的垃圾对象，然后将可达的对象移动到 S0 区，并将不可达的对象清理掉。这时候，Eden 区就是空的了。在这个过程中，使用了标记清理算法及复制算法。</li><li>随着 Eden 放不下时，会再次触发 minorGC，和上一步一样，先标记。这个时候，Eden 和 S0 区可能都有垃圾对象了，而 S1 区是空的。这个时候，会直接将 Eden 和 S0 区的对象直接搬到S1区，然后将Eden 与 S0 区的垃圾对象清理掉。经历这一轮的 MinorGC 后，Eden 与 S0 区为空。</li><li>随着程序的运行，Eden 空间会被分配殆尽，这时会重复刚才 MinorGC 的过程，不过此时，S0 区是空的，S0 和 S1 区域会互换，此时存活的对象会从 Eden 和 S1 区，向S0 区移动。然后 Eden 和 S1 区中的垃圾会被清除，这一轮完成之后，这两个区域为空。</li><li>在程序运行过程中，虽然大多数对象都会很快消亡，但仍然存在一些存活时间较长的对象，对于这些对象，<strong>在 S0 和 S1 区中反复移动</strong>，会造成一定的性能开销，降低 GC 的效率。因此引入了对象晋升的行为。</li><li>当对象在新生代的 Eden、S0、S1 区域之间，每次从一个区域移动到另一个区域时，年龄都会加一，在达到一定的阈值后，如果该对象仍然存活，该对象将会晋升到老年代。</li><li>如果老年代也被分配完毕后，就会出现 <strong>MajorGC（即Full GC）</strong>，由于老年代通常对象比较多，因此标记-整理算法的耗时较长，因此会出现 <strong>STW</strong> 现象，因此大多数应用都会尽量减少或者避免出现 Full GC 的原因。</li></ul><p>需要特别说明的是：对于一个新分配的对象，如果 Eden 区放不下，但是老年代可以放下时，该对象会被直接分配到老年代，不会按照上述从新生代晋升到老年代。</p><p>上面提到了一些如<strong>「复制算法」、「不可达」</strong>、<strong>「标记-整理」</strong>等概念，这里引用网络资料进行一一简单介绍：</p><h4 id="2-2-1-识别垃圾"><a href="#2-2-1-识别垃圾" class="headerlink" title="2.2.1. 识别垃圾"></a>2.2.1. 识别垃圾</h4><ul><li><strong>引用计数法（Reference Counting）：</strong> 对每个对象的引用进行计数，每当有一个地方引用它时计数器 +1、引用失效则 -1，引用的计数放到对象头中，大于 0 的对象被认为是存活对象。虽然循环引用的问题可通过 Recycler 算法解决，但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较低，早期的编程语言会采用此算法。</li><li><strong>可达性分析，又称引用链法（Tracing GC）：</strong> 从 GC Root 开始进行对象搜索，可以被搜索到的对象即为可达对象，此时还不足以判断对象是否存活&#x2F;死亡，需要经过多次标记才能更加准确地确定，整个连通图之外的对象便可以作为垃圾被回收掉。目前 Java 中主流的虚拟机均采用此算法。</li></ul><h4 id="2-2-2-收集算法"><a href="#2-2-2-收集算法" class="headerlink" title="2.2.2. 收集算法"></a>2.2.2. 收集算法</h4><p>自从有自动内存管理出现之时就有的一些收集算法，不同的收集器也是在不同场景下进行组合。</p><ul><li><strong>Mark-Sweep（标记-清除）：</strong> 回收过程主要分为两个阶段，第一阶段为追踪（Tracing）阶段，即从 GC Root 开始遍历对象图，并标记（Mark）所遇到的每个对象，第二阶段为清除（Sweep）阶段，即回收器检查堆中每一个对象，并将所有未被标记的对象进行回收，整个过程不会发生对象移动。整个算法在不同的实现中会使用三色抽象（Tricolour Abstraction）、位图标记（BitMap）等技术来提高算法的效率，存活对象较多时较高效。</li></ul><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115174549490.png" alt="image-20231115174549490" style="zoom:33%;" /></div><ul><li><strong>Copying（复制）：</strong> 该算法是为了解决标记-清除算法效率低下、GC 之后空间不连续的问题。该算法将空间分为两个大小相同的 From 和 To 两个半区，同一时间只会使用其中一个，每次进行回收时将一个半区的存活对象通过复制的方式转移到另一个半区。复制算法可以通过碰撞指针的方式进行快速地分配内存，但是也存在着空间利用率不高（只有一半）的缺点，另外就是存活对象比较大时复制的成本比较高。</li></ul><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115174612759.png" alt="image-20231115174612759" style="zoom: 40%;" /></div><ul><li><strong>Mark-Compact （标记-整理）：</strong> 这个算法的主要目的就是解决在非移动式回收器中都会存在的碎片化问题，也分为两个阶段，第一阶段与 Mark-Sweep 类似，标记哪些对象死亡，哪些对象被引用，第二阶段则会对存活对象按照整理顺序（Compaction Order）进行整理。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115180028849.png" alt="image-20231115180028849"></p><p>在 JDK 8 中，默认情况下采用分代垃圾回收策略，其中新生代使用标记-复制算法，老年代使用标记-整理算法。</p><p>这是因为老年代<strong>长生命周期</strong>对象多，如果使用复制算法会十分低效。</p><ul><li>三种算法在是否移动对象、空间和时间方面的一些对比，假设存活对象数量为 <em>L</em>、堆空间大小为 <em>H</em>，则：</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115180015502.png" alt="image-20231115180015502"></p><p>把 mark、sweep、compaction、copying 这几种动作的耗时放在一起看，大致有这样的关系：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115180005979.png" alt="image-20231115180005979"></p><p>虽然 compaction 与 copying 都涉及移动对象，但取决于具体算法，compaction 可能要先计算一次对象的目标地址，然后修正指针，最后再移动对象。copying 则可以把这几件事情合为一体来做，所以可以快一些。另外，<strong>还需要留意</strong> <strong>GC</strong> <strong>带来的开销不能只看 Collector 的耗时，还得看 Allocator</strong> 。如果能保证内存没碎片，分配就可以用 pointer bumping 方式，只需要挪一个指针就完成了分配，非常快。而如果内存有碎片就得用 freelist 之类的方式管理，分配速度通常会慢一些。</p><ul><li><strong>Generational Collection(分代收集)算法</strong></li></ul><p>分代收集算法根据对象的生存周期，将堆分为新生代(<code>Young</code>)和老年代(<code>Tenur</code>)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用<strong>复制算法</strong>。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用<strong>标记-整理</strong>或者<strong>标记-清除</strong>。</p><h2 id="3-GC-收集器"><a href="#3-GC-收集器" class="headerlink" title="3. GC 收集器"></a>3. GC 收集器</h2><p>这里枚举一下各 JDK 版本支持的 GC 收集器，作为快速了解。针对具体常用收集器的调研可参见【10. 其他】</p><p>根据 JDK 版本支持的策略，JDK 8、JDK 11 和 JDK 17 是目前长期支持的版本。目前这3个版本共支持7个垃圾回收器，分别是</p><ol><li><strong>SerialGC</strong></li><li><strong>Parallel</strong> <strong>GC</strong></li><li><strong>CMS</strong></li><li><strong>G1</strong></li><li><strong>Shenandoah</strong> <strong>GC</strong></li><li><strong>ZGC</strong></li><li><strong>Epsilon</strong>（实验特性，仅支持分配不回收，实际场景中不会采用）</li></ol><p>CMS 仅在 JDK 8 和 JDK 11 中支持，ZGC 在 JDK11 中为实验特性，在 JDK 17 中为正式产品，Shenandoah 在JDK 17 中为正式产品，Epsilon 在 JDK 11 和 JDK 17 中为实验特性。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175821783.png" alt="image-20231115175821783"></p><h3 id="3-1-分代收集器"><a href="#3-1-分代收集器" class="headerlink" title="3.1. 分代收集器"></a>3.1. 分代收集器</h3><ul><li><strong>ParNew：</strong> 一款多线程的收集器，采用复制算法，主要工作在 Young 区，可以通过 <code>-XX:ParallelGCThreads</code> 参数来控制收集的线程数，整个过程都是 STW 的，常与 CMS 组合使用。</li><li><strong>CMS</strong>： 以获取最短回收停顿时间为目标，采用「标记-清除」算法，分 4 大步进行垃圾收集，其中初始标记和重新标记会 STW ，多数应用于互联网站或者 B&#x2F;S 系统的服务器端上。虽然在 JDK9 被标记弃用，JDK14 被删除，<strong>但仍经常使用。</strong></li></ul><h3 id="3-2-分区收集器"><a href="#3-2-分区收集器" class="headerlink" title="3.2. 分区收集器"></a>3.2. 分区收集器</h3><ul><li><strong>G1：</strong> 一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能地满足垃圾收集暂停时间的要求。<strong>经常使用。</strong></li><li><strong>ZGC：</strong> JDK11 中推出的一款低延迟垃圾回收器，适用于大内存低延迟服务的内存管理和回收，SPECjbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68 ms，停顿时间远胜于 G1 和 CMS。<strong>近期也经常见到应用。</strong></li><li><strong>Shenandoah：</strong> 由 Red Hat 的一个团队负责开发，与 G1 类似，基于 Region 设计的垃圾收集器，但不需要 Remember Set 或者 Card Table <em>（都是 G1 中的数据结构）</em>来记录跨 Region 引用，停顿时间和堆的大小没有任何关系。停顿时间与 ZGC 接近。</li></ul><h2 id="4-GC-异常的判断"><a href="#4-GC-异常的判断" class="headerlink" title="4. GC 异常的判断"></a>4. GC 异常的判断</h2><h3 id="4-1-评价标准"><a href="#4-1-评价标准" class="headerlink" title="4.1. 评价标准"></a>4.1. 评价标准</h3><p>这里引用美团技术团队的文章，美团在生产实践中发现如下指标比较重要：</p><ul><li><strong>延迟（Latency）：</strong> 也可以理解为最大停顿时间，即垃圾收集过程中一次 STW 的最长时间，越短越好，一定程度上可以接受频次的增大，GC 技术的主要发展方向。</li><li><strong>吞吐量（Throughput）：</strong> 应用系统的生命周期内，由于 GC 线程会占用 Mutator 当前可用的 CPU 时钟周期，吞吐量即为 Mutator 有效花费的时间占系统总运行时间的百分比，例如系统运行了 100 min，GC 耗时 1 min，则系统吞吐量为 99%，吞吐量优先的收集器可以接受较长的停顿。</li></ul><p>目前各大互联网公司的系统基本都更追求低延时，避免一次 GC 停顿的时间过长对用户体验造成损失，衡量指标需要结合一下应用服务的 SLA，主要如下两点来判断：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175939344.png" alt="image-20231115175939344"></p><p>简而言之，即为**一次停顿的时间不超过应用服务的 TP9999，GC的吞吐量不小于 99.99%**。</p><blockquote><p>TP9999: 即 Top Percentile 99.99%，保证 99.99% 的网络服务可用的最低耗时</p></blockquote><p>举个例子，假设某个服务 A 的 TP9999 为 80 ms，平均 GC 停顿为 30 ms，那么该服务的最大停顿时间最好不要超过 80 ms，GC 频次控制在 5 min 以上一次。如果满足不了，那就需要调优或者通过更多资源来进行并联冗余。</p><p>备注：除了这两个指标之外还有 Footprint（资源量大小测量）、反应速度等指标，互联网这种实时系统追求低延迟，而很多嵌入式系统则追求 Footprint。</p><p>个人认为：作为时序数据库，IoTDB 追求低延时、异常可告警的需求和互联网公司系统这方面的需求大致吻合，因此可以将上述指标映射到 IoTDB 的 JVM GC 监控系统中作为参考。</p><h3 id="4-2-GC-Cause"><a href="#4-2-GC-Cause" class="headerlink" title="4.2. GC Cause"></a>4.2. GC Cause</h3><p>个人了解到，IoTDB 目前在某些实际环境有一些异常 GC，<strong>而要分析异常 GC，先要读懂 GC Cause</strong>，即 JVM 什么样的条件下选择进行 GC 操作，具体 Cause 的分类可以参考 Hotspot 源码：src&#x2F;share&#x2F;vm&#x2F;gc&#x2F;shared&#x2F;gcCause.hpp 和 src&#x2F;share&#x2F;vm&#x2F;gc&#x2F;shared&#x2F;gcCause.cpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GCCause::to_string</span><span class="params">(GCCause::Cause cause)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (cause) &#123;</span><br><span class="line">    <span class="keyword">case</span> _java_lang_system_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;System.gc()&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _full_gc_alot:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;FullGCAlot&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _scavenge_alot:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ScavengeAlot&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _allocation_profiler:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Allocation Profiler&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _jvmti_force_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;JvmtiEnv ForceGarbageCollection&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _gc_locker:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;GCLocker Initiated GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _heap_inspection:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Heap Inspection Initiated GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _heap_dump:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Heap Dump Initiated GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _wb_young_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;WhiteBox Initiated Young GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _update_allocation_context_stats_inc:</span><br><span class="line">    <span class="keyword">case</span> _update_allocation_context_stats_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Update Allocation Context Stats&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _no_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;No GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _allocation_failure:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Allocation Failure&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _tenured_generation_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Tenured Generation Full&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _metadata_GC_threshold:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Metadata GC Threshold&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_generation_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Generation Full&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_initial_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Initial Mark&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_final_remark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Final Remark&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_concurrent_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Concurrent Mark&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _old_generation_expanded_on_last_scavenge:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Old Generation Expanded On Last Scavenge&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _old_generation_too_full_to_scavenge:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Old Generation Too Full To Scavenge&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _adaptive_size_policy:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Ergonomics&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _g1_inc_collection_pause:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;G1 Evacuation Pause&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _g1_humongous_allocation:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;G1 Humongous Allocation&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _last_ditch_collection:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Last ditch collection&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _last_gc_cause:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ILLEGAL VALUE - last gc cause - ILLEGAL VALUE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;unknown GCCause&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ShouldNotReachHere</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体每种 Cause 的含义，可以参考：<a href="https://blog.csdn.net/lbh_paopao/article/details/120269135">https://blog.csdn.net/lbh_paopao/article/details/120269135</a></li></ul><p>对于以上 Cause，这里还是引用美团技术团队在业界实践的经验：</p><blockquote><p>重点需要关注的几个GC Cause：</p><ul><li><strong>System.gc()：</strong> 手动触发GC操作。</li><li><strong>CMS（如果使用的是 CMS 收集器的话）：</strong> CMS GC 在执行过程中的一些动作，重点关注 CMS Initial Mark 和 CMS Final Remark 两个 STW 阶段。</li><li><strong>Promotion Failure：</strong> Old 区没有足够的空间分配给 Young 区晋升的对象（即使总可用内存足够大，此处特指  CMS）。</li><li><strong>Concurrent</strong> <strong>Mode Failure（如果使用的是</strong> <strong>CMS</strong> <strong>收集器的话）：</strong> CMS GC 运行期间，Old 区预留的空间不足以分配给新的对象，此时收集器会发生退化，严重影响 GC 性能。</li><li><strong>GCLocker Initiated GC</strong>： 如果线程执行在 JNI 临界区时，刚好需要进行 GC，此时 GC Locker 将会阻止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。</li></ul></blockquote><h2 id="5-启示"><a href="#5-启示" class="headerlink" title="5. 启示"></a>5. 启示</h2><p>通过以上的基础调研，可以对 IoTDB JVM GC 监控系统的设计得出如下启示：</p><ol><li>收纳 <strong>延迟（Latency）和吞吐量（Throughput）</strong>作为 metric（可通过直接收集指标或间接计算得出），可以考虑使用 Timer 对每一个 GC Cause 记录 Duration，将 Cause 和 Duration 绑定起来一起记录，从而对 GC 异常分析有据可循。</li></ol><ul><li>期望大致效果如下：可以看到一段时间内应用 GC Cause 的集合以及 GC Duration 相关信息。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175800875.png" alt="image-20231115175800875"></p><ol><li>由于不同的 GC 收集器对内存的划分不同（对不同区域内存的行为也不同），因此需要针对不同 GC 收集器<strong>定制化 Memory usage 监控指标。</strong></li><li>某些 GC 收集器包含 concurrent phase（具体可以查看【10.其他】）。由于它们的 concurrent phase 并不 stw，导致 JMX 的 <strong>GcInfo.getDuration()</strong> 的<strong>实际值比应用程序的停止时间更长</strong>（因为它们把并发阶段也算进去了）。因此对于某些特殊收集器（如涉及到并行 GC），需要<strong>定制化指标计算方式，防止指标计算失准。</strong></li></ol><h2 id="6-现有监控工具及框架"><a href="#6-现有监控工具及框架" class="headerlink" title="6. 现有监控工具及框架"></a>6. 现有监控工具及框架</h2><p>功能大同小异，主要是使用体验上的差别，此处不赘述，仅罗列以扫盲。</p><h3 id="6-1-框架"><a href="#6-1-框架" class="headerlink" title="6.1. 框架"></a>6.1. 框架</h3><ul><li>集成框架（内置 JVM GC 监控模块）Micormeter、Dropwizard</li></ul><h3 id="6-2-命令行终端"><a href="#6-2-命令行终端" class="headerlink" title="6.2. 命令行终端"></a>6.2. 命令行终端</h3><ul><li>jps、jinfo、jstat、jstack、jmap、jcmd、arthas 等</li></ul><h3 id="6-3-可视化界面"><a href="#6-3-可视化界面" class="headerlink" title="6.3. 可视化界面"></a>6.3. 可视化界面</h3><ul><li>JConsole、GCHisto、GCViewer、JProfiler 等</li></ul><p>本文参考了以上项目关注的指标和设计方法。部分项目在 Github 有源码，感兴趣的读者可自行查阅。</p><h2 id="7-JMX-运行时指标收集工具"><a href="#7-JMX-运行时指标收集工具" class="headerlink" title="7. JMX - 运行时指标收集工具"></a>7. JMX - 运行时指标收集工具</h2><p>在实际的 Java 应用中，常常见到开发者通过添加 VM 参数<code>-XX:+PrintGC</code>、<code>-XX:+PrintHeapAtGC</code>等来获取 GC 相关信息。<strong>那么如何用代码的形式在运行时显式获取这些信息呢？</strong>答案是使用 <strong>JVM 提供的相应 api（JMX）。</strong></p><p>我们可以利用 JMX 提供的一些钩子函数，获得我们想要的信息，<strong>理论上来说，通过 JMX，我们可以自己手搓<code>-XX:+PrintGC</code>等的相关功能</strong>。接下来以 GC Info 为例，详细介绍一下 JMX 的相关概念和快速使用。</p><h3 id="7-1-什么是-JMX？"><a href="#7-1-什么是-JMX？" class="headerlink" title="7.1. 什么是 JMX？"></a>7.1. 什么是 JMX？</h3><blockquote><p>Java Management Extensions（<strong>JMX</strong>）技术是 Java SE 平台的标准功能，提供了一种简单的、标准的监控和管理资源的方式，对于如何定义一个资源给出了明确的结构和设计模式，主要用于监控和管理 Java 应用程序运行状态、设备和资源信息、Java 虚拟机运行情况等信息。 JMX 是可以动态的，所以也可以在资源创建、安装、实现时进行动态监控和管理，JDK 自带的 jconsole 就是使用 JMX 技术实现的监控工具。</p></blockquote><p>使用 JMX 技术时，通过定义一个被称为 <strong>MBean</strong> 或 <strong>MXBean</strong> 的 Java 对象来表示要管理指定的资源，然后可以把资源信息注册到 <strong>MBean Server</strong> 对外提供服务。MBean Server 充当了对外提供服务和对内管理 MBean 资源的代理功能，如此优雅的设计让 MBean 资源管理和 MBean Server 代理完全独立开，使之可以自由的控制 MBean 资源信息。</p><h3 id="7-2-资源管理-MBean"><a href="#7-2-资源管理-MBean" class="headerlink" title="7.2. 资源管理 MBean"></a>7.2. 资源管理 MBean</h3><p>在 JMX 中， 使用 <strong>MBean</strong> 或 <strong>MXBean</strong> 来表示一个资源（下面简称 MBean），访问和管理资源也都是通过 MBean，所以 MBean 往往包含着资源的<strong>属性和操作方法</strong>。</p><p>JMX 已经对 JVM 进行了多维度资源检测，所以可以轻松启动 JMX 代理来访问内置的 JVM 资源检测，从而通过 JMX 技术远程监控和管理 JVM。下表列出了一些 JMX 中的资源接口：</p><table><thead><tr><th><strong>资源接口</strong></th><th><strong>管理的资源</strong></th><th><strong>Object Name</strong></th><th><strong>VM</strong> <strong>中的实例个数</strong></th></tr></thead><tbody><tr><td>ClassLoadingMXBean</td><td>类加载</td><td>java.lang:type&#x3D; ClassLoading</td><td>1个</td></tr><tr><td>CompilationMXBean</td><td>汇编系统</td><td>java.lang:type&#x3D; Compilation</td><td>0 个或1个</td></tr><tr><td><strong>GarbageCollectorMXBean</strong>（本文主要关注的）</td><td><em><strong>垃圾收集</strong></em></td><td><em><strong>java.lang:type&#x3D; GarbageCollector, name&#x3D;collectorName</strong></em></td><td><em><strong>1个或更多</strong></em></td></tr><tr><td>LoggingMXBean</td><td>日志系统</td><td>java.util.logging:type &#x3D;Logging</td><td>1个</td></tr><tr><td><strong>MemoryManagerMXBean</strong></td><td><strong>内存池</strong></td><td><strong>java.lang: typeMemoryManager, name&#x3D;managerName</strong></td><td><strong>1个或更多</strong></td></tr><tr><td><strong>MemoryPoolMXBean</strong></td><td><strong>内存</strong></td><td><strong>java.lang: type&#x3D; MemoryPool, name&#x3D;poolName</strong></td><td><strong>1个或更多</strong></td></tr><tr><td><strong>MemoryMXBean</strong></td><td><strong>内存系统</strong></td><td><strong>java.lang:type&#x3D; Memory</strong></td><td><strong>1个</strong></td></tr><tr><td>OperatingSystemMXBean</td><td>操作系统</td><td>java.lang:type&#x3D; OperatingSystem</td><td>1个</td></tr><tr><td>RuntimeMXBean</td><td>运行时系统</td><td>java.lang:type&#x3D; Runtime</td><td>1个</td></tr><tr><td>hreadMXBean</td><td>线程系统</td><td>java.lang:type&#x3D; Threading</td><td>1个</td></tr></tbody></table><h3 id="7-2-JMX-的具体使用"><a href="#7-2-JMX-的具体使用" class="headerlink" title="7.2. JMX 的具体使用"></a>7.2. JMX 的具体使用</h3><ol><li>根据上面的信息，我们可以根据 JMX 内置的 MBean 获取系统信息，<strong>本文的</strong> <strong>JVM</strong> <strong>GC</strong> <strong>监控使用了此方法。</strong></li></ol><p>实例：获得<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">堆内存</a>和非堆内存的大小。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">monitorMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Memory:&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="type">MemoryMXBean</span> <span class="variable">mmbean</span> <span class="operator">=</span> ManagementFactory.getMemoryMXBean();</span><br><span class="line">        <span class="type">MemoryUsage</span> <span class="variable">hmu</span> <span class="operator">=</span> mmbean.getHeapMemoryUsage();</span><br><span class="line">        sb.append(<span class="string">&quot;[HeapMemoryUsage:&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot; Used=&quot;</span> + formatBytes(hmu.getUsed()));</span><br><span class="line">        sb.append(<span class="string">&quot; Committed=&quot;</span> + formatBytes(hmu.getCommitted()));</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">MemoryUsage</span> <span class="variable">nhmu</span> <span class="operator">=</span> mmbean.getNonHeapMemoryUsage();</span><br><span class="line">        sb.append(<span class="string">&quot;[NonHeapMemoryUsage:&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot; Used=&quot;</span> + formatBytes(nhmu.getUsed()));</span><br><span class="line">        sb.append(<span class="string">&quot; Committed=&quot;</span> + formatBytes(nhmu.getCommitted()));</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>我们甚至可以自己按需写一个 MBean 注册到 JMX 中，以供外部使用。<strong>（实际上在 IoTDB 中经常能够见到这样的应用）</strong></li></ul><p>MBean 的编写必须遵守 JMX 的设计规范，MBean 很像一个特殊的 Java Bean，它需要一个接口和一个实现类。MBean 资源接口总是以 MBean 或者 MXBean 结尾，实现类则要以接口去掉 MBean 或 MXBean 之后的名字来命名。</p><p>MBean 资源需要注册到 MBean Server 进行代理才可以暴露给外部进行调用，所以我们想要通过远程管理我们自定义的 MyMemory 资源，需要先进行资源代理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 MBean Server</span></span><br><span class="line"><span class="type">MBeanServer</span> <span class="variable">platformMBeanServer</span> <span class="operator">=</span> ManagementFactory.getPlatformMBeanServer();</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="type">ObjectName</span> <span class="variable">objectName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectName</span>(MBeanName);</span><br><span class="line">platformMBeanServer.registerMBean(your_mbean, objectName);</span><br></pre></td></tr></table></figure><h4 id="7-3-1-监听器模式——Notification"><a href="#7-3-1-监听器模式——Notification" class="headerlink" title="7.3.1. 监听器模式——Notification"></a>7.3.1. 监听器模式——Notification</h4><p>JMX API 定义了一种机制，使得 MBeans 能够生成通知 Notification，比如通知一个状态改变、一个检测到的事件或者问题，系统状态，GC 事件。通知的作用是主动通知远程客户端。例如程序出现异常，CPU使用率过高，出现了死锁等。这时程序能事件触发主动发送给远程客户端，将这些问题记录下来，或者执行一些其他的报警操作。<strong>本文的</strong> <strong>JVM</strong> <strong>GC 监控使用了此方法。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javax.management.Notification</span><br><span class="line">public class NotificationBroadcasterSupport implements NotificationEmitter &#123;</span><br><span class="line">    ...</span><br><span class="line">    public MBeanNotificationInfo[] getNotificationInfo()&#123;...&#125;</span><br><span class="line">    public void sendNotification(Notification notification)&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个 MBean 生成通知必须实现接口 <code>NotificationEmitter</code> 或者扩展 <code>NotificationBroadcasterSupport</code></li><li>Notification 监听器必须实现 <code>NotificationListener</code> 接口</li></ul><p>其中，本文重点关注 GC 相关的 Info，通过阅读源码得知 **<code>GarbageCollectionNotificationInfo</code>**（ notification）的数据结构如下：</p><table><thead><tr><th><strong>属性名</strong></th><th><strong>类型</strong></th><th><strong>注释</strong></th></tr></thead><tbody><tr><td>gcName</td><td>java.lang.String</td><td>如: G1 Old Generation,G1 Young Generation等</td></tr><tr><td>gcAction</td><td>java.lang.String</td><td>标识是哪个 gc 动作，一般为：end of major GC，end of minor GC 等，分别表示老年代和新生代的 gc 结束。</td></tr><tr><td>gcCause</td><td>java.lang.String</td><td>引起 gc 的原因,如：System.gc()，Allocation Failure，G1 Humongous Allocation等</td></tr><tr><td>gcInfo</td><td>javax.management.openmbean.CompositeData</td><td>gc 的详细信息，见下表</td></tr></tbody></table><p>通过阅读 openjdk 官网手册和源码，我们可以得知 <strong><code>GCInfo</code></strong> 详细信息如下：</p><table><thead><tr><th><strong>属性名</strong></th><th><strong>类型</strong></th><th><strong>注释</strong></th></tr></thead><tbody><tr><td>index</td><td>java.lang.Long</td><td>标识这个收集器进行了几次 gc（垃圾回收事件的 ID）</td></tr><tr><td>startTime</td><td>java.lang.Long</td><td>gc 的开始时间</td></tr><tr><td>endTime</td><td>java.lang.Long</td><td>gc 的结束时间</td></tr><tr><td>memoryUsageBeforeGc</td><td>javax.management.openmbean.TabularData</td><td>gc 前内存情况</td></tr><tr><td>memoryUsageAfterGc</td><td>javax.management.openmbean.TabularData</td><td>gc 后内存情况</td></tr></tbody></table><p>以 GC 为例，最简单的 <code>NotificationListener</code> 使用如下：</p><ul><li>该程序实现了：当发生 GC 时，自动读取 GC 时间、GC 原因、相关内存池前后使用情况等相关信息（见 <code>map</code> 变量）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GarbageNotificationListener</span> <span class="keyword">implements</span> <span class="title class_">NotificationListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNotification</span><span class="params">(Notification notification, Object handback)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">notifType</span> <span class="operator">=</span> notification.getType();</span><br><span class="line">        <span class="keyword">if</span> (notifType.equals(GarbageCollectionNotificationInfo.GARBAGE_COLLECTION_NOTIFICATION)) &#123;</span><br><span class="line">            <span class="type">CompositeData</span> <span class="variable">cd</span> <span class="operator">=</span> (CompositeData) notification.getUserData();</span><br><span class="line">            <span class="type">GarbageCollectionNotificationInfo</span> <span class="variable">info</span> <span class="operator">=</span> GarbageCollectionNotificationInfo.from(cd);</span><br><span class="line">            <span class="type">GcInfo</span> <span class="variable">gcInfo</span> <span class="operator">=</span> info.getGcInfo();</span><br><span class="line">            HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;duration&quot;</span>, gcInfo.getDuration());</span><br><span class="line">            map.put(<span class="string">&quot;id&quot;</span>, gcInfo.getId());</span><br><span class="line">            map.put(<span class="string">&quot;UsageAfterGc&quot;</span>, gcInfo.getMemoryUsageAfterGc());</span><br><span class="line">            map.put(<span class="string">&quot;UsageBeforeGc&quot;</span>, gcInfo.getMemoryUsageBeforeGc());</span><br><span class="line">            map.put(<span class="string">&quot;GcAction&quot;</span>, info.getGcAction());</span><br><span class="line">            map.put(<span class="string">&quot;GcCause&quot;</span>, info.getGcCause());</span><br><span class="line">            map.put(<span class="string">&quot;GcName&quot;</span>, info.getGcName());</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-监控方案设计"><a href="#8-监控方案设计" class="headerlink" title="8. 监控方案设计"></a>8. 监控方案设计</h2><h3 id="8-1-push-base"><a href="#8-1-push-base" class="headerlink" title="8.1. push base"></a>8.1. push base</h3><blockquote><p>参考：org.apache.cassandra.service.GCInspector、<em>io.micrometer.core.instrument.binder.jvm.JvmGcMetrics</em></p><p>IoTDB 实现类：</p><ul><li>org.apache.iotdb.metrics.metricsets.jvm.JvmGcMetrics</li></ul></blockquote><p><strong>思路：</strong>利用 JMX 的 notification 机制，实现一个 Listener 对 GC 进行监听。每次 JVM 发生 GC 时，接受 JVM 主动发送的 GcInfo，从中解析出相应的信息（具体查看【9. 监控指标设计】）</p><p><strong>核心方法：</strong>可查看源码，此处不再赘述</p><p><strong>注意点：</strong></p><ul><li>包含并发过程 GC 的 duration 需要采用特别的计算方式，因为 GcInfo.getDuration() 得到的 duration 比实际 stw 的时间长（把并发标记的时间也算上去了）</li><li>一些 GC 如 G1 会在 minor GC 时减小 old gen memory 的 size，需要对其进行追踪</li><li>需要对非代际 GC 和 分代 GC 分别监控</li></ul><p><strong>与 IoTDB 整合的实现效果：</strong></p><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175714192.png" alt="image-20231115175714192" style="zoom:50%;" /></div><h3 id="8-2-pull-base"><a href="#8-2-pull-base" class="headerlink" title="8.2. pull base"></a>8.2. pull base</h3><blockquote><p>参考：org.apache.hadoop.util.GcTimeMonitor</p><p>IoTDB 实现类：</p><ul><li>org.apache.iotdb.commons.service.metric.JvmGcMetrics </li><li>org.apache.iotdb.commons.service.metric.GcTimeAlerter</li></ul></blockquote><p><strong>思路：</strong>在<strong>设定好的频率</strong>下，不断 pull JMX 中的 GC 信息。该 metric 类将监视 JVM 在指定观察窗口（例如1分钟）内的 GC 暂停时间的百分比。用户可以<strong>提供一个钩子</strong>（hook），当这个百分比超过<strong>指定的阈值</strong>（例如 70%）时，将会调用该钩子进行告警、处理等操作。</p><p><strong>核心方法：</strong><code>calculateGCTimePercentageWithinObservedInterval()</code> 在设定好的频率下不停运行。假设调用该方法的时刻是 <code>startTs</code>，那么该方法将计算 [<code>startTs</code> - <code>observerWindowMs</code>，<code>startTs</code>] 时间窗口下的 <code>GcTime</code>、<code>GcCount</code></p><ul><li>方法内部：统计所有 collector 的 <code>GcTime</code> 和 <code>GcCount</code>，并将该次统计信息保存到一个循环缓冲区里，并更新该缓冲区的开始和结束索引以跟踪最早和最新的 GC 暂停时间戳。<ul><li>注意从最早的时间戳开始累加 GcTime 时，需要考虑 <code>startTs</code> - <code>observerWindowMs</code> <strong>之前</strong>发生并延续到[<code>startTs</code> - <code>observerWindowMs</code>，<code>startTs</code>] 时间窗口下的 GC。这时我们只需要统计该时间窗口下的 Gc，<strong>舍弃</strong><code>startTs</code> - <code>observerWindowMs</code> 之前的 GC 时间。</li></ul></li></ul><p><strong>告警处理：</strong>当在指定观察窗口内的 GC 暂停时间百分比超过指定的阈值（例如 70%）时，将会调用<code>org.apache.iotdb.commons.service.metric.GcTimeAlerter</code>进行告警、处理等操作。用户可以在此部分自定义代码，比如打日志、清理内存等。（目前只实现了简单的 <code>logger.warn()</code> 告警功能，如下图）</p><blockquote><p><strong>目前实现的 Alerter 效果：</strong></p><ul><li>打印当前异常时间</li><li>打印当前时间窗口内，GC 时间所占比例（类似吞吐量）</li><li>打印当前时间窗口内，累计 GC 时间</li><li>打印当前时间窗口的起始时间</li><li>打印当前时间窗口的时长（默认为 1 分钟，如果 IoTDB 启动还没满 1 分钟，那么该值为 IoTDB 的累计运行时间）</li></ul></blockquote><p><strong>与 IoTDB 整合的实现效果：</strong></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175656708.png" alt="image-20231115175656708"></p><h3 id="8-3-测试方法"><a href="#8-3-测试方法" class="headerlink" title="8.3. 测试方法"></a>8.3. 测试方法</h3><p>IDEA 3c3d（3个 ConfigNode、3个 DataNode） 环境下，在 IoTDB ConfigNode 和 DataNode 启动时开启一个添加内存的线程，并可以按需 System.gc()。通过观察日志和 <code>curl localhost:9091/metrics</code> 观察指标。以 IoTDB ConfigNode 为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  LOGGER.info(</span><br><span class="line">      <span class="string">&quot;&#123;&#125; environment variables: &#123;&#125;&quot;</span>,</span><br><span class="line">      ConfigNodeConstant.GLOBAL_NAME,</span><br><span class="line">      ConfigNodeConfig.getEnvironmentVariables());</span><br><span class="line">  LOGGER.info(</span><br><span class="line">      <span class="string">&quot;&#123;&#125; default charset is: &#123;&#125;&quot;</span>,</span><br><span class="line">      ConfigNodeConstant.GLOBAL_NAME,</span><br><span class="line">      Charset.defaultCharset().displayName());</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ConfigNodeCommandLine</span>().doMain(args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">          () -&gt; &#123;</span><br><span class="line">            List&lt;<span class="type">byte</span>[]&gt; byteList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">              <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">              byteList.add(bytes);</span><br><span class="line">              <span class="comment">// 可以手动 GC，也可以让系统自动 GC 直至 heap overflow</span></span><br><span class="line"><span class="comment">//              if (i % 10 == 0) &#123;</span></span><br><span class="line"><span class="comment">//                System.gc();</span></span><br><span class="line"><span class="comment">//              &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      .start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-监控指标设计"><a href="#9-监控指标设计" class="headerlink" title="9. 监控指标设计"></a>9. 监控指标设计</h2><h3 id="9-1-push-base"><a href="#9-1-push-base" class="headerlink" title="9.1. push base"></a>9.1. push base</h3><table><thead><tr><th><strong>metric</strong></th><th><strong>Type</strong></th><th><strong>Monitor Approach</strong></th><th><strong>Tips</strong></th></tr></thead><tbody><tr><td>jvm_gc_max_data_size_bytes</td><td>AutoGauge</td><td>JMX</td><td>长生命周期内存池 (old gen &amp; perm gen(Metaspace)  最大内存大小</td></tr><tr><td>jvm_gc_live_data_size_bytes</td><td>AutoGauge</td><td>notification update</td><td>长生命周期内存池已使用大小</td></tr><tr><td>jvm_gc_young_memory_allocated_bytes</td><td>Counter</td><td>notification update</td><td>年轻代内存池已分配对象大小</td></tr><tr><td>jvm_gc_old_memory_allocated_bytes</td><td>Counter</td><td>notification update</td><td>年老代内存池直接分配的对象大小（不包括晋升的对象）</td></tr><tr><td>jvm_gc_non_gen_memory_allocated_bytes</td><td>Counter</td><td>notification update</td><td>非代际内存池已分配的对象大小</td></tr><tr><td>jvm_gc_memory_promoted_bytes</td><td>Counter</td><td>notification update</td><td>移动到 old gen 的对象大小</td></tr><tr><td>jvm_gc_pause</td><td>Timer</td><td>notification update</td><td>具体 GC cause 下的 GC 暂停时间<strong>（将不同</strong> <strong>GC</strong> <strong>的 cause 跟每次 GC 的 duration 绑定，Timer 还可以统计各 cause 的频率）</strong></td></tr><tr><td>jvm_zgc_pauses_count</td><td>Counter</td><td>notification update</td><td><strong>ZGC</strong> pauses 的次数</td></tr><tr><td>jvm_zgc_cycles_count</td><td>Counter</td><td>notification update</td><td><strong>ZGC</strong> circles 的次数</td></tr></tbody></table><h3 id="9-2-pull-base"><a href="#9-2-pull-base" class="headerlink" title="9.2. pull base"></a>9.2. pull base</h3><table><thead><tr><th><strong>metric</strong></th><th><strong>Type</strong></th><th><strong>Monitor Approach</strong></th><th><strong>Tips</strong></th></tr></thead><tbody><tr><td>jvm_gc_accumulated_time</td><td>Alerter 日志打印</td><td>JMX + 累加计算</td><td>在指定时间窗口内，GC 总时间，单位毫秒<strong>，支持 ZGC</strong></td></tr><tr><td>observation_window_start_time</td><td>Alerter 日志打印</td><td>计算</td><td>指定时间窗口的起始时间</td></tr><tr><td>observation_window_end_time</td><td>Alerter 日志打印</td><td>计算</td><td>指定时间窗口的结束时间</td></tr><tr><td>observation_window_time</td><td>Alerter 日志打印</td><td>计算</td><td>指定时间窗口的总时长，默认为 1 min。如果 IoTDB 启动还没满 1 分钟，那么该值为 IoTDB 的累计运行时间</td></tr><tr><td>jvm_gc_accumulated_time_percentage</td><td>AutoGauge</td><td>jvm_gc_accumulated_time &#x2F; total_time</td><td>在指定时间窗口内，GC 时间所占的比例（类似吞吐量的概念）。若超过 threshold，进行告警<strong>（可选）</strong></td></tr></tbody></table><h2 id="10-其他"><a href="#10-其他" class="headerlink" title="10. 其他"></a>10. 其他</h2><p>在实际场景中，<strong>G1 和</strong> <strong>CMS</strong> <strong>使用的较多</strong>，而 <strong>ZGC 作为内存不分代的新型垃圾回收器代表</strong>，也有必要被研究。尽管这些算法的具体执行细节难以监控追踪，但我们仍可以了解它们。这里做一个简单整理，更深入可以阅读资料或者查看 hotspot 源码。</p><h3 id="10-1-CMS-经久不衰的常用回收器"><a href="#10-1-CMS-经久不衰的常用回收器" class="headerlink" title="10.1. CMS - 经久不衰的常用回收器"></a>10.1. CMS - 经久不衰的常用回收器</h3><blockquote><p>CMS（Concurrent Mark Sweep）垃圾回收器是第一个关注 GC 停顿时间的垃圾收集器。 在这之前的垃圾回收器，要么就是串行垃圾回收方式，要么就是关注系统吞吐量。这样的垃圾回收器对于强交互的程序很不友好，而 CMS 垃圾回收器的出现，则打破了这个尴尬的局面。因此，CMS 垃圾回收器诞生之后就受到了大家的欢迎，导致现在还有非常多的应用还在继续使用它。</p></blockquote><p>CMS 垃圾回收器之所以能够实现对 GC 停顿时间的控制，其本质来源于对「根可达算法」的改进，即三色标记算法。在 CMS 垃圾回收器出现之前，无论是 Serious 垃圾回收器，还是 ParNew 垃圾回收器，亦或是 Parallel Scavenge 垃圾回收器，他们在进行垃圾回收的时候都需要 Stop the World，即无法实现垃圾回收线程与用户线程并发执行。而 CMS 垃圾回收器通过<strong>三色标记算法，</strong>实现了垃圾回收线程<strong>与用户线程并发执行</strong>，从而极大地降低了系统响应时间，提高了强交互应用程序的体验。</p><h4 id="10-1-1-三色标记算法"><a href="#10-1-1-三色标记算法" class="headerlink" title="10.1.1. 三色标记算法"></a>10.1.1. 三色标记算法</h4><p>三色标记法将对象的颜色分为了黑、灰、白，三种颜色。</p><p>「白色」：该对象没有被标记过。（对象垃圾）</p><p>「灰色」：该对象已经被标记过了，但该对象下的属性没有全被标记完。（GC 需要从此对象中去寻找垃圾）</p><p>「黑色」：该对象已经被标记过了，且该对象下的属性也全部都被标记过了。（程序所需要的对象）</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175630425.png" alt="image-20231115175630425"></p><h5 id="10-1-2-算法流程"><a href="#10-1-2-算法流程" class="headerlink" title="10.1.2. 算法流程"></a>10.1.2. 算法流程</h5><p>从 GC Root 开始沿着他们的对象向下查找，用黑灰白的规则，标记出所有跟 GC Root 相连接的对象，扫描一遍结束后，一般需要进行一次短暂的 STW，再次进行扫描，此时因为黑色对象的属性都也已经被标记过了，所以只需找出灰色对象并顺着继续往下标记（且因为大部分的标记工作已经在第一次并发的时候发生了，所以灰色对象数量会很少，标记时间也会短很多）, 此时程序继续执行，GC 线程扫描所有的内存，找出扫描之后依旧被标记为白色的对象（垃圾）并清除。具体流程如下</p><ol><li>首先创建三个集合：白、灰、黑。</li><li>将所有对象放入白色集合中。</li><li>然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入灰色集合。</li><li>之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</li><li>重复 4 直到灰色中无任何对象</li><li>通过 write-barrier 检测对象有变化，重复以上操作</li><li>收集所有白色对象（垃圾）</li></ol><h5 id="10-1-3-存在问题"><a href="#10-1-3-存在问题" class="headerlink" title="10.1.3. 存在问题"></a>10.1.3. 存在问题</h5><ol><li><strong>浮动垃圾</strong>：并发标记的过程中，若一个已经被标记成黑色或者灰色的对象，突然变成了垃圾，由于不会再对黑色标记过的对象重新扫描，所以不会被发现，那么这个对象不是白色的但是不会被清除，重新标记也不能从 GC Root 中去找到，所以成为了浮动垃圾，「浮动垃圾对系统的影响不大，留给下一次 GC 进行处理即可」。</li><li><strong>对象漏标问题（需要的对象被回收）</strong>：并发标记的过程中，一个业务线程将一个未被扫描过的白色对象断开引用成为垃圾（删除引用），同时黑色对象引用了该对象（增加引用）（这两部可以不分先后顺序）；因为黑色对象的含义为其属性都已经被标记过了，重新标记也不会从黑色对象中去找，导致该对象被程序所需要，却又要被 GC 回收，此问题会导致系统出现问题，对此「CMS 对增加引用环节进行处理（Increment Update），G1 则对删除引用环节进行处理 (SATB)（这里不做详细介绍，可以自行查阅）」</li></ol><h4 id="10-1-2-与用户线程并发执行-GC"><a href="#10-1-2-与用户线程并发执行-GC" class="headerlink" title="10.1.2. 与用户线程并发执行 GC"></a>10.1.2. 与用户线程并发执行 GC</h4><p><strong>主要</strong>分为4个阶段（注意，该部分在 G1 回收器中也能窥见思想和相似应用）</p><ul><li><strong>初始标记（CMS initial mark）</strong>，指的是寻找所有被 GCRoots 引用的对象，该阶段需要「Stop the World」。 这个步骤仅仅只是标记一下 GC Roots 能直接关联到的对象，并不需要做整个引用的扫描，因此速度很快。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175606653.png" alt="image-20231115175606653"></p><ul><li><strong>并发标记（CMS concurrent mark）</strong>，指的是对「初始标记阶段」标记的对象进行整个引用链的扫描，该阶段不需要「Stop the World」。 对整个引用链做扫描需要花费非常多的时间，因此通过垃圾回收线程与用户线程并发执行，可以降低垃圾回收的时间，从而降低系统响应时间。但这也带来了一些问题，即：并发标记的时候，引用可能发生变化，因此可能发生漏标（本应该被标记的对象，没有被正确地标记颜色，导致不应该回收的对象被回收）和多标（本不该被标记的对象，被错误地标记颜色，导致应该被回收的对象没有被回收）了。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175554390.png" alt="image-20231115175554390"></p><ul><li><strong>重新标记（CMS remark）</strong>，指的是对「并发标记」阶段出现的问题进行校正，该阶段需要「Stop the World」。 正如并发标记阶段说到的，由于垃圾回收算法和用户线程并发执行，虽然能降低响应时间，但是会发生漏标和多标的问题。所以对于 CMS 回收器来说，它需要这个阶段来做一些校验，解决并发标记阶段发生的问题。</li><li><strong>并发清除（CMS concurrent sweep）</strong>，指的是将标记为垃圾的对象进行清除，该阶段不需要「Stop the World」。 在这个阶段，垃圾回收线程与用户线程可以并发执行，因此并不影响用户的响应时间。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175542197.png" alt="image-20231115175542197"></p><p>从上面的描述步骤中我们可以看出：CMS 之所以能极大地降低 GC 停顿时间，本质上是将原本冗长的引用链扫描进行切分。通过 GC 线程与用户线程并发执行，加上重新标记校正的方式，减少了垃圾回收的时间。</p><h3 id="10-2-G1-CMS-的替代者-Java-9-默认回收器"><a href="#10-2-G1-CMS-的替代者-Java-9-默认回收器" class="headerlink" title="10.2. G1 - CMS 的替代者 | Java 9 默认回收器"></a>10.2. G1 - CMS 的替代者 | Java 9 默认回收器</h3><h4 id="10-2-1-内存模型"><a href="#10-2-1-内存模型" class="headerlink" title="10.2.1. 内存模型"></a>10.2.1. 内存模型</h4><p>传统的 GC 收集器将连续的内存空间划分为新生代、老年代和永久代（JDK8 去除了永久代，引入了元空间 Metaspace），这种划分的特点是各代的存储地址（逻辑地址，下同）是连续的。如下图所示：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175528545.png" alt="image-20231115175528545"></p><p>而G1的各代存储地址是<strong>不连续的</strong>，每一代都使用了 n 个不连续的<strong>大小相同</strong>的 Region，每个 Region 占有一块连续的虚拟内存地址（<strong>但内存仍是分代际的，只是分散在不连续的 Region 中</strong>）。如下图所示：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175518344.png" alt="image-20231115175518344"></p><p>这里为了帮助理解，再贴一张 CMS（传统收集器） 和 G1 的内存分布图：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175504522.png" alt="image-20231115175504522"></p><p>在上面的图中，注意到还有一些 Region 标明了 H，它代表 Humongous，这表示这些 Region 存储的是巨大对象（humongous object，H-obj），即大小 ≥ region 一半的对象。H-obj 有如下几个特征：</p><ul><li>H-obj 直接分配到了 old gen，防止了反复拷贝移动。</li><li>H-obj 在 global concurrent marking 阶段的 cleanup 和 full GC 阶段回收。</li><li>在分配 H-obj 之前先检查是否超过 initiating heap occupancy percent 和 the marking threshold（G1 的相关参数，可通过 VM 参数设定）, 如果超过的话，就启动 global concurrent marking，为的是提早回收，防止 evacuation failures 和 full GC。</li></ul><blockquote><p>为了减少连续 H-objs 分配对 GC 的影响，需要把大对象变为普通的对象，建议增大 Region size。</p></blockquote><p>一个 Region 的大小可以通过参数<code> -XX:G1HeapRegionSize</code> 设定，取值范围从 1M 到 32M，且是2的指数。如果不设定，那么 G1 会根据 Heap 大小自动决定</p><p>每一个分配的 Region，都可以分成两个部分，已分配的和未被分配的。它们之间的界限被称为 top。总体上来说，把一个对象分配到 Region 内，只需要简单增加 top 的值。这个做法实际上就是 bump-the-pointer。过程如下：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175448522.png" alt="image-20231115175448522"></p><p>Region 可以说是 G1 回收器一次回收的最小单元。即每一次回收都是回收 N 个 Region。这个 N 是多少，主要受到 G1 回收的效率和用户设置的<strong>软实时目标</strong><em>（用户可以指定<strong>垃圾回收</strong>时间的限时，G1会努力在这个时限内完成垃圾回收，但是G1并不担保每次都能在这个时限内完成垃圾回收。通过设定一个合理的目标，可以让达到90%以上的垃圾回收时间都在这个时限内。）</em>有关。每一次的回收，G1 会选择可能回收最多垃圾的 Region 进行回收。与此同时，G1 回收器会维护一个空间 Region 的链表。每次回收之后的 Region 都会被加入到这个链表中。</p><h4 id="10-2-2-GC-模式"><a href="#10-2-2-GC-模式" class="headerlink" title="10.2.2. GC 模式"></a>10.2.2. GC 模式</h4><p>G1提供了两种GC模式，<strong>Young GC</strong> 和 <strong>Mixed GC</strong>，两种都是完全 Stop The World 的，下面依次简单介绍：</p><blockquote><p>补充论据：为什么 Young GC 和 Mixed GC 都是 stw 的？</p><p><strong>结论：几乎所有收集器的所有回收策略（Young、Mixed、Full）都会 stw，只是停顿时间不同。</strong></p><ol><li>什么情况&#x2F;操作会 STW<ol><li>以 G1 为例。引用《深入理解 Java 虚拟机》，G1 的运行过程有4个步骤：<ul><li>初始标记：标记 GC Roots 的可达对象以及其他一些指针修改操作。<strong>GC Roots 的对象扫描操作是 stw 的，尽管停顿时间很短。</strong>因为如果与用户线程并行，会存在漏扫、错扫等问题</li><li>并发标记，不 stw</li><li>最终标记：<strong>很显然是 stw 的</strong>，因为是为了修正并发标记时可能发生的漏标错标问题，所以必须暂停用户线程以保证正确性。</li><li>筛选回收：负责更新 Region 的统计数据，制定回收计划。可以自由的选择任意多个 Region 构成回收集，然后把决定回收的那部分 Region 复制到空的 Region 中，再清理掉整个旧 Region 的空间（即标记-复制算法）。<strong>由于操作涉及存活对象的移动，必须 stw。</strong></li></ul></li><li>让我们把粒度再变细一点，在 GC 操作中，以下情况会 stw：<ul><li><strong>根节点枚举</strong>。因为必须 Root scan 必须在一个能保障一致性的快照中才能得以进行，否则无法保证正确性，尽管现在可达性分析算法中的查找引用链过程已经能够做到和用户线程并发。</li><li><strong>存活对象的移动</strong>。常发生在标记-复制、标记-整理算法的对象清理过程中</li></ul></li></ol></li><li>Young GC、Mixed GC、Full GC 过程中发生了什么？<ol><li>GC 无论是发生在哪个区域（哪个 region），基本过程都类似，都需要有<strong>扫描和标记的环节（如枚举根节点）</strong>来找出需要被回收&#x2F;复制的对象，如果涉及标记-整理算法，如 Full GC ，还需要整理内存。<strong>这些环节都需要 stw 来保证正确性。</strong>所以我们说所有种类的 GC 都 stw<strong>，</strong>只是 stw 的时间不同。</li></ol></li><li>验证论据<ol><li><p>提出 G1 的论文：<a href="https://dl.acm.org/doi/abs/10.1145/1029873.1029879">Garbage-first garbage collection | Proceedings of the 4th international symposium on Memory manageme</a></p><ul><li>文中 section 3.4 提到：In <strong>fully-young generational mode</strong>, we maintain a dynamic estimate of the number of young-generation regions that <strong>leads to an evacuation pause</strong> that meets the pause time bound, and initiate a pause whenever this number of young regions is allocated. For steady-state applications, this leads to a natural period between evacuation pauses. Note that we can meet the soft real-time goal only if this period exceeds its time slice. <strong>In partially-young mode</strong>, on the other hand, <strong>we do evacuation pauses</strong> as often as the soft real-time goal allows. Doing pauses at the maximum allowed frequency minimizes the number of young regions collected in those pauses, and therefore maximizes the number of non-young regions that may be added to the collection set.</li><li>具体的论述与 GC 的停顿时间预测有关，此处不展开赘述。但我们可以从作者的论述看出：Young GC 和 Mixed GC 都会有 <strong>evacuation pauses。</strong></li><li>那么什么是 evacuation pause 呢？论文的 section 2.4 给出了定义：At appropriate points (described in section 3.4), <strong>we stop the mutator threads and perform an evacuation pause.</strong></li><li>由此可以感性的认知：G1 的 young GC 和 mixed GC 是会 stw 的。</li></ul></li><li><p>源码：G1 触发 Young GC 后，会执行一个叫 do_collection_pause 的方法，方法签名如下：</p></li><li><pre><code class="C++">HeapWord* G1CollectedHeap::do_collection_pause(size_t word_size,                                               unsigned int gc_count_before,                                               bool* succeeded,                                               GCCause::Cause gc_cause) &#123;  // 记录 gc 停顿  g1_policy()-&gt;record_stop_world_start();  // gc 操作任务类,第三个参数表示本次 gc 是不是老年代并发 gc  VM_G1IncCollectionPause op(gc_count_before,                             word_size,                             false, /* should_initiate_conc_mark */                             g1_policy()-&gt;max_pause_time_ms(),                             gc_cause);  // 真正的停顿方法在 VMThread::execute(&amp;op) 中  VMThread::execute(&amp;op);                                            HeapWord* result = op.result();  bool ret_succeeded = op.prologue_succeeded() &amp;&amp; op.pause_succeeded();                                            *succeeded = ret_succeeded;                                            return result;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. do_collection_pause 会在 VMThread::execute(&amp;op) 里会产生停顿，再来看这个方法：</span><br><span class="line">5. ```C++</span><br><span class="line">   void VMThread::execute(VM_Operation* op) &#123;</span><br><span class="line">     Thread* t = Thread::current();</span><br><span class="line">     // 判断当前线程是否是 vm 线程</span><br><span class="line">     if (!t-&gt;is_VM_thread()) &#123;</span><br><span class="line">       // 跳过这里，其实这里的逻辑是当前不是 vm 线程是 java 线程或者 watcher 线程</span><br><span class="line">       // 会先将任务放到一个 queue 中，之后再执行</span><br><span class="line">       ......</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       // 如果是 vm 线程则会进入这里</span><br><span class="line">       ......</span><br><span class="line">       HandleMark hm(t);</span><br><span class="line">       _cur_vm_operation = op;</span><br><span class="line">       // 判断任务是否需要在安全点执行且当前是否在安全点</span><br><span class="line">       if (op-&gt;evaluate_at_safepoint() &amp;&amp; !SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">         // 如果不是安全点,则等待所有线程进入安全点,然后把线程暂时挂起</span><br><span class="line">         // 这个类中有个状态 _state,所有 java 线程转换线程状态时会去判断这个状态然后</span><br><span class="line">         // 决定是否 block</span><br><span class="line">         SafepointSynchronize::begin();</span><br><span class="line">         // 开始任务, op 是刚刚传入的 VM_G1IncCollectionPause 操作任务类</span><br><span class="line">         // evaluate() 方法最后会调用 gc 操作任务类的 doit() 方法</span><br><span class="line">         op-&gt;evaluate();</span><br><span class="line">         // 安全点结束</span><br><span class="line">         SafepointSynchronize::end();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         // 是安全点则直接执行</span><br><span class="line">         op-&gt;evaluate();</span><br><span class="line">       &#125;</span><br><span class="line">                                             </span><br><span class="line">       if (op-&gt;is_cheap_allocated()) delete op;</span><br><span class="line">                                             </span><br><span class="line">       _cur_vm_operation = prev_vm_operation;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>该方法会判断线程是否都进入安全区（安全区概念参考：<a href="https://www.zhihu.com/question/371699670%EF%BC%8C%E8%AF%A5%E9%97%AE%E9%A2%98%E9%AB%98%E8%B5%9E%E5%9B%9E%E7%AD%94%E6%AF%94%E8%BE%83%E5%85%A8%E9%9D%A2%E7%9A%84%E9%98%90%E8%BF%B0%E4%BA%86%E5%AE%89%E5%85%A8%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%8C%BA%E5%8F%97%E7%94%A8%E7%9A%84%EF%BC%89%EF%BC%8C%E5%A6%82%E6%98%AF%EF%BC%8C%E6%89%A7%E8%A1%8C">https://www.zhihu.com/question/371699670，该问题高赞回答比较全面的阐述了安全区的概念，挺受用的），如是，执行</a> op-&gt;evaluate() 以 stw。实际上，<strong>SafepointSynchronize::begin() 方法内包括了准备进入安全点到所有 java 线程 Block 的过程，此时 Young</strong> <strong>GC</strong> <strong>的全局停顿开始了</strong>。因此，Young GC 是 stw 的。</p></li><li><p>Mixed GC 和 Full GC 由于涉及到老年代内存对象的回收，需要根节点枚举、对象复制整理等操作，显然是 stw 的，此处不再从源码角度赘述。</p></li></ol></li></ol><ul><li>Reference：<ul><li><a href="https://dl.acm.org/doi/abs/10.1145/1029873.1029879">Garbage-first garbage collection | Proceedings of the 4th international symposium on Memory manageme</a></li><li>深入理解 Java 虚拟机（第三版）</li><li><a href="https://zhuanlan.zhihu.com/p/114293273">JVM源码分析之G1垃圾收集器分析一</a></li><li><a href="https://zhuanlan.zhihu.com/p/528819545">细节炸裂！阿里大佬深入探究G1源码之YoungGC技术</a></li><li><a href="https://blog.csdn.net/a860MHz/article/details/97799282">JVM G1 源码分析(五)- 新生代回收YGC_g1 新生代_860MHz的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/a860MHz/article/details/98062558">JVM G1 源码分析(六)- 混合式GC_g1 混合gc_860MHz的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/a860MHz/article/details/98494732">JVM G1 源码分析(七)- Full GC_jvm g1 full gc 触发参数_860MHz的博客-CSDN博客CSDN博客</a></li></ul></li></ul></blockquote><ul><li>Young GC：选定所有年轻代里的 Region。通过控制年轻代的 region 个数，即年轻代内存大小，来控制 young GC的时间开销。</li><li>Mixed GC：选定所有年轻代里的 Region，外加根据 global concurrent marking 统计得出收集收益高的若干老年代 Region。在用户指定的开销目标范围内尽可能选择收益高的老年代 Region。</li></ul><p>由上面的描述可知，Mixed GC 不是 full GC，它只能回收部分老年代的 Region，如果 mixed GC 实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行 Mixed GC，就会使用 serial old GC（full GC）来收集整个 GC heap。所以我们可以知道，<strong>G1 是不提供 full GC 的</strong>。</p><p>此外，Young GC 和 Mixed GC 都是基于「标记-复制算法」的</p><p>上文中，多次提到了<strong>「global</strong> <strong>concurrent</strong> <strong>marking」</strong>，它的执行过程类似 CMS，但是不同的是，在 G1 GC 中，它主要是为 Mixed GC 提供标记服务的，并不是一次 GC 过程的一个必须环节。global concurrent marking 的执行过程分为四个步骤：</p><ol><li><strong>初始标记（initial mark，STW）</strong>。它标记了从 GC Root 开始直接可达的对象。</li><li><strong>并发标记（Concurrent Marking）</strong>。这个阶段从 GC Root 开始对 heap 中的对象标记，标记线程与应用程序线程并行执行，并且收集各个 Region 的存活对象信息。 </li><li><strong>重新标记（Remark，STW）</strong>。标记那些在并发标记阶段发生变化的对象，将被回收。</li><li><strong>清除垃圾（Cleanup）</strong>。清除空 Region（没有存活对象的），加入到 free list。</li></ol><p>第一阶段 initial mark 是共用了 Young GC 的暂停，这是因为他们可以复用 root scan 操作，所以可以说 global concurrent marking 是伴随 Young GC 而发生的。第四阶段 Cleanup 只是回收了没有存活对象的 Region，所以它并不需要 STW。</p><p>那什么时候发生 Mixed GC 呢？其实是由一些参数控制着的，另外也控制着哪些老年代 Region 会被选入 Collection Set（<em>Collection Set（CSet），记录了 GC 要收集的 Region 集合，集合里的 Region 可以是任意年代的</em>）。</p><ul><li>G1HeapWastePercent：在 global concurrent marking 结束之后，我们可以知道 old gen regions 中有多少空间要被回收，在每次 YGC 之后和再次发生 Mixed GC 之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生Mixed GC。</li><li>G1MixedGCLiveThresholdPercent：old generation region 中的存活对象的占比，只有在此参数之下，才会被选入CSet。</li><li>G1MixedGCCountTarget：一次 global concurrent marking 之后，最多执行 Mixed GC 的次数。</li><li>G1OldCSetRegionThresholdPercent：一次 Mixed GC 中能被选入 CSet 的最多 old generation region 数量。</li></ul><blockquote><p>由于篇幅限制，这里就只整理了对理解 G1 比较重要的 region 概念以及 GC 模式。其实 G1 还有其它的专有算法以及数据结构，比如停顿预测、Remember Set、SATB 等，感兴趣的读者可以自行搜索。</p></blockquote><h3 id="10-3-ZGC-基于非代际内存的最新回收器"><a href="#10-3-ZGC-基于非代际内存的最新回收器" class="headerlink" title="10.3. ZGC - 基于非代际内存的最新回收器"></a>10.3. ZGC - 基于非代际内存的最新回收器</h3><p>ZGC（The Z Garbage Collector）是 JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：</p><ul><li>停顿时间不超过10ms；</li><li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</li><li>支持 8MB~4TB 级别的堆（未来支持 16TB）</li></ul><h4 id="10-3-1-内存模型"><a href="#10-3-1-内存模型" class="headerlink" title="10.3.1. 内存模型"></a>10.3.1. 内存模型</h4><p>ZGC 与传统的 CMS、G1 不同、它没有分代的概念，只有类似 G1 的 Region 概念，ZGC 的 Region 可以具有如下图所示的大中下三类容量：</p><ul><li>小型 Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。</li><li>中型 Region（Medium Region）：容量固定为32MB，用于放置大于256KB但是小于4MB的对象。</li><li>大型 Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型 Region 中会存放一个大对象，这也预示着虽然名字叫“大型 Region”，但它的实际容量完全有可能小于中型 Region，最小容量可低至4MB。大型 Region 在 ZGC 的实现中是不会被重分配的（重分配是ZGC的一种处理动作，用于复制对象的收集器阶段）因为复制大对象的代价非常高。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175430186.png" alt="image-20231115175430186"></p><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用「标记-复制」算法，不过 ZGC 对该算法做了重大改进：ZGC 在标记、转移和重定位阶段几乎都是并发的，这是 ZGC 实现停顿时间小于10ms目标的最关键原因。</p><p>ZGC 垃圾回收周期如下图所示：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175414710.png" alt="image-20231115175414710"></p><p>ZGC只有三个STW阶段：<strong>初始标记</strong>，<strong>再标记</strong>，<strong>初始转移</strong>。其中，初始标记和初始转移分别都只需要扫描所有 GC Roots，其处理时间和 GC Roots 的数量成正比，一般情况耗时非常短；再标记阶段 STW 时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC 几乎所有暂停都只依赖于 GC Roots 集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与 ZGC 对比，G1 的转移阶段完全 STW 的，且停顿时间随存活对象的大小增加而增加。</p><p>Java 实测打印 ZGC 的内存池结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CodeHeap <span class="string">&#x27;non-nmethods&#x27;</span></span><br><span class="line">Metaspace</span><br><span class="line">ZHeap</span><br><span class="line">CodeHeap <span class="string">&#x27;profiled nmethods&#x27;</span></span><br><span class="line">Compressed Class Space</span><br><span class="line">CodeHeap <span class="string">&#x27;non-profiled nmethods&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="10-3-2-关键技术"><a href="#10-3-2-关键技术" class="headerlink" title="10.3.2. 关键技术"></a>10.3.2. 关键技术</h4><p>ZGC 通过<strong>着色指针</strong>和<strong>读屏障技术</strong>，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着 GC 线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在 ZGC 中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM 是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。</p><p><strong>着色指针</strong></p><blockquote><p>着色指针是一种将信息存储在指针中的技术。</p></blockquote><p>ZGC仅支持64位系统，它把64位虚拟地址空间划分为多个子空间，如下图所示：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175350372.png" alt="image-20231115175350372"></p><p>其中，[0~4TB) 对应Java堆，[4TB ~ 8TB) 称为 M0 地址空间，[8TB ~ 12TB) 称为 M1 地址空间，[12TB ~ 16TB) 预留未使用，[16TB ~ 20TB) 称为 Remapped 空间。</p><p>当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址。ZGC 同时会为该对象在 M0、M1 和 Remapped 地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但<strong>这三个空间在同一时间有且只有一个空间有效</strong>。ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低 GC 停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。后面将详细介绍这三个空间的切换过程。</p><p>与上述地址空间划分相对应，ZGC 实际仅使用64位地址空间的第0<del>41位，而第42</del>45位存储元数据，第47~63位固定为0。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175338597.png" alt="image-20231115175338597"></p><p>ZGC将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。</p><p><strong>读屏障</strong></p><blockquote><p>读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。</p></blockquote><p>读屏障示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> obj.FieldA   <span class="comment">// 从堆中读取引用，需要加入屏障</span></span><br><span class="line">&lt;Load barrier&gt;</span><br><span class="line"><span class="type">Object</span> <span class="variable">p</span> <span class="operator">=</span> o  <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line">o.dosomething() <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br></pre></td></tr></table></figure><p>ZGC 中读屏障的代码作用：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。</p><p>接下来详细介绍ZGC一次垃圾回收周期中地址视图的切换过程：</p><ul><li><strong>初始化</strong>：ZGC初始化之后，整个内存空间的地址视图被设置为 Remapped。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。</li><li><strong>并发标记阶段</strong>：第一次进入标记阶段时视图为 M0，如果对象被 GC 标记线程或者应用线程访问过，那么就将对象的地址视图从 Remapped 调整为 M0。所以，在标记阶段结束之后，对象的地址要么是 M0视图，要么是 Remapped。如果对象的地址是 M0 视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。</li><li><strong>并发转移阶段</strong>：标记结束后就进入转移阶段，此时地址视图再次被设置为 Remapped。如果对象被 GC转移线程或者应用线程访问过，那么就将对象的地址视图从 M0 调整为 Remapped。</li></ul><p>其实，在标记阶段存在两个地址视图 M0 和 M1，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了区别前一次标记和当前标记。也即，第二次进入并发标记阶段后，地址视图调整为 M1，而非M0。</p><p>着色指针和读屏障技术不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中；而在 ZGC 中，只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175323045.png" alt="image-20231115175323045"></p><h3 id="10-4-其他分享"><a href="#10-4-其他分享" class="headerlink" title="10.4. 其他分享"></a>10.4. 其他分享</h3><h4 id="10-4-1-如何调试-GC-的-notification-线程？"><a href="#10-4-1-如何调试-GC-的-notification-线程？" class="headerlink" title="10.4.1. 如何调试 GC 的 notification 线程？"></a>10.4.1. 如何调试 GC 的 notification 线程？</h4><p>JDK 8、11 的 notification 是 Service Thread 在做，这个 Thread 不能被 idea 捕获，无法正常调试；</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175301099.png" alt="image-20231115175301099"></p><p>解决：JDK 17 里 notification 的 handle 由 Notification Thread 负责，可以被 idea 捕获，把 JDK 换成 17 之后就可以切换到 Notification Thread 调试 handleNotification </p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175243105.png" alt="image-20231115175243105"></p><h4 id="10-4-2-GC-使用参数"><a href="#10-4-2-GC-使用参数" class="headerlink" title="10.4.2. GC 使用参数"></a>10.4.2. GC 使用参数</h4><table><thead><tr><th>Collector</th><th>Option</th></tr></thead><tbody><tr><td>指定年轻代为Serial收集器</td><td>-XX:+UseSerialGC</td></tr><tr><td>指定老年代为Serial收集器</td><td>‐XX:+UseSerialOldGC</td></tr><tr><td>指定年轻代为ParNew收集器</td><td>‐XX:+UseParNewGC</td></tr><tr><td>指定年轻代为 Parallel 收集器</td><td>‐XX:+UseParallelGC</td></tr><tr><td>指定老年代为 Parallel 收集器</td><td>‐XX:+UseParallelOldGC</td></tr><tr><td>指定老年代为 CMS 收集器</td><td>‐XX:+UseConcMarkSweepGC</td></tr><tr><td>G1</td><td>‐XX:+UseG1GC</td></tr><tr><td>ZGC</td><td>-XX:+UseZGC</td></tr></tbody></table><p>IDEA 使用：在 VM options 添加即可</p><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175206555.png" alt="image-20231115175206555" style="zoom:60%;" /></div><h4 id="10-4-3-JMX-可以监控-G1-的-mixed-GC-吗？"><a href="#10-4-3-JMX-可以监控-G1-的-mixed-GC-吗？" class="headerlink" title="10.4.3. JMX 可以监控 G1 的 mixed GC 吗？"></a>10.4.3. JMX 可以监控 G1 的 mixed GC 吗？</h4><p>不能。实验过程如下：</p><p><strong>可以看到，对于同一次 GC，JVM自带的 GC log 显示是 mixed GC，但 JMX 显示为 minor GC。</strong></p><ul><li>猜测：由于 mixed GC 在 hotspot 源码中是由 YGC 触发，所以 JMX 为了简化将 YGC 和 mixed GC 统一视为 minor GC。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[GC pause (G1 Evacuation Pause) (mixed), <span class="number">0.0237647</span> secs]</span><br><span class="line">   [Parallel <span class="type">Time</span>: <span class="number">22.2</span> ms, GC Workers: <span class="number">9</span>]</span><br><span class="line">      [GC Worker <span class="keyword">Start</span> (ms): Min: <span class="number">10897.2</span>, Avg: <span class="number">10899.3</span>, Max: <span class="number">10900.4</span>, Diff: <span class="number">3.3</span>]</span><br><span class="line">      [Ext Root Scanning (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.1</span>, Max: <span class="number">0.4</span>, Diff: <span class="number">0.3</span>, Sum: <span class="number">0.7</span>]</span><br><span class="line">      [<span class="keyword">Update</span> RS (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">1.1</span>, Max: <span class="number">4.3</span>, Diff: <span class="number">4.3</span>, Sum: <span class="number">9.8</span>]</span><br><span class="line">         [Processed Buffers: Min: <span class="number">0</span>, Avg: <span class="number">1.6</span>, Max: <span class="number">6</span>, Diff: <span class="number">6</span>, Sum: <span class="number">14</span>]</span><br><span class="line">      [Scan RS (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>, Sum: <span class="number">0.1</span>]</span><br><span class="line">      [Code Root Scanning (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>, Sum: <span class="number">0.0</span>]</span><br><span class="line">      [Object <span class="keyword">Copy</span> (ms): Min: <span class="number">7.4</span>, Avg: <span class="number">8.6</span>, Max: <span class="number">8.8</span>, Diff: <span class="number">1.4</span>, Sum: <span class="number">77.2</span>]</span><br><span class="line">      [Termination (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">1.3</span>, Max: <span class="number">10.3</span>, Diff: <span class="number">10.3</span>, Sum: <span class="number">11.8</span>]</span><br><span class="line">         [Termination Attempts: Min: <span class="number">1</span>, Avg: <span class="number">397.3</span>, Max: <span class="number">588</span>, Diff: <span class="number">587</span>, Sum: <span class="number">3576</span>]</span><br><span class="line">      [GC Worker Other (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>, Sum: <span class="number">0.1</span>]</span><br><span class="line">      [GC Worker Total (ms): Min: <span class="number">8.9</span>, Avg: <span class="number">11.1</span>, Max: <span class="number">19.0</span>, Diff: <span class="number">10.2</span>, Sum: <span class="number">99.7</span>]</span><br><span class="line">      [GC Worker <span class="keyword">End</span> (ms): Min: <span class="number">10909.3</span>, Avg: <span class="number">10910.4</span>, Max: <span class="number">10919.3</span>, Diff: <span class="number">10.0</span>]</span><br><span class="line">   [Code Root Fixup: <span class="number">0.0</span> ms]</span><br><span class="line">   [Code Root Purge: <span class="number">0.0</span> ms]</span><br><span class="line">   [Clear CT: <span class="number">0.1</span> ms]</span><br><span class="line">   [Other: <span class="number">1.5</span> ms]</span><br><span class="line">      [Choose CSet: <span class="number">0.0</span> ms]</span><br><span class="line">      [<span class="keyword">Ref</span> Proc: <span class="number">1.2</span> ms]</span><br><span class="line">      [<span class="keyword">Ref</span> Enq: <span class="number">0.0</span> ms]</span><br><span class="line">      [Redirty Cards: <span class="number">0.1</span> ms]</span><br><span class="line">      [Humongous Register: <span class="number">0.1</span> ms]</span><br><span class="line">      [Humongous Reclaim: <span class="number">0.0</span> ms]</span><br><span class="line">      [<span class="keyword">Free</span> CSet: <span class="number">0.0</span> ms]</span><br><span class="line">   [Eden: <span class="number">46080.0</span>K(<span class="number">46080.0</span>K)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">0.0</span>B(<span class="number">48128.0</span>K) Survivors: <span class="number">7168.0</span>K<span class="operator">-</span><span class="operator">&gt;</span><span class="number">7168.0</span>K Heap: <span class="number">1043.1</span>M(<span class="number">1049.0</span>M)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">1044.6</span>M(<span class="number">1098.0</span>M)]</span><br><span class="line"> [Times: <span class="keyword">user</span><span class="operator">=</span><span class="number">0.05</span> sys<span class="operator">=</span><span class="number">0.01</span>, <span class="type">real</span><span class="operator">=</span><span class="number">0.02</span> secs] </span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.446</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> <span class="keyword">end</span> <span class="keyword">of</span> minor GC</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> minor GC: <span class="operator">-</span> <span class="number">45</span> (G1_Evacuation_Pause) <span class="keyword">start</span>: <span class="number">2023</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">58</span>:<span class="number">54.422</span>, <span class="keyword">end</span>: <span class="number">2023</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">58</span>:<span class="number">54.445</span></span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [G1 <span class="keyword">Old</span> Gen] init:<span class="number">235520</span>K; used:<span class="number">24.1</span><span class="operator">%</span>(<span class="number">1014924</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">25.3</span><span class="operator">%</span>(<span class="number">1062540</span>K); committed: <span class="number">24.2</span><span class="operator">%</span>(<span class="number">1017856</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">25.4</span><span class="operator">%</span>(<span class="number">1065984</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [Code Cache] init:<span class="number">2496</span>K; used:<span class="number">1.9</span><span class="operator">%</span>(<span class="number">2586</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1.9</span><span class="operator">%</span>(<span class="number">2586</span>K); committed: <span class="number">2.0</span><span class="operator">%</span>(<span class="number">2624</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">2.0</span><span class="operator">%</span>(<span class="number">2624</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [G1 Survivor Space] init:<span class="number">0</span>K; used:<span class="number">7168</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">7168</span>K); committed: <span class="number">7168</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">7168</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [Compressed Class Space] init:<span class="number">0</span>K; used:<span class="number">0.0</span><span class="operator">%</span>(<span class="number">777</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0.0</span><span class="operator">%</span>(<span class="number">777</span>K); committed: <span class="number">0.0</span><span class="operator">%</span>(<span class="number">896</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0.0</span><span class="operator">%</span>(<span class="number">896</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [Metaspace] init:<span class="number">0</span>K; used:<span class="number">6965</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">6965</span>K); committed: <span class="number">7296</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">7296</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [G1 Eden Space] init:<span class="number">26624</span>K; used:<span class="number">46080</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span>K); committed: <span class="number">49152</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">51200</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> duration:<span class="number">23</span>ms, throughput:<span class="number">96.4</span><span class="operator">%</span></span><br></pre></td></tr></table></figure><p><strong>测试参数：</strong></p><p>这里有一个 trick：由于 G1 的特点，我们希望能平缓的增加内存，使得 G1 「来得及」进行垃圾回收，触发 mixed GC，而不是触发 full GC。因此需要对 JVM 进行调参，同时测试代码中需要延缓内存消耗速度。</p><blockquote><p>-XX:+PrintGCDetails -XX:+UseG1GC -XX:InitiatingHeapOccupancyPercent&#x3D;20 &#x2F;&#x2F; 默认值为 40，是触发 mixed GC 的堆内存占用 threshold，这里调低一点，防止 full GC -XX:G1HeapWastePercent&#x3D;5 &#x2F;&#x2F; 当整个堆可回收的百分比小于该阈值时，Java HotSpot VM不会启动Mixed GC。默认值为10％。这里同理，调低一点防止 full GC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">          <span class="comment">// manually add heap usage</span></span><br><span class="line">          List&lt;<span class="type">byte</span>[]&gt; byteList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">          <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">10000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 为了尽量少的触发 Full GC 而触发 mixed GC，需要减缓内存消耗速度</span></span><br><span class="line">                Thread.sleep(TimeUnit.MILLISECONDS.toMillis(<span class="number">100</span>));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            byteList.add(bytes);</span><br><span class="line">            i++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    .start();</span><br></pre></td></tr></table></figure></blockquote><h4 id="10-4-4-Duration-的计算准确性"><a href="#10-4-4-Duration-的计算准确性" class="headerlink" title="10.4.4. Duration 的计算准确性"></a>10.4.4. Duration 的计算准确性</h4><p>这里贴一个详细的例子来说明：涉及并发 GC 时，JMX notification 提供的 duration 比实际 duration 大。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175146661.png" alt="image-20231115175146661"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[GC pause (G1 Evacuation Pause) (mixed), <span class="number">0.0162640</span> secs]</span><br><span class="line">   [Parallel <span class="type">Time</span>: <span class="number">15.6</span> ms, GC Workers: <span class="number">9</span>]</span><br><span class="line">      [GC Worker <span class="keyword">Start</span> (ms): Min: <span class="number">9212.1</span>, Avg: <span class="number">9214.5</span>, Max: <span class="number">9215.2</span>, Diff: <span class="number">3.1</span>]</span><br><span class="line">      [Ext Root Scanning (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.1</span>, Max: <span class="number">0.6</span>, Diff: <span class="number">0.6</span>, Sum: <span class="number">0.6</span>]</span><br><span class="line">      [<span class="keyword">Update</span> RS (ms): Min: <span class="number">0.9</span>, Avg: <span class="number">2.0</span>, Max: <span class="number">3.2</span>, Diff: <span class="number">2.2</span>, Sum: <span class="number">18.0</span>]</span><br><span class="line">         [Processed Buffers: Min: <span class="number">1</span>, Avg: <span class="number">2.1</span>, Max: <span class="number">4</span>, Diff: <span class="number">3</span>, Sum: <span class="number">19</span>]</span><br><span class="line">      [Scan RS (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.1</span>, Max: <span class="number">0.3</span>, Diff: <span class="number">0.3</span>, Sum: <span class="number">1.1</span>]</span><br><span class="line">      [Code Root Scanning (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>, Sum: <span class="number">0.0</span>]</span><br><span class="line">      [Object <span class="keyword">Copy</span> (ms): Min: <span class="number">9.3</span>, Avg: <span class="number">10.2</span>, Max: <span class="number">10.7</span>, Diff: <span class="number">1.4</span>, Sum: <span class="number">92.0</span>]</span><br><span class="line">      [Termination (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.4</span>, Max: <span class="number">0.5</span>, Diff: <span class="number">0.5</span>, Sum: <span class="number">3.3</span>]</span><br><span class="line">         [Termination Attempts: Min: <span class="number">1</span>, Avg: <span class="number">449.8</span>, Max: <span class="number">606</span>, Diff: <span class="number">605</span>, Sum: <span class="number">4048</span>]</span><br><span class="line">      [GC Worker Other (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.1</span>, Diff: <span class="number">0.1</span>, Sum: <span class="number">0.4</span>]</span><br><span class="line">      [GC Worker Total (ms): Min: <span class="number">12.2</span>, Avg: <span class="number">12.8</span>, Max: <span class="number">15.2</span>, Diff: <span class="number">3.1</span>, Sum: <span class="number">115.4</span>]</span><br><span class="line">      [GC Worker <span class="keyword">End</span> (ms): Min: <span class="number">9227.3</span>, Avg: <span class="number">9227.3</span>, Max: <span class="number">9227.4</span>, Diff: <span class="number">0.1</span>]</span><br><span class="line">   [Code Root Fixup: <span class="number">0.0</span> ms]</span><br><span class="line">   [Code Root Purge: <span class="number">0.0</span> ms]</span><br><span class="line">   [Clear CT: <span class="number">0.1</span> ms]</span><br><span class="line">   [Other: <span class="number">0.5</span> ms]</span><br><span class="line">      [Choose CSet: <span class="number">0.0</span> ms]</span><br><span class="line">      [<span class="keyword">Ref</span> Proc: <span class="number">0.2</span> ms]</span><br><span class="line">      [<span class="keyword">Ref</span> Enq: <span class="number">0.0</span> ms]</span><br><span class="line">      [Redirty Cards: <span class="number">0.1</span> ms]</span><br><span class="line">      [Humongous Register: <span class="number">0.1</span> ms]</span><br><span class="line">      [Humongous Reclaim: <span class="number">0.0</span> ms]</span><br><span class="line">      [<span class="keyword">Free</span> CSet: <span class="number">0.0</span> ms]</span><br><span class="line">   [Eden: <span class="number">38912.0</span>K(<span class="number">38912.0</span>K)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">0.0</span>B(<span class="number">40960.0</span>K) Survivors: <span class="number">6144.0</span>K<span class="operator">-</span><span class="operator">&gt;</span><span class="number">6144.0</span>K Heap: <span class="number">880.2</span>M(<span class="number">886.0</span>M)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">882.2</span>M(<span class="number">928.0</span>M)]</span><br><span class="line"> [Times: <span class="keyword">user</span><span class="operator">=</span><span class="number">0.08</span> sys<span class="operator">=</span><span class="number">0.02</span>, <span class="type">real</span><span class="operator">=</span><span class="number">0.02</span> secs] </span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">58.092</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> <span class="keyword">end</span> <span class="keyword">of</span> minor GC</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">58.092</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> minor GC: <span class="operator">-</span> <span class="number">41</span> (G1_Evacuation_Pause) <span class="keyword">start</span>: <span class="number">2023</span><span class="number">-07</span><span class="number">-26</span> <span class="number">10</span>:<span class="number">48</span>:<span class="number">58.074</span>, <span class="keyword">end</span>: <span class="number">2023</span><span class="number">-07</span><span class="number">-26</span> <span class="number">10</span>:<span class="number">48</span>:<span class="number">58.091</span></span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">58.092</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> duration:<span class="number">17</span>ms, throughput:<span class="number">96.4</span><span class="operator">%</span></span><br></pre></td></tr></table></figure><p>可以看到：这里发生了 mixed GC，有部分 old genertaion 内存被回收。由于 old generation 的回收有一部分 phase 和用户线程并发，这里 JMX notification 提供的 duration 17ms 大于实际的 duration（GC log 打印）16.2ms。</p><blockquote><p>实测这里的误差比较小，在 Millisecond 的粒度，很多时候看不出来误差。然而误差仍然是存在的。</p></blockquote><p>当涉及并发 GC（某些阶段可以和用户线程并发执行，如 G1 old generation）的 duration 时，JMX notification 提供的 duration 实际上比准确的 duration 要大。因此此时需要换一种计算方式：主动向 gcBean 获取总回收时间，通过作差算出现在所需的运算时间。</p><h5 id="10-4-4-1-源码说明"><a href="#10-4-4-1-源码说明" class="headerlink" title="10.4.4.1. 源码说明"></a>10.4.4.1. 源码说明</h5><p><strong>结论</strong>：</p><ul><li>JMX 提供了两种得到 GC duration 的 api，一种是 notification 的 gcInfo，一种是向 GarbageCollectorMXBean 拉取累计 GC 时间，作差算出 duration。前者在涉及并发 GC 的时候 duration 有点不准确。</li><li>GarbageCollectorMXBean 的 getCollectionTime() 方法计算的是 GC pause 的时间，如果 GC 包含与用户线程并发的部分，不会被计算入 getCollectionTime() 中。因此这种方法算出来的 GC duration 是准确的 stw 时间。</li></ul><p>接下来看看为什么 GarbageCollectorMXBean 的 getCollectionTime() 方法获取的是准确的 stw 时间。</p><p>首先来看看 java 上该方法的签名：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175127154.png" alt="image-20231115175127154"></p><p>深入 getCollectionTime()，发现是 native 方法</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175112530.png" alt="image-20231115175112530"></p><p>查看 openjdk 源码，native 方法签名如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jlong JNICALL <span class="title">Java_sun_management_GarbageCollectorImpl_getCollectionTime</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *env, jobject mgr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jmm_interface-&gt;<span class="built_in">GetLongAttribute</span>(env, mgr, JMM_GC_TIME_MS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是返回 JMM_GC_TIME_MS 变量，继续追踪，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">get_gc_attribute</span><span class="params">(GCMemoryManager* mgr, jmmLongAttribute att)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (att) &#123;</span><br><span class="line">  <span class="keyword">case</span> JMM_GC_TIME_MS:</span><br><span class="line">    <span class="keyword">return</span> mgr-&gt;<span class="built_in">gc_time_ms</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> JMM_GC_COUNT:</span><br><span class="line">    <span class="keyword">return</span> mgr-&gt;<span class="built_in">gc_count</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> JMM_GC_EXT_ATTRIBUTE_INFO_SIZE:</span><br><span class="line">    <span class="comment">// current implementation only has 1 ext attribute</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">0</span>, <span class="string">&quot;Unrecognized GC attribute&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该变量通过 mgr-&gt;gc_time_ms() 获取，mgr 是 GCMemoryManager，这个类的签名如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GCMemoryManager</span> : <span class="keyword">public</span> MemoryManager &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> We should unify the GCCounter and GCMemoryManager statistic</span></span><br><span class="line">  <span class="type">size_t</span>       _num_collections;</span><br><span class="line">  elapsedTimer _accumulated_timer;</span><br><span class="line">  GCStatInfo*  _last_gc_stat;</span><br><span class="line">  Mutex*       _last_gc_lock;</span><br><span class="line">  GCStatInfo*  _current_gc_stat;</span><br><span class="line">  <span class="type">int</span>          _num_gc_threads;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">bool</span> _notification_enabled;</span><br><span class="line">  <span class="type">bool</span>         _pool_always_affected_by_gc[MemoryManager::max_num_pools];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">GCMemoryManager</span>(<span class="type">const</span> <span class="type">char</span>* name);</span><br><span class="line">  ~<span class="built_in">GCMemoryManager</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_pool</span><span class="params">(MemoryPool* pool)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_pool</span><span class="params">(MemoryPool* pool, <span class="type">bool</span> always_affected_by_gc)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">pool_always_affected_by_gc</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">num_memory_pools</span>(), <span class="string">&quot;Invalid index&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> _pool_always_affected_by_gc[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span>   <span class="title">initialize_gc_stat_info</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span>   <span class="title">is_gc_memory_manager</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="function">jlong  <span class="title">gc_time_ms</span><span class="params">()</span>                   </span>&#123; <span class="keyword">return</span> _accumulated_timer.<span class="built_in">milliseconds</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">gc_count</span><span class="params">()</span>                     </span>&#123; <span class="keyword">return</span> _num_collections; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span>    <span class="title">num_gc_threads</span><span class="params">()</span>               </span>&#123; <span class="keyword">return</span> _num_gc_threads; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span>   <span class="title">set_num_gc_threads</span><span class="params">(<span class="type">int</span> count)</span>  </span>&#123; _num_gc_threads = count; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span>   <span class="title">gc_begin</span><span class="params">(<span class="type">bool</span> recordGCBeginTime, <span class="type">bool</span> recordPreGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">bool</span> recordAccumulatedGCTime)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span>   <span class="title">gc_end</span><span class="params">(<span class="type">bool</span> recordPostGCUsage, <span class="type">bool</span> recordAccumulatedGCTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">bool</span> recordGCEndTime, <span class="type">bool</span> countCollection, GCCause::Cause cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">bool</span> allMemoryPoolsAffected, <span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span>        <span class="title">reset_gc_stat</span><span class="params">()</span>   </span>&#123; _num_collections = <span class="number">0</span>; _accumulated_timer.<span class="built_in">reset</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy out _last_gc_stat to the given destination, returning</span></span><br><span class="line">  <span class="comment">// the collection count. Zero signifies no gc has taken place.</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">get_last_gc_stat</span><span class="params">(GCStatInfo* dest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_notification_enabled</span><span class="params">(<span class="type">bool</span> enabled)</span> </span>&#123; _notification_enabled = enabled; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_notification_enabled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _notification_enabled; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现，最终 gc_time 是 _accumulated_timer 来记录的。这个 timer 是通过记录 start 和 end 时间，将 end 和 start 时间作差进行计时的。</p><p>那 start 和 end 时间是在哪里记录的呢？继续跟进发现在 gc_begin() 和 gc_end() 方法里。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GCMemoryManager::gc_begin</span><span class="params">(<span class="type">bool</span> recordGCBeginTime, <span class="type">bool</span> recordPreGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">bool</span> recordAccumulatedGCTime)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(_last_gc_stat != <span class="literal">nullptr</span> &amp;&amp; _current_gc_stat != <span class="literal">nullptr</span>, <span class="string">&quot;Just checking&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (recordAccumulatedGCTime) &#123;</span><br><span class="line">    _accumulated_timer.<span class="built_in">start</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// _num_collections now increases in gc_end, to count completed collections</span></span><br><span class="line">  <span class="keyword">if</span> (recordGCBeginTime) &#123;</span><br><span class="line">    _current_gc_stat-&gt;<span class="built_in">set_index</span>(_num_collections+<span class="number">1</span>);</span><br><span class="line">    _current_gc_stat-&gt;<span class="built_in">set_start_time</span>(Management::<span class="built_in">timestamp</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GCMemoryManager::gc_end</span><span class="params">(<span class="type">bool</span> recordPostGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> recordAccumulatedGCTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> recordGCEndTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> countCollection,</span></span></span><br><span class="line"><span class="params"><span class="function">                             GCCause::Cause cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> allMemoryPoolsAffected,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> <span class="type">char</span>* message)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (recordAccumulatedGCTime) &#123;</span><br><span class="line">    _accumulated_timer.<span class="built_in">stop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (recordGCEndTime) &#123;</span><br><span class="line">    _current_gc_stat-&gt;<span class="built_in">set_end_time</span>(Management::<span class="built_in">timestamp</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 gc_begin() 和 gc_end() 方法是何时调用呢？继续跟进，省去一些中间 wrapper，最终可以发现是在 TraceMemoryManagerStats 这个类里调用。该类签名如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TraceMemoryManagerStats::<span class="built_in">TraceMemoryManagerStats</span>(GCMemoryManager* gc_memory_manager,</span><br><span class="line">                                                 GCCause::Cause cause,</span><br><span class="line">                                                 <span class="type">const</span> <span class="type">char</span>* end_message,</span><br><span class="line">                                                 <span class="type">bool</span> allMemoryPoolsAffected,</span><br><span class="line">                                                 <span class="type">bool</span> recordGCBeginTime,</span><br><span class="line">                                                 <span class="type">bool</span> recordPreGCUsage,</span><br><span class="line">                                                 <span class="type">bool</span> recordPeakUsage,</span><br><span class="line">                                                 <span class="type">bool</span> recordPostGCUsage,</span><br><span class="line">                                                 <span class="type">bool</span> recordAccumulatedGCTime,</span><br><span class="line">                                                 <span class="type">bool</span> recordGCEndTime,</span><br><span class="line">                                                 <span class="type">bool</span> countCollection) &#123;</span><br><span class="line">  <span class="built_in">initialize</span>(gc_memory_manager, cause, end_message,</span><br><span class="line">             allMemoryPoolsAffected, recordGCBeginTime, recordPreGCUsage,</span><br><span class="line">             recordPeakUsage, recordPostGCUsage, recordAccumulatedGCTime,</span><br><span class="line">             recordGCEndTime, countCollection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for a subclass to create then initialize an instance before invoking</span></span><br><span class="line"><span class="comment">// the MemoryService</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraceMemoryManagerStats::initialize</span><span class="params">(GCMemoryManager* gc_memory_manager,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         GCCause::Cause cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> <span class="type">char</span>* end_message,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> allMemoryPoolsAffected,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordGCBeginTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordPreGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordPeakUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordPostGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordAccumulatedGCTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordGCEndTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> countCollection)</span> </span>&#123;</span><br><span class="line">  _gc_memory_manager = gc_memory_manager;</span><br><span class="line">  _cause = cause;</span><br><span class="line">  _end_message = end_message;</span><br><span class="line">  _allMemoryPoolsAffected = allMemoryPoolsAffected;</span><br><span class="line">  _recordGCBeginTime = recordGCBeginTime;</span><br><span class="line">  _recordPreGCUsage = recordPreGCUsage;</span><br><span class="line">  _recordPeakUsage = recordPeakUsage;</span><br><span class="line">  _recordPostGCUsage = recordPostGCUsage;</span><br><span class="line">  _recordAccumulatedGCTime = recordAccumulatedGCTime;</span><br><span class="line">  _recordGCEndTime = recordGCEndTime;</span><br><span class="line">  _countCollection = countCollection;</span><br><span class="line"></span><br><span class="line">  MemoryService::<span class="built_in">gc_begin</span>(_gc_memory_manager, _recordGCBeginTime, _recordAccumulatedGCTime,</span><br><span class="line">                          _recordPreGCUsage, _recordPeakUsage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TraceMemoryManagerStats::~<span class="built_in">TraceMemoryManagerStats</span>() &#123;</span><br><span class="line">  MemoryService::<span class="built_in">gc_end</span>(_gc_memory_manager, _recordPostGCUsage, _recordAccumulatedGCTime,</span><br><span class="line">                        _recordGCEndTime, _countCollection, _cause, _allMemoryPoolsAffected,</span><br><span class="line">                        _end_message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重点来了</strong>：TraceMemoryManagerStats 在初始化时调用 gc_begin() 来记录开始时间，在析构时调用 gc_end() 记录结束时间。也就是说，TraceMemoryManagerStats 的生命周期长度等于记录的 <strong>GC 时间。在 JVM 中，在需要记录 GC duration 的地方声明一个 TraceMemoryManagerStats 对象就可以达到记录时间的目的，如果某些 GC phases，如 G1 的并发标记阶段，不需要记录 GC duration，那么就不会声明 TraceMemoryManagerStats 对象。</strong></p><p>接下来追踪该对象在哪里被声明，哪里被析构。继续跟进，发现对于 G1，G1MonitoringScape 类 wrap 了 TraceMemoryManagerStats 对象：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Scope object for java.lang.management support.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">G1MonitoringScope</span> : <span class="keyword">public</span> StackObj &#123;</span><br><span class="line">  G1MonitoringSupport* _monitoring_support;</span><br><span class="line">  TraceCollectorStats _tcs;</span><br><span class="line">  TraceMemoryManagerStats _tms;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">G1MonitoringScope</span>(G1MonitoringSupport* monitoring_support,</span><br><span class="line">                    CollectorCounters* collection_counters,</span><br><span class="line">                    GCMemoryManager* gc_memory_manager,</span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span>* end_message,</span><br><span class="line">                    <span class="type">bool</span> all_memory_pools_affected = <span class="literal">true</span>);</span><br><span class="line">  ~<span class="built_in">G1MonitoringScope</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继续跟进，发现 G1 有三个类记录了 G1MonitoringScope 对象。换句话来说，只要声明了这三个类，就等于声明了 TraceMemoryManagerStats 对象，而后者会随着初始化和析构记录 gc 时间。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">G1YoungGCMonitoringScope::<span class="built_in">G1YoungGCMonitoringScope</span>(G1MonitoringSupport* monitoring_support,</span><br><span class="line">                                                   <span class="type">bool</span> all_memory_pools_affected) :</span><br><span class="line">  <span class="built_in">G1MonitoringScope</span>(monitoring_support,</span><br><span class="line">                    monitoring_support-&gt;_young_collection_counters,</span><br><span class="line">                    &amp;monitoring_support-&gt;_young_gc_memory_manager,</span><br><span class="line">                    <span class="string">&quot;end of minor GC&quot;</span>,</span><br><span class="line">                    all_memory_pools_affected) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">G1FullGCMonitoringScope::<span class="built_in">G1FullGCMonitoringScope</span>(G1MonitoringSupport* monitoring_support) :</span><br><span class="line">  <span class="built_in">G1MonitoringScope</span>(monitoring_support,</span><br><span class="line">                    monitoring_support-&gt;_full_collection_counters,</span><br><span class="line">                    &amp;monitoring_support-&gt;_full_gc_memory_manager,</span><br><span class="line">                    <span class="string">&quot;end of major GC&quot;</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">G1ConcGCMonitoringScope::<span class="built_in">G1ConcGCMonitoringScope</span>(G1MonitoringSupport* monitoring_support) :</span><br><span class="line">  <span class="built_in">G1MonitoringScope</span>(monitoring_support,</span><br><span class="line">                    monitoring_support-&gt;_conc_collection_counters,</span><br><span class="line">                    &amp;monitoring_support-&gt;_conc_gc_memory_manager,</span><br><span class="line">                    <span class="string">&quot;end of concurrent GC pause&quot;</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们重点关注一下 G1ConcGCMonitoringScope，顾名思义，该类主要用于 concurrent G1。继续跟进，发现<strong>只有</strong>在 VM_G1PauseConcurrent::doit() 该类被声明。也就是说，对于 concurrent G1，JVM 只统计了 VM_G1PauseConcurrent::doit() 的耗时。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VM_G1PauseConcurrent::doit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">GCIdMark <span class="title">gc_id_mark</span><span class="params">(_gc_id)</span></span>;</span><br><span class="line">  G1CollectedHeap* g1h = G1CollectedHeap::<span class="built_in">heap</span>();</span><br><span class="line">  <span class="function">GCTraceCPUTime <span class="title">tcpu</span><span class="params">(g1h-&gt;concurrent_mark()-&gt;gc_tracer_cm())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GCTraceTime(...) only supports sub-phases, so a more verbose version</span></span><br><span class="line">  <span class="comment">// is needed when we report the top-level pause phase.</span></span><br><span class="line">  <span class="built_in">GCTraceTimeLogger</span>(Info, gc) <span class="built_in">logger</span>(_message, GCCause::_no_gc, <span class="literal">true</span>);</span><br><span class="line">  <span class="function">GCTraceTimePauseTimer       <span class="title">timer</span><span class="params">(_message, g1h-&gt;concurrent_mark()-&gt;gc_timer_cm())</span></span>;</span><br><span class="line">  <span class="function">GCTraceTimeDriver           <span class="title">t</span><span class="params">(&amp;logger, &amp;timer)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">G1ConcGCMonitoringScope <span class="title">monitoring_scope</span><span class="params">(g1h-&gt;monitoring_support())</span></span>;</span><br><span class="line">  <span class="function">SvcGCMarker <span class="title">sgcm</span><span class="params">(SvcGCMarker::CONCURRENT)</span></span>;</span><br><span class="line">  IsGCActiveMark x;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">work</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下 VM_G1PauseConcurrent::doit() 干了什么。doit() 是 VM_G1PauseConcurrent 的入口方法，而 VM_G1PauseConcurrent 是 concurrent G1 stw 的 operations。这点源码也通过注释解释的很清楚了。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175033983-20231115175047189.png"></p><p>综上，可以看出：JMX 对于 getCollectionTime() 方法只记录了 concurrent G1 的 stw 部分的耗时，因此 getCollectionTime() 的统计耗时是 accumulated stw GC time，更为精确。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《深入理解Java虚拟机（第3版）》 周志明 </p><p><a href="https://openjdk.java.net/projects/jdk/15/">https://openjdk.java.net/projects/jdk/15/</a></p><p><a href="https://aijishu.com/a/1060000000083459">https://aijishu.com/a/1060000000083459</a></p><p><a href="https://www.jianshu.com/p/aef0f4765098">https://www.jianshu.com/p/aef0f4765098</a></p><p><a href="https://blog.csdn.net/lbh_paopao/article/details/120269135">https://blog.csdn.net/lbh_paopao/article/details/120269135</a></p><p><a href="https://zhuanlan.zhihu.com/p/546651403">https://zhuanlan.zhihu.com/p/546651403</a></p><p><a href="https://zhuanlan.zhihu.com/p/431406707">https://zhuanlan.zhihu.com/p/431406707</a></p><p><a href="https://juejin.cn/post/6844903970142421005">https://juejin.cn/post/6844903970142421005</a></p><p><a href="https://stackoverflow.com/questions/19154607/how-actually-card-table-and-writer-barrier-work">https://stackoverflow.com/questions/19154607/how-actually-card-table-and-writer-barrier-work</a></p><p><a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">https://tech.meituan.com/2020/11/12/java-9-cms-gc.html</a></p><p><a href="https://tech.meituan.com/2016/09/23/g1.html">https://tech.meituan.com/2016/09/23/g1.html</a></p><p><a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">https://tech.meituan.com/2020/11/12/java-9-cms-gc.html</a></p><p><a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html</a></p><p><a href="https://blog.csdn.net/wisgood/article/details/79850093">https://blog.csdn.net/wisgood/article/details/79850093</a></p><p><a href="https://juejin.cn/post/7095643412082196511#heading-7">https://juejin.cn/post/7095643412082196511#heading-7</a></p><p><a href="https://blog.csdn.net/weixin_42596455/article/details/81228611">https://blog.csdn.net/weixin_42596455/article/details/81228611</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NASM 概念与实战/踩坑记录</title>
      <link href="/article/NASM/"/>
      <url>/article/NASM/</url>
      
        <content type="html"><![CDATA[<ul><li>NJU OS lab-1</li></ul><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221006001450200.png" alt="image-20221006001450200" style="zoom:50%;" /><h1 id="1-NASM-与-GDB-调试"><a href="#1-NASM-与-GDB-调试" class="headerlink" title="1. NASM 与 GDB 调试"></a>1. NASM 与 GDB 调试</h1><h2 id="1-1-安装与运行"><a href="#1-1-安装与运行" class="headerlink" title="1.1. 安装与运行"></a>1.1. 安装与运行</h2><p>在 Ubuntu 下可以通过 apt 安装</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo apt install nasm</span><br></pre></td></tr></table></figure><p>安装后就可以对文件进行汇编了，以<code>big_decimal.asm</code>为例</p><p>在 Ubuntu 下</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nasm -f elf big_decimal.asm -o big_decimal.o</span><br><span class="line">ld -m elf_i386 big_decimal.o -o big_decimal</span><br></pre></td></tr></table></figure><p><code>ld</code>是 GUN 自带的链接工具，可以将目标文件链接起来，我们这里因为只有一个文件因此不需要额外的指令。</p><p>复习一下，我们将一个写好的 C 程序转化为一个可以在 Unix 内核机器上执行的文件，需要经历下面四个步骤：</p><ul><li>预处理：处理 C 中的预处理命令，也就是#开头的那些，默认的生成文件格式为<code>.i</code></li><li>编译：将 C 程序编译为汇编语言， 默认的生成文件格式为<code>.s</code>，这里的<code>.s</code>和我们的<code>.asm</code>没什么区别</li><li>汇编：将汇编语言转化为机器码，默认的生成文件格式为<code>.o</code></li><li>链接：链接动态库和静态库</li></ul><p>因为我们直接在写汇编程序，当然就不需要第一步和第二步了。</p><h2 id="1-2-GDB-调试"><a href="#1-2-GDB-调试" class="headerlink" title="1.2. GDB 调试"></a>1.2. GDB 调试</h2><p>说到 GUN，不得不提今天的另一个主角，那就是 GDB，GNU symbolic debugger，它是一个在 Unix 内核中广受好评的调试工具。</p><p>我们可以使用 GDB 来调试我们的汇编代码</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nasm -f elf big_decimal.asm -o big_decimal.o</span><br><span class="line">ld -m elf_i386 big_decimal.o -o big_decimal</span><br><span class="line">sudo gdb big_decimal</span><br></pre></td></tr></table></figure><p>接下来进入 gdb 界面，开始你的调试工作。</p><p>和前面说到的一样，使用<code>gdb</code> 打开你的文件就好了，因为<code>gdb</code>要控制另一个进程，所以别忘了给它开权限。</p><p>可以在汇编文件中设置断点，并在你想停止的地方<code>call</code>它，比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break_demo:</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>然后只要在<code>gdb</code>中</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">b break_demo</span><br></pre></td></tr></table></figure><p>就可以让它在执行到<code>b</code>的时候中止程序。</p><p>可以使用指令</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">i registers</span><br></pre></td></tr></table></figure><p>查看代码运行的位置和寄存器状态。</p><p>如果你的代码有<code>stdout</code>的输出，可能会破坏这个 layout 的格局，这时候使用<code>refresh</code>指令刷新它。</p><p>最后，可以使用<code>x</code>指令查看你的内存状况，比如查看<code>0x40201c</code>开始的 20 个 bits 的内存</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x/20b 0x40201c</span><br></pre></td></tr></table></figure><h1 id="2-NASM-详解"><a href="#2-NASM-详解" class="headerlink" title="2. NASM 详解"></a>2. NASM 详解</h1><h2 id="2-1-NASM-程序的结构"><a href="#2-1-NASM-程序的结构" class="headerlink" title="2.1. NASM 程序的结构"></a>2.1. NASM 程序的结构</h2><p>NASM 是基于行的。大多数程序由指令后跟一个或多个部分组成。行可以具有可选标签。大多数行都有一条指令,后跟零个或多个操作数。</p><p><a href="https://raw.githubusercontent.com/zhangjunlei26/NASM-Tutorial-CN/master/assets/nasmstructure.png"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221004164300281.png" alt="image-20221004164300281"></a></p><p>通常,您将代码放在的部分中,<code>.text</code>并将常量数据放在的部分中<code>.data</code>。</p><h2 id="2-2-NASM-语法"><a href="#2-2-NASM-语法" class="headerlink" title="2.2. NASM 语法"></a>2.2. NASM 语法</h2><h3 id="2-2-1-基础指令"><a href="#2-2-1-基础指令" class="headerlink" title="2.2.1. 基础指令"></a>2.2.1. 基础指令</h3><p>有数百条指令。您无法一次全部学习它们。从这些 start:</p><table><thead><tr><th><code>mov</code> <em>x</em>,<em>y</em></th><th><em>x</em> ← <em>y</em></th></tr></thead><tbody><tr><td><code>and</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> and <em>y</em></td></tr><tr><td><code>or</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> or <em>y</em></td></tr><tr><td><code>xor</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> xor <em>y</em></td></tr><tr><td><code>add</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> + <em>y</em></td></tr><tr><td><code>sub</code> <em>x</em>,<em>y</em></td><td><em>x</em> ← <em>x</em> – <em>y</em></td></tr><tr><td><code>inc</code> <em>x</em></td><td><em>x</em> ← <em>x</em> + 1</td></tr><tr><td><code>dec</code> <em>x</em></td><td><em>x</em> ← <em>x</em> – 1</td></tr><tr><td><code>syscall</code></td><td>调用操作系统例程</td></tr><tr><td><code>db</code></td><td>一个<a href="http://www.nasm.us/xdoc/2.11.02/html/nasmdoc3.html#section-3.2">伪指令</a> 声明字节, 这将是在内存中的程序运行时</td></tr></tbody></table><ul><li><code>cmp</code> 做比较</li><li><code>je</code>如果先前的比较相等则跳转。</li><li><code>jne</code>(如果不等于则跳转)</li><li><code>jl</code>(如果不等于则跳转)</li><li><code>jnl</code>(如果不小于则跳转)</li><li><code>jg</code>(如果大于则跳转)</li><li><code>jng</code>(如果不大于则跳转)</li><li><code>jle</code>(如果小于或等于则跳转)</li><li><code>jnle</code>(如果不小于或等于则跳转)</li><li><code>jge</code>(如果大于或等于则跳转)</li><li><code>jnge</code>(如果不大于或等于则跳转)</li><li><code>equ</code>实际上不是真正的指令。它只是定义了供汇编程序本身使用的缩写。(这是一个意义深远的想法)</li><li>本<code>.bss</code>节适用于<em>可写</em>数据。</li></ul><h3 id="2-2-2-伪指令"><a href="#2-2-2-伪指令" class="headerlink" title="2.2.2. 伪指令"></a>2.2.2. 伪指令</h3><p>伪指令不是 x86&#x2F;x64 机器的真实指令，伪指令是用于给编译器指示如何进行编译。</p><h4 id="2-2-2-1-nasm-定义的-7-种数据-size"><a href="#2-2-2-1-nasm-定义的-7-种数据-size" class="headerlink" title="2.2.2.1. nasm 定义的 7 种数据 size"></a>2.2.2.1. nasm 定义的 7 种数据 size</h4><ul><li>byte ： 8 位</li><li>word ： 16 位</li><li>dword ： 32 位</li><li>qword ： 64 位</li><li>tword ： 80 位</li><li>oword ： 128 位</li><li>yword ： 256 位</li></ul><p>oword 可以对应 Microsoft MASM 的 xmmword 类型，yword 对应 Microsoft MASM 的 ymmword 类型。</p><p>tword, oword 以及 yword 使用在 非整型 数据，使用在 float 和 SSE 型数据。</p><h4 id="2-2-2-2-定义初始化数据：db-家族"><a href="#2-2-2-2-定义初始化数据：db-家族" class="headerlink" title="2.2.2.2. 定义初始化数据：db 家族"></a>2.2.2.2. 定义初始化数据：db 家族</h4><p>nasm 定义了用于初始化上面 7 种 size 的 db 家族，它们用于定义初化常量值。</p><ul><li>db : define byte</li><li>dw ：define word</li><li>dd ：define doubleword</li><li>dq ：define quadword</li><li>dt ：define tword</li><li>do ：define oword</li><li>dy ：define yword</li></ul><p>正如前面所说的：dt , do , dy 不接受整型数值常量，它们被使用在定义 float 或 SSE 数据常量。dt 可以定义 extended-precision float 数据，do 可以定义 quad-precision float，dy 可定义 ymm 数据。而 dq 可以定义 double-precision float 数据，dd 可以定义 single-precision float 数据。</p><h4 id="2-2-2-3-定义非初始化数据：resb-家族"><a href="#2-2-2-3-定义非初始化数据：resb-家族" class="headerlink" title="2.2.2.3. 定义非初始化数据：resb 家族"></a>2.2.2.3. 定义非初始化数据：resb 家族</h4><p>程序中使用到的非初始化数据通常放在 <code>bss section</code> 里，<code>bss</code> 代表 <strong>uninitialized storage space</strong>(如果您试图在一个<code>.text</code>小节中使用它们,将会出现错误)：</p><p>nasm 使用了 resb （reserve byte） 家族来定义非初始化数据。</p><ul><li>resb ：reserve byte</li><li>resw ：reserve word</li><li>resd ：reserve doubword</li><li>resq ：reserve quadword</li><li>rest ：reserve tword</li><li>reso ：reserve oword</li><li>resy ：reserve yword</li></ul><p>resb 相当于 Microsoft MASM 语法中的 db ?</p><p>下面是 NASM Manual 的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buffer:         resb    64              ; reserve 64 bytes</span><br><span class="line">wordvar:        resw    1               ; reserve a word</span><br><span class="line">realarray       resq    10              ; array of ten reals</span><br><span class="line">ymmval:         resy    1               ; one YMM register</span><br></pre></td></tr></table></figure><h3 id="2-3-5-使用-equ-定义常量"><a href="#2-3-5-使用-equ-定义常量" class="headerlink" title="2.3.5 使用 equ 定义常量"></a>2.3.5 使用 equ 定义常量</h3><p>equ 用来为标识符定义一个 整型 常量，它的作用类似 C 语言中的 #define</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a  equ 0                          ; OK</span><br><span class="line">b  equ &#x27;abcd&#x27;                     ; OK! b = 0x64636261</span><br><span class="line">c  equ &#x27;abcdefghi&#x27;                ; warning! c = 0x6867666564636261</span><br><span class="line">d  equ 1.2                        ; error!</span><br><span class="line"></span><br><span class="line">    section .data</span><br><span class="line">string db &#x27;hello,word&#x27;,0</span><br><span class="line">len    equ $-string               ; OK! len = 0x0b</span><br><span class="line"></span><br><span class="line">    section .text</span><br><span class="line">textlen equ  _end - entry         ; OK! textlen = 0x05</span><br><span class="line"></span><br><span class="line">_entry:</span><br><span class="line">    mov ecx, textlen</span><br><span class="line"></span><br><span class="line">_end:</span><br></pre></td></tr></table></figure><p>例子中： b 定义为常量 ‘abcd’ 它将是字符串的 ASCII 码序列，‘abcdefghi’ 常量将会被截断，整型常量最长为 quadword（8 bytes)，而 d 企图被定义为一个 float 常量，这产生会错误。len 和 textlen 被定义为编译期确定的数值。</p><h2 id="2-3-寄存器"><a href="#2-3-寄存器" class="headerlink" title="2.3. 寄存器"></a>2.3. 寄存器</h2><p>您可以将每个寄存器的最低 32 位视为寄存器本身,但可以使用以下名称：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R0D R1D R2D R3D R4D R5D R6D R7D R8D R9D R10D R11D R12D R13D R14D R15D</span><br><span class="line">EAX ECX EDX EBX ESP EBP ESI EDI</span><br></pre></td></tr></table></figure><p>您可以使用以下名称将每个寄存器的最低 16 位看作一个寄存器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R0W R1W R2W R3W R4W R5W R6W R7W R8W R9W R10W R11W R12W R13W R14W R15W</span><br><span class="line">AX CX DX BX SP BP SI DI</span><br></pre></td></tr></table></figure><p>您可以使用以下名称将每个寄存器的最低 8 位看作一个寄存器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R0B R1B R2B R3B R4B R5B R6B R7B R8B R9B R10B R11B R12B R13B R14B R15B</span><br><span class="line">AL CL DL BL SPL BPL SIL DIL</span><br></pre></td></tr></table></figure><p>由于历史原因，<code>R0...R3</code>的第 15 至 8 位被命名为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AH CH DH BH</span><br></pre></td></tr></table></figure><h2 id="2-4-操作数"><a href="#2-4-操作数" class="headerlink" title="2.4. 操作数"></a>2.4. 操作数</h2><h3 id="2-4-1-内存操作数"><a href="#2-4-1-内存操作数" class="headerlink" title="2.4.1. 内存操作数"></a>2.4.1. 内存操作数</h3><ul><li>其实就是几种寻址的方式<ul><li>直接寻址</li><li>寄存器间接寻址</li><li>寄存器相对寻址</li><li>基址加变址</li><li>相对基址加变址</li></ul></li><li>注意：没有立即寻址和寄存器寻址</li></ul><p>这些是寻址的基本形式：</p><ul><li><code>[ number ]</code></li><li><code>[ reg ]</code></li><li><code>[ reg + reg*scale ]</code> <em>小数位数只能是 1、2、4 或 8</em></li><li><code>[ reg + number ]</code></li><li><code>[ reg + reg*scale + number ]</code></li></ul><p>这个数字叫做<strong>位移</strong> ; 普通寄存器称为<strong>基</strong> ; 带有刻度的寄存器称为<strong>索引</strong>。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[750]               ; 仅位移</span><br><span class="line">[rbp]               ; 仅基址寄存器</span><br><span class="line">[rcx + rsi*4]       ; 基数+指数*比例</span><br><span class="line">[rbp + rdx]         ; scale is 1</span><br><span class="line">[rbx-8]             ; 位移-8</span><br><span class="line">[rax + rdi*8 + 500] ; 所有四个组成部分</span><br><span class="line">[rbx + counter]     ; 使用变量&quot;counter&quot;地址作为偏移</span><br></pre></td></tr></table></figure><h3 id="2-4-2-直接操作数"><a href="#2-4-2-直接操作数" class="headerlink" title="2.4.2. 直接操作数"></a>2.4.2. 直接操作数</h3><p>这些可以用多种方式编写。以下是官方文档中的一些示例。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200         ; 十进制数</span><br><span class="line">0200        ; 仍然是十进制-前导0不会使其变为八进制</span><br><span class="line">0200d       ; 显式十进制-d后缀</span><br><span class="line">0d200       ; 也十进制-0d prefex</span><br><span class="line">0c8h        ; 十六进制-h后缀,但是前导0是必需的,因为c8h看起来像var</span><br><span class="line">0xc8        ; hex-经典的0x前缀</span><br><span class="line">0hc8        ; 十六进制-由于某些原因,NASM偏爱0h写法</span><br><span class="line">310q        ; 八进制-q后缀</span><br><span class="line">0q310       ; 八进制-0q前缀</span><br><span class="line">11001000b   ; 二进制-b后缀</span><br><span class="line">0b1100_1000 ; 二进制-0b前缀,顺便说一下,允许使用下划线</span><br></pre></td></tr></table></figure><h2 id="2-5-使用-C-库"><a href="#2-5-使用-C-库" class="headerlink" title="2.5. 使用 C 库"></a>2.5. 使用 C 库</h2><p>仅使用 syscall 编写独立程序就已经很酷了，但很少见。我们想使用 C 库中的好东西。</p><p>为何在 C 语言程序中，看上去都是从 <code>main</code>函数开始执行？这是因为 C library 的内部有<code>_start</code>标签！<code>_start</code>开始处的代码会做一些初始化的工作，然后调用<code>main</code>函数中的代码，最后执行清理工作，最终执行 60 号系统调用以退出。因此，您只需要实现<code>main</code>函数即可，我们可以在汇编语言中实现这么做：</p><p>如果您有 Linux,请尝试以下操作：</p><p>hola.asm</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">; 使用C库将&quot; Hola,mundo&quot;写入控制台。程序运行在 Linux 或者其他在 C 语言库中不使用下划线的操作系统上。</span><br><span class="line">; 如何编译执行:</span><br><span class="line">; nasm -felf64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span><br><span class="line">; ----------------------------------------------------------------------------------------</span><br><span class="line">global    main</span><br><span class="line">          extern    puts</span><br><span class="line"></span><br><span class="line">          section   .text</span><br><span class="line">main:                                       ; 这里被 C library初始化代码所调用</span><br><span class="line">          mov       rdi, message            ; rdi中的第一个整数(或指针)参数</span><br><span class="line">          call      puts                    ; puts(message)</span><br><span class="line">          ret                               ; 由 main 函数返回 C 语言库例程</span><br><span class="line">message:</span><br><span class="line">          db        &quot;Hola, mundo&quot;, 0        ; 注意字符串必须在C中以0结尾</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nasm -felf64 hola.asm &amp;&amp; gcc hola.o &amp;&amp; ./a.out</span><br><span class="line">Hola, mundo</span><br></pre></td></tr></table></figure><h2 id="2-6-字符常量"><a href="#2-6-字符常量" class="headerlink" title="2.6. 字符常量"></a>2.6. 字符常量</h2><p>在 nasm 中，可以使用 3 种引号来提供字符</p><ul><li>’ …’ （单引号）</li><li>” …” （双引号）</li><li><code> …</code> （反引号）</li></ul><p>如下示例，它们的结果是一样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db  &#x27;abcd&#x27;</span><br><span class="line">db  &quot;abcd&quot;</span><br><span class="line">db  `abcd`</span><br></pre></td></tr></table></figure><h1 id="3-实践-OS-lab1"><a href="#3-实践-OS-lab1" class="headerlink" title="3. 实践 - OS lab1"></a>3. 实践 - OS lab1</h1><ul><li>使用 nasm 实现大数加法和乘法</li></ul><h2 id="3-1-思路"><a href="#3-1-思路" class="headerlink" title="3.1. 思路"></a>3.1. 思路</h2><ul><li><p>输入输出</p><ul><li>需要熟悉 Linux 系统调用（ics 教过）</li><li>需要熟悉寄存器的使用</li><li>打印 int 数组需要 itoa</li></ul></li><li><p>加法</p><ul><li>按位加，细节略</li></ul></li><li><p>减法</p><ul><li>找出绝对值较大者，计算<code>dest - src // (abs(dest) &gt; abs(src))</code></li><li>按位减，每次减要考虑借位，其他细节略</li></ul></li><li><p>乘法</p><ul><li><p>$$<br>基本原理：<br>\Sigma_{i+j&#x3D;k}(a_i \times b_j) &#x3D; c_k<br>$$</p></li><li><p>先按位乘，最后再统一 normalize</p></li></ul></li><li><p>技巧</p><ul><li>string 转 int 数组后倒序存储，方便 int 数组正序遍历</li><li>比如<code>&quot;123&quot;</code>，存储为<code>[3, 2, 1]</code></li></ul></li></ul><h2 id="3-2-踩坑"><a href="#3-2-踩坑" class="headerlink" title="3.2. 踩坑"></a>3.2. 踩坑</h2><ul><li>jmp 的函数无须 ret！！！<ul><li>否则即使 push 的已全部 pop，ret 仍会 segmentation fault</li></ul></li><li>调用栈的使用</li><li>ebp 用 leave 弹出</li><li>intel 语法（nasm）的 mov 不接受两个 opcode</li><li>.bss 和.data 定义出的是指针</li><li>区分字符（’1’）和数字（0x1）</li><li>loop 循环不可轻易 jmp 到压栈代码段（除非是设计好的）</li><li>gdb 和 objdump 结合的使用</li><li>每次循环后要清空bss和寄存器</li></ul><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h1><p><a href="https://github.com/zhangjunlei26/NASM-Tutorial-CN">zhangjunlei26&#x2F;NASM-Tutorial-CN: Nasm 指南中文 (NASM Tutorial) (github.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/263102219">NASM 与 GDB 的使用指南：如何编好你的汇编 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/jadeshu/article/details/89159196">(29 条消息) nasm 汇编讲解_jadeshu 的博客-CSDN 博客_nasm</a></p><p>[学习 nasm 语言-阿里云开发者社区 (aliyun.com)](<a href="https://developer.aliyun.com/article/25221#:~:text=%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8">https://developer.aliyun.com/article/25221#:~:text=代码中使用</a> byte 关键字对 memory 操作数进行了修饰，指明 memory 操作数的大小为 byte,语法）有些不同， masm 的语法是： 在 masm 语法中需配合 ptr 指示字。)</p><p><a href="https://zhuanlan.zhihu.com/p/297925056">GDB 使用详解 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/u014470361/article/details/102230583">(29 条消息) GDB 调试查看内存数据_夜风~的博客-CSDN 博客_gdb 查看内存数据</a></p><p><a href="https://blog.csdn.net/weixin_44395686/article/details/104727314">(29 条消息) 使用 GDB 查看和修改寄存器的值_@HDS 的博客-CSDN 博客_gdb 查看寄存器的值</a></p><p><a href="http://www.bytekits.com/nasm/system-callback.html">Nasm 系统调用 - 字节流 (bytekits.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> nasm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iPad + RD client 实现 Win10 远程控制</title>
      <link href="/article/Win10-RD-client/"/>
      <url>/article/Win10-RD-client/</url>
      
        <content type="html"><![CDATA[<p>由于游戏本不便携 + 续航差；而 ipad 正好完美弥补了上述缺点。某日下午上课正好看到朋友在用远程桌面记笔记，遂请教之，晚上回宿舍后倒腾出了本篇记录。</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027202123527.png" alt="image-20221027202123527" style="zoom:60%;"><h2 id="1-开启-Win10-远程桌面功能"><a href="#1-开启-Win10-远程桌面功能" class="headerlink" title="1. 开启 Win10 远程桌面功能"></a>1. 开启 Win10 远程桌面功能</h2><ul><li>前往<a href="https://github.com/stascorp/rdpwrap/releases%E4%B8%8B%E8%BD%BD%E5%8E%8B%E7%BC%A9%E5%8C%85%EF%BC%88%E6%9C%80%E6%96%B0%E7%89%88%E5%8D%B3%E5%8F%AF%EF%BC%89">https://github.com/stascorp/rdpwrap/releases下载压缩包（最新版即可）</a></li><li>解压得到如下文件</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027191109863.png" alt="image-20221027191109863"></p><ul><li><p>管理员权限运行 install.bat 文件，然后双击 RDPConf.exe 。正常应该是全绿，可以看到我这里第三行报错。<img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027191413015.png" alt="image-20221027191413015"></p></li><li><p>找到上图框出版本号的 rdpwrap.ini 文件，下载后将其复制到 C:\Program Files\RDP Wrapper 中。**<em>注意：复制之前一定要先关闭 Remote Desktop Services 服务，复制完成之后在打开 Remote Desktop Services 服务</em>**</p><ul><li>关闭 Remote Desktop Services 方法：右击此电脑-&gt;管理-&gt;服务与应用程序-&gt;服务-&gt;选择 Remote Desktop Services -&gt;关闭</li></ul></li><li><p>随后再次双击 RDPConf.exe 可以看到启动成功</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027191623785.png" alt="image-20221027191623785"></p><h2 id="2-服务器内网穿透"><a href="#2-服务器内网穿透" class="headerlink" title="2. 服务器内网穿透"></a>2. 服务器内网穿透</h2><h3 id="2-1-服务端"><a href="#2-1-服务端" class="headerlink" title="2.1. 服务端"></a>2.1. 服务端</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://ghproxy.com/https://github.com/fatedier/frp/releases/download/v0.45.0/frp_0.45.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf frp_0.45.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">cd frp_0.45.0_linux_amd64</span><br></pre></td></tr></table></figure><ul><li>编辑 frps.ini</li></ul><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_addr</span> = xxx.xxx.xxx.xxx  <span class="comment">##云服务器内网ip</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">auto_token</span> = username</span><br><span class="line"><span class="attr">dashboard_user</span> = admin</span><br><span class="line"><span class="attr">dashboard_pwd</span> = admin</span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br></pre></td></tr></table></figure><ul><li><p>执行如下命令 后台持续运行此任务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure><p>打开浏览器输入<code>xx.xx.xx.xx(云服务器公网ip):7500</code>（需要提前放行 3389、7000、7500 端口）</p><p>出现如下画面即配置成功。</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027194029822.png" alt="image-20221027194029822"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027192439031.png" alt="image-20221027192439031"></p><h3 id="2-2-客户端"><a href="#2-2-客户端" class="headerlink" title="2.2. 客户端"></a>2.2. 客户端</h3><p>进入 <a href="https://github.com/fatedier/frp/releases">Releases · fatedier&#x2F;frp (github.com)</a>下载如下版本</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027194215035.png" alt="image-20221027194215035"></p><p>将刚才 github 上下载的 frp_0.44.0_windows_amd64.zip 解压出来，编辑文件夹中的 frpc.ini，直接用记事本打开即可，复制以下字段保存。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = xxx.xxx.xxx.xxx ##服务器公网ip</span><br><span class="line">bind_port = 7000</span><br><span class="line">auto_token = username</span><br><span class="line"></span><br><span class="line">[username]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 3389</span><br><span class="line">remote_port = 3390</span><br></pre></td></tr></table></figure><p><strong>注意：server_addr 字段为云服务器公网 ip，这里的 bind_port，auto_token 需要与 frps.ini 文件中的 bind_port，auto_token 匹配。</strong></p><p>进入 frp 目录打开 cmd 命令窗口，启动 frp 客户端服务<code>.\frpc.exe -c frpc.ini</code> ，出现如下提示即配置成功！</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221027192357724.png" alt="image-20221027192357724"></p><h4 id="2-2-1-脚本启动-frp-客户端服务"><a href="#2-2-1-脚本启动-frp-客户端服务" class="headerlink" title="2.2.1. 脚本启动 frp 客户端服务"></a>2.2.1. 脚本启动 frp 客户端服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%1&quot;</span> == <span class="string">&quot;h&quot;</span> goto begin</span><br><span class="line">mshta vbscript:createobject(<span class="string">&quot;wscript.shell&quot;</span>).run(<span class="string">&quot;&quot;</span><span class="string">&quot;%~nx0&quot;</span><span class="string">&quot; h&quot;</span>,0)(window.close)&amp;&amp;<span class="built_in">exit</span></span><br><span class="line">:begin</span><br><span class="line">REM</span><br><span class="line"><span class="built_in">cd</span> &amp;&#123;你的 frp 安装路径&#125;</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>将以上代码新建为<code>frp.bat</code>文件，双击即可运行。</p><p>如果想关闭进程，就<code>Ctrl + shift + esc</code>打开资源管理器关闭一个叫<code>frpc</code>的进程。</p><hr><h2 id="3-参考资料："><a href="#3-参考资料：" class="headerlink" title="3. 参考资料："></a>3. 参考资料：</h2><p><a href="https://zhuanlan.zhihu.com/p/572216097">iPad 远程登录 windows 主机（内网穿透 RD client 版） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/339089087">利用 iPad 的 RD client 软件远程控制 PC - 知乎 (zhihu.com)</a></p><p><a href="https://www.johng-mit.cn/technology/rdp/">使用 RD Client + frp 内网穿透实现 iPad 远程控制 - 杂项 - 技术 | Feast &#x3D; 身如蘆葦 &#x3D; 人間似夢 (johng-mit.cn)</a></p><p><strong><em>特别感谢：zzb 同学</em></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> RD client </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 7. Join Algorithms</title>
      <link href="/article/CMU-15-445-7-Join-Algorithms/"/>
      <url>/article/CMU-15-445-7-Join-Algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="7-Join-Algorithms"><a href="#7-Join-Algorithms" class="headerlink" title="7. Join Algorithms"></a>7. Join Algorithms</h1><ul><li>为什么需要 join</li></ul><p>由于为消除 table 中信息的冗余，我们会采取<strong>normalize</strong>来使得数据库 table 的设计符合一定范式，但是之后需要使用<strong>join</strong>来重建原来的 tuple</p><p>一般使用<strong>inner equijoin</strong>,<strong>inner equijoin</strong>连接两张表中 key 相同的 tuple。其他 join 算法可以通过该算法调整得到</p><h2 id="7-1-Join-operator-output"><a href="#7-1-Join-operator-output" class="headerlink" title="7.1. Join operator output"></a>7.1. Join operator output</h2><ul><li>copy outer 和 inner tuples 的 attributes into a new tuple.</li><li>Subsequent operators in the query plan never need to go back to the base tables to get more data.</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930094703596.png" alt="image-20220930094703596"></p><ul><li><p>两种处理方式</p><ul><li>可以在 Join 的时候将所有非 Join Attributes 都放入新的 tuple 中，这样 Join 之后的操作都不需要从 tables 中重新获取数据</li></ul><p>![image](<a href="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-La5GNw04x8dghkKNnFu%2F-La5KYkuE3zEy5hImXRs%2FScreen">https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-La5GNw04x8dghkKNnFu%2F-La5KYkuE3zEy5hImXRs%2FScreen</a> Shot 2019-03-16 at 7.49.45 PM.jpg?alt&#x3D;media&amp;token&#x3D;5d9c0b76-0bd8-4224-b105-52edd6b2cb79)</p><ul><li>也可以在 Join 的时候只复制 Join Attributes 以及 record id，后续操作自行根据 record id 去 tables 中获取相关数据。对于列存储数据库，这是比较理想的处理方式，被称为 <strong>Late Materialization</strong>。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930095130571.png" alt="image-20220930095130571"></p></li></ul><h2 id="7-2-Cost-analysis"><a href="#7-2-Cost-analysis" class="headerlink" title="7.2. Cost analysis"></a>7.2. Cost analysis</h2><ul><li>由于数据库中的数据量通常较大，无法一次性载入内存，因此 Join Algorithm 的设计目的，在于减少磁盘 I&#x2F;O，因此我们衡量 Join Algorithm 好坏的标准，就是 I&#x2F;O 的数量。此外我们不需要考虑 Join 结果的大小，因为不论使用怎样的 Join Algorithm，结果集的大小都一样。</li><li>用笛卡尔积加谓词筛选实现 join 非常低效</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/1743182-20220227162356973-2142439747.png" alt="image"></p><h2 id="7-3-Nested-Loop-Join"><a href="#7-3-Nested-Loop-Join" class="headerlink" title="7.3. Nested Loop Join"></a>7.3. Nested Loop Join</h2><h3 id="7-3-1-分类"><a href="#7-3-1-分类" class="headerlink" title="7.3.1. 分类"></a>7.3.1. 分类</h3><ul><li>其实就是嵌套 for 循环</li><li>Stupid nested loop join<ul><li>效率极其低下</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930103128904.png" alt="image-20220930103128904"></p><ul><li>Block nested loop join<ul><li>更少的磁盘 IO</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930103647389.png" alt="image-20220930103647389"></p><ul><li>Index nested loop join</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930103932165.png" alt="image-20220930103932165"></p><h3 id="7-3-2-总结"><a href="#7-3-2-总结" class="headerlink" title="7.3.2. 总结"></a>7.3.2. 总结</h3><ul><li>总是选择较小的 table 作为 outer table（因为较小 table 是作为乘数）</li><li>尽可能多的缓存 outer table 到 buffer 里</li><li>扫描 Inner Table 时，尽量使用索引</li></ul><h2 id="7-4-Sort-Merge-Join"><a href="#7-4-Sort-Merge-Join" class="headerlink" title="7.4. Sort-Merge Join"></a>7.4. Sort-Merge Join</h2><h3 id="7-4-1-Sort"><a href="#7-4-1-Sort" class="headerlink" title="7.4.1. Sort"></a>7.4.1. Sort</h3><ul><li>对 join key(s)进行排序</li></ul><h3 id="7-4-2-Merge"><a href="#7-4-2-Merge" class="headerlink" title="7.4.2. Merge"></a>7.4.2. Merge</h3><ul><li>用 cursors 扫描两个排好序的表，然后 emit key(s)匹配的 tuples</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930104754006.png" alt="image-20220930104754006"></p><h2 id="7-5-Hash-Join"><a href="#7-5-Hash-Join" class="headerlink" title="7.5. Hash Join"></a>7.5. Hash Join</h2><h3 id="7-5-1-Build"><a href="#7-5-1-Build" class="headerlink" title="7.5.1. Build"></a>7.5.1. Build</h3><ul><li>扫描外表，然后使用哈希函数<em>h1</em>在 join attributes 上生成一个哈希表</li></ul><h3 id="7-5-2-Probe"><a href="#7-5-2-Probe" class="headerlink" title="7.5.2. Probe"></a>7.5.2. Probe</h3><ul><li>扫描内标，然后在每个 tuple 上使用<em>h1</em>，跳转到哈希表上并找到匹配的 tuple</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220930105402810.png" alt="image-20220930105402810"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 6. Query Execution</title>
      <link href="/article/CMU-15-445-6-Query-Execution/"/>
      <url>/article/CMU-15-445-6-Query-Execution/</url>
      
        <content type="html"><![CDATA[<h1 id="6-Query-Execution"><a href="#6-Query-Execution" class="headerlink" title="6. Query Execution"></a>6. Query Execution</h1><ul><li>how to execute queries using table heaps and indexes.</li></ul><h2 id="6-1-Query"><a href="#6-1-Query" class="headerlink" title="6.1. Query"></a>6.1. Query</h2><ul><li>Query operators are arranged in a tree.</li><li>数据从底层向根节点流动</li><li>根节点的输出为 query 的输出</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929143456391.png" alt="image-20220929143456391"></p><h2 id="6-2-Sorting"><a href="#6-2-Sorting" class="headerlink" title="6.2. Sorting"></a>6.2. Sorting</h2><ul><li>我们在 query 时，时常需要 retrieve tuples in a specific order</li><li>但是 data 通常 not fit in memory（有时需要向磁盘 IO）。我们需要用一种能考虑到 IO 开销的技术</li><li>需要排序算法的原因：<strong>本质在于 tuples 在 table 中没有顺序</strong>，无论是用户还是 DBMS 本身，在处理某些任务时希望 tuples 能够按一定的顺序排列，如：<ul><li>若 tuples 已经排好序，去重操作将变得很容易（DISTINCT)</li><li>批量将排好序的 tuples 插入到 B+ Tree index 中，速度更快</li><li>Aggregations (GROUP BY)</li></ul></li></ul><h3 id="6-2-1-External-Merge-Sort"><a href="#6-2-1-External-Merge-Sort" class="headerlink" title="6.2.1. External Merge Sort"></a>6.2.1. External Merge Sort</h3><p>思想是分治，就是把大数据分成独立的 <strong>*runs*</strong> 再分别 sort 它们。它们可以写回到硬盘，也可以读出来。这个算法包含两步： <strong>Phase #1 - Sorting：</strong> 首先算法会 sort 可以放在内存的小 chunk，然后写回到硬盘中。 <strong>Phase #2 - Merge：</strong> 然后合并这些子文件到一个大的单独文件中。</p><ul><li>Divide-and-conquer sorting（分治排序）<ul><li>先排序：将数据分为多个 chunk，每个 chunk 可以 fit in main-memory，然后将它们排序，再将排好序的 data 写回 disk</li><li>再合并：将排好的 data 合并成一个 larger file</li></ul></li><li>复杂度：见 ppt</li></ul><h4 id="6-2-1-1-2-Way-External-Merge-Sort"><a href="#6-2-1-1-2-Way-External-Merge-Sort" class="headerlink" title="6.2.1.1. 2-Way External Merge Sort"></a>6.2.1.1. 2-Way External Merge Sort</h4><ul><li><p>“2” represents the number of runs that we are going to merge into a new run for each pass.</p></li><li><p>假设：</p><ul><li>Files 本分成 N 个 pages</li><li>DBMS 有 B 个 fixed-size buffers</li></ul></li><li><p><em>Pass #0</em></p><ul><li>从 table 中读入 B pages tuples</li><li>将这些 tuples 排序后<strong>写回</strong>到 disk 中</li><li>每一轮成为一个 run</li></ul></li><li><p><em>Pass #1,2,3,…</em></p></li><li><p>递归地将一对 runs 合并成一个两倍长度的 run</p></li><li><p>这一操作值需要 3 个 buffer pages ( 2 个用于输入，1 个用于输出)</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929145647966.png" alt="image-20220929145647966"></p><h5 id="6-2-1-1-2-双重-buffering-优化"><a href="#6-2-1-1-2-双重-buffering-优化" class="headerlink" title="6.2.1.1.2. 双重 buffering 优化"></a>6.2.1.1.2. 双重 buffering 优化</h5><ul><li>当系统在处理当前 run 的时候，提前将下一次 run 取进第二个 buffer。<ul><li>通过充分利用 disk，减少等待 IO 的时间。</li></ul></li></ul><h4 id="6-2-1-2-General-External-Merge-Sort"><a href="#6-2-1-2-General-External-Merge-Sort" class="headerlink" title="6.2.1.2. General External Merge Sort"></a>6.2.1.2. General External Merge Sort</h4><ul><li>就是把 2-way 泛化成 N-way，充分利用磁盘空间</li></ul><h3 id="6-2-2-Using-B-Tree"><a href="#6-2-2-Using-B-Tree" class="headerlink" title="6.2.2. Using B+ Tree"></a>6.2.2. Using B+ Tree</h3><ul><li>如果需要排序的属性已经有了 B+树索引，我们可以用 B+树来加速排序</li></ul><h2 id="6-3-Aggregation"><a href="#6-3-Aggregation" class="headerlink" title="6.3. Aggregation"></a>6.3. Aggregation</h2><p>aggregation 就是对一组 tuples 的某些值做统计，转化成一个标量，如平均值、最大值、最小值等，aggregation 的实现通常有两种方案：</p><ul><li>Sorting</li></ul><p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-L_joWM39KHaJfccjyzE%2F-L_kEY93VltutLrspExH%2FScreen%20Shot%202019-03-12%20at%2012.51.50%20PM.jpg?alt=media&token=8f780e68-b277-48d4-93b6-ce7ffb61a217" alt="image"></p><ul><li><h2 id="Hashing-不需要排序-在-DBMS-扫描的时候填冲一个暂时的-hash-table，对于每一个-record，检查它是否已经存在于-hash-table-DISTINCT：丢弃-GROUP-BY：进行聚合计算"><a href="#Hashing-不需要排序-在-DBMS-扫描的时候填冲一个暂时的-hash-table，对于每一个-record，检查它是否已经存在于-hash-table-DISTINCT：丢弃-GROUP-BY：进行聚合计算" class="headerlink" title="Hashing- 不需要排序- 在 DBMS 扫描的时候填冲一个暂时的 hash table，对于每一个 record，检查它是否已经存在于 hash table  - DISTINCT：丢弃  - GROUP BY：进行聚合计算"></a>Hashing<br>- 不需要排序<br>- 在 DBMS 扫描的时候填冲一个暂时的 hash table，对于每一个 record，检查它是否已经存在于 hash table<br>  - DISTINCT：丢弃<br>  - GROUP BY：进行聚合计算</h2></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 5. Index Concurrency Control</title>
      <link href="/article/CMU-15-445-5-Index-Concurrency-Control/"/>
      <url>/article/CMU-15-445-5-Index-Concurrency-Control/</url>
      
        <content type="html"><![CDATA[<h1 id="5-Index-Concurrency-Control"><a href="#5-Index-Concurrency-Control" class="headerlink" title="5. Index Concurrency Control"></a>5. Index Concurrency Control</h1><h2 id="5-1-concurrency（并发）"><a href="#5-1-concurrency（并发）" class="headerlink" title="5.1. concurrency（并发）"></a>5.1. concurrency（并发）</h2><p>A concurrency control protocol 的正确性标准在于：</p><ul><li>logical correctness：线程必须能够完整正确的看到其应该看到的数据</li><li>physical correctness：数据内部是否完整合理，比如一个数据结构指针不会指向非法的内存地址</li></ul><h2 id="5-2-Lock-Latches"><a href="#5-2-Lock-Latches" class="headerlink" title="5.2. Lock &amp; Latches"></a>5.2. Lock &amp; Latches</h2><ul><li><p>Lock：</p><p>是一个高层，逻辑上的原语，其在事务之间保护数据库的内容。</p><ul><li><p>保护数据库中的逻辑内容</p><ul><li>逻辑内容可以是 tuple、tuple set、table、db</li></ul></li><li><p>一个 txn(transaction 的简写)会<strong>全程</strong>持有 lock</p></li><li><p>在查询执行时，数据库可以将 lock 暴露给用户</p></li><li><p>lock 需要能够回滚变化，比如说，如果一个被 lock 锁上的 tuple 被修改了，这次修改可以回滚</p></li></ul></li><li><p>Latch(有时又叫 mutex)：</p><p>是一个底层保护原语，在线程之间，其用来保护 DBMS 内部数据结构的关键区域(比如，数据结构，内存区域)</p><ul><li><p>latch 只有在操作执行的时候才会持有</p></li><li><p>latch 并不需要能够回滚数据，因为 latch 所尝试进行的操作本质上是原子性操作</p></li><li><p>存在两种 latch mode</p><ul><li><strong>READ：</strong>多个线程可以同时读，也就是线程可以持有<strong>read latch</strong>，即使是其他线程也持有<strong>read latch</strong></li></ul></li></ul></li><li><p><strong>WRITE：</strong>对于<strong>write latch</strong>，当一个 thread 持有时，其他 thread 就不能持有</p></li></ul><h3 id="5-2-1-Latch-的实现"><a href="#5-2-1-Latch-的实现" class="headerlink" title="5.2.1. Latch 的实现"></a>5.2.1. Latch 的实现</h3><ul><li>Blocking OS Mutex</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929123045453.png" alt="image-20220929123045453"></p><ul><li>Test-and-Set Spin Latch</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929123101195.png" alt="image-20220929123101195"></p><ul><li>Reader-Writer Latches</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220929123141190.png" alt="image-20220929123141190"></p><p><a href="https://www.cnblogs.com/mlmz/p/15935749.html">CMU15445 Lecture 9 Index Concurrency Control - 抿了抿嘴丶 - 博客园 (cnblogs.com)</a></p><ul><li>其实正式的读写线程调度取决于上下文和使用策略。不能一昧的读优先，因为这样可能造成写进程 starvation。</li></ul><h3 id="5-2-2-Hash-Table-Latching"><a href="#5-2-2-Hash-Table-Latching" class="headerlink" title="5.2.2. Hash Table Latching"></a>5.2.2. Hash Table Latching</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221022165348816.png" alt="image-20221022165348816"></p><ul><li><p>区别是 latches 的粒度，后者更小。</p><ul><li>前者方便，但减少并行性：因为无法让两个线程同时操作不同的 slot</li><li>后者并行性更高。付出的代价更高：因为扫描每个 slot 都要获取 latch</li></ul></li><li><p>在 hash table 中，由于线程都是从上往下（同方向）扫描，因此不用考虑死锁的问题</p><ul><li>即来自另一个方向的线程在我争抢该处写锁前就将内容修改，无法保证数据一致性，即前一条线程刚修改完，但我之前刚通过读锁读了数据，修改的数据是在原来的数据上进行的，此时，如果不重新读，事务会出现问题，所以就需要做更多考虑了，如果都是从上往下的，那就无须考虑这点</li></ul></li></ul><h3 id="5-2-3-B-Tree-Latching"><a href="#5-2-3-B-Tree-Latching" class="headerlink" title="5.2.3. B+ Tree Latching"></a>5.2.3. B+ Tree Latching</h3><ul><li><p>这里的情况更复杂。比如有一条线程可能正在遍历 B+Tree，接着在它到达叶子结点之前，另一条线程对 B+Tree 进行了修改，这引起了节点间的拆分与合并。使得 B+Tree 中节点的位置可能会有所移动，我所查找的数据可能就并不在原来的位置上了，甚至在最糟糕的情况下，指针指向了内存中的一个无效内存地址，导致 segmentation fault，并且程序崩溃。</p></li><li><p>如何处理？</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221022203308518.png" alt="image-20221022203308518"></p><ul><li>即 latch crabbing 或者 latch doubling<ul><li>一种允许多条线程在同一时间访问 B+ Tree 的技术</li><li>在任何时候，当我们在一个节点中时，我们必须在该节点上挂一个 latch，不管是写模式还是读模式的 latch 都可以。</li><li>接着，在我们跳到我们的孩子节点之前，我们要拿到我们孩子节点上的 latch，以及我们想要到达的下一个节点的 latch。</li><li>然后，当我们落到那个孩子节点上时，我们要对它里面的内容进行测试。如果我们判断出来移到到该孩子节点是安全的话，那么，对我们来说将父节点上的 latch 释放掉是 ok 的。<ul><li>如何判断安全？<ul><li>如果我们要进行一次修改，我们所在的节点无须进行拆分或合并操作，也不用去管在它下面所发生的事情</li></ul></li></ul></li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221022203812729.png" alt="image-20221022203812729"></p><ul><li>例子</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221022204015361.png" alt="image-20221022204015361"></p><ul><li>A -&gt; B：不安全，不释放 A latch</li><li>B -&gt; D：安全，因为 D 已满（相反，如果是 insert 操作，则 D 不满才是安全的），不管 D 下面发生了什么，都不会影响到 B 和 A，可以释放 B 和 A 的 latches</li><li>D -&gt; H：安全，释放 D 的 latch，删除完后，释放 H</li></ul><p>基本上来讲，在 B+Tree 中，当线程往下进行遍历时，线程会通过一个 stack 来保存它一路上所持有的 latch</p><p>在某个时间点，当我在一个安全的节点处时，我就可以释放掉该节点之前所有节点上的 latch</p><ul><li>注意：释放时：想尽量快的先释放更上层的 latch，因为这样可以尽快减小 latch 对其他线程的影响。但是由于是栈结构，所以还是 FILO</li></ul><h3 id="5-2-4-乐观和悲观"><a href="#5-2-4-乐观和悲观" class="headerlink" title="5.2.4. 乐观和悲观"></a>5.2.4. 乐观和悲观</h3><ul><li>但是这样的锁机制存在着一个问题：每个线程访问 B+树时都需要在根节点获得 write latch。但是 W latch 是独占的，会造成并发性的性能瓶颈。</li><li>因此会有乐观锁：<ul><li>乐观地假设我不会去进行任何拆分操作，向下访问 B+Tree 的时候，我所采用的是 read latch，而不是 write latch。然后，我在对叶子节点进行处理时，会使用 write latch。</li><li>如果我判断出我并不需要进行拆分的话，that’s good. 如果我在进行拆分或合并操作时犯错了，那么，我直接终止操作，并在根节点处重启该操作，在向下遍历的时候获取 write latch</li><li>这样可以有效避免，非拆分合并操作占用非叶子结点 W latch 造成性能瓶颈的情况：因为非拆分合并操作不会造成非叶子结点的变化</li></ul></li></ul><h2 id="5-3-Observation"><a href="#5-3-Observation" class="headerlink" title="5.3. Observation"></a>5.3. Observation</h2><ul><li><p>目前所有的遍历都是从上到下。如果有从左到右的遍历呢？</p></li><li><p>如果是 Write 操作，可能会存在死锁问题</p></li><li><p>解决方法：中断其中之一</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 3. Hash Table</title>
      <link href="/article/CMU-15-445-3-Hash-Table/"/>
      <url>/article/CMU-15-445-3-Hash-Table/</url>
      
        <content type="html"><![CDATA[<h1 id="3-Hash-Table"><a href="#3-Hash-Table" class="headerlink" title="3. Hash Table"></a>3. Hash Table</h1><p>[CMU-15-445 Lecture 6 Hash Tables - 知乎 (zhihu.com)</p><h2 id="3-1-Hash-Function"><a href="#3-1-Hash-Function" class="headerlink" title="3.1. Hash Function"></a>3.1. Hash Function</h2><h2 id="3-2-Hash-Scheme"><a href="#3-2-Hash-Scheme" class="headerlink" title="3.2. Hash Scheme"></a>3.2. Hash Scheme</h2><h3 id="3-2-1-static-hash-scheme"><a href="#3-2-1-static-hash-scheme" class="headerlink" title="3.2.1. static hash scheme"></a>3.2.1. static hash scheme</h3><h4 id="3-2-1-1-线性"><a href="#3-2-1-1-线性" class="headerlink" title="3.2.1.1. 线性"></a>3.2.1.1. 线性</h4><h4 id="3-2-1-2-Robin-Hood-Hashing"><a href="#3-2-1-2-Robin-Hood-Hashing" class="headerlink" title="3.2.1.2. Robin Hood Hashing"></a>3.2.1.2. Robin Hood Hashing</h4><ul><li>不清晰，需要学习一下</li></ul><h4 id="3-2-1-3-Cuckoo-Hashing"><a href="#3-2-1-3-Cuckoo-Hashing" class="headerlink" title="3.2.1.3. Cuckoo Hashing"></a>3.2.1.3. Cuckoo Hashing</h4><ul><li>多个 hash 表，对应不同的 hash function</li></ul><p>上述谈论的 3 种方案都是静态哈希，这就意味着哈希表的大小是固定的，我们必须提前知道我们想要保存的 key 的大概数量，这样才能知道如何分配空间使得其足够容纳并能最小化哈希碰撞。但是现实没有那么理想，一旦超过容量，就要扩容。扩容并非是直接 append 一段内存，一般来说得重建整个哈希表并迁移。当我们谈到分布式数据库时我们还会谈到一致性哈希算法，这个算法无需调整大小（令人期待的算法）。但是对于单机数据库中的哈希表，我们还是得重新构建，这也是动态的哈希所要解决的问题。</p><h3 id="3-2-2-dynamic-hash-scheme"><a href="#3-2-2-dynamic-hash-scheme" class="headerlink" title="3.2.2. dynamic hash scheme"></a>3.2.2. dynamic hash scheme</h3><h4 id="3-2-2-1-Chained-Hashing"><a href="#3-2-2-1-Chained-Hashing" class="headerlink" title="3.2.2.1. Chained Hashing"></a>3.2.2.1. Chained Hashing</h4><h4 id="3-2-2-2-Extendible-Hashing"><a href="#3-2-2-2-Extendible-Hashing" class="headerlink" title="3.2.2.2. Extendible Hashing"></a>3.2.2.2. Extendible Hashing</h4><ul><li>妙，但不好理解。多看看</li></ul><h4 id="3-2-2-3-Linear-Hashing"><a href="#3-2-2-3-Linear-Hashing" class="headerlink" title="3.2.2.3. Linear Hashing"></a>3.2.2.3. Linear Hashing</h4><h3 id="3-2-3-布隆过滤器"><a href="#3-2-3-布隆过滤器" class="headerlink" title="3.2.3. 布隆过滤器"></a>3.2.3. 布隆过滤器</h3><ul><li>这篇文章写的很好</li></ul><p><a href="https://developer.aliyun.com/article/773205">布隆过滤器，这一篇给你讲的明明白白-阿里云开发者社区 (aliyun.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 2. Buffer Pools</title>
      <link href="/article/CMU-15-445-2-Buffer-Pools/"/>
      <url>/article/CMU-15-445-2-Buffer-Pools/</url>
      
        <content type="html"><![CDATA[<h1 id="2-Buffer-Pools"><a href="#2-Buffer-Pools" class="headerlink" title="2. Buffer Pools"></a>2. Buffer Pools</h1><p><a href="https://www.jianshu.com/p/fecd0358cd29">【学习笔记 3】数据库中的 buffer pool - 简书 (jianshu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/364322857">CMU 15445 学习笔记——Buffer Pool - 知乎 (zhihu.com)</a></p><ul><li>这段内存完全是由数据库控制而不是操作系统</li><li>类似于数据库的内存</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220927172727486.png" alt="image-20220927172727486"></p><h2 id="2-1-Lock-和-Latch"><a href="#2-1-Lock-和-Latch" class="headerlink" title="2.1. Lock 和 Latch"></a>2.1. Lock 和 Latch</h2><ul><li><p>lock 更高级，保护高级内容 from other transaction。</p></li><li><p>事务运行时持有 lock</p></li><li><p>要求能够回滚 changes</p></li><li><p>可以暴露给开发人员</p></li><li><p>latch 是更底层的概念，来保护数据结构和内存</p></li><li><p>不需要能够回滚 changes</p></li><li><p>有点类似 mutex（互斥锁）</p></li></ul><h2 id="2-2-page-table-和-page-directory"><a href="#2-2-page-table-和-page-directory" class="headerlink" title="2.2. page table 和 page directory"></a>2.2. page table 和 page directory</h2><ul><li>page directory<ul><li>page id 到数据库文件中的 page location 的映射</li><li>所有 changes 必须持久化</li></ul></li><li>page table<ul><li>page id 到 buffer pool frames 中 page copy 的银蛇</li><li>内存中的数据，不需要在磁盘中保存</li></ul></li></ul><h2 id="2-3-buffer-pool-optimization"><a href="#2-3-buffer-pool-optimization" class="headerlink" title="2.3. buffer pool optimization"></a>2.3. buffer pool optimization</h2><h3 id="2-3-1-Multiple-Buffer-Pool"><a href="#2-3-1-Multiple-Buffer-Pool" class="headerlink" title="2.3.1. Multiple Buffer Pool"></a>2.3.1. Multiple Buffer Pool</h3><ul><li>有多个 buffer pool</li><li>在每个 buffer pool 有局部策略</li><li>比如对每个表都有一个 buffer pool</li><li>可以一定程度缓解多线程争抢 latch 的场景</li></ul><p>Approach Methods：</p><h4 id="2-3-1-1-Object-Id"><a href="#2-3-1-1-Object-Id" class="headerlink" title="2.3.1.1. Object Id"></a>2.3.1.1. Object Id</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928103255171.png" alt="image-20220928103255171"></p><h4 id="2-3-1-2-Hashing"><a href="#2-3-1-2-Hashing" class="headerlink" title="2.3.1.2. Hashing"></a>2.3.1.2. Hashing</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928103318990.png" alt="image-20220928103318990"></p><h3 id="2-3-2-pre-fetching"><a href="#2-3-2-pre-fetching" class="headerlink" title="2.3.2. pre-fetching"></a>2.3.2. pre-fetching</h3><ul><li><p>为了最小化磁盘 IO 的影响</p></li><li><p>pre-fetching 的方法</p><ul><li>Sequential Scans</li><li>Index Scans</li></ul></li></ul><h3 id="2-3-3-scan-sharing"><a href="#2-3-3-scan-sharing" class="headerlink" title="2.3.3. scan sharing"></a>2.3.3. scan sharing</h3><ul><li>复用某次查询的数据，用于其他的查询<ul><li>不是 caching，caching 指的是完全相同的查询</li><li>但是 scan sharing 只在乎是否取了同一个 page，而不是查询</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928105027699.png" alt="image-20220928105027699"></p><h3 id="2-3-4-buffer-pool-bypass"><a href="#2-3-4-buffer-pool-bypass" class="headerlink" title="2.3.4. buffer pool bypass"></a>2.3.4. buffer pool bypass</h3><ul><li>为了避免从 page table（hash 表）中查询的开销。</li><li>给每个查询线程分配一个本地内存作为该线程的缓存</li></ul><h2 id="2-4-replace-policy"><a href="#2-4-replace-policy" class="headerlink" title="2.4. replace policy"></a>2.4. replace policy</h2><ul><li>lRU（Least Recently Used）<ul><li>单独维护一个 queue，根据 page 的修改顺序排列</li><li>实现<ul><li>每个 page 带一个时间戳</li><li>clock：每个 page 带一个标志位（reference bit）<ul><li>代表我们上次 check 后，该 page 是否被访问</li><li>page 在一个环形队列（like a clock）</li><li>不是严格的 LRU</li><li>其实它的基本假设是：如果一个 page 在一段时间内不被使用，那么它大概率也不会再被使用，即可移除</li></ul></li></ul></li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928143037173.png" alt="image-20220928143037173"></p><ul><li>问题：sequential flooding。</li></ul><h3 id="2-4-1-解决-sequential-flooding"><a href="#2-4-1-解决-sequential-flooding" class="headerlink" title="2.4.1. 解决 sequential flooding"></a>2.4.1. 解决 sequential flooding</h3><h4 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h4><ul><li><p>记录每页的 K 次历史记录</p></li><li><p>不是看哪个 page 的时间戳最老，而是看时间戳之间的间隔</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220928145520506.png" alt="image-20220928145520506"></p><h4 id="localization"><a href="#localization" class="headerlink" title="localization"></a>localization</h4><ul><li>从本地的角度移除最少使用的 page，而不是全局的角度</li></ul><h4 id="priority-hints"><a href="#priority-hints" class="headerlink" title="priority hints"></a>priority hints</h4><h4 id="dirty-page"><a href="#dirty-page" class="headerlink" title="dirty page"></a>dirty page</h4><ul><li>每个 page 有一个 dirty bit<ul><li>告诉我们自从上次 page 被放入后，是否被修改</li></ul></li><li>要么每次 drop 掉不 dirty 的 page，但这些 page 可能会被用到</li><li>要么每次写出一个 dirty page 到磁盘（产生一次 IO），再将其替换之（又产生一次 IO）</li><li>数据库一般有一个定时任务线程，负责定时写出 dirty page，然后将其置为 clean</li></ul><p>project 说明在 13：40<a href="https://www.zhihu.com/zvideo/1416128309478862848">(2 封私信) CMU 15-445 18 Buffer Pools 04 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-445: 1. Disk Manager</title>
      <link href="/article/CMU-15-445-1-Disk-Manager/"/>
      <url>/article/CMU-15-445-1-Disk-Manager/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Disk-Manager"><a href="#1-Disk-Manager" class="headerlink" title="1. Disk Manager"></a>1. Disk Manager</h1><ul><li>面向磁盘的数据库系统<ul><li>主要存储放在磁盘上，每次查询时，访问的数据不在内存中</li></ul></li></ul><h2 id="1-1-none-volatile-storage"><a href="#1-1-none-volatile-storage" class="headerlink" title="1.1. (none) volatile storage"></a>1.1. (none) volatile storage</h2><ul><li>此部分在计组和 ics 已经学过，不再赘述</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220923152440566.png" alt="image-20220923152440566"></p><h2 id="1-2-总览目标"><a href="#1-2-总览目标" class="headerlink" title="1.2. 总览目标"></a>1.2. 总览目标</h2><ul><li>给应用提供一种假象：它总是拥有足够的内存来处理</li><li>允许 DBMS 来用超过内存的大小处理数据库</li></ul><h2 id="1-3-mmap"><a href="#1-3-mmap" class="headerlink" title="1.3. mmap"></a>1.3. mmap</h2><ul><li>虚存的思想。交给 OS 来处理缺页中断</li><li>但是在数据库系统里，这样会产生问题（read 不会产生问题，但是 write 要谨慎）：有时候页与页之间写有顺序要求（比如日志和并发控制），而 os 并不知道这些事情，导致会出现错误</li><li>因此：慎用 mmap。事实上，数据库总是能够接管 os 能干的事情，并能够比 os 干的更好</li></ul><h2 id="1-4-file-storage"><a href="#1-4-file-storage" class="headerlink" title="1.4. file storage"></a>1.4. file storage</h2><ul><li>DBMS 将数据库存储在磁盘上的一个或多个文件中<ul><li>OS 对它们的内容并无所知</li></ul></li><li>Storage manager 负责维护数据库的文件<ul><li>page 可以保存很多类型，比如 tuples，meta-data 等</li><li>但是一般一个 page 只存储一个类型的</li><li>每个物理 page 有一个实际 id 对应它</li></ul></li><li>不同的 DBMS 通过不同的方式管理磁盘上的页<ul><li>堆文件（Heap File）组织（Organization）</li><li>Sequential &#x2F; Sorted File Organization</li></ul></li></ul><h2 id="1-5-Heap-File"><a href="#1-5-Heap-File" class="headerlink" title="1.5. Heap File"></a>1.5. Heap File</h2><ul><li>无序的 pages 集合。其中 tuples 是无序（随机）的存储于其中</li></ul><h2 id="1-6-Page-Layout"><a href="#1-6-Page-Layout" class="headerlink" title="1.6. Page Layout"></a>1.6. Page Layout</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220924122654927.png" alt="image-20220924122654927"></p><ul><li>通过 fileId + pageId + slotId 来寻找具体的 slot</li></ul><h2 id="1-7-Tuple-Layout"><a href="#1-7-Tuple-Layout" class="headerlink" title="1.7. Tuple Layout"></a>1.7. Tuple Layout</h2><ul><li>tuple is a sequence of bytes</li><li>DBMS 需要解释这些 sequence of byte</li></ul><h3 id="1-7-1-tuple-header"><a href="#1-7-1-tuple-header" class="headerlink" title="1.7.1. tuple header"></a>1.7.1. tuple header</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220924154320372.png" alt="image-20220924154320372"></p><h3 id="1-7-2-tuple-data"><a href="#1-7-2-tuple-data" class="headerlink" title="1.7.2. tuple data"></a>1.7.2. tuple data</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220924154420159.png" alt="image-20220924154420159"></p><h1 id="剩余笔记"><a href="#剩余笔记" class="headerlink" title="剩余笔记"></a>剩余笔记</h1><p><a href="https://zhuanlan.zhihu.com/p/454591350">CMU-15-445 Lecture 4 数据库存储（下） - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学软件学院-云计算第一次作业-OBS展示</title>
      <link href="/article/Cloud-computing-OBS/"/>
      <url>/article/Cloud-computing-OBS/</url>
      
        <content type="html"><![CDATA[<h1 id="云计算第一次实践：网络测试-个人主页"><a href="#云计算第一次实践：网络测试-个人主页" class="headerlink" title="云计算第一次实践：网络测试+个人主页"></a>云计算第一次实践：网络测试+个人主页</h1><p>2022-Fall Cloud Computing</p><p>描述：下图即为 Huawei OBS 存储对象</p><img src="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png"><h1 id="一、过程记录"><a href="#一、过程记录" class="headerlink" title="一、过程记录"></a>一、过程记录</h1><h2 id="1-网络测试"><a href="#1-网络测试" class="headerlink" title="1. 网络测试"></a>1. 网络测试</h2><h3 id="1-1-测试过程描述：虚拟机申请过程、测试工具、操作过程"><a href="#1-1-测试过程描述：虚拟机申请过程、测试工具、操作过程" class="headerlink" title="1.1. 测试过程描述：虚拟机申请过程、测试工具、操作过程"></a>1.1. 测试过程描述：虚拟机申请过程、测试工具、操作过程</h3><h3 id="1-2-跨区域公网：虚拟机网络配置情况-测试结果"><a href="#1-2-跨区域公网：虚拟机网络配置情况-测试结果" class="headerlink" title="1.2. 跨区域公网：虚拟机网络配置情况 + 测试结果"></a>1.2. 跨区域公网：虚拟机网络配置情况 + 测试结果</h3><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921205319574.png" alt="image-20220921205319574"></p><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921205336815.png" alt="image-20220921205336815"></p><h3 id="1-3-同区域跨可用区公网：虚拟机网络配置情况-测试结果"><a href="#1-3-同区域跨可用区公网：虚拟机网络配置情况-测试结果" class="headerlink" title="1.3. 同区域跨可用区公网：虚拟机网络配置情况 + 测试结果"></a>1.3. 同区域跨可用区公网：虚拟机网络配置情况 + 测试结果</h3><h3 id="1-3-1-公网"><a href="#1-3-1-公网" class="headerlink" title="1.3.1. 公网"></a>1.3.1. 公网</h3><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921191009640.png" alt="image-20220921191009640"></p><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921191000516.png" alt="image-20220921191000516"></p><h3 id="1-3-2-私网"><a href="#1-3-2-私网" class="headerlink" title="1.3.2. 私网"></a>1.3.2. 私网</h3><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921203324190.png" alt="image-20220921203324190"></p><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921203335678.png" alt="image-20220921203335678"></p><h3 id="1-4-同可用区公网-私网：虚拟机网络配置情况-测试结果"><a href="#1-4-同可用区公网-私网：虚拟机网络配置情况-测试结果" class="headerlink" title="1.4. 同可用区公网+私网：虚拟机网络配置情况 + 测试结果"></a>1.4. 同可用区公网+私网：虚拟机网络配置情况 + 测试结果</h3><h4 id="1-4-1-公网"><a href="#1-4-1-公网" class="headerlink" title="1.4.1. 公网"></a>1.4.1. 公网</h4><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921154258878.png" alt="image-20220921154258878"></p><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921154328161.png" alt="image-20220921154328161"></p><h4 id="1-4-2-私网"><a href="#1-4-2-私网" class="headerlink" title="1.4.2. 私网"></a>1.4.2. 私网</h4><p>客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921154807390.png" alt="image-20220921154807390"></p><p>服务器端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220921154817551.png" alt="image-20220921154817551"></p><h2 id="2-个人主页"><a href="#2-个人主页" class="headerlink" title="2. 个人主页"></a>2. 个人主页</h2><p>（1）对应的 OBS 链接</p><ul><li><a href="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/">https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com</a></li></ul><p>（2）上传的 obs 图片链接</p><ul><li><a href="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png">https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png</a></li></ul><p>（3）个人主页地址（公网 IP）</p><ul><li><a href="http://116.204.103.36/">http://116.204.103.36/</a></li></ul><h1 id="二、详细作业叙述"><a href="#二、详细作业叙述" class="headerlink" title="二、详细作业叙述"></a>二、详细作业叙述</h1><ol><li>201250214-彭俊植</li><li>网络测试：</li></ol><ul><li><p><strong>虚拟机申请过程：</strong></p><ul><li>虚拟机 ①<ul><li>华北-乌兰察布一&#x2F;可用区 2</li><li>ID：test0921-wlcb2qu</li><li>配置 1C4G；系统镜像 CentOS 8.2 64bit；按需计费</li><li>带宽：5 Mbit&#x2F;s</li><li>公网 ip：116.204.103.253；私网 ip：192.168.0.173</li></ul></li><li>虚拟机 ②<ul><li>华北-乌兰察布一&#x2F;可用区 2</li><li>ID：test0921-wlcb2qu-02</li><li>配置 1C4G；系统镜像 CentOS 8.2 64bit；按需计费</li><li>带宽：5 Mbit&#x2F;s</li><li>公网 ip：116.204.103.36；私网 ip：192.168.0.83</li></ul></li><li>虚拟机 ③<ul><li>华北-乌兰察布一&#x2F;可用区 3</li><li>ID：test0921-wlcb3qu</li><li>配置 1C4G；系统镜像 CentOS 8.2 64bit；按需计费</li><li>带宽：5 Mbit&#x2F;s</li><li>公网 ip：121.37.97.146；私网 ip：192.168.0.128</li></ul></li><li>虚拟机 ④<ul><li>西南-贵阳一&#x2F;可用区 1</li><li>ID：test0921-guiyang1qu</li><li>配置 1C4G；系统镜像 CentOS 8.2 64bit；按需计费</li><li>带宽：5 Mbit&#x2F;s</li><li>公网 ip：140.210.210.244；私网 ip：192.168.0.109</li></ul></li></ul></li><li><p><strong>测试工具</strong>：iperf 3.1.3</p></li><li><p><strong>操作过程</strong></p><ul><li>先按如上配置申请四台虚拟机，并开放必要的 5000、22、ICMP 等端口，并安装 iperf 3.1.3。随后分别按作业要求所述的三种情况展开测试。</li><li>测试手段如下：同时开启两台虚拟机，一台作为客户端，一台作为服务端。先在服务端运行命令<code>iperf3 –s –i 5 –p 5000</code>，再于客户端运行命令<code>Iperf3 –c $&#123;serverIP&#125; –i 5 –t 100 –p 5000</code>。其中客户端中第二个参数填上服务端的 ip（可视实验情况选择填写公网 ip 或私网 ip）。观察屏幕输出结果，并进行记录。</li></ul></li><li><p><strong>跨区域</strong></p><ul><li>公网：服务端为 wlcb2qu-02，客户端为 guiyang1qu。测试结果为客户端 sender 5.18 Mbits&#x2F;sec，receiver 4.85 Mbits&#x2F;sec，服务端 receiver 4.85 Mbits&#x2F;sec</li><li>私网：ping 不通</li></ul></li><li><p><strong>同区域跨可用区</strong></p><ul><li>公网：服务端为 wlcb3qu ，客户端为 wlcb2qu-02。测试结果为客户端 sender 5.56 Mbits&#x2F;sec，receiver 5.46 Mbits&#x2F;sec，服务端 receiver 5.46 Mbits&#x2F;sec</li><li>私网：可 ping 通，服务端为 wlcb3qu，客户端为 wlcb2qu-02。测试结果为客户端 sender 531 Mbits&#x2F;sec，receiver 531 Mbits&#x2F;sec，服务端 receiver 531 Mbits&#x2F;sec</li></ul></li><li><p><strong>同区域同可用区</strong></p><ul><li><p>公网：服务端为 wlcb2qu-02 ，客户端为 wlcb2qu。测试结果为客户端 sender 5.38 Mbits&#x2F;sec，receiver 5.35 Mbits&#x2F;sec，服务端 receiver 5.34 Mbits&#x2F;sec</p></li><li><p>私网：可 ping 通，服务端为 wlcb2qu，客户端为 wlcb2qu-02。测试结果为客户端 sender 55.4 Gbits&#x2F;sec，receiver 55.4 Gbits&#x2F;sec，服务端 receiver 55.4 Gbits&#x2F;sec</p><p>3.个人主页</p></li></ul></li></ul><p>（1）对应的 OBS 链接</p><ul><li><a href="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/">https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com</a></li></ul><p>（2）上传的 obs 图片链接</p><ul><li><a href="https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png">https://pengzna-cloud-computing.obs.cn-east-3.myhuaweicloud.com/5612488132C6F7BAB6B1C96D04075AA7.png</a></li></ul><p>（3）个人主页地址</p><ul><li><a href="http://116.204.103.36/">http://116.204.103.36/</a> （部署在虚拟机 ② 上）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 整理重点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS Melodic 安装踩坑</title>
      <link href="/article/ROS-installation/"/>
      <url>/article/ROS-installation/</url>
      
        <content type="html"><![CDATA[<img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221006110534808.png" alt="image-20221006110534808" style="zoom:67%;" /><hr><h2 id="1-安装过程"><a href="#1-安装过程" class="headerlink" title="1. 安装过程"></a>1. 安装过程</h2><ul><li>安装 amd64 Ubuntu18.04 虚拟机（基于 virtual box）</li><li>配置安装源<code>sudo sh -c &#39;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;</code></li><li>设置密钥<code>sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 </code></li><li><code>sudo apt update</code></li><li>出现报错。输入<code>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F42ED6FBAB17C654</code>解决</li><li>开始安装 ROS Melodic <code>sudo apt-get install ros-melodic-desktop-full</code></li><li>避免后面出现<code>sudo rosdep：找不到命令</code>提示，执行如下命令<code>sudo apt install python-rosdep</code></li><li>初始化 rosdep<code>sudo rosdep init</code><ul><li>此处出现最大问题，由于众所周知的原因，init 失败，无法 hit 到 raw.githubusercontent</li><li><strong><em>解决：</em></strong><ul><li>定位 rosdep 资源下载函数：&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;rosxxx&#x2F;xxxx.py 文件（有若干个文件）</li><li>直接修改源 py 代码，在所有下载 url 地址前添加<a href="https://ghproxy.com/%E5%89%8D%E7%BC%80%E6%9D%A5%E5%BA%94%E7%94%A8%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1">https://ghproxy.com/前缀来应用代理服务</a></li></ul></li></ul></li><li>执行 rosdep 更新<code>rosdep update</code></li><li>添加 ros 环境变量<code>echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrc source ~/.bashrc</code></li><li>安装 rosinstall<code>sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential</code></li><li><strong><em>到此安装完成，可以运行命令启动小海龟</em></strong></li></ul><h2 id="2-运行截图"><a href="#2-运行截图" class="headerlink" title="2. 运行截图"></a>2. 运行截图</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221006110534808.png" alt="image-20221006110534808"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Redis 发布订阅实现IM消息队列</title>
      <link href="/article/RedisMQ-IM/"/>
      <url>/article/RedisMQ-IM/</url>
      
        <content type="html"><![CDATA[<p>使用Redis的发布订阅模式实现即时通讯功能的消息队列中间件，以适应分布式模块中即时通讯服务的需要。</p><p>整合方式：SpringBoot + WebSocket + Redis</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/60047df223d04285afea73d1cacfa688.png" alt="在这里插入图片描述"></p><h2 id="1-发布订阅模式"><a href="#1-发布订阅模式" class="headerlink" title="1. 发布订阅模式"></a>1. 发布订阅模式</h2><p>Redis的发布订阅机制是一种消息通信模式，包括三个部分，发布者（pub）发送消息，订阅者（sub）接收信息和<code>Channel</code>，这里的<code>Channel</code>类似于<code>Kafka</code>中的<code>topic</code>的概念。</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/20210702104227710.png" alt="img"></p><p>发布者和订阅者都是<code>Redis</code>客户端，<code>Channel</code>则为<code>Redis</code>服务器端，可以理解为一种特殊的数据<a href="https://so.csdn.net/so/search?q=%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">存储结构</a>。发布者将消息发送到某个的频道，订阅了这个频道的订阅者就能接收到这条消息。</p><p>Redis客户端可以订阅任意数量的频道。</p><p><code>Redis</code>的这种发布订阅机制与基于主题的发布订阅类似，<code>Channel</code>相当于主题。</p><p>下图展示频道channel1，以及订阅这个频道的三个客户端–client2，client5和client1之间的关系</p><p><img src="https://img-blog.csdnimg.cn/ae3ee06fde0b4b81ad1278a920dbfcc2.png#pic_center" alt="img"></p><p>当有新消息通过PUBLISH命令发送给频道channel1时，这个消息就会被发送给订阅它的三个客户端</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/ce1bfeef41514ea59745f713fc49d439.png" alt="在这里插入图片描述"></p><h3 id="1-1-相关命令"><a href="#1-1-相关命令" class="headerlink" title="1.1. 相关命令"></a>1.1. 相关命令</h3><h4 id="1-1-1-订阅者-等待接收消息"><a href="#1-1-1-订阅者-等待接收消息" class="headerlink" title="1.1.1. 订阅者&#x2F;等待接收消息"></a>1.1.1. 订阅者&#x2F;等待接收消息</h4><p>首先打开 Redis 客户端，然后订阅了一个名为“bbx”的 channel，使用如下命令:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE bbx</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;bbx&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>使用SUBSCRIBE命令订阅了名为 bbx 的 channel。命令执行后该客户端会出处于等待接收消息的阻塞状态。</p><h4 id="1-1-2-发布者-发送消息"><a href="#1-1-2-发布者-发送消息" class="headerlink" title="1.1.2. 发布者&#x2F;发送消息"></a>1.1.2. 发布者&#x2F;发送消息</h4><p>下面再启动一个 Redis 客户端，输入如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH bbx hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH bbx world</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><h4 id="1-1-3-订阅者-成功接收消息"><a href="#1-1-3-订阅者-成功接收消息" class="headerlink" title="1.1.3. 订阅者&#x2F;成功接收消息"></a>1.1.3. 订阅者&#x2F;成功接收消息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE bbx</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;bbx&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">#等待读取推送消息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span><span class="comment">#消息</span></span><br><span class="line">2) <span class="string">&quot;bbx&quot;</span><span class="comment">#频道</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span><span class="comment">#消息具体内容</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;bbx&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2. 原理"></a>1.2. 原理</h3><blockquote><p>源码：pubsub.c</p></blockquote><p>Redis通过<code>PUBLISH</code>，<code>SUBSCRIBE</code>和<code>PSUBSCRIBE</code>等命令实现发布和订阅功能</p><p>通过<code>SUBSCRIBE</code>命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个频道，字典的值则是一个链表，链表中保存了所有订阅这个频道的客户端。<code>SUBSCRIBE</code>命令的关键，就是将客户端添加到给定频道的订阅链表中。</p><p>通过<code>PUBLISH</code>命令向订阅者发送消息，redis-server会使用给定频道作为键，在它维护的频道字典中查找记录了订阅这个频道的所有客户端的链表，将消息发布给所有订阅者</p><p>Pub和Sub从字面上理解就是发布（Publish）和订阅（Subscribe），在redis中，可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的信息，这一功能最明显的用法就是实时消息系统，比如普通的即时聊天，群聊等功能。</p><h3 id="1-3-缺点"><a href="#1-3-缺点" class="headerlink" title="1.3. 缺点"></a>1.3. 缺点</h3><ul><li>消息无法持久化，存在丢失风险，即消息一经发布，即使没有任何订阅方处理,该条消息就会丢失</li><li>没有类似ACK的机制，即发布方不会确保订阅方成功接收</li><li>广播机制，下游消费能力取决于消费方本身。广播机制无法通过添加多个消费方增强消费能力, 因为这和发布&#x2F;订阅模型本身的目的是不符的。广播机制的目的是一个一个发布者被多个订阅进行不同的处理</li></ul><p>解决方法：</p><blockquote><ol><li>添加持久化层，加入redis缓存和MySQL</li><li>结合WebSocket，实现消息推送、握手、心跳检测和广播等机制</li></ol></blockquote><h2 id="2-和SpringBoot、WebSocket的整合"><a href="#2-和SpringBoot、WebSocket的整合" class="headerlink" title="2. 和SpringBoot、WebSocket的整合"></a>2. 和SpringBoot、WebSocket的整合</h2><h3 id="2-1-依赖"><a href="#2-1-依赖" class="headerlink" title="2.1. 依赖"></a>2.1. 依赖</h3><ul><li><em><strong>spring-boot-starter-web</strong></em>：帮助我们启动一个Web服务器；</li><li><em><strong>spring-boot-starter-data-redis</strong></em>：帮助我们集成Redis；</li><li><em><strong>lombok</strong></em>：方便我们使用 <em><strong>@Slf4j</strong></em>&#x2F;<em><strong>@Data</strong></em> 等，简化代码；</li><li><em><strong>spring-boot-starter-websocket</strong></em>：帮助我们在SpringBoot客户端起WebSocket进程</li></ul><h3 id="2-2-架构"><a href="#2-2-架构" class="headerlink" title="2.2. 架构"></a>2.2. 架构</h3><h4 id="2-2-1-整体架构"><a href="#2-2-1-整体架构" class="headerlink" title="2.2.1. 整体架构"></a>2.2.1. 整体架构</h4><blockquote><p>Redis(消息队列)——&gt; MySQL(持久化) ——&gt; WebSockets(消息转发)——&gt; FrontEnd(客户端)</p></blockquote><h4 id="2-2-2-后端架构"><a href="#2-2-2-后端架构" class="headerlink" title="2.2.2. 后端架构"></a>2.2.2. 后端架构</h4><blockquote><p>Controller——(n,1)——&gt;Redis——(1,n)———&gt;Listener——(1,n)——&gt;WebSockets</p></blockquote><h3 id="2-3-Redis配置"><a href="#2-3-Redis配置" class="headerlink" title="2.3. Redis配置"></a>2.3. Redis配置</h3><h4 id="2-3-1-自定义RedisTemplate"><a href="#2-3-1-自定义RedisTemplate" class="headerlink" title="2.3.1. 自定义RedisTemplate"></a>2.3.1. 自定义RedisTemplate</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTemp</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-发布订阅配置"><a href="#2-3-2-发布订阅配置" class="headerlink" title="2.3.2. 发布订阅配置"></a>2.3.2. 发布订阅配置</h4><p>由于我们在发布者、订阅者的代码中均没有指定要订阅的channel，因此需要在其他地方（发布订阅配置类）指定channel。</p><p>此配置类主要实现了Redis消息监听器容器，这个容器加载了RedisConnectionFactory和消息监听器；可以添加多个监听不同话题的redis监听器，只需要把消息监听器和相应的消息订阅处理器绑定，该消息监听器通过反射技术调用消息订阅处理器的相关方法进行一些业务处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubConfig</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisConnectionFactory = redisConnectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;配置消息监听器&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageListener <span class="title function_">listener</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ConnectionListener.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;配置 发布/订阅 的 Topic&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ChannelTopic <span class="title function_">channelTopic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChannelTopic</span>(<span class="string">&quot;nxb message test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;将消息监听器绑定到消息容器&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * 并进行容器的设置</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisMessageListenerContainer <span class="title function_">messageListenerContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RedisMessageListenerContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisMessageListenerContainer</span>();</span><br><span class="line">        container.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">// 此处可以更换订阅主题</span></span><br><span class="line">        container.addMessageListener(listener(), channelTopic());</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-消费者（sub）"><a href="#2-4-消费者（sub）" class="headerlink" title="2.4. 消费者（sub）"></a>2.4. 消费者（sub）</h3><p>这里需要实现<code>MessageListener</code>接口。目的是利用<code>onMessage</code>方法，监听<code>channel</code>中的消息队列，实现接受消息。</p><p>消费者的核心方法是<code>onMessage</code>，方法传入订阅到的消息，然后进行处理即可。</p><p>这里把redis的消费者方法和websocket进行了整合，redis消费者收到上游消息后，由websocket转发给对应用户，再转发给前端。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负责订阅redis发布的接受器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionListener</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, WebSocket&gt; webSockets = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ConnectionListener</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionListener</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ConnectionListener</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConnectionListener <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收到消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, <span class="type">byte</span>[] pattern)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        <span class="type">MessageVO</span> <span class="variable">messageVO</span> <span class="operator">=</span> JSON.parseObject((String)JSON.parse(message.toString()), MessageVO.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;received message: &quot;</span>+ messageVO);</span><br><span class="line">        sendMessage(messageVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addConnection</span><span class="params">(String userId,WebSocket webSocket)</span>&#123;</span><br><span class="line">        webSockets.put(userId,webSocket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containConnection</span><span class="params">(String userId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webSockets.containsKey(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeConnection</span><span class="params">(String userId)</span>&#123;</span><br><span class="line">        webSockets.remove(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">connectionCount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webSockets.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(MessageVO message)</span>&#123;</span><br><span class="line">        <span class="comment">// 优化逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (containConnection(message.getUser()))&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> message.getUser();</span><br><span class="line">            webSockets.get(key).sendMessage(message);</span><br><span class="line">            System.out.println(message + <span class="string">&quot; has been sent to &quot;</span> + key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-生产者（pub）"><a href="#2-5-生产者（pub）" class="headerlink" title="2.5. 生产者（pub）"></a>2.5. 生产者（pub）</h3><p>指定要发布到的channel和要发布的消息。注意这里的channel由配置类进行管理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息发布者服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublishService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入自定义redisTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChannelTopic channelTopic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Publish.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message   the message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(Object message)</span> &#123;</span><br><span class="line">        redisUtil.convertAndSend(channelTopic.getTopic(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>redisUtil</code>封装了转发消息方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向通道发布消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">convertAndSend</span><span class="params">(String channel, Object message)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(channel)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redisTemplate.convertAndSend(channel, message);</span><br><span class="line">        log.info(<span class="string">&quot;发送消息成功，channel：&#123;&#125;，message：&#123;&#125;&quot;</span>, channel, message);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;发送消息失败，channel：&#123;&#125;，message：&#123;&#125;&quot;</span>, channel, message);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><h3 id="3-1-测试类"><a href="#3-1-测试类" class="headerlink" title="3.1. 测试类"></a>3.1. 测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSubPubTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChannelTopic topic;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOPIC</span> <span class="operator">=</span> <span class="string">&quot;TEST_TOPIC1&quot;</span>; <span class="comment">// 订阅主题</span></span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">        <span class="type">MessageVO</span> <span class="variable">messageVO</span> <span class="operator">=</span> MessageVO.builder()</span><br><span class="line">                .user(<span class="string">&quot;pengzna&quot;</span>)</span><br><span class="line">                .msg(<span class="string">&quot;hello world！&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        redisUtil.convertAndSend(topic.getTopic(), messageVO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-测试结果"><a href="#3-2-测试结果" class="headerlink" title="3.2. 测试结果"></a>3.2. 测试结果</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220726182800342.png" alt="image-20220726182800342"></p><hr><p><em>参考资料</em></p><ul><li><a href="https://www.runoob.com/redis/redis-pub-sub.html">Redis 发布订阅 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://www.cnblogs.com/kendoziyu/p/15802698.html">SpringBoot整合Redis实现发布订阅功能实践 - 极客子羽 - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/BBQ__ZXB/article/details/124980860">(26条消息) Spring boot整合Redis实现发布订阅（超详细）_BBQ__XB的博客-CSDN博客_springboot 发布订阅</a></li><li><a href="https://blog.csdn.net/Vector97/article/details/118407461?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-118407461-blog-124980860.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-118407461-blog-124980860.pc_relevant_default&utm_relevant_index=2">(26条消息) Springboot集成Redis实现发布订阅功能（Java Lettuce客户端）_iFence的博客-CSDN博客_lettuce 发布订阅</a></li><li><a href="https://blog.csdn.net/weixin_44874132/article/details/124192307">(26条消息) SpringBoot整合redis实现发布订阅模式_叶枫^_^的博客-CSDN博客_redis发布订阅 springboot</a></li><li>jfy同学代码</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> spring </tag>
            
            <tag> redis </tag>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript ·入门</title>
      <link href="/article/TypeScript-learning/"/>
      <url>/article/TypeScript-learning/</url>
      
        <content type="html"><![CDATA[<p>参考资料：<a href="https://juejin.cn/post/6844904182843965453">https://juejin.cn/post/6844904182843965453</a></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172916652ec072e3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom: 33%;" /><h2 id="1-TypeScript-简介"><a href="#1-TypeScript-简介" class="headerlink" title="1. TypeScript 简介"></a>1. TypeScript 简介</h2><h3 id="1-1-TypeScript-与-JavaScript-的区别"><a href="#1-1-TypeScript-与-JavaScript-的区别" class="headerlink" title="1.1 TypeScript 与 JavaScript 的区别"></a>1.1 TypeScript 与 JavaScript 的区别</h3><table><thead><tr><th>TypeScript</th><th>JavaScript</th></tr></thead><tbody><tr><td>JavaScript 的超集用于解决大型项目的代码复杂性</td><td>一种脚本语言，用于创建动态网页。</td></tr><tr><td>可以在编译期间发现并纠正错误</td><td>作为一种解释型语言，只能在运行时发现错误</td></tr><tr><td>强类型，支持静态和动态类型</td><td>弱类型，没有静态类型选项</td></tr><tr><td>最终被编译成 JavaScript 代码，使浏览器可以理解</td><td>可以直接在浏览器中使用</td></tr><tr><td>支持模块、泛型和接口</td><td>不支持模块，泛型或接口</td></tr><tr><td>支持 ES3，ES4，ES5 和 ES6 等</td><td>不支持编译其他 ES3，ES4，ES5 或 ES6 功能</td></tr><tr><td>社区的支持仍在增长，而且还不是很大</td><td>大量的社区支持以及大量文档和解决问题的支持</td></tr></tbody></table><h3 id="1-2-获取-TypeScript"><a href="#1-2-获取-TypeScript" class="headerlink" title="1.2 获取 TypeScript"></a>1.2 获取 TypeScript</h3><p>命令行的 TypeScript 编译器可以使用 Node.js 包来安装。</p><p><strong>1.安装 TypeScript</strong></p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>npm install -g typescript</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>2.编译 TypeScript 文件</strong></p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>tsc helloworld.ts</span><br><span class="line"><span class="comment"># helloworld.ts =&gt; helloworld.js</span></span><br></pre></td></tr></table></figure><h2 id="2-TypeScript-基础类型"><a href="#2-TypeScript-基础类型" class="headerlink" title="2. TypeScript 基础类型"></a>2. TypeScript 基础类型</h2><h3 id="2-1-Boolean-类型"><a href="#2-1-Boolean-类型" class="headerlink" title="2.1 Boolean 类型"></a>2.1 Boolean 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let isDone: <span class="attr">boolean</span> = <span class="literal">false</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">isDone</span> = <span class="literal">false</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-Number-类型"><a href="#2-2-Number-类型" class="headerlink" title="2.2 Number 类型"></a>2.2 Number 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let count: <span class="attr">number</span> = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">count</span> = <span class="number">10</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-String-类型"><a href="#2-3-String-类型" class="headerlink" title="2.3 String 类型"></a>2.3 String 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let name: <span class="attr">string</span> = <span class="string">&quot;Semliker&quot;</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">name</span> = <span class="string">&#x27;Semlinker&#x27;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-Array-类型"><a href="#2-4-Array-类型" class="headerlink" title="2.4 Array 类型"></a>2.4 Array 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let list: number<span class="section">[]</span> = <span class="section">[1, 2, 3]</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let list: Array&lt;number&gt; = <span class="section">[1, 2, 3]</span><span class="comment">; // Array&lt;number&gt;泛型语法</span></span><br><span class="line">// ES5：var <span class="attr">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-5-Enum-类型"><a href="#2-5-Enum-类型" class="headerlink" title="2.5 Enum 类型"></a>2.5 Enum 类型</h3><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。</p><h4 id="2-5-1-数字枚举"><a href="#2-5-1-数字枚举" class="headerlink" title="2.5.1.数字枚举"></a><strong>2.5.1.数字枚举</strong></h4><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  NORTH,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dir: <span class="attr">Direction</span> = Direction.NORTH<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。上面的枚举示例代码经过编译后会生成以下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;NORTH&#x27;</span>] = <span class="number">0</span>)] = <span class="string">&#x27;NORTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;SOUTH&#x27;</span>] = <span class="number">1</span>)] = <span class="string">&#x27;SOUTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;EAST&#x27;</span>] = <span class="number">2</span>)] = <span class="string">&#x27;EAST&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;WEST&#x27;</span>] = <span class="number">3</span>)] = <span class="string">&#x27;WEST&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;))</span><br><span class="line"><span class="keyword">var</span> dir = <span class="title class_">Direction</span>.<span class="property">NORTH</span></span><br></pre></td></tr></table></figure><p>当然我们也可以设置 NORTH 的初始值，比如：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  <span class="attr">NORTH</span> = <span class="number">3</span>,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-字符串枚举"><a href="#2-5-2-字符串枚举" class="headerlink" title="2.5.2.字符串枚举"></a>2.5.<strong>2.字符串枚举</strong></h4><p>在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  <span class="attr">NORTH</span> = <span class="string">&quot;NORTH&quot;</span>,</span><br><span class="line">  <span class="attr">SOUTH</span> = <span class="string">&quot;SOUTH&quot;</span>,</span><br><span class="line">  <span class="attr">EAST</span> = <span class="string">&quot;EAST&quot;</span>,</span><br><span class="line">  <span class="attr">WEST</span> = <span class="string">&quot;WEST&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码对于的 ES5 代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;NORTH&#x27;</span>] = <span class="string">&#x27;NORTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;SOUTH&#x27;</span>] = <span class="string">&#x27;SOUTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;EAST&#x27;</span>] = <span class="string">&#x27;EAST&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;WEST&#x27;</span>] = <span class="string">&#x27;WEST&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2-5-3-异构枚举"><a href="#2-5-3-异构枚举" class="headerlink" title="2.5.3.异构枚举"></a>2.5.<strong>3.异构枚举</strong></h4><p>异构枚举的成员值是数字和字符串的混合：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Enum &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">  <span class="attr">C</span> = <span class="string">&quot;C&quot;</span>,</span><br><span class="line">  <span class="attr">D</span> = <span class="string">&quot;D&quot;</span>,</span><br><span class="line">  <span class="attr">E</span> = <span class="number">8</span>,</span><br><span class="line">  F,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码对于的 ES5 代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Enum</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">Enum</span>) &#123;</span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;A&#x27;</span>] = <span class="number">0</span>)] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;B&#x27;</span>] = <span class="number">1</span>)] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[<span class="string">&#x27;C&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[<span class="string">&#x27;D&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;E&#x27;</span>] = <span class="number">8</span>)] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;F&#x27;</span>] = <span class="number">9</span>)] = <span class="string">&#x27;F&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Enum</span> || (<span class="title class_">Enum</span> = &#123;&#125;))</span><br></pre></td></tr></table></figure><p>通过观察上述生成的 ES5 代码，我们可以发现数字枚举相对字符串枚举多了 “反向映射”：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(Enum.A) <span class="comment">//输出：0</span></span><br><span class="line">console.<span class="built_in">log</span>(Enum[<span class="number">0</span>]) <span class="comment">// 输出：A</span></span><br></pre></td></tr></table></figure><h3 id="2-6-Any-类型"><a href="#2-6-Any-类型" class="headerlink" title="2.6 Any 类型"></a>2.6 Any 类型</h3><p>在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的<strong>顶级类型</strong>（也被称作全局超级类型）。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let notSure: <span class="attr">any</span> = <span class="number">666</span><span class="comment">;</span></span><br><span class="line"><span class="attr">notSure</span> = <span class="string">&quot;Semlinker&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">notSure</span> = <span class="literal">false</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p><code>any</code> 类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由：TypeScript 允许我们对 <code>any</code> 类型的值执行任何操作，而无需事先执行任何形式的检查。比如：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">let value: any;</span><br><span class="line"></span><br><span class="line">value<span class="selector-class">.foo</span><span class="selector-class">.bar</span>; <span class="comment">// OK</span></span><br><span class="line">value<span class="selector-class">.trim</span>(); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">value</span>(); <span class="comment">// OK</span></span><br><span class="line">new <span class="built_in">value</span>(); <span class="comment">// OK</span></span><br><span class="line">value<span class="selector-attr">[0]</span><span class="selector-attr">[1]</span>; <span class="comment">// OK</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在许多场景下，这太宽松了。使用 <code>any</code> 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 <code>any</code> 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 <code>any</code> 带来的问题，TypeScript 3.0 引入了 <code>unknown</code> 类型。</p><h3 id="2-7-Unknown-类型"><a href="#2-7-Unknown-类型" class="headerlink" title="2.7 Unknown 类型"></a>2.7 Unknown 类型</h3><p>就像所有类型都可以赋值给 <code>any</code>，所有类型也都可以赋值给 <code>unknown</code>。这使得 <code>unknown</code> 成为 TypeScript 类型系统的另一种顶级类型（另一种是 <code>any</code>）。下面我们来看一下 <code>unknown</code> 类型的使用示例：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let value: unknown<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">value</span> = <span class="literal">true</span><span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = <span class="number">42</span><span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = <span class="string">&quot;Hello World&quot;</span><span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = []<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = &#123;&#125;<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = Math.random<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = null<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = undefined<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = new TypeError()<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = Symbol(<span class="string">&quot;type&quot;</span>)<span class="comment">; // OK</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对 <code>value</code> 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 <code>unknown</code> 的值赋值给其他类型的变量时会发生什么？</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let value: unknown<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let value1: <span class="attr">unknown</span> = value<span class="comment">; // OK</span></span><br><span class="line">let value2: <span class="attr">any</span> = value<span class="comment">; // OK</span></span><br><span class="line">let value3: <span class="attr">boolean</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value4: <span class="attr">number</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value5: <span class="attr">string</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value6: <span class="attr">object</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value7: any<span class="section">[]</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value8: <span class="attr">Function</span> = value<span class="comment">; // Error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>unknown</code> 类型只能被赋值给 <code>any</code> 类型和 <code>unknown</code> 类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 <code>unknown</code> 类型的值。毕竟我们不知道变量 <code>value</code> 中存储了什么类型的值。</p><p>现在让我们看看当我们尝试对类型为 <code>unknown</code> 的值执行操作时会发生什么。以下是我们在之前 <code>any</code> 章节看过的相同操作：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">let value: unknown;</span><br><span class="line"></span><br><span class="line">value<span class="selector-class">.foo</span><span class="selector-class">.bar</span>; <span class="comment">// Error</span></span><br><span class="line">value<span class="selector-class">.trim</span>(); <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">value</span>(); <span class="comment">// Error</span></span><br><span class="line">new <span class="built_in">value</span>(); <span class="comment">// Error</span></span><br><span class="line">value<span class="selector-attr">[0]</span><span class="selector-attr">[1]</span>; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>将 <code>value</code> 变量类型设置为 <code>unknown</code> 后，这些操作都不再被认为是类型正确的。通过将 <code>any</code> 类型改变为 <code>unknown</code> 类型，我们已将允许所有更改的默认设置，更改为<strong>禁止任何更改</strong>。</p><h3 id="2-8-Tuple-类型"><a href="#2-8-Tuple-类型" class="headerlink" title="2.8 Tuple 类型"></a>2.8 Tuple 类型</h3><p>众所周知，数组一般由同种类型的值组成，<strong>但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组</strong>。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。</p><p>元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值。为了更直观地理解元组的概念，我们来看一个具体的例子：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let tupleType: <span class="section">[string, boolean]</span><span class="comment">;</span></span><br><span class="line"><span class="attr">tupleType</span> = [<span class="string">&quot;Semlinker&quot;</span>, <span class="literal">true</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>在上面代码中，我们定义了一个名为 <code>tupleType</code> 的变量，它的类型是一个类型数组 <code>[string, boolean]</code>，然后我们按照正确的类型依次初始化 tupleType 变量。与数组一样，我们可以通过下标来访问元组中的元素：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(tupleType[<span class="number">0</span>]); <span class="comment">// Semlinker</span></span><br><span class="line">console.<span class="built_in">log</span>(tupleType[<span class="number">1</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在元组初始化的时候，如果出现类型不匹配的话，比如：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">tupleType</span> = [<span class="literal">true</span>, <span class="string">&quot;Semlinker&quot;</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>此时，TypeScript 编译器会提示以下错误信息：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>]: <span class="type">Type</span> <span class="string">&#x27;true&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> assignable to <span class="built_in">type</span> <span class="string">&#x27;string&#x27;</span>.</span><br><span class="line">[<span class="number">1</span>]: <span class="type">Type</span> <span class="string">&#x27;string&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> assignable to <span class="built_in">type</span> <span class="string">&#x27;boolean&#x27;</span>.</span><br></pre></td></tr></table></figure><p>很明显是因为类型不匹配导致的。在元组初始化的时候，我们还必须提供<strong>每个属性的值</strong>，不然也会出现错误，比如：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">tupleType</span> = [<span class="string">&quot;Semlinker&quot;</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>此时，TypeScript 编译器会提示以下错误信息：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Property <span class="string">&#x27;1&#x27;</span> <span class="keyword">is</span> missing <span class="keyword">in</span> <span class="built_in">type</span> <span class="string">&#x27;[string]&#x27;</span> but required <span class="keyword">in</span> <span class="built_in">type</span> <span class="string">&#x27;[string, boolean]&#x27;</span>.</span><br></pre></td></tr></table></figure><h3 id="2-9-Void-类型"><a href="#2-9-Void-类型" class="headerlink" title="2.9 Void 类型"></a>2.9 Void 类型</h3><p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数返回值为void</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is my warning message&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码编译生成的 ES5 代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is my warning message&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，声明一个 void 类型的变量没有什么作用，因为它的值只能为 <code>undefined</code> 或 <code>null</code>：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let unusable: <span class="attr">void</span> = undefined<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="2-10-Null-和-Undefined-类型"><a href="#2-10-Null-和-Undefined-类型" class="headerlink" title="2.10 Null 和 Undefined 类型"></a>2.10 Null 和 Undefined 类型</h3><p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者有各自的类型分别为 <code>undefined</code> 和 <code>null</code>。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let u: <span class="attr">undefined</span> = undefined<span class="comment">;</span></span><br><span class="line">let n: <span class="attr">null</span> = null<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。<strong>然而，如果你指定了<code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自的类型。</strong></p><h3 id="2-11-Never-类型"><a href="#2-11-Never-类型" class="headerlink" title="2.11 Never 类型"></a>2.11 Never 类型</h3><p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如，<code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">controlFlowAnalysisWithNever</span>(<span class="params">foo: Foo</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里 foo 被收窄为 string 类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里 foo 被收窄为 number 类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// foo 在这里是 never</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">check</span>: <span class="built_in">never</span> = foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然而他忘记同时修改 <code>controlFlowAnalysisWithNever</code> 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 <code>boolean</code> 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保</p><p><code>controlFlowAnalysisWithNever</code> 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：<strong>使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。</strong></p><h2 id="3-TypeScript-断言"><a href="#3-TypeScript-断言" class="headerlink" title="3. TypeScript 断言"></a>3. TypeScript 断言</h2><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p><p>类型断言有两种形式：</p><h3 id="3-1-“尖括号”-语法"><a href="#3-1-“尖括号”-语法" class="headerlink" title="3.1. “尖括号” 语法"></a>3.1. “尖括号” 语法</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let someValue: <span class="attr">any</span> = <span class="string">&quot;this is a string&quot;</span><span class="comment">;</span></span><br><span class="line">let strLength: <span class="attr">number</span> = (&lt;string&gt;someValue).length<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-as-语法"><a href="#3-2-as-语法" class="headerlink" title="3.2. as 语法"></a>3.2. as 语法</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let someValue: <span class="attr">any</span> = <span class="string">&quot;this is a string&quot;</span><span class="comment">;</span></span><br><span class="line">let strLength: <span class="attr">number</span> = (someValue as string).length<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="4-类型守卫"><a href="#4-类型守卫" class="headerlink" title="4. 类型守卫"></a>4. 类型守卫</h2><blockquote><p>A type guard is some expression that performs a runtime check that guarantees the type in some scope. —— TypeScript 官方文档</p></blockquote><p>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。目前主要有四种的方式来实现类型保护：</p><h3 id="4-1-in-关键字"><a href="#4-1-in-关键字" class="headerlink" title="4.1 in 关键字"></a>4.1 in 关键字</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Admin</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">privileges</span>: <span class="built_in">string</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">startDate</span>: <span class="title class_">Date</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnknownEmployee</span> = <span class="title class_">Employee</span> | <span class="title class_">Admin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printEmployeeInformation</span>(<span class="params">emp: UnknownEmployee</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Name: &#x27;</span> + emp.<span class="property">name</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;privileges&#x27;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Privileges: &#x27;</span> + emp.<span class="property">privileges</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;startDate&#x27;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Start Date: &#x27;</span> + emp.<span class="property">startDate</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-typeof-关键字"><a href="#4-2-typeof-关键字" class="headerlink" title="4.2 typeof 关键字"></a>4.2 typeof 关键字</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>(padding + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>) + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typeof</code> 类型保护只支持两种形式：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== typename</code>，<code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>， <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</p><h3 id="4-3-instanceof-关键字"><a href="#4-3-instanceof-关键字" class="headerlink" title="4.3 instanceof 关键字"></a>4.3 instanceof 关键字</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Padder</span> &#123;</span><br><span class="line">  <span class="title function_">getPaddingString</span>(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceRepeatingPadder</span> <span class="keyword">implements</span> <span class="title class_">Padder</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">getPaddingString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>(<span class="variable language_">this</span>.<span class="property">numSpaces</span> + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringPadder</span> <span class="keyword">implements</span> <span class="title class_">Padder</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">getPaddingString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">padder</span>: <span class="title class_">Padder</span> = <span class="keyword">new</span> <span class="title class_">SpaceRepeatingPadder</span>(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> <span class="title class_">SpaceRepeatingPadder</span>) &#123;</span><br><span class="line">  <span class="comment">// padder的类型收窄为 &#x27;SpaceRepeatingPadder&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-自定义类型保护的类型谓词"><a href="#4-4-自定义类型保护的类型谓词" class="headerlink" title="4.4 自定义类型保护的类型谓词"></a>4.4 自定义类型保护的类型谓词</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): x is <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">x: <span class="built_in">any</span></span>): x is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-联合类型和类型别名"><a href="#5-联合类型和类型别名" class="headerlink" title="5. 联合类型和类型别名"></a>5. 联合类型和类型别名</h2><h3 id="5-1-联合类型"><a href="#5-1-联合类型" class="headerlink" title="5.1 联合类型"></a>5.1 联合类型</h3><p>联合类型通常与 <code>null</code> 或 <code>undefined</code> 一起使用：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sayHello</span> = (<span class="params">name: <span class="built_in">string</span> | <span class="literal">undefined</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，这里 <code>name</code> 的类型是 <code>string | undefined</code> 意味着可以将 <code>string</code> 或 <code>undefined</code> 的值传递给<code>sayHello</code> 函数。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sayHello</span>(&quot;Semlinker&quot;);</span><br><span class="line"><span class="built_in">sayHello</span>(undefined);</span><br></pre></td></tr></table></figure><p>通过这个示例，你可以凭直觉知道类型 A 和类型 B 联合后的类型是同时接受 A 和 B 值的类型。</p><h3 id="5-2-可辨识联合"><a href="#5-2-可辨识联合" class="headerlink" title="5.2 可辨识联合"></a>5.2 可辨识联合</h3><p>TypeScript 可辨识联合（Discriminated Unions）类型，也称为代数数据类型或标签联合类型。<strong>它包含 3 个要点：可辨识、联合类型和类型守卫。</strong></p><p>这种类型的本质是结合联合类型和字面量类型的一种类型保护方法。<strong>如果一个类型是多个类型的联合类型，且多个类型含有一个公共属性，那么就可以利用这个公共属性，来创建不同的类型保护区块。</strong></p><p><strong>1.可辨识</strong></p><p>可辨识要求联合类型中的每个元素都含有一个单例类型属性，比如：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">enum CarTransmission &#123;</span><br><span class="line">  Automatic = <span class="number">200</span>,</span><br><span class="line">  Manual = <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Motorcycle &#123;</span><br><span class="line">  vType: <span class="string">&quot;motorcycle&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  make: number; <span class="comment">// year</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Car &#123;</span><br><span class="line">  vType: <span class="string">&quot;car&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  transmission: CarTransmission</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Truck &#123;</span><br><span class="line">  vType: <span class="string">&quot;truck&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  capacity: number; <span class="comment">// in tons</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们分别定义了 <code>Motorcycle</code>、 <code>Car</code> 和 <code>Truck</code> 三个接口，在这些接口中都包含一个 <code>vType</code> 属性，该属性被称为可辨识的属性，而其它的属性只跟特性的接口相关。</p><p><strong>2.联合类型</strong></p><p>基于前面定义了三个接口，我们可以创建一个 <code>Vehicle</code> 联合类型：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">type <span class="attr">Vehicle</span> = Motorcycle | Car | Truck<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>现在我们就可以开始使用 <code>Vehicle</code> 联合类型，对于 <code>Vehicle</code> 类型的变量，它可以表示不同类型的车辆。</p><p><strong>3.类型守卫</strong></p><p>下面我们来定义一个 <code>evaluatePrice</code> 方法，该方法用于根据车辆的类型、容量和评估因子来计算价格，具体实现如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">const <span class="attr">EVALUATION_FACTOR</span> = Math.PI<span class="comment">;</span></span><br><span class="line">function evaluatePrice(vehicle: Vehicle) &#123;</span><br><span class="line">  return vehicle.capacity * EVALUATION_FACTOR<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myTruck: <span class="attr">Truck</span> = &#123; vType: <span class="string">&quot;truck&quot;</span>, capacity: <span class="number">9.5</span> &#125;<span class="comment">;</span></span><br><span class="line">evaluatePrice(myTruck)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>对于以上代码，TypeScript 编译器将会提示以下错误信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Property <span class="string">&#x27;capacity&#x27;</span> does not exist on <span class="built_in">type</span> <span class="string">&#x27;Vehicle&#x27;</span>.</span><br><span class="line">Property <span class="string">&#x27;capacity&#x27;</span> does not exist on <span class="built_in">type</span> <span class="string">&#x27;Motorcycle&#x27;</span>.</span><br></pre></td></tr></table></figure><p>原因是在 Motorcycle 接口中，并不存在 <code>capacity</code> 属性，而对于 Car 接口来说，它也不存在 <code>capacity</code> 属性。那么，现在我们应该如何解决以上问题呢？这时，我们可以使用类型守卫。下面我们来重构一下前面定义的 <code>evaluatePrice</code> 方法，重构后的代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">evaluatePrice</span>(<span class="params">vehicle: Vehicle</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (vehicle.<span class="property">vType</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;car&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.<span class="property">transmission</span> * <span class="variable constant_">EVALUATION_FACTOR</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;truck&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.<span class="property">capacity</span> * <span class="variable constant_">EVALUATION_FACTOR</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;motorcycle&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.<span class="property">make</span> * <span class="variable constant_">EVALUATION_FACTOR</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们使用 <code>switch</code> 和 <code>case</code> 运算符来实现类型守卫，从而确保在 <code>evaluatePrice</code> 方法中，我们可以安全地访问 <code>vehicle</code> 对象中的所包含的属性，来正确的计算该车辆类型所对应的价格。</p><h3 id="5-3-类型别名"><a href="#5-3-类型别名" class="headerlink" title="5.3 类型别名"></a>5.3 类型别名</h3><p>类型别名用来给一个类型起个新名字。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">type <span class="attr">Message</span> = string | string[]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">greet</span> = (message: Message) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="6-交叉类型"><a href="#6-交叉类型" class="headerlink" title="6. 交叉类型"></a>6. 交叉类型</h2><p>TypeScript 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它<strong>包含了所需的所有类型的特性</strong>。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IWorker</span> &#123;</span><br><span class="line">  <span class="attr">companyId</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IStaff</span> = <span class="title class_">IPerson</span> &amp; <span class="title class_">IWorker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">staff</span>: <span class="title class_">IStaff</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;E1006&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">33</span>,</span><br><span class="line">  <span class="attr">companyId</span>: <span class="string">&#x27;EFT&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(staff)</span><br></pre></td></tr></table></figure><p>在上面示例中，我们首先为 IPerson 和 IWorker 类型定义了不同的成员，然后通过 <code>&amp;</code> 运算符定义了 IStaff 交叉类型，所以该类型同时拥有 IPerson 和 IWorker 这两种类型的成员。</p><h2 id="7-TypeScript-函数"><a href="#7-TypeScript-函数" class="headerlink" title="7. TypeScript 函数"></a>7. TypeScript 函数</h2><h3 id="7-1-TypeScript-函数与-JavaScript-函数的区别"><a href="#7-1-TypeScript-函数与-JavaScript-函数的区别" class="headerlink" title="7.1 TypeScript 函数与 JavaScript 函数的区别"></a>7.1 TypeScript 函数与 JavaScript 函数的区别</h3><table><thead><tr><th>TypeScript</th><th>JavaScript</th></tr></thead><tbody><tr><td>含有类型</td><td>无类型</td></tr><tr><td>箭头函数</td><td>箭头函数（ES2015）</td></tr><tr><td>函数类型</td><td>无函数类型</td></tr><tr><td>必填和可选参数</td><td>所有参数都是可选的</td></tr><tr><td>默认参数</td><td>默认参数</td></tr><tr><td>剩余参数</td><td>剩余参数</td></tr><tr><td>函数重载</td><td>无函数重载</td></tr></tbody></table><h3 id="7-2-箭头函数"><a href="#7-2-箭头函数" class="headerlink" title="7.2 箭头函数"></a>7.2 箭头函数</h3><p><strong>1.常见语法</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reading&#x27;</span>));</span><br><span class="line"></span><br><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function"><span class="params">title</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(title));</span><br><span class="line"></span><br><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">title, idx, arr</span>) =&gt;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(idx + <span class="string">&#x27;-&#x27;</span> + title);</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">title, idx, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(idx + <span class="string">&#x27;-&#x27;</span> + title);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>2.使用示例</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未使用箭头函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span></span><br><span class="line">  self.<span class="property">publishDate</span> = <span class="number">2016</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(self.<span class="property">publishDate</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">publishDate</span> = <span class="number">2016</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">publishDate</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-参数类型和返回类型"><a href="#7-3-参数类型和返回类型" class="headerlink" title="7.3 参数类型和返回类型"></a>7.3 参数类型和返回类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-函数类型"><a href="#7-4-函数类型" class="headerlink" title="7.4 函数类型"></a>7.4 函数类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数类型，然后再赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">IdGenerator</span>: <span class="function">(<span class="params">chars: <span class="built_in">string</span>, nums: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">IdGenerator</span> = createUserId</span><br></pre></td></tr></table></figure><h3 id="7-5-可选参数及默认参数"><a href="#7-5-可选参数及默认参数" class="headerlink" title="7.5 可选参数及默认参数"></a>7.5 可选参数及默认参数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可选参数：加个问号即可</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span>, age?: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name: <span class="built_in">string</span> = <span class="string">&#x27;Semlinker&#x27;</span>,</span></span><br><span class="line"><span class="params">  id: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  age?: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在声明函数时，可以通过 <code>?</code> 号来定义可选参数，比如 <code>age?: number</code> 这种形式。在实际使用时，需要注意的是可选参数要放在普通参数的后面，不然会导致编译错误。</p><h3 id="7-6-剩余参数"><a href="#7-6-剩余参数" class="headerlink" title="7.6 剩余参数"></a>7.6 剩余参数</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加...表示剩余参数</span></span><br><span class="line">function <span class="built_in">push</span>(array, ...items) &#123;</span><br><span class="line">  items<span class="selector-class">.forEach</span>(function (item) &#123;</span><br><span class="line">    array<span class="selector-class">.push</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="selector-tag">a</span> = <span class="selector-attr">[]</span>;</span><br><span class="line"><span class="built_in">push</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="7-7-函数重载"><a href="#7-7-函数重载" class="headerlink" title="7.7 函数重载"></a>7.7 函数重载</h3><p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: Combinable, b: Combinable</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">toString</span>() + b.<span class="title function_">toString</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们为 add 函数提供了多个函数类型定义，从而实现函数的重载。之后，可恶的错误消息又消失了，因为这时 result 变量的类型是 <code>string</code> 类型。在 TypeScript 中除了可以重载普通函数之外，我们还可以重载类中的成员方法。</p><p>方法重载是指在同一个类中方法同名，参数不同（参数类型不同、参数个数不同或参数个数相同时参数的先后顺序不同），调用时根据实参的形式，选择与它匹配的方法执行操作的一种技术。所以类中成员方法满足重载的条件是：在同一个类中，方法名相同且参数列表不同。下面我们来举一个成员方法重载的例子：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: number, <span class="attr">b</span>: number): number;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: <span class="keyword">string</span>, <span class="attr">b</span>: <span class="keyword">string</span>): <span class="keyword">string</span>;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: <span class="keyword">string</span>, <span class="attr">b</span>: number): <span class="keyword">string</span>;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: number, <span class="attr">b</span>: <span class="keyword">string</span>): <span class="keyword">string</span>;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: Combinable, <span class="attr">b</span>: Combinable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof a === <span class="string">&quot;string&quot;</span> || typeof b === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.<span class="title function_ invoke__">toString</span>() + b.<span class="title function_ invoke__">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">calculator</span> = <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">result</span> = calculator.<span class="title function_ invoke__">add</span>(<span class="string">&quot;Semlinker&quot;</span>, <span class="string">&quot; Kakuqo&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里需要注意的是，当 TypeScript 编译器处理函数重载时，它会查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。另外在 Calculator 类中，<code>add(a: Combinable, b: Combinable)&#123; &#125;</code> 并不是重载列表的一部分，因此对于 add 成员方法来说，我们只定义了四个重载方法。</p><h2 id="8-TypeScript-数组"><a href="#8-TypeScript-数组" class="headerlink" title="8. TypeScript 数组"></a>8. TypeScript 数组</h2><h3 id="8-1-数组解构"><a href="#8-1-数组解构" class="headerlink" title="8.1 数组解构"></a>8.1 数组解构</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> five_array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">;[x, y, z] = five_array</span><br></pre></td></tr></table></figure><h3 id="8-2-数组展开运算符"><a href="#8-2-数组展开运算符" class="headerlink" title="8.2 数组展开运算符"></a>8.2 数组展开运算符</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let <span class="attr">two_array</span> = [<span class="number">0</span>, <span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">let <span class="attr">five_array</span> = [...two_array, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="8-3-数组遍历"><a href="#8-3-数组遍历" class="headerlink" title="8.3 数组遍历"></a>8.3 数组遍历</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">colors</span>: <span class="built_in">string</span>[] = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> colors) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-TypeScript-对象"><a href="#9-TypeScript-对象" class="headerlink" title="9. TypeScript 对象"></a>9. TypeScript 对象</h2><h3 id="9-1-对象解构"><a href="#9-1-对象解构" class="headerlink" title="9.1 对象解构"></a>9.1 对象解构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Semlinker&quot;</span>,</span><br><span class="line">  gender: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; name, gender &#125; = person;</span><br></pre></td></tr></table></figure><h3 id="9-2-对象展开运算符"><a href="#9-2-对象展开运算符" class="headerlink" title="9.2 对象展开运算符"></a>9.2 对象展开运算符</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Semlinker&quot;</span>,</span><br><span class="line">  gender: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line">  address: <span class="string">&quot;Xiamen&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装对象</span></span><br><span class="line"><span class="keyword">let</span> personWithAge = &#123; ...person, age: <span class="number">33</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取除了某些项外的其它项</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, ...rest &#125; = person;</span><br></pre></td></tr></table></figure><h2 id="10-TypeScript-接口"><a href="#10-TypeScript-接口" class="headerlink" title="10. TypeScript 接口"></a>10. TypeScript 接口</h2><p>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。</p><p>TypeScript 中的接口是一个非常灵活的概念，除了可用于<a href="https://link.juejin.cn/?target=https://ts.xcatliu.com/advanced/class-and-interfaces.html%23%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状（Shape）」进行描述。</p><h3 id="10-1-对象的形状"><a href="#10-1-对象的形状" class="headerlink" title="10.1 对象的形状"></a>10.1 对象的形状</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let Semlinker: Person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Semlinker&quot;</span>,</span><br><span class="line">  age: <span class="number">33</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="10-2-可选-只读属性"><a href="#10-2-可选-只读属性" class="headerlink" title="10.2 可选 | 只读属性"></a>10.2 可选 | 只读属性</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只读属性用于限制只能在<strong>对象刚刚创建的时候修改其值</strong>。此外 TypeScript 还提供了 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let a: number<span class="section">[]</span> = <span class="section">[1, 2, 3, 4]</span><span class="comment">;</span></span><br><span class="line">let ro: ReadonlyArray&lt;number&gt; = a<span class="comment">;</span></span><br><span class="line">ro<span class="section">[0]</span> = 12<span class="comment">; // error!</span></span><br><span class="line">ro.push(5)<span class="comment">; // error!</span></span><br><span class="line"><span class="attr">ro.length</span> = <span class="number">100</span><span class="comment">; // error!</span></span><br><span class="line"><span class="attr">a</span> = ro<span class="comment">; // error!</span></span><br></pre></td></tr></table></figure><h2 id="11-TypeScript-类"><a href="#11-TypeScript-类" class="headerlink" title="11. TypeScript 类"></a>11. TypeScript 类</h2><h3 id="11-1-类的属性与方法"><a href="#11-1-类的属性与方法" class="headerlink" title="11.1 类的属性与方法"></a>11.1 类的属性与方法</h3><p>在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。</p><p>在 TypeScript 中，我们可以通过 <code>Class</code> 关键字来定义一个类：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="keyword">static</span> <span class="attr">cname</span>: <span class="built_in">string</span> = <span class="string">&#x27;Greeter&#x27;</span></span><br><span class="line">  <span class="comment">// 成员属性</span></span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数 - 执行初始化操作</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getClassName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Class name is Greeter&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成员方法</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那么成员属性与静态属性，成员方法与静态方法有什么区别呢？这里无需过多解释，我们直接看一下以下编译生成的 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Greeter</span> = <span class="comment">/** <span class="doctag">@class</span> */</span> (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 构造函数 - 执行初始化操作</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Greeter</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="title class_">Greeter</span>.<span class="property">getClassName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Class name is Greeter&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 成员方法</span></span><br><span class="line">  <span class="title class_">Greeter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="title class_">Greeter</span>.<span class="property">cname</span> = <span class="string">&#x27;Greeter&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Greeter</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">var</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="11-2-访问器"><a href="#11-2-访问器" class="headerlink" title="11.2 访问器"></a>11.2 访问器</h3><p>在 TypeScript 中，我们可以通过 <code>getter</code> 和 <code>setter</code> 方法来实现数据的封装和有效性校验，防止出现异常数据。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">&#x27;Hello TypeScript&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_fullName</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_fullName</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">newName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">&#x27;Hello TypeScript&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_fullName</span> = newName</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error: Unauthorized update of employee!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>()</span><br><span class="line">employee.<span class="property">fullName</span> = <span class="string">&#x27;Semlinker&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (employee.<span class="property">fullName</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(employee.<span class="property">fullName</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-类的继承"><a href="#11-3-类的继承" class="headerlink" title="11.3 类的继承"></a>11.3 类的继承</h3><p>继承 (Inheritance) 是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。</p><p>继承是一种 <a href="https://link.juejin.cn/?target=https://zh.wikipedia.org/wiki/Is-a">is-a </a>关系：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172916651d29ba48~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>在 TypeScript 中，我们可以通过 <code>extends</code> 关键字来实现继承：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = theName</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snake</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distanceInMeters = <span class="number">5</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Slithering...&#x27;</span>)</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">move</span>(distanceInMeters)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> <span class="title class_">Snake</span>(<span class="string">&#x27;Sammy the Python&#x27;</span>)</span><br><span class="line">sam.<span class="title function_">move</span>()</span><br></pre></td></tr></table></figure><h3 id="11-4-ECMAScript-私有字段"><a href="#11-4-ECMAScript-私有字段" class="headerlink" title="11.4 ECMAScript 私有字段"></a>11.4 ECMAScript 私有字段</h3><p>在 TypeScript 3.8 版本就开始支持<strong>ECMAScript 私有字段</strong>，使用方式如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  #<span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.#name&#125;</span>!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> semlinker = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Semlinker&#x27;</span>)</span><br><span class="line"></span><br><span class="line">semlinker.#name</span><br><span class="line"><span class="comment">//     ~~~~~</span></span><br><span class="line"><span class="comment">// Property &#x27;#name&#x27; is not accessible outside class &#x27;Person&#x27;</span></span><br><span class="line"><span class="comment">// because it has a private identifier.</span></span><br></pre></td></tr></table></figure><p>与常规属性（甚至使用 <code>private</code> 修饰符声明的属性）不同，私有字段要牢记以下规则：</p><ul><li>私有字段以 <code>#</code> 字符开头，有时我们称之为私有名称；</li><li>每个私有字段名称都唯一地限定于其包含的类；</li><li>不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；</li><li>私有字段不能在包含的类之外访问，甚至不能被检测到。</li></ul><h2 id="12-TypeScript-泛型"><a href="#12-TypeScript-泛型" class="headerlink" title="12. TypeScript 泛型"></a>12. TypeScript 泛型</h2><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p><p><strong>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</strong></p><p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p><p>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p><h3 id="12-1-泛型接口"><a href="#12-1-泛型接口" class="headerlink" title="12.1 泛型接口"></a>12.1 泛型接口</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">interface GenericIdentityFn<span class="operator">&lt;</span><span class="built_in">T</span><span class="operator">&gt;</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">(</span>arg<span class="operator">:</span> <span class="built_in">T</span><span class="punctuation">)</span><span class="operator">:</span> <span class="built_in">T</span>;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="12-2-泛型类"><a href="#12-2-泛型类" class="headerlink" title="12.2 泛型类"></a>12.2 泛型类</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">  zeroValue: T<span class="comment">;</span></span><br><span class="line">  add: (x: T, y: T) =&gt; T<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="attr">myGenericNumber</span> = new GenericNumber&lt;number&gt;()<span class="comment">;</span></span><br><span class="line"><span class="attr">myGenericNumber.zeroValue</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="attr">myGenericNumber.add</span> = function (x, y) &#123;</span><br><span class="line">  return x + y<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="12-3-泛型变量"><a href="#12-3-泛型变量" class="headerlink" title="12.3 泛型变量"></a>12.3 泛型变量</h3><p>对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：</p><ul><li>T（Type）：表示一个 TypeScript 类型</li><li>K（Key）：表示对象中的键类型</li><li>V（Value）：表示对象中的值类型</li><li>E（Element）：表示元素类型</li></ul><h3 id="12-4-泛型工具类型"><a href="#12-4-泛型工具类型" class="headerlink" title="12.4 泛型工具类型"></a>12.4 泛型工具类型</h3><p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍 Partial 工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。</p><h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a><strong>1.typeof</strong></h4><p>在 TypeScript 中，<code>typeof</code> 操作符可以用来获取一个变量声明或对象的类型。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">sem</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;semlinker&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sem</span> = <span class="keyword">typeof</span> sem <span class="comment">// -&gt; Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toArray</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [x]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Func</span> = <span class="keyword">typeof</span> toArray <span class="comment">// -&gt; (x: number) =&gt; number[]</span></span><br></pre></td></tr></table></figure><h4 id="2-keyof"><a href="#2-keyof" class="headerlink" title="2.keyof"></a><strong>2.keyof</strong></h4><p><code>keyof</code> 操作符可以用来一个对象中的所有 key 值：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> K1 = keyof Person; // <span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="built_in">type</span> K2 = keyof Person[]; // <span class="string">&quot;length&quot;</span> | <span class="string">&quot;toString&quot;</span> | <span class="string">&quot;pop&quot;</span> | <span class="string">&quot;push&quot;</span> | <span class="string">&quot;concat&quot;</span> | <span class="string">&quot;join&quot;</span></span><br><span class="line"><span class="built_in">type</span> K3 = keyof &#123; [x: <span class="built_in">string</span>]: Person &#125;;  // <span class="built_in">string</span> | number</span><br></pre></td></tr></table></figure><h4 id="3-in"><a href="#3-in" class="headerlink" title="3.in"></a><strong>3.in</strong></h4><p><code>in</code> 用来遍历枚举类型：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Keys = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Obj =  &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: <span class="built_in">any</span></span><br><span class="line">&#125; // -&gt; &#123; a: <span class="built_in">any</span>, b: <span class="built_in">any</span>, c: <span class="built_in">any</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="4-infer"><a href="#4-infer" class="headerlink" title="4.infer"></a><strong>4.infer</strong></h4><p>在条件类型语句中，可以用 <code>infer</code> 声明一个类型变量并且对它进行使用。</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">type ReturnType<span class="operator">&lt;</span><span class="built_in">T</span><span class="operator">&gt;</span> <span class="operator">=</span> <span class="built_in">T</span> extends <span class="punctuation">(</span></span><br><span class="line">  ...args<span class="operator">:</span> <span class="built_in">any</span><span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">)</span> <span class="operator">=</span><span class="operator">&gt;</span> infer R <span class="operator">?</span> R <span class="operator">:</span> <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><p>以上代码中 <code>infer R</code> 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p><p><strong>5.extends</strong></p><p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">interface ILengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ILengthwise</span>&gt;<span class="params">(arg: T)</span></span>: T &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">arg</span>.length);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arg</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">loggingIdentity</span>(<span class="number">3</span>);  <span class="comment">// Error, number doesn&#x27;t have a .length property</span></span><br></pre></td></tr></table></figure><p>这时我们需要传入符合约束类型的值，必须包含必须的属性：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">loggingIdentity</span>(&#123;<span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>6.Partial</strong></p><p><code>Partial&lt;T&gt;</code> 的作用就是将某个类型里的属性全部变为可选项 <code>?</code>。</p><p><strong>定义：</strong></p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"> <span class="operator">*</span> node_modules<span class="operator">/</span>typescript<span class="operator">/</span>lib<span class="operator">/</span>lib.es5.d.ts</span><br><span class="line"> <span class="operator">*</span> Make <span class="built_in">all</span> properties <span class="keyword">in</span> <span class="built_in">T</span> optional</span><br><span class="line"> <span class="operator">*</span><span class="operator">/</span></span><br><span class="line">type Partial<span class="operator">&lt;</span><span class="built_in">T</span><span class="operator">&gt;</span> <span class="operator">=</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">[</span>P <span class="keyword">in</span> keyof <span class="built_in">T</span><span class="punctuation">]</span><span class="operator">?</span><span class="operator">:</span> <span class="built_in">T</span><span class="punctuation">[</span>P<span class="punctuation">]</span>;</span><br><span class="line"><span class="punctuation">&#125;</span>;</span><br></pre></td></tr></table></figure><p>在以上代码中，首先通过 <code>keyof T</code> 拿到 <code>T</code> 的所有属性名，然后使用 <code>in</code> 进行遍历，将值赋给 <code>P</code>，最后通过 <code>T[P]</code> 取得相应的属性值。中间的 <code>?</code> 号，用于将所有属性变为可选。</p><p><strong>示例：</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line">  title: <span class="keyword">string</span>;</span><br><span class="line">  description: <span class="keyword">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTodo</span>(<span class="params">todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">todo1</span> = &#123;</span><br><span class="line">  title: <span class="string">&quot;organize desk&quot;</span>,</span><br><span class="line">  description: <span class="string">&quot;clear clutter&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">todo2</span> = <span class="title function_ invoke__">updateTodo</span>(todo1, &#123;</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&quot;throw out trash&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的 <code>updateTodo</code> 方法中，我们利用 <code>Partial&lt;T&gt;</code> 工具类型，定义 <code>fieldsToUpdate</code> 的类型为 <code>Partial&lt;Todo&gt;</code>，即：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   title?: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">   description?: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> front-end </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM 复习及前端架构</title>
      <link href="/article/DOM-review-frontend-%20architecture/"/>
      <url>/article/DOM-review-frontend-%20architecture/</url>
      
        <content type="html"><![CDATA[<h2 id="1-DOM基础"><a href="#1-DOM基础" class="headerlink" title="1. DOM基础"></a>1. DOM基础</h2><ul><li>DOM是Document Object Model的简写，文档对象模型</li><li>DOM是HTML的编程接口</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714162844731.png" alt="image-20220714162844731"></p><p>HTML文件和DOM树是一一对应的关系</p><h3 id="1-1-DOM基本操作"><a href="#1-1-DOM基本操作" class="headerlink" title="1.1. DOM基本操作"></a>1.1. DOM基本操作</h3><h4 id="1-1-1-查"><a href="#1-1-1-查" class="headerlink" title="1.1.1. 查"></a>1.1.1. 查</h4><ol><li><p>通过id查找</p><p><code>document.getElementById(&#39;&#39;)</code></p></li><li><p>通过标签名查找</p><p><code>document.getElementsByTagName(&#39;&#39;)</code></p><p>返回的是NodeList（类数组的对象）</p></li><li><p>通过class查找</p><p><code>document.getElementsByClass(&#39;&#39;)</code></p></li><li><p>根据传入的css选择器，查找匹配的DOM结点</p><ol><li><code>document.querySelector(&quot;p&quot;)</code> 只返回第一个匹配到的DOM结点</li><li><code>document.querySelectorAll(&quot;.detail&quot;)</code> 返回类为detail的所有DOM结点的集合<ol><li>eg: <code>document.querySelectorAll(&quot;ul &gt; li&quot;)</code>; 匹配嵌套在ul中的所有li元素</li><li><code>document.querySelectorAll(&quot;img+h3&quot;)</code>；匹配所有紧邻在img后的h3元素</li><li><code>document.querySelectorAll(&#39;[data-index]&#39;)</code>; 匹配所有有data-index属性的元素</li></ol></li></ol></li><li><p>根据已获取的结点，拿到该节点的子节点或父节点</p><ol><li><code>document.getElementById(&#39;&#39;).parentNode / nextElementSibling / [0]</code></li></ol></li></ol><h4 id="1-1-2-改"><a href="#1-1-2-改" class="headerlink" title="1.1.2. 改"></a>1.1.2. 改</h4><ol><li><p>改innerHTML</p><p><code>dom.innerHTML = &quot;&lt;strong&gt;修改内容&lt;strong&gt;&quot;</code></p></li><li><p>改textContent</p><p><code>dom.textContent = &quot;修改text内容&quot;</code></p></li><li><p>修改style值</p><p><code>dom.style = &quot;color: blue&quot;</code></p></li><li><p>修改指定属性值</p><p><code>dom.setAttribute(&quot;some-attribute&quot;, &quot;666&quot;)</code></p></li></ol><h4 id="1-1-3-增"><a href="#1-1-3-增" class="headerlink" title="1.1.3. 增"></a>1.1.3. 增</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCurrentTimeStr</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">const</span> hour = date.<span class="title function_">getHours</span>();</span><br><span class="line">    <span class="keyword">const</span> minutes = date.<span class="title function_">getMinutes</span>();</span><br><span class="line">    <span class="keyword">const</span> second = date.<span class="title function_">getSeconds</span>();</span><br><span class="line">    <span class="keyword">return</span> [hour, minutes, second].<span class="title function_">join</span>(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建元素</span></span><br><span class="line"><span class="keyword">let</span> newDom = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>)</span><br><span class="line">newDom.<span class="property">textContent</span> = <span class="string">&quot;页面加载时间为&quot;</span> + <span class="title function_">getCurrentTimeStr</span>();</span><br><span class="line"><span class="comment">// 将新创建的结点添加到body的子节点列表的末尾处</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(newDom) <span class="comment">// or ParentNode.appendChild(newDom)</span></span><br></pre></td></tr></table></figure><h4 id="1-1-4-删"><a href="#1-1-4-删" class="headerlink" title="1.1.4. 删"></a>1.1.4. 删</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> liToRemove = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">liToRemove.<span class="title function_">remove</span>();</span><br></pre></td></tr></table></figure><h2 id="2-DOM事件"><a href="#2-DOM事件" class="headerlink" title="2. DOM事件"></a>2. DOM事件</h2><h3 id="2-1-什么是DOM事件"><a href="#2-1-什么是DOM事件" class="headerlink" title="2.1. 什么是DOM事件"></a>2.1. 什么是DOM事件</h3><ul><li>Demo</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> liDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;something&quot;</span>)</span><br><span class="line"><span class="comment">// DOM 0级</span></span><br><span class="line">liDom.<span class="property">onclick</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exe!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>页面上的DOM之间是嵌套的结构，如果给内层DOM绑定了事件监听函数，则外层的DOM也会相应触发点击事件</li></ul><h3 id="2-2-DOM事件传播"><a href="#2-2-DOM事件传播" class="headerlink" title="2.2. DOM事件传播"></a>2.2. DOM事件传播</h3><ul><li>事件捕获阶段 –&gt; 目标事件阶段 –&gt; 事件冒泡阶段</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714170409071.png" alt="image-20220714170409071"></p><h3 id="2-2-addEventListener"><a href="#2-2-addEventListener" class="headerlink" title="2.2. addEventListener"></a>2.2. addEventListener</h3><p>DOM 2级</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> liDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;something&quot;</span>)</span><br><span class="line">liDom.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exe!(回调1)&#x27;</span>)</span><br><span class="line">&#125;); <span class="comment">// 其实还有第三个参数，once：是否只响应一次；capture：是否在捕获阶段触发（默认是false：即在冒泡阶段触发）</span></span><br><span class="line">liDom.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exe!(回调2)&#x27;</span>)</span><br><span class="line">&#125;, &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">liDom.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;exe!(回调3)&#x27;</span>)</span><br><span class="line">&#125;, &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><ul><li>和直接onClick相比，可以给一个DOM绑定多个事件</li></ul><h2 id="3-BOM"><a href="#3-BOM" class="headerlink" title="3. BOM"></a>3. BOM</h2><p>Browser Object Model，控制浏览器的行为的接口</p><h3 id="3-1-通过window访问"><a href="#3-1-通过window访问" class="headerlink" title="3.1. 通过window访问"></a>3.1. 通过window访问</h3><ul><li>通过window可以访问浏览器提供的BOM对象<ul><li>location</li><li>navigator</li><li>screen</li><li>alert、prompt、confirm</li><li>localStorage</li><li>…</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;welcome!&quot;</span>) <span class="comment">// 提示框</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="variable language_">window</span>,<span class="title function_">prompt</span>(<span class="string">&quot;请输入...&quot;</span>, <span class="string">&quot;张三&quot;</span>) <span class="comment">// 输入提示框，用户可以输入内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iinfo = <span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span> <span class="comment">// 获取浏览器和系统信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&quot;是否跳转？&quot;</span>) <span class="comment">// 弹出确认框 </span></span><br><span class="line"><span class="keyword">if</span>(res) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;http://www.baidu.com&quot;</span> <span class="comment">// 跳转到百度首页</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以省window</span></span><br><span class="line">location.<span class="property">href</span> <span class="comment">// 完整url</span></span><br><span class="line">location.<span class="property">protocol</span> <span class="comment">// 协议头</span></span><br><span class="line">location.<span class="property">host</span> <span class="comment">// 域名</span></span><br><span class="line">location.<span class="property">pathname</span> <span class="comment">// 路径</span></span><br><span class="line">location.<span class="property">search</span> <span class="comment">// 参数</span></span><br><span class="line">location.<span class="property">hash</span> <span class="comment">// 哈希值</span></span><br></pre></td></tr></table></figure><h2 id="4-AJAX"><a href="#4-AJAX" class="headerlink" title="4. AJAX"></a>4. AJAX</h2><p>AJAX是异步的Javascript和XML，可以请求服务端数据，并将数据更新到页面上，且是异步的</p><h3 id="4-1-XMLHttpRequest"><a href="#4-1-XMLHttpRequest" class="headerlink" title="4.1. XMLHttpRequest"></a>4.1. XMLHttpRequest</h3><p>使用XMLHttpRequest对象与服务器通信</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> httpRequest = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="keyword">if</span>(!httpRequest) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;浏览器不支持XMLHttpRequest，如IE！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    httpRequest.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 服务器响应时触发此回调函数</span></span><br><span class="line">        <span class="keyword">if</span> (httpRequest.<span class="property">readyState</span> === httpRequest.<span class="property">DONE</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (httpRequest.<span class="property">status</span> === <span class="number">200</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(httpRequest.<span class="property">responseText</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error!&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;readyState change: &quot;</span> + httpRequest.<span class="property">readyState</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    httpRequest.<span class="title function_">open</span>(</span><br><span class="line">        <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;url&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    httpRequest.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-Fetch"><a href="#4-2-Fetch" class="headerlink" title="4.2. Fetch"></a>4.2. Fetch</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;url&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">myJson</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myJson)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-架构模式"><a href="#5-架构模式" class="headerlink" title="5. 架构模式"></a>5. 架构模式</h2><p>从一个例子开始…</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714173054756.png" alt="image-20220714173054756"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;save&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;age&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> listHtml = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;tr&gt;</span></span><br><span class="line"><span class="string">    &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">    &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">    &lt;/tr&gt;`</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> tableElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="property">innerHTML</span> += listHtml</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;upload&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> listElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> lineElement = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;tr&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    lineElement.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tds = item.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;td&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> name = tds[<span class="number">0</span>].<span class="property">innerText</span>;</span><br><span class="line">        <span class="keyword">let</span> age = tds[<span class="number">1</span>].<span class="property">innerText</span>;</span><br><span class="line">        result.<span class="title function_">push</span>(&#123;name, age&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714173909347.png" alt="image-20220714173909347"></p><p>修改：维护一个全局result，然后每次增加时添加数据到result，最后导出的时候就不需要从dom中取，直接取result即可</p><h2 id="6-MVC"><a href="#6-MVC" class="headerlink" title="6. MVC"></a>6. MVC</h2><h3 id="6-1-架构"><a href="#6-1-架构" class="headerlink" title="6.1. 架构"></a>6.1. 架构</h3><ul><li>Model ：比如前文中提到的result全局数组</li><li>View</li><li>Controller</li></ul><h3 id="6-2-基于MVC的代码重构"><a href="#6-2-基于MVC的代码重构" class="headerlink" title="6.2. 基于MVC的代码重构"></a>6.2. 基于MVC的代码重构</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> model = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller = &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> name = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;age&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">        model.<span class="title function_">push</span>(&#123; name, age &#125;);</span><br><span class="line">        view.<span class="title function_">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">upload</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(model)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> view = &#123;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = model;</span><br><span class="line">        <span class="keyword">let</span> listHtml = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123;name, age&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            listHtml += <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;tr&gt;</span></span><br><span class="line"><span class="string">                &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">                &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;/tr&gt;</span></span><br><span class="line"><span class="string">            `</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> tableElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="property">innerHTML</span> = listHtml</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;save&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    controller.<span class="title function_">add</span>();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;upload&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    controller.<span class="title function_">upload</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714174712763.png" alt="image-20220714174712763"></p><ul><li><p>再优化：单一职责</p></li><li><p>如何监听model变化？</p><ul><li><p>观察者模式</p><ul><li><code>addEventListener</code>就是一个观察者模式</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">target.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line">target.<span class="title function_">dispatchEvent</span>(<span class="string">&#x27;click&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>现在我们自己引入一个类似的事件监听器</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line">event.<span class="title function_">on</span>(<span class="string">&#x27;addItem&#x27;</span>, showList); <span class="comment">// 注册一个addItem方法，并传showList方法</span></span><br><span class="line">event.<span class="title function_">emit</span>(<span class="string">&#x27;addItem&#x27;</span>)；</span><br></pre></td></tr></table></figure></li><li><p>用观察者模式改写model层</p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_events</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">on</span>(<span class="params">evt, listener</span>) &#123;</span><br><span class="line">        (<span class="variable language_">this</span>.<span class="property">_event</span>[evt] || (<span class="variable language_">this</span>.<span class="property">_events</span>[evt] = [])).<span class="title function_">push</span>(listen)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> event = <span class="title class_">EventEmmitter</span>();</span><br><span class="line">event.<span class="title function_">on</span>(<span class="string">&#x27;add&#x27;</span>, view.<span class="property">update</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> model = &#123;</span><br><span class="line">    _value = [],</span><br><span class="line"><span class="title function_">push</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span>.<span class="title function_">push</span>(value);</span><br><span class="line">        event.<span class="title function_">emit</span>(<span class="string">&#x27;add&#x27;</span>); <span class="comment">// 每次push之后触发add方法（即view.update方法）</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller = &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> name = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;name&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;age&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">        model.<span class="title function_">push</span>(&#123; name, age &#125;);</span><br><span class="line">        <span class="comment">// view.update();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">upload</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(model.<span class="title function_">get</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> view = &#123;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = model.<span class="title function_">get</span>();</span><br><span class="line">        <span class="keyword">let</span> listHtml = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123;name, age&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            listHtml += <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;tr&gt;</span></span><br><span class="line"><span class="string">                &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">                &lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;/tr&gt;</span></span><br><span class="line"><span class="string">            `</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> tableElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="property">innerHTML</span> = listHtml</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714175834918.png" alt="image-20220714175834918"></p><h2 id="7-MVVM"><a href="#7-MVVM" class="headerlink" title="7. MVVM"></a>7. MVVM</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714175940359.png" alt="image-20220714175940359"></p><p>修改ViewModel可以同步更新到View上</p><p>MVC：如何更新Model …&amp; 能够观察到Model更新的方法</p><p>MVVM：包含数据驱动视图更新的机制 &amp; 渲染视图的模板引擎</p><h3 id="7-1-如何绑定视图和数据的关系"><a href="#7-1-如何绑定视图和数据的关系" class="headerlink" title="7.1. 如何绑定视图和数据的关系"></a>7.1. 如何绑定视图和数据的关系</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714182522507.png" alt="image-20220714182522507"></p><h3 id="7-2-Vue实现MVVM的思路"><a href="#7-2-Vue实现MVVM的思路" class="headerlink" title="7.2. Vue实现MVVM的思路"></a>7.2. Vue实现MVVM的思路</h3><h4 id="7-2-1-数据劫持"><a href="#7-2-1-数据劫持" class="headerlink" title="7.2.1. 数据劫持"></a>7.2.1. 数据劫持</h4><blockquote><p>数据劫持 为什么要数据劫持？带着这个问题我们先来看下如何实现数据劫持，在vue2的源码中有个名为defineReactive$$1的方法，该方法就是用来实现数据劫持的，但该方法也只是个壳子，最终实现数据劫持的还是靠的<strong>js原生的Object.defineProperty方法</strong>，这也是vue2死活不支持ie8的原因之一。</p></blockquote><p>Object.defineProperty方法接受三个参数：</p><ul><li>第一个参数是被劫持的对象</li><li>第二个参数是被劫持的对象中的属性（key）</li><li>第三个参数是一个配置项对象（包括：value、enumerable、configurable、get和set等几个属性），如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,key,&#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们在做数据劫持时主要用到的就是get和set两个属性。</p><p>通过该方法，被劫持的对象属性，只要在外界获取或者修改属性值都会触发get或set方法，这样我们就可以在get或set中对属性做一些额外对操作。</p><p>了解了数据劫持的实现，也就知道了我们为什么要做数据劫持。是因为我们可以通过数据劫持对数据做一些额外对操作从而实现响应式数据。下面我们以vue的data为例实现一个简单的数据劫持。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="comment">// data必须是一个对象</span></span><br><span class="line">    <span class="comment">// &#123;&#125;.toString.call(): 判断类型</span></span><br><span class="line">    <span class="keyword">if</span>( (&#123;&#125;).<span class="property">toString</span>.<span class="title function_">call</span>(data) !== <span class="string">&#x27;[object Object]&#x27;</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//获取data中所有的属性</span></span><br><span class="line">    <span class="comment">// ES5 引入了Object.keys方法，成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的键名。</span></span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data); </span><br><span class="line">    <span class="comment">//循环遍历keys为data中的每个属性做数据劫持</span></span><br><span class="line">    keys.<span class="title function_">foreach</span>(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">defineReactive$$1</span>(data, key, data[key]);</span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive$$1</span>(<span class="params">obj, key, val</span>)&#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newV</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newV !== val)&#123;</span><br><span class="line">                val = newV;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-2-模板编译"><a href="#7-2-2-模板编译" class="headerlink" title="7.2.2. 模板编译"></a>7.2.2. 模板编译</h4><blockquote><p>为什么要模板编译？ 我们知道在vue中是通过一些指令或者小胡子语法来实现数据绑定的，而浏览器并不认识这些指令或者小胡子语法，因此在页面加载后需要将这些语法转换成真正的数据呈现给用户。</p></blockquote><p>下面我们以input元素和v-model指令为例来实现一个简单的模板编译。 本案例中实现模板编译的流程：</p><blockquote><ul><li>遍历#app下所有的节点，然后根据节点的类型做相应的操作<ul><li>如果是元素节点，获取该节点中所有的属性（attributes）并遍历看是否有v-model指令<ul><li>如果有v-model指令，则根据该指令绑定的属性名（data中的属性名）获取到对应到值，并赋值给节点的value属性</li></ul></li><li>如果是文本节点，则看该文本内容中是否包含小胡子语法<ul><li>如果有小胡子语法，同样需要解析出小胡子中绑定的属性名（data中的属性名）并获取到对应到值替换该文本内容</li></ul></li></ul></li><li>遍历完每个节点后再将该节点作为子节点添加到html到文档碎片中</li><li>最后再将整个文档碎片添加到dom中 需要说明到是：在vue中实现是借助虚拟dom实现的，而这里为了简单就借助文档碎片来模拟虚拟dom实现，另外为什么一定要用文档碎片，不能直接遍历节点吗？直接遍历也是可以的但是这样一来由于不停的修改节点势必会造成大量的性能消耗，而通过文档碎片在所有节点遍历完成后只需要一次消耗，这样就大大降低了回流重汇带来的性能损耗。</li></ul></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">nodeTofragment</span>(<span class="params">el, vm</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">    <span class="keyword">let</span> child;</span><br><span class="line">    <span class="keyword">while</span>(child = el.<span class="property">firstChild</span>)&#123;</span><br><span class="line">        <span class="title function_">compile</span>(child, vm);<span class="comment">//模板编译</span></span><br><span class="line">        fragment.<span class="title function_">appendChild</span>(child);<span class="comment">//将节点添加到文档碎片中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compile</span>(<span class="params">node, vm</span>)&#123;</span><br><span class="line">    <span class="comment">// 每个节点都有个节点类型属性（nodeType）对应的值分别是：1元素、2文本、8注释和9根节点</span></span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">nodeType</span> === <span class="number">1</span>)&#123;<span class="comment">//  如果是元素节点</span></span><br><span class="line">        <span class="comment">// 遍历所有的属性，看是否有v-model指令</span></span><br><span class="line">        [...node.<span class="property">attributes</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="regexp">/^v-/</span>.<span class="title function_">test</span>(item.<span class="property">nodeName</span>))&#123;<span class="comment">//nodeName就是属性名，如：class、type、v-model等</span></span><br><span class="line">                node.<span class="property">value</span> = vm.<span class="property">$data</span>[item.<span class="property">nodeValue</span>]; <span class="comment">//nodeValue就是属性名中对应的值，如v-model=&quot;name&quot;中的name</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 元素节点还可能有很多子节点或孙子节点等，因此还需递归处理</span></span><br><span class="line">        [...node.<span class="property">childNodes</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">compile</span>(item, vm);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.<span class="property">nodeType</span> === <span class="number">3</span>)&#123; <span class="comment">// 如果是文本节点</span></span><br><span class="line">        <span class="comment">// 检测该文本中是否包含小胡子语法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/\&#123;\&#123;\w+\&#125;\&#125;/</span>.<span class="title function_">test</span>(node.<span class="property">textContent</span>))&#123;</span><br><span class="line">            <span class="comment">// 将小胡子替换为真正的数据</span></span><br><span class="line">            node.<span class="property">textContent</span> = node.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>, <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">                <span class="comment">// 参数a是匹配到到大的正则内容</span></span><br><span class="line">                <span class="comment">// 参数b是小分组中匹配到到内容 所以b就对应的data中定义的属性</span></span><br><span class="line">                <span class="keyword">return</span> vm.<span class="property">$data</span>[b];</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-3-双向绑定"><a href="#7-2-3-双向绑定" class="headerlink" title="7.2.3. 双向绑定"></a>7.2.3. 双向绑定</h4><p>vue主要是利用数据劫持加发布订阅模式来实现数据的双向绑定的。</p><p>在前面数据劫持的时候我们提到，数据劫持的目的就是为了在获取数据或给数据赋值之前对数据做一些额外的操作，那么这些额外的操作其实就是利用发布订阅模式对数据属性进行监控，比如说data中的name属性，首先需要知道这个name属性都在哪里用到了，以便后面如果name值发生改变时及时通知用到name的地方同步更新，这个在vue中叫做依赖收集。怎么才能知道name属性都在哪里用到了呢，这个时候数据劫持就派上用场了，前面说过只要外界对name进行访问都会触发Object.defineProperty中的get函数，那么我们就可以利用这个特点在get函数中对name属性进行监听收集。大概实现思路如下：</p><blockquote><ul><li>首先我们需要定义一个Dep类，用于对属性进行依赖收集和通知用到属性到地方进行同步更新</li><li>然后再定义一个Watcher类，用于对属性进行监听，并实现属性值的同步更新</li><li>在模板编译的时候，通过watcher来监听属性</li><li>在数据劫持的get函数中进行依赖收集</li><li>在数据劫持的set函数中通知各个watcher进行数据更新</li></ul></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span> = [];<span class="comment">//事件池 存储watcher实例对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addSub</span>(<span class="params">sub</span>)&#123;</span><br><span class="line">        <span class="comment">//sub就是watcher的实例</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">notify</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            item.<span class="title function_">update</span>();<span class="comment">//调用watcher的update</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">node, key, vm</span>)&#123;</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;<span class="comment">//用于标识只用通过Watcher监听过的属性才会进行依赖收集</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span> = node;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getValue</span>();</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getValue</span>();<span class="comment">//首先获取下最新值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeType</span> === <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeType</span> === <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">key</span>];</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-3-完整代码"><a href="#7-3-完整代码" class="headerlink" title="7.3.  完整代码"></a>7.3.  完整代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向绑定</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addSubs</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.<span class="title function_">update</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">node, key, vm</span>) &#123;</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getValue</span>();</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getValue</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">key</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">observe</span>(<span class="variable language_">this</span>.<span class="property">$data</span>)</span><br><span class="line">  <span class="title function_">nodeTofragment</span>(<span class="variable language_">this</span>.<span class="property">$el</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;西瓜watermelon&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据劫持</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((&#123;&#125;).<span class="property">toString</span>.<span class="title function_">call</span>(data) !== <span class="string">&#x27;[object Object]&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data);</span><br><span class="line">  keys.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">defineReactive$$1</span>(data, key, data[key]);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive$$1</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">addSubs</span>(<span class="title class_">Dep</span>.<span class="property">target</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newV</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newV !== val) &#123;</span><br><span class="line">        val = newV</span><br><span class="line">        dep.<span class="title function_">notify</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板编译</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nodeTofragment</span>(<span class="params">el, vm</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line">  <span class="keyword">while</span> (child = el.<span class="property">firstChild</span>) &#123;</span><br><span class="line">    <span class="title function_">compiler</span>(child, vm);</span><br><span class="line">    fragment.<span class="title function_">appendChild</span>(child);</span><br><span class="line">  &#125;</span><br><span class="line">  el.<span class="title function_">appendChild</span>(fragment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compiler</span>(<span class="params">node, vm</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;<span class="comment">//元素节点</span></span><br><span class="line">    [...node.<span class="property">attributes</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/^v-/</span>.<span class="title function_">test</span>(item.<span class="property">nodeName</span>)) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(node, item.<span class="property">nodeValue</span>, vm)</span><br><span class="line">        node.<span class="property">value</span> = vm.<span class="property">$data</span>[item.<span class="property">nodeValue</span>];</span><br><span class="line">        node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          vm.<span class="property">$data</span>[item.<span class="property">nodeValue</span>] = node.<span class="property">value</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [...node.<span class="property">childNodes</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">compiler</span>(item, vm);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/\&#123;\&#123;\w+\&#125;\&#125;/</span>.<span class="title function_">test</span>(node.<span class="property">textContent</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      node.<span class="property">textContent</span> = node.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>, <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(node, b, vm)</span><br><span class="line">        <span class="keyword">return</span> vm.<span class="property">$data</span>[b]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>我自己个的vue - mvvm<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-设计模式"><a href="#8-设计模式" class="headerlink" title="8. 设计模式"></a>8. 设计模式</h2><h3 id="8-1-观察者模式"><a href="#8-1-观察者模式" class="headerlink" title="8.1. 观察者模式"></a>8.1. 观察者模式</h3><p>当对象之间存在一对多的依赖关系时，其中一个对象的状态发生改变，所有依赖它的对象都会收到通知，这就是观察者模式。</p><p>在观察者模式中，只有两种主体：目标对象 (<code>Object</code>) 和 观察者 (<code>Observer</code>)。宗门任务大殿就是目标对象，弟子们就是观察者。</p><ul><li>目标对象 <code>Subject</code>：<ul><li>维护观察者列表 <code>observerList</code> ———— 维护拥有订阅权限的弟子列表</li><li>定义添加观察者的方法 ———— 提供弟子购买订阅权限的功能</li><li>当自身发生变化后，通过调用自己的 <code>notify</code> 方法依次通知每个观察者执行 <code>update</code> 方法 ———— 发布对应任务后通知有订阅权限的弟子</li></ul></li><li>观察者 <code>Observer</code> 需要实现 <code>update</code> 方法，供目标对象调用。<code>update</code>方法中可以执行自定义的业务逻辑 ———— 弟子们需要定义接收任务通知后的方法，例如去抢任务或任务不适合，继续等待下一个任务</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220715000730818.png" alt="image-20220715000730818"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params">&#123;taskType, taskInfo&#125;</span>) &#123;</span><br><span class="line">        <span class="comment">// 假设任务分为日常route和战斗war</span></span><br><span class="line">        <span class="keyword">if</span> (taskType === <span class="string">&quot;route&quot;</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>不需要日常任务`</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">goToTaskHome</span>(taskInfo);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">goToTaskHome</span>(<span class="params">info</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>去任务大殿抢<span class="subst">$&#123;info&#125;</span>任务`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observerList</span> = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addObserver</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">push</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">notify</span>(<span class="params">task</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发布五星任务&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> observer.<span class="title function_">update</span>(task))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line"><span class="keyword">const</span> stu1 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&quot;弟子1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> stu2 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&quot;弟子2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stu1 stu2 购买五星任务通知权限</span></span><br><span class="line">subject.<span class="title function_">addObserver</span>(stu1);</span><br><span class="line">subject.<span class="title function_">addObserver</span>(stu2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务殿发布五星战斗任务</span></span><br><span class="line"><span class="keyword">const</span> warTask = &#123;</span><br><span class="line">    <span class="attr">taskType</span>: <span class="string">&#x27;war&#x27;</span>,</span><br><span class="line">    <span class="attr">taskInfo</span>: <span class="string">&quot;猎杀时刻&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务大殿通知购买权限弟子</span></span><br><span class="line">subject.<span class="title function_">notify</span>(warTask);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务殿发布五星日常任务</span></span><br><span class="line"><span class="keyword">const</span> routeTask = &#123;</span><br><span class="line">    <span class="attr">taskType</span>: <span class="string">&#x27;route&#x27;</span>,</span><br><span class="line">    <span class="attr">taskInfo</span>: <span class="string">&quot;种树浇水&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.<span class="title function_">notify</span>(routeTask);</span><br></pre></td></tr></table></figure><h3 id="8-2-发布订阅模式"><a href="#8-2-发布订阅模式" class="headerlink" title="8.2. 发布订阅模式"></a>8.2. 发布订阅模式</h3><ul><li>基本概念</li></ul><blockquote><p>基于一个事件（主题）通道，希望接收通知的对象 <code>Subscriber</code> 通过自定义事件订阅主题，被激活事件的对象 <code>Publisher</code> 通过发布主题事件的方式通知各个订阅该主题的 <code>Subscriber</code> 对象。</p></blockquote><p>因此发布订阅模式与观察者模式相比，发布订阅模式中有三个角色，发布者 <code>Publisher</code> ，事件调度中心 <code>Event Channel</code> ，订阅者 <code>Subscriber</code> 。</p><p>我们继续以弟子领取任务为栗子，宗门感觉把任务订阅放在任务大殿中有些繁琐，于是决定在任务大殿和弟子中间添加<strong>中介</strong>。弟子在中介中订阅其需要的任务类型，当任务大殿发布任务后，中介会将发布任务给对应的订阅者。</p><ul><li><p>宗门任务大殿: 任务发布者 —— <code>Publisher</code></p></li><li><p>中介功能 —— <code>Event Channel</code></p><ul><li><p>维护任务类型，以及每种任务下的订阅情况</p></li><li><p>给订阅者提供订阅功能 —— <code>subscribe</code> 功能</p></li><li><p>当宗门发布任务后，中介会给所有的订阅者发布任务 —— <code>publish</code> 功能</p></li></ul></li><li><p>弟子: 任务接受者 —— <code>Subscriber</code></p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220715000719802.png" alt="image-20220715000719802"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PubSub</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 事件中心</span></span><br><span class="line">        <span class="comment">// 存储格式: warTask: [], routeTask: []</span></span><br><span class="line">        <span class="comment">// 每种事件(任务)下存放其订阅者的回调函数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 订阅方法</span></span><br><span class="line">    <span class="title function_">subscribe</span>(<span class="params">type, cb</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">events</span>[type] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">push</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发布方法</span></span><br><span class="line">    <span class="title function_">publish</span>(<span class="params">type, ...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">forEach</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(...args))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消订阅方法</span></span><br><span class="line">    <span class="title function_">unsubscribe</span>(<span class="params">type, cb</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="keyword">const</span> cbIndex = <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">findIndex</span>(<span class="function"><span class="params">e</span>=&gt;</span> e === cb)</span><br><span class="line">            <span class="keyword">if</span> (cbIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="title function_">splice</span>(cbIndex, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[type].<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">events</span>[type];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">unsubscribeAll</span>(<span class="params">type</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[type]) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">events</span>[type];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个中介公司</span></span><br><span class="line"><span class="keyword">let</span> pubsub = <span class="keyword">new</span> <span class="title class_">PubSub</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弟子一订阅战斗任务</span></span><br><span class="line">pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;warTask&#x27;</span>, <span class="keyword">function</span> (<span class="params">taskInfo</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;宗门殿发布战斗任务，任务信息:&quot;</span> + taskInfo);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 弟子一订阅战斗任务</span></span><br><span class="line">pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;routeTask&#x27;</span>, <span class="keyword">function</span> (<span class="params">taskInfo</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;宗门殿发布日常任务，任务信息:&quot;</span> + taskInfo);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 弟子三订阅全类型任务</span></span><br><span class="line">pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;allTask&#x27;</span>, <span class="keyword">function</span> (<span class="params">taskInfo</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;宗门殿发布五星任务，任务信息:&quot;</span> + taskInfo);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布战斗任务</span></span><br><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;warTask&#x27;</span>, <span class="string">&quot;猎杀时刻&quot;</span>);</span><br><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;allTask&#x27;</span>, <span class="string">&quot;猎杀时刻&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布日常任务</span></span><br><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;routeTask&#x27;</span>, <span class="string">&quot;种树浇水&quot;</span>);</span><br><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;allTask&#x27;</span>, <span class="string">&quot;种树浇水&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在发布订阅模式中，发布者和订阅者不知道对方的存在。需要第三方中介，将订阅者和发布者串联起来，利用中介过滤和分配所有输入的消息。也就是说，<strong>发布-订阅模式用来处理不同系统组件的信息交流，即使这些组件不知道对方的存在</strong>。</p></blockquote><h4 id="8-3-观察者模式和发布订阅模式的差异"><a href="#8-3-观察者模式和发布订阅模式的差异" class="headerlink" title="8.3. 观察者模式和发布订阅模式的差异"></a>8.3. 观察者模式和发布订阅模式的差异</h4><table><thead><tr><th>设计模式</th><th>观察者模式</th><th>发布订阅模式</th></tr></thead><tbody><tr><td>主体</td><td>Object观察者、Subject目标对象</td><td>Publisher发布者、Event Channel事件中心、Subscribe订阅者</td></tr><tr><td>主体关系</td><td>Subject中通过observerList记录ObServer</td><td>Publisher和Subscribe不想不知道对方，通过中介联系</td></tr><tr><td>优点</td><td>角色明确，Subject和Object要遵循约定的成员方法</td><td>松散耦合，灵活度高，通常应用在异步编程中</td></tr><tr><td>缺点</td><td>紧耦合</td><td>当事件类型变多时，会增加维护成本</td></tr><tr><td>使用案例</td><td>双向数据绑定</td><td>事件总线EventBus</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Typescript 实现的简易 MVVM 框架</title>
      <link href="/article/a-MVVM-toy-with-TypeScript/"/>
      <url>/article/a-MVVM-toy-with-TypeScript/</url>
      
        <content type="html"><![CDATA[<p>2022年秋季百度暑期课程的大作业，用typescript实现的简易MVVM框架。</p><p>实现了数据劫持、单向绑定、双向绑定、发布订阅模式等</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220714175940359.png" alt="image-20220714175940359" style="zoom:50%;" /><h1 id="1-核心原理"><a href="#1-核心原理" class="headerlink" title="1. 核心原理"></a>1. 核心原理</h1><p>与 MVC 相比，MVVM 包含数据驱动视图更新的机制 &amp; 渲染视图的模板引擎。总的来说 MVVM 框架的核心原理如下：</p><h2 id="1-1-数据劫持"><a href="#1-1-数据劫持" class="headerlink" title="1.1. 数据劫持"></a>1.1. 数据劫持</h2><blockquote><p>通过 js 原生的<code>Object.defineProperty</code>方法，可以进行数据劫持。而做数据劫持时主要用到的就是 get 和 set 两个属性。通过该方法，被劫持的对象属性，只要在外界获取或者修改属性值都会触发 get 或 set 方法，这样我们就可以在 get 或 set 中对属性做一些额外对操作。</p></blockquote><p>由此，可以通过数据劫持对数据做一些额外的操作从而实现响应式数据。</p><h2 id="1-2-模板编译"><a href="#1-2-模板编译" class="headerlink" title="1.2. 模板编译"></a>1.2. 模板编译</h2><blockquote><p>为什么要模板编译？ 我们知道在 vue 中是通过一些指令或者小胡子语法来实现数据绑定的，而浏览器并不认识这些指令或者小胡子语法，因此在页面加载后需要将这些语法转换成真正的数据呈现给用户。</p></blockquote><p><strong>本次大作业中</strong>，我实现模板编译的主要流程如下：</p><ul><li><p>遍历#app 下所有的节点，然后根据节点的类型做相应的操作</p><ul><li>如果是元素节点，获取该节点中所有的属性（attributes）并遍历看是否有 v-model、v-bind、v-on 指令<ul><li>如果有相应指令，则根据该指令绑定的属性名（data 中的属性名）获取到对应到值，并赋值给节点的 value 属性</li></ul></li><li>如果是文本节点，则看该文本内容中是否包含小胡子语法<ul><li>如果有小胡子语法，同样需要解析出小胡子中绑定的属性名（data 中的属性名）并获取到对应到值替换该文本内容</li></ul></li></ul></li><li><p>遍历完每个节点后再将该节点作为子节点添加到 html 到文档碎片中</p></li><li><p>最后再将整个文档碎片添加到 dom 中。</p><blockquote><p>说明：这里借鉴了虚拟 dom 的思路，本次大作业借助文档碎片来模拟虚拟 dom 实现。</p><p>使用虚拟 dom 思路可以避免直接遍历由于不停的修改节点而带来的性能消耗，通过文档碎片在所有节点遍历完成后只需要一次消耗，可以降低了回流重汇带来的性能损耗。</p></blockquote></li></ul><h2 id="1-3-双向绑定"><a href="#1-3-双向绑定" class="headerlink" title="1.3. 双向绑定"></a>1.3. 双向绑定</h2><blockquote><p>本次大作业主要是利用数据劫持加发布订阅模式来实现数据的双向绑定的。</p></blockquote><p>数据劫持的目的是为了在获取数据或给数据赋值之前对数据做一些额外的操作，那么这些额外的操作其实就是利用发布订阅模式对数据属性进行监控。大概实现思路如下：</p><ul><li>定义一个 Watcher 类，用于对属性进行监听，并实现属性值的同步更新</li><li>在模板编译的时候，通过 watcher 来监听属性</li><li>在数据劫持的 get 函数中进行依赖收集</li><li>在数据劫持的 set 函数中通知各个 watcher 进行数据更新</li></ul><h1 id="2-代码架构"><a href="#2-代码架构" class="headerlink" title="2. 代码架构"></a>2. 代码架构</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MVVM</span><br><span class="line">│</span><br><span class="line">├─ src</span><br><span class="line">│  ├─ compile</span><br><span class="line">│  │  └─ compile.ts // compile模块</span><br><span class="line">│  ├─ const</span><br><span class="line">│  │  └─ regex.ts // 正则表达式枚举</span><br><span class="line">│  ├─ observer</span><br><span class="line">│  │  └─ observer.ts // observer模块</span><br><span class="line">│  ├─ watcher</span><br><span class="line">│  │  └─ watcher.ts // wather类</span><br><span class="line">│  └─ index.ts // 主入口文件</span><br><span class="line">├─ test</span><br><span class="line">│  ├─ unitTest // 单元测试文件</span><br><span class="line">│  │  ├─ vBind.test.js</span><br><span class="line">│  │  ├─ vModel.test.js</span><br><span class="line">│  │  └─ vOn.test.js</span><br><span class="line">│  ├─ index.html // 集成测试html</span><br><span class="line">│  └─ mock.js // mock</span><br><span class="line">├─ .gitignore</span><br><span class="line">├─ package-lock.json</span><br><span class="line">├─ package.json</span><br><span class="line">├─ README.md</span><br><span class="line">├─ tsconfig.json</span><br><span class="line">└─ webpack.config.js</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-1-MVVM"><a href="#2-1-MVVM" class="headerlink" title="2.1. MVVM"></a>2.1. MVVM</h2><p>入口文件，在这里对 vue 当中的<code>$el、$methods、$data</code>进行初始化，调用 <code>observer</code> 遍历<code>$data</code>的数据并进行挟持，调用<code>compile</code>遍历<code>$el</code>下的所有节点，解析之类和取值操作。遍历<code>$data</code>的数据，通过<code>Object.defineProperty</code>的<code>getter</code>和<code>setter</code>实现对<code>$data</code> 的代理。</p><h2 id="2-2-Observer"><a href="#2-2-Observer" class="headerlink" title="2.2. Observer"></a>2.2. Observer</h2><p>遍历 <code>$data</code>，通过 <code>Object.defineProperty</code> 设置 <code>getter</code> 和 <code>setter</code>，在 <code>setter</code> 知道数据发生了改变，然后通知 <code>Wacher</code> 去更新 <code>view</code>。</p><h2 id="2-3-Compile"><a href="#2-3-Compile" class="headerlink" title="2.3. Compile"></a>2.3. Compile</h2><p>遍历<code>$el</code> 下的所有节点，解析指令和取值操作等，为每个节点绑定更新函数（在这里），绑定事件和 <code>method</code> 的关系，同时也添加订阅者，当接受到视图更新的订阅消息后，调用更新函数，实现视图更新。同时在添加订阅者的时候，初始化渲染视图。</p><h2 id="2-4-Watcher"><a href="#2-4-Watcher" class="headerlink" title="2.4. Watcher"></a>2.4. Watcher</h2><p><code>Watcher</code> 作为订阅者，充当 <code>Observer</code> 和 <code>Compile</code> 的中间桥梁，包含 <code>update</code> 方法，<code>update</code> 方法调用 <code>Compile</code> 中绑定的事件更新函数，实现对视图的初始化和更新操作。</p><h1 id="3-实例"><a href="#3-实例" class="headerlink" title="3. 实例"></a>3. 实例</h1><blockquote><p>实现功能：</p><ul><li>v-on（事件绑定）</li><li>v-bind（单向绑定）</li><li>v-model（双向绑定）</li><li>小胡子语法（插值表达式，双向绑定）</li></ul></blockquote><h2 id="3-1-HTML"><a href="#3-1-HTML" class="headerlink" title="3.1. HTML"></a>3.1. HTML</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;id&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>获取输入值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title function_">MVVM</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">message</span>: <span class="string">&#x27;测试&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&#x27;百度前端&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">id</span>: <span class="string">&#x27;1234&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">handleClick</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">message</span> + <span class="string">&#x27;:&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;, 点击确定会修改值&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;修改了值为此~&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="number">1234</span>))</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-效果展示"><a href="#3-2-效果展示" class="headerlink" title="3.2. 效果展示"></a>3.2. 效果展示</h2><p><strong><em>v-model</em></strong><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220719232943560.png" alt="image-20220719232943560"></p><p><strong><em>v-on &#x2F; v-bind</em></strong><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220719232957753.png" alt="image-20220719232957753"></p><h1 id="4-单元测试"><a href="#4-单元测试" class="headerlink" title="4. 单元测试"></a>4. 单元测试</h1><blockquote><p>考虑到我编写的都是类，在<code>MVVM</code>类构造的时候即调用所有模块，进行绑定、注册、监听、订阅等工作。因此选择构造 dom 对 v-on（事件绑定）、v-model（双向绑定）、v-bind（数据单向绑定）进行测试</p></blockquote><h2 id="4-1-测试配置"><a href="#4-1-测试配置" class="headerlink" title="4.1. 测试配置"></a>4.1. 测试配置</h2><ul><li><p>测试工具：<code>&quot;jest&quot;: &quot;^28.1.3&quot;</code></p></li><li><p>测试环境：<code>&quot;node.js&quot;: &quot;^v16.13.2&quot;</code></p></li><li><p><code>package.json</code>配置</p><ul><li><pre><code class="json">&#123;  &quot;dependencies&quot;: &#123;    &quot;http&quot;: &quot;^0.0.1-security&quot;,    &quot;jest-environment-jsdom&quot;: &quot;^28.1.3&quot;,    &quot;jsdom&quot;: &quot;^20.0.0&quot;,    &quot;text-encoding&quot;: &quot;^0.7.0&quot;  &#125;,  &quot;name&quot;: &quot;mvvm&quot;,  &quot;description&quot;: &quot;简易的MVVM框架，用typescript实现&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;directories&quot;: &#123;    &quot;test&quot;: &quot;test&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@babel/core&quot;: &quot;^7.18.9&quot;,    &quot;@babel/preset-env&quot;: &quot;^7.18.9&quot;,    &quot;@babel/preset-typescript&quot;: &quot;^7.18.6&quot;,    &quot;@types/chai&quot;: &quot;^4.3.1&quot;,    &quot;@types/jest&quot;: &quot;^28.1.6&quot;,    &quot;@types/mocha&quot;: &quot;^9.1.1&quot;,    &quot;babel-jest&quot;: &quot;^28.1.3&quot;,    &quot;chai&quot;: &quot;^4.3.6&quot;,    &quot;jest&quot;: &quot;^28.1.3&quot;,    &quot;mocha&quot;: &quot;^10.0.0&quot;,    &quot;ts-loader&quot;: &quot;^9.3.1&quot;,    &quot;ts-node&quot;: &quot;^10.9.1&quot;,    &quot;typescript&quot;: &quot;^4.7.4&quot;,    &quot;webpack&quot;: &quot;^5.73.0&quot;,    &quot;webpack-cli&quot;: &quot;^4.10.0&quot;  &#125;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;jest&quot;,    &quot;build&quot;: &quot;webpack&quot;,    &quot;coverage&quot;: &quot;jest --coverage&quot;  &#125;,  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git+https://github.com/Pengzna/MVVM-toy.git&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;bugs&quot;: &#123;    &quot;url&quot;: &quot;https://github.com/Pengzna/MVVM-toy/issues&quot;  &#125;,  &quot;homepage&quot;: &quot;https://github.com/Pengzna/MVVM-toy#readme&quot;&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `jest.config.js`配置</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">      transform: &#123;</span><br><span class="line">        &#x27;^.+\\.js$&#x27;: &#x27;babel-jest&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      testEnvironment: &#x27;jsdom&#x27;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h2 id="4-2-测试代码"><a href="#4-2-测试代码" class="headerlink" title="4.2. 测试代码"></a>4.2. 测试代码</h2><h3 id="4-2-1-vBind-test-js"><a href="#4-2-1-vBind-test-js" class="headerlink" title="4.2.1. vBind.test.js"></a>4.2.1. vBind.test.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">MVVM</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../../src/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;v-bind test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div v-bind:id=&quot;id&quot;&gt;&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;button v-on:click=&quot;handleClick&quot;&gt;获取输入值&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title function_">MVVM</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;测试&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;百度前端&#x27;</span>,</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> testNode = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;1234&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> actualValue = <span class="string">&#x27;&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;&#x27;</span></span><br><span class="line">  <span class="title function_">expect</span>(testNode.<span class="property">textContent</span>).<span class="title function_">toBe</span>(actualValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-2-2-vModel-test-js"><a href="#4-2-2-vModel-test-js" class="headerlink" title="4.2.2. vModel.test.js"></a>4.2.2. vModel.test.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">MVVM</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../../src/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;v-model test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div v-bind:id=&quot;id&quot;&gt;&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;button v-on:click=&quot;handleClick&quot;&gt;获取输入值&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title function_">MVVM</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;测试&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;百度前端&#x27;</span>,</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> actualValue = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>].<span class="property">value</span></span><br><span class="line">  <span class="title function_">expect</span>(vue.<span class="property">name</span>).<span class="title function_">toBe</span>(actualValue)</span><br><span class="line">  <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="comment">// 触发v-model需要触发事件。</span></span><br><span class="line">  input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    vue.<span class="property">name</span> = <span class="string">&#x27;修改后&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> inputEvent = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">  input.<span class="title function_">dispatchEvent</span>(inputEvent)</span><br><span class="line">  <span class="keyword">const</span> modifiedValue = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>].<span class="property">value</span></span><br><span class="line">  <span class="title function_">expect</span>(vue.<span class="property">name</span>).<span class="title function_">toBe</span>(modifiedValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-2-3-vOn-test-js"><a href="#4-2-3-vOn-test-js" class="headerlink" title="4.2.3. vOn.test.js"></a>4.2.3. vOn.test.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">MVVM</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../../src/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;v-on test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;div v-bind:id=&quot;id&quot;&gt;&#123;&#123;message&#125;&#125;:&#123;&#123;name&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;button v-on:click=&quot;handleClick&quot; id=&quot;bt&quot;&gt;获取输入值&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">const</span> vue = <span class="keyword">new</span> <span class="title function_">MVVM</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;测试&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;百度前端&#x27;</span>,</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="attr">handleClick</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;修改了值为此~&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;bt&#x27;</span>).<span class="title function_">click</span>()</span><br><span class="line">  <span class="keyword">const</span> actualValue = <span class="string">&#x27;修改了值为此~&#x27;</span></span><br><span class="line">  <span class="title function_">expect</span>(vue.<span class="property">name</span>).<span class="title function_">toBe</span>(actualValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-3-测试结果"><a href="#4-3-测试结果" class="headerlink" title="4.3. 测试结果"></a>4.3. 测试结果</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220720123743581.png" alt="image-20220720123743581"></p><h2 id="4-4-测试覆盖率"><a href="#4-4-测试覆盖率" class="headerlink" title="4.4. 测试覆盖率"></a>4.4. 测试覆盖率</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220722113152793.png" alt="image-20220722113152793"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220722113218413.png" alt="image-20220722113218413"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学软件学院-软件工程与计算Ⅱ大作业心得</title>
      <link href="/article/SE%E2%85%A1-significant-hw/"/>
      <url>/article/SE%E2%85%A1-significant-hw/</url>
      
        <content type="html"><![CDATA[<p>笔者在南京大学软件学院2022年春-软件工程与计算Ⅱ课程中获得99分，其中大作业118分（满分100，拿了18分的 bonus）。因此记录下自己的作业心得。</p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="1-面向接口编程"><a href="#1-面向接口编程" class="headerlink" title="1. 面向接口编程"></a>1. 面向接口编程</h3><ul><li>主要用于代码复用、消除循环依赖、实现拓展等</li><li>方法：抽象公共父类（最低阶）、<strong>泛型编程</strong>（更灵活，根据具体类注入，可以实现参数和实现的多态）。下面以个人项目实践中的根据泛型实现面向接口编程举出实例：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口类，通过泛型注入具体参数，实现每个方法的参数多态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SheetService</span> &lt;SheetVO, SheetState&gt;&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建单据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userVO 操作用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetVO 单据VO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSheet</span><span class="params">(UserVO userVO, SheetVO sheetVO)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据状态获取单据(state == null 则获取所有单据)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state 单据状态</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 符合条件的所有单据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;SheetVO&gt; <span class="title function_">getSheetByState</span><span class="params">(SheetState state)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据进货单id进行审批(state == 审批完成&quot;/&quot;审批失败&quot;)</span></span><br><span class="line"><span class="comment">     * 在controller层进行权限控制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetId 单据id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state 单据修改后的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">approval</span><span class="params">(String sheetId, SheetState state)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据单据Id搜索单据信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetId 单据Id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SheetVO <span class="title function_">getSheetById</span><span class="params">(String sheetId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxSheetServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SheetService</span>&lt;xxxSheetVO, xxxSheetState&gt;</span><br></pre></td></tr></table></figure><h3 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h3><ul><li>策略模式：<ul><li>将策略方法抽象成接口，用不同的实现类实现它。</li><li>在调用 service 里组合接口类（而不是具体的实现类），根据情况向接口中注入具体的类。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PromotionStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据type制定不同的促销策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">makePromotionStrategy</span><span class="params">(PromotionStrategyVO promotionStrategyVO)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// service类（调用strategy）</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">makePromotionStrategy</span><span class="params">(PromotionStrategyVO promotionStrategyVO)</span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;制定促销策略&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    PromotionStrategy promotionStrategy;</span><br><span class="line">    <span class="comment">// 策略模式</span></span><br><span class="line">    <span class="keyword">switch</span> (promotionStrategyVO.getType())&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            promotionStrategy = <span class="keyword">new</span> <span class="title class_">UserPromotionStrategy</span>(promotionStrategyDao, customerDao);</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;对不同级别用户制定促销策略...&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            promotionStrategy = <span class="keyword">new</span> <span class="title class_">SpecialPricePromotionStrategy</span>(promotionStrategyDao);</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;制定特价包（组合商品降价）...&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            promotionStrategy = <span class="keyword">new</span> <span class="title class_">TotalAmountPromotionStrategy</span>(promotionStrategyDao);</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;针对不同总价制定促销策略...&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;错误：未指定促销策略类型！&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;完成促销策略制定&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> promotionStrategy.makePromotionStrategy(promotionStrategyVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-定时任务"><a href="#3-定时任务" class="headerlink" title="3. 定时任务"></a>3. 定时任务</h3><ul><li><p>比较简单，主要通过 SpringBoot 的<code>org.springframework.scheduling.annotation.Scheduled</code> 包实现</p></li><li><p>需要书写<code>cron</code> 表达式，跟 Linux 系统的 cron 定时任务语法相似</p></li></ul><h3 id="4-AOP（面向切面编程）"><a href="#4-AOP（面向切面编程）" class="headerlink" title="4. AOP（面向切面编程）"></a>4. AOP（面向切面编程）</h3><ul><li><p>思想：通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。</p><ul><li><p>所谓的切面（Aspect），可以简单理解为程序中的共性功能。AOP 通过关注程序中的共性功能（面），将其通过一些技术（预编译、代理等）进行统一处理，从而减少代码重复，提高效率。</p></li><li><p>一般认为切面 &#x3D; 通知 + 切入点</p><ul><li><blockquote><p>切入点是指我们要对哪些 Joinpoint 进行拦截的定义，通俗的说就是<code>被增强类中的被增强的方法</code>，即切入的地方。注意，被增强类中并不是所有的方法都被代理了</p></blockquote></li><li><blockquote><p>所谓通知是指拦截到 Joinpoint （被增强的方法）之后所要做的事情就是通知，通俗的说就是<code>对被增强的方法进行增强的代码</code>，即要做的事情</p></blockquote></li></ul></li><li><p>典型的 AOP 应用场景有：HTTP request 的鉴权授权、日志记录等</p></li></ul></li><li><p>使用：</p></li></ul><blockquote><p>Spring Boot 使用 AOP 需要添加 spring-boot-starter-aop 依赖，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;` `&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;` `&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;` `&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></blockquote><p>代码实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示当前的类是一个配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//该注解只能用在类上，作用：代表当前类是一个切面类</span></span><br><span class="line"><span class="comment">// 切面 == 通知 +　切入点</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdviceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Before</span>：前置通知</span></span><br><span class="line"><span class="comment">     * value：切入点表达式  二者加起来构建成为一个切面</span></span><br><span class="line"><span class="comment">     * JoinPoint：连接点：可以理解为两个圆形的切点，从这个切点就可以获取到当前执行的目标类及方法</span></span><br><span class="line"><span class="comment">     * 前置通知和后置通知的参数的都是 JoinPoint， 前置后置通知都没有返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 方法级别：具体到某个具体的方法</span></span><br><span class="line">    <span class="comment">// @Before(value = &quot;execution(* com.xxx.xxx.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="comment">// value值里可以加权限控制，比如public * com.xxx.xxx等</span></span><br><span class="line">    <span class="comment">// 表示service包下的所有类所有方法都执行该前置通知</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;within(com.xxx.xxx.service.*)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before开始执行查询.......&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行的目标类是: &quot;</span> + joinPoint.getTarget());</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行的目标方法是: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行的目标方法参数是: &quot;</span> + joinPoint.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知，属性参数同上面的前置通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 前置通知和后置通知独有的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(value = &quot;execution(* com.xxx.xxx.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after查询结束.......&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取执行目标类和方法名等等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proceedingJoinPoint 环绕通知的正在执行中的连接点（这是环绕通知独有的参数）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标方法执行的返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Around</span>: 环绕通知，有返回值，环绕通知必须进行放行方法（就相当于拦截器），否则目标方法无法执行)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;execution(* com.xxx.xxx.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroud</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aroud环绕通知开始.......&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;执行的目标类 = &quot;</span> + proceedingJoinPoint.getTarget());</span><br><span class="line">        System.out.println(<span class="string">&quot;执行的目标方法 = &quot;</span> + proceedingJoinPoint.getSignature().getName());</span><br><span class="line">        <span class="comment">// 必须方法目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;aroud环绕通知结束.......&quot;</span>);</span><br><span class="line">        <span class="comment">// 将目标方法的返回值进行返回，否则调用目标方法的方法无法获取到返回值</span></span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Bean-的装配"><a href="#5-Bean-的装配" class="headerlink" title="5. Bean 的装配"></a>5. Bean 的装配</h3><ul><li><p>这里主要记录踩到的坑，具体的知识点较为庞杂，在本周的学习中进行具体的记录</p></li><li><p>主要是装配时发生了空指针异常，而异常类已经标上了相关注解。百思不得其解，最后发现 SpringBoot 对 bean 的装配是自动管理，即不需要程序员手动 new。而一旦程序员手动 new，SpringBoot 即认为程序员接管了装配，不再进行自动配置。而本人的异常即为手动 new 了对象造成。</p></li></ul><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><ul><li>resultType &#x2F; resultMap<ul><li>用于指定返回类，用途相似，一般用 resultType 更方便。详细的知识点在之后的文档学习中具体记录。</li></ul></li></ul><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><ul><li><p>Agent</p><ul><li>可以简单理解为执行 pipeline 的环境。一般选择代码构建所需的环境。</li><li><blockquote><p>在配置前端 Jenkins 时，曾遇到 npm: not found 错误。原因是 Jenkins 所在容器未安装 nodejs，也并未挂载宿主机的 nodejs 脚本。解决方法是配置 node 某个版本（我用的是 node: 14)的 agent。在 agent 中执行 npm</p></blockquote></li></ul></li><li><p>Pipeline</p><ul><li>简单的说就是 Jenkins 执行的一个个任务。可以按照环境清理（Image clear）、环境准备（Prepare）、构建（Build）、测试（Test）、打包（Deploy）等步骤细分</li></ul></li><li><p>Docker in docker</p><ul><li>由于我的 Jenkins 部署在 docker 中，而有时需要在 Jenkins 环境下执行 docker 命令，即（Docker in docker），我是通过挂载宿主机的 docker 脚本和 docker.sock 实现的</li></ul></li></ul><h2 id="Gitlab-runner"><a href="#Gitlab-runner" class="headerlink" title="Gitlab-runner"></a>Gitlab-runner</h2><ul><li><p>基本配置</p><ul><li>基本照着网上的教程一路走下来即可。踩的一个大坑是需要手动在配置文件里指定<code>clone_url</code> （仓库的地址）。并且这个地址亲测不能是 ci&#x2F;cd 页面给的 http 地址，必须与仓库 url 一致（如果是 https 必须是 https）。但是由此在设置<code>artifact</code> 时可能会带来请求拦截问题，目前尚未解决。</li></ul></li><li><p>Volumes</p><ul><li>与上述 Jenkins 同样，需要挂载宿主机的 docker 脚本和 docker.sock 来实现 Docker in docker</li></ul></li><li><p>Type</p><ul><li>我用的是 docker，没试过 shell 等其他类型</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 整理重点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 学习-2</title>
      <link href="/article/Spring-learning2/"/>
      <url>/article/Spring-learning2/</url>
      
        <content type="html"><![CDATA[<h1 id="2-SpringBoot-集成-NoSQL"><a href="#2-SpringBoot-集成-NoSQL" class="headerlink" title="2. SpringBoot 集成 NoSQL"></a>2. SpringBoot 集成 NoSQL</h1><h2 id="2-1-Redis"><a href="#2-1-Redis" class="headerlink" title="2.1. Redis"></a>2.1. Redis</h2><p>使用 <code>spring-boot-starter-data-redis</code> starter 可方便地引入相关依赖。默认情况下，它使用 <a href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>。该 starter 可处理传统应用程序和响应式应用程序。</p><h3 id="2-1-1-连接"><a href="#2-1-1-连接" class="headerlink" title="2.1.1. 连接"></a>2.1.1. 连接</h3><p>您可以像所有 Spring Bean 一样注入自动配置的 <code>RedisConnectionFactory</code>、<code>StringRedisTemplate</code> 或普通的 <code>RedisTemplate</code> 实例。默认情况下，实例将尝试在 <code>localhost:6379</code> 上连接 Redis 服务器，以下是 bean 示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">(StringRedisTemplate template)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><blockquote><p>您还可以注册任意数量个实现了 <code>LettuceClientConfigurationBuilderCustomizer</code> 的 bean，以进行更高级的自定义。如果你使用 Jedis，则可以使用 <code>JedisClientConfigurationBuilderCustomizer</code>。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 学习-1</title>
      <link href="/article/Spring-learning/"/>
      <url>/article/Spring-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="1-IoC-容器"><a href="#1-IoC-容器" class="headerlink" title="1. IoC 容器"></a>1. IoC 容器</h1><ul><li>Inversion of Control （IoC）</li></ul><h2 id="1-1-Spring-IoC-Container-Bean"><a href="#1-1-Spring-IoC-Container-Bean" class="headerlink" title="1.1. Spring IoC Container &amp; Bean"></a>1.1. Spring IoC Container &amp; Bean</h2><blockquote><p>IoC 也成为依赖注入，是对象仅通过<strong>*构造函数参数、工厂方法的参数 或在对象实例被构造 或从工厂方法返回后在对象实例上设置的属性来定义它们的依赖项</strong>。*</p></blockquote><ul><li>容器在创建 Bean 时注入这些依赖性。这个过程是 Bean 本身的逆过程，因此得名控制反转<ul><li><a href="https://blog.csdn.net/sinat_36817189/article/details/123410280">(26 条消息) 浅谈控制反转（IoC）<em>米碎师兄的博客-CSDN 博客</em>控制反转</a></li></ul></li><li>在 Spring 中，构成应用程序主干并由 Spring IoC 容器管理的对象称为 bean。</li><li>bean 是由 Spring IoC 容器实例化、组装和管理的对象。 否则，bean 只是应用程序中众多对象之一。 Bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。</li></ul><h2 id="1-2-容器概述"><a href="#1-2-容器概述" class="headerlink" title="1.2. 容器概述"></a>1.2. 容器概述</h2><blockquote><p><code>org.springframework.context.ApplicationContext</code> 接口代表 Spring IoC 容器，负责实例化、配置和组装 bean。 容器通过读取配置元数据来获取有关要实例化、配置和组装哪些对象的指令。 配置元数据以 XML、**<em>Java 注解</em>**或 Java 代码表示。 它可以让您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。</p></blockquote><ul><li>一般来说，创建并初始化了<code>ApplicationContext</code>后，就有了一个完全配置且可执行的系统或应用程序</li></ul><h3 id="1-2-1-配置元数据"><a href="#1-2-1-配置元数据" class="headerlink" title="1.2.1. 配置元数据"></a>1.2.1. 配置元数据</h3><p>方式主要有三</p><ul><li>基于 XML（基本用不到，不详述）</li><li>基于注解（后文提到）</li><li>基于 Java（后文提到）</li></ul><h3 id="1-2-2-实例化容器"><a href="#1-2-2-实例化容器" class="headerlink" title="1.2.2. 实例化容器"></a>1.2.2. 实例化容器</h3><ul><li>Spring 的实例化用的比较少了，略</li></ul><h3 id="1-2-3-使用容器"><a href="#1-2-3-使用容器" class="headerlink" title="1.2.3. 使用容器"></a>1.2.3. 使用容器</h3><ul><li>Spring 的实例化用的比较少了，略</li></ul><h2 id="1-3-Bean-概述"><a href="#1-3-Bean-概述" class="headerlink" title="1.3. Bean 概述"></a>1.3. Bean 概述</h2><ul><li>略</li></ul><h2 id="1-4-依赖关系"><a href="#1-4-依赖关系" class="headerlink" title="1.4. 依赖关系"></a>1.4. 依赖关系</h2><h3 id="1-4-1-依赖注入"><a href="#1-4-1-依赖注入" class="headerlink" title="1.4.1. 依赖注入"></a>1.4.1. 依赖注入</h3><ul><li>基于构造函数的依赖注入<ul><li>基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数代表一个依赖项。 调用带有特定参数的 <code>static</code> 工厂方法来构造 bean 几乎是等效的，本讨论将类似地处理构造函数和 <code>static</code> 工厂方法的参数。 以下示例显示了一个只能使用构造函数注入进行依赖注入的类</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot 中多用注解结合构造函数进行 DI</p><ul><li>构造函数参数解析<ul><li>构造函数参数解析匹配通过使用参数的类型发生。 如果 bean 定义的构造函数参数中不存在潜在的歧义，那么在 bean 定义中定义构造函数参数的顺序就是在实例化 bean 时将这些参数提供给适当的构造函数的顺序。</li></ul></li><li>Spring 中构造函数消歧义的问题<ul><li>略，SpringBoot 中很少碰到</li></ul></li><li>依赖解析流程<ul><li>容器执行 bean 依赖解析如下：<ul><li><code>ApplicationContext</code> 是用描述所有 bean 的配置元数据创建和初始化的。 配置元数据可以由 XML、Java 代码或注解指定。</li><li>对于每个 bean，它的依赖关系以属性、构造函数参数或静态工厂方法的参数（如果您使用它而不是普通构造函数）的形式表示。 在实际创建 bean 时，将这些依赖关系提供给 bean。</li><li>每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个 bean 的引用。</li><li>作为值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型。 默认情况下，Spring 可以将字符串格式提供的值转换为所有内置类型，例如 <code>int</code>、<code>long</code>、<code>String</code>、<code>boolean</code> 等等。</li></ul></li></ul></li></ul><h2 id="1-5-基于注解的容器配置"><a href="#1-5-基于注解的容器配置" class="headerlink" title="1.5. 基于注解的容器配置"></a>1.5. 基于注解的容器配置</h2><h3 id="1-5-1-Required"><a href="#1-5-1-Required" class="headerlink" title="1.5.1. @Required"></a>1.5.1. @Required</h3><p><code>@Required</code> 注解适用于 bean 属性 setter 方法，如下例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此注解表明必须在配置时通过 bean 定义中的显式属性值或通过自动装配来填充受影响的 bean 属性。 如果尚未填充受影响的 bean 属性，则容器将引发异常。 避免以后出现 <code>NullPointerException</code> 实例等。</p><blockquote><p><code>@Required</code> 注解和 <code>RequiredAnnotationBeanPostProcessor</code> 从 Spring Framework 5.1 开始正式弃用，赞成使用构造函数注入进行所需设置（或 <code>InitializingBean.afterPropertiesSet 的自定义实现 ()</code> 或自定义 <code>@PostConstruct</code> 方法以及 bean 属性 setter 方法）</p></blockquote><h3 id="1-5-2-Autowired"><a href="#1-5-2-Autowired" class="headerlink" title="1.5.2. @Autowired"></a>1.5.2. @Autowired</h3><p>您可以将 <code>@Autowired</code> 注解应用于构造函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从 Spring Framework 4.3 开始，如果目标 bean 只定义了一个构造函数，则不再需要在这样的构造函数上添加 <code>@Autowired</code> 注解。 但是，如果有多个构造函数可用且没有主&#x2F;默认构造函数，则必须至少用 <code>@Autowired</code> 注解其中一个构造函数，以便指示容器使用哪一个。</p></blockquote><p>您还可以将 <code>@Autowired</code> 注解应用于 <em>传统</em> setter 方法，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以将注解应用于具有任意名称和多个参数的方法，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span><br><span class="line"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您也可以将 <code>@Autowired</code> 应用于字段，甚至将其与构造函数混合，如下例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以通过将 <code>@Autowired</code> 注解添加到需要该类型数组的字段或方法来指示 Spring 从 <code>ApplicationContext</code> 提供特定类型的所有 bean，如 以下示例显示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，当给定注入点没有匹配的候选 bean 可用时，自动装配失败。 对于声明的数组、集合或映射，至少需要一个匹配元素。</p><p>默认行为是将带注解的方法和字段视为指示所需的依赖项。 您可以更改此行为，如下例所示，通过将不可满足的注入点标记为非必需（即，通过在 <code>@ 自动连线</code>到<code>false</code>）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-Primary"><a href="#1-5-3-Primary" class="headerlink" title="1.5.3. @Primary"></a>1.5.3. @Primary</h3><ul><li><code>@Primary</code> 表示当多个 bean 是自动装配到单值依赖项的候选者时，应优先考虑特定 bean。 如果候选中恰好存在一个主要 bean，则它成为自动装配的值。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> MovieCatalog <span class="title function_">firstMovieCatalog</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MovieCatalog <span class="title function_">secondMovieCatalog</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-4-使用泛型作为自动装配限定符"><a href="#1-5-4-使用泛型作为自动装配限定符" class="headerlink" title="1.5.4. 使用泛型作为自动装配限定符"></a>1.5.4. 使用泛型作为自动装配限定符</h3><ul><li>可以用泛型和<code>@Autowired</code>搭配装配</li></ul><h3 id="1-5-5-Resource"><a href="#1-5-5-Resource" class="headerlink" title="1.5.5. @Resource"></a>1.5.5. @Resource</h3><p>Spring 还通过在字段或 bean 属性 setter 方法上使用 JSR-250 <code>@Resource</code> 注解 (<code>javax.annotation.Resource</code>) 来支持注入。</p><p>在没有指定显式名称的 <code>@Resource</code> 用法的唯一情况下，与 <code>@Autowired</code> 类似，<code>@Resource</code> 找到主要类型匹配而不是 一个特定的命名 bean 并解析众所周知的可解析依赖项：<code>BeanFactory</code>、<code>ApplicationContext</code>、<code>ResourceLoader</code>、<code>ApplicationEventPublisher</code> 和 <code>MessageSource</code> 接口。</p><h3 id="1-5-6-Value"><a href="#1-5-6-Value" class="headerlink" title="1.5.6. @Value"></a>1.5.6. @Value</h3><p><code>@Value</code> 通常用于注入外化属性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String catalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(<span class="meta">@Value(&quot;$&#123;catalog.name&#125;&quot;)</span> String catalog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.catalog = catalog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用以下配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>以及以下 <code>application.properties</code> 文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">catalog.name=MovieCatalog</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>catalog</code> 参数和字段将等于 <code>MovieCatalog</code> 值。</p><p>Spring 提供了一个默认的宽松嵌入值解析器。 它将尝试解析属性值，如果无法解析，则属性名称（例如 <code>$&#123;catalog.name&#125;</code>）将作为值注入。 如果你想对不存在的值保持严格的控制，你应该声明一个 <code>PropertySourcesPlaceholderConfigurer</code> bean，如下例所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PropertySourcesPlaceholderConfigurer <span class="title function_">propertyPlaceholderConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertySourcesPlaceholderConfigurer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Spring Boot 默认配置一个 <code>PropertySourcesPlaceholderConfigurer</code> bean，它将从 <code>application.properties</code> 和 <code>application.yml</code> 文件中获取属性。</p></blockquote><p>当 <code>@Value</code> 包含 <a href="https://geekdoc.top/docs/languages/java/spring-framework/5.3.11/reference/html/core.html#expressions"><code>SpEL</code> 表达式</a> 时，该值将在运行时动态计算，如下例所示：</p><ul><li>注：SpEL 表达式是 Spring 表达式语言</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String catalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(<span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;user.catalog&#x27;] + &#x27;Catalog&#x27; &#125;&quot;)</span> String catalog)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.catalog = catalog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-7-Component-和进一步的定型注解"><a href="#1-5-7-Component-和进一步的定型注解" class="headerlink" title="1.5.7. @Component 和进一步的定型注解"></a>1.5.7. @Component 和进一步的定型注解</h3><p><code>@Repository</code> 注解是任何实现存储库角色或构造型（也称为数据访问对象或 DAO）的类的标记。 此标记的用途之一是自动转换异常。</p><p>Spring 提供了更多构造型注解：<code>@Component</code>、<code>@Service</code> 和 <code>@Controller</code>。 <code>@Component</code> 是任何 Spring 管理的组件的通用构造型。</p><p><code>@Repository</code>、<code>@Service</code> 和 <code>@Controller</code> 是 <code>@Component</code> 的特化，用于更具体的用例（在分别为持久层、服务层和表示层）。因此，您可以使用 <code>@Component</code> 注解您的组件类，但是，通过使用 <code>@Repository</code>、<code>@Service</code> 或 <code>@ 注解它们Controller</code> 相反，您的类更适合由工具处理或与切面相关联。例如，这些构造型注解是切入点的理想目标。 <code>@Repository</code>、<code>@Service</code> 和 <code>@Controller</code> 还可以在 Spring Framework 的未来版本中携带额外的语义。因此，如果您在服务层使用 <code>@Component</code> 或 <code>@Service</code> 之间做出选择，<code>@Service</code> 显然是更好的选择。同样，如前所述，<code>@Repository</code> 已经被支持作为持久层中自动异常转换的标记。</p><h2 id="1-6-基于-Java-的容器配置"><a href="#1-6-基于-Java-的容器配置" class="headerlink" title="1.6. 基于 Java 的容器配置"></a>1.6. 基于 Java 的容器配置</h2><h3 id="1-6-1-Bean-和-Component"><a href="#1-6-1-Bean-和-Component" class="headerlink" title="1.6.1. @Bean 和@Component"></a>1.6.1. @Bean 和@Component</h3><p>Spring 的新 Java 配置支持中的核心工件是 <code>@Configuration</code> 注解类和 <code>@Bean</code> 注解方法。</p><p><code>@Bean</code> 注解用于指示一个方法实例化、配置和初始化一个由 Spring IoC 容器管理的新对象。 对于熟悉 Spring 的 &#96;&#96;XML 配置的人来说，<code> </code>@Bean<code>注解与元素扮演着相同的角色。 您可以将带有</code>@Bean<code>注解的方法与任何 Spring</code>@Component<code>一起使用。 然而，它们最常与</code>@Configuration&#96; bean 一起使用。</p><p>用 <code>@Configuration</code> 注解一个类表明它的主要目的是作为 bean 定义的来源。 此外，<code>@Configuration</code> 类允许通过调用同一类中的其他 <code>@Bean</code> 方法来定义 bean 间的依赖关系。 最简单的 <code>@Configuration</code> 类如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-Component-注解"><a href="#使用-Component-注解" class="headerlink" title="使用 Component 注解"></a>使用 Component 注解</h5><p><code>@Configuration</code> 是一个类级别的注解，表明一个对象是 bean 定义的来源。 <code>@Configuration</code> 类通过带有 <code>@Bean</code> 注解的方法来声明 bean。 对 <code>@Configuration</code> 类上的 <code>@Bean</code> 方法的调用也可用于定义 bean 间的依赖关系。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京大学2022春-黄骏老师史纲重点整理</title>
      <link href="/article/2022-history-review/"/>
      <url>/article/2022-history-review/</url>
      
        <content type="html"><![CDATA[<p>2022年春 黄骏老师班</p><blockquote><p>参考： 2018版教材、2021版教材、黄骏老师重点、腿姐背诵手册、xqh同学总结重点、2021年春同学总结重点、2020年学长学姐总结重点</p></blockquote><p>考试体验</p><ul><li>重点外的内容：戊戌变法的时间、南昌起义、抗日战争中的国际援助</li><li>大约20分重点外，80分重点内。书写量大，前面的题目给的空少、字多</li><li>90+不多，大部分同学在85 - 90之间。</li></ul><p>建议</p><ul><li>黄骏老师最近几年考题均有重点外内容，如有条件可以平时听课，黄骏老师讲课很有意思。如果平时没有听课，考前复习务必把课本过一遍，对重大历史事件和基本历史常识要有宏观把握。</li><li>背诵类课程建议画思维导图复习，本人同样整理有史纲思维导图，但由于格式受限便不放此，有需要的同学可以联系我</li><li>本人记忆力算平均水平，考试周用了4整天背诵、巩固、强化本重点的所有内容。此复习时间和强度供大家参考</li><li>黄骏老师的课有考勤，务必做好签到</li></ul><p><em><strong>整理不易，如果觉得有用，请支持公益</strong></em></p><div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220725222848913.png" alt="image-20220725222848913" style="zoom:50%;" /></div><p>思维导图（不完全、无内容版，需要整版请联系我）</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220725223756857.png" alt="image-20220725223756857"></p><h2 id="1-列强的入侵"><a href="#1-列强的入侵" class="headerlink" title="1. 列强的入侵"></a>1. 列强的入侵</h2><h3 id="方式方法"><a href="#方式方法" class="headerlink" title="方式方法"></a>方式方法</h3><p>（1）<strong>军事</strong>侵略：首先和主要的侵略方式<br>（2）<strong>政治</strong>控制： 控制中国政府或培植代理人，操纵中国的内政、外交。<br>（3）<strong>经济</strong>掠夺： 强迫中国支付巨额的战争赔款，利用其与清政府签订的不平等条约赋予的特权，进一步扩大对中国的商品倾销和资本输出<br>（4）<strong>文化</strong>渗透： 如目的是宣扬殖民主义奴化思想。</p><h3 id="几场重要的中外战争"><a href="#几场重要的中外战争" class="headerlink" title="几场重要的中外战争"></a>几场重要的中外战争</h3><ol><li><strong>鸦片战争( 1840 )</strong><ul><li><strong>名词解释：</strong>1840年至1842年英国对中国发动的一场非正义的侵略战争，也是中国近代屈辱史的开端。鸦片战争以中国失败并赔款割地告终。中英双方签订了中国历史上第一个丧权辱国不平等条约《南京条约》。中国开始失去了领土、领海、关税、司法主权，开始沦为半殖民地半封建社会。同时，鸦片战争也揭开了近代中国人民反抗外来侵略的历史新篇章。</li></ul></li></ol><ul><li><p>1840 年 4 月，英国国会通过对华战争的决定。同年 6 月，英国侵华舰队封锁了珠江海口和广东海面。鸦片战争正式爆发。</p></li><li><p><strong>开始沦为半殖民地半封建社会</strong>， 社会性质、主要矛盾、历史任务阶级关系开始变化</p></li><li><p><strong>第一个不平等条约（ 南京条约，1842）</strong>，之后还有中英（ 虎门条约，1843）、中美（望厦条约，1844）、中法（ 黄埔条约，1844）</p></li><li><p>已经开始失去了领土、领海、关税、司法主权</p><ul><li>割占香港岛，破坏了中国的主权和领土完整；外国船舰可在中国领海自由航行，破坏了中国的领海主权；外国人在华不受中国法律管束，享受领事裁判权，破坏了中国的司法主权；协定关税，则破坏了中国的关税主权</li></ul></li><li><p>民族意识开始在少数人中觉醒。</p></li><li><p>引起的反抗： 太平天国起义，而镇压太平天国起义又是洋务运动的首要原因。</p></li></ul><ol start="2"><li><p><strong>第二次鸦片战争（1856）</strong></p><ul><li><p><strong>名词解释：</strong>英、法两国在美、俄支持下联合发动的侵华战争。其目的是英、法为了进一步打开中国市场，扩大在华侵略利益。第二次鸦片战争期间，英法联军在强迫清政府签订《天津条约》《北京条约》的同时，表示愿意帮助清政府镇压太平天国，终于使清政府基本屈服。</p></li><li><p>第二次鸦片战争后，英、法各得赔款800万两白银。</p></li></ul></li><li><p><strong>甲午战争(1894一1895)</strong></p><ul><li><strong>名词解释：</strong>日本侵略中国和朝鲜的战争。最终中国战败，战后签订了《马关条约》，甲午战争标志着洋务运动的失败，给<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E6%B0%91%E6%97%8F/1186">中华民族</a>带来空前严重的民族危机，使中国进一步沦为半殖民地半封建社会，使得中国民族意识普遍觉醒；另一方面则使日本国力更为强大，为其跻身列强奠定了重要基础。</li></ul></li></ol><ul><li>进一步沦为半殖民地半封建社会</li><li>中日（ 马关条约〉，中国失去了台湾，列强以竞相租借港湾为起点，掀起了瓜分中国的狂潮</li><li>民族意识普遍觉醒（中日甲午战争以后，当中华民族面临生死存亡的关头时，中国人才开始有了普遍的民族意识的觉醒。）</li><li>标志着洋务运动的失败</li><li>引起的反抗：民族危亡、救亡， 维新运动(1898) 兴起</li></ul><ol start="3"><li>八国联军侵华(1900)<ul><li><strong>名词解释：</strong>1900年5月28日以英、俄、日、法、意、美、德、奥为首的八个主要国家组成的对中国的武装侵略战争。侵略军制造了众多惨案，并最终与中国签订《辛丑条约》，从此中国完全沦为半殖民地半封建社会。</li></ul></li></ol><ul><li><p>侵略军制造众多惨案：1900 年 8 月，八国联军侵占北京后，皇宫以及北海、中南海、颐和园等禁苑里的无数金银财宝、珍贵文物古籍遭到他们的肆意劫掠。日本侵略军还从户部银库掠去300万两库银。八国联军总司令、德国元帅瓦德西承认：“所有中国此次所受毁损及抢劫之损失，其详数将永远不能查出，但为数必极重大无疑。”1900 年，俄国入侵中国东北时，先后制造了海兰泡惨案和江东六十四屯惨案。同年8 月，八国联军侵占北京后，仅在庄王府一处，就烧死和杀死义和团团民与平民 1700 多人。</p></li><li><p>1900年八国联军侵华战争期间，欧美报刊纷纷公开讨论如何瓜分中国。</p></li><li><p>签订《辛丑条约》，中国完全沦为半殖民地半封建社会。</p></li><li><p>引起的反抗： 辛亥革命。</p></li></ul><h3 id="一系列不平等条约"><a href="#一系列不平等条约" class="headerlink" title="一系列不平等条约"></a>一系列不平等条约</h3><h4 id="中英《南京条约》"><a href="#中英《南京条约》" class="headerlink" title="中英《南京条约》"></a>中英《南京条约》</h4><ul><li><p>1842年</p></li><li><p>内容</p><ol><li>把香港岛割让给英国</li><li>向英国赔偿鸦片烟价、商欠、军费共二千一百万银元</li><li>五口通商，开放广州、福州、厦门、宁波、上海五处为通商口岸，允许英人居<br>住并设派领事</li><li>协定关税，英商应纳进出口货税、饷费，中国海关无权自主</li><li>废除公行制度，准许英商在华自由贸易等</li></ol></li><li><p>签订原因</p><ul><li>第一次鸦片战争失败</li></ul></li><li><p>后果</p><ul><li>中国开始沦为半殖民地半封建社会；破坏了原有的自给自足的自然经济体系，促进了资本主义的发展——半殖民地半封建经济体系</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611151709794.png" alt="image-20220611151709794"></p><h4 id="中俄边境诸约"><a href="#中俄边境诸约" class="headerlink" title="中俄边境诸约"></a>中俄边境诸约</h4><ol><li>1858 年俄国胁迫黑龙江将军奕山与之签订《瑷珲条约》，割去黑龙江以北 60<br>万平方公里领土</li><li>1860 年，俄国通过签订中俄《北京条约》，割去乌苏里江以东40万平方公里领<br>土</li><li>1864 年，俄国强迫清政府签订《勘分西北界约记》，割去中国西北 44 万平方<br>公里领土</li><li>1881年，通过《改订伊犁条约》和 5 个勘界议定书，割去中国西北 7 万多平方<br>公里领土</li><li>通过这一系列不平等条约，俄国共侵占中国领土 150 多万平方公里</li></ol><h4 id="中俄、美、英、法《天津条约》"><a href="#中俄、美、英、法《天津条约》" class="headerlink" title="中俄、美、英、法《天津条约》"></a>中俄、美、英、法《天津条约》</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611152353606.png" alt="image-20220611152353606"></p><h4 id="中英、中法《北京条约》"><a href="#中英、中法《北京条约》" class="headerlink" title="中英、中法《北京条约》"></a>中英、中法《北京条约》</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611152328498.png" alt="image-20220611152328498"></p><h4 id="中日《马关条约》"><a href="#中日《马关条约》" class="headerlink" title="中日《马关条约》"></a>中日《马关条约》</h4><p>1895年</p><ul><li><p>内容</p><ul><li>中国割让辽东半岛（后因三国干涉还辽而未能得逞）、台湾岛及其附属各岛<br>屿、澎湖列岛给日本</li><li>中国赔偿 2 亿两白银，加上“赎辽费”3000 万两，威海卫日军“守备费”150<br>万两，共 23150 万两</li><li>增开沙市、重庆、苏州、杭州为商埠，并允许日本在中国的通商口岸投资办厂</li></ul></li><li><p>签订原因</p><ul><li>甲午中日战争失败（1894年）</li></ul></li><li><p>后果</p><p>①台湾等大片领土的割让，进一步破坏了中国主权的完整，刺激了列强瓜分中国的野心，民族危机进一步加深。而且还造成了台湾和大陆难以弥补的隔阂，遗患至今。</p><p>②巨额赔款，加重了中国人民的负担。同时，加速了日本军国主义的发展，刺激其侵略野心。清朝因此大借外债，致使列强控制了中国的经济命脉。</p><p>③通商口岸开放，使帝国主义侵略势力深入到中国内地，中国民族危机空前严重，半殖民地化程度大大加深。</p><p>④该条约适应了帝国主义列强对华资本输出的需要，随后列强掀起了瓜分中国的狂潮。允许在华投资办厂，其他列强引用“利益均沾”的条款，争先恐后地在中国开设工厂，严重阻碍了中国民族资本主义的发展。同时也反映出列强对华经济侵略由商品输出到资本输出的过程。</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611152145246.png" alt="image-20220611152145246"></p><h4 id="《辛丑条约》"><a href="#《辛丑条约》" class="headerlink" title="《辛丑条约》"></a>《辛丑条约》</h4><p>1901年</p><ul><li><p>内容</p><ul><li>中国应支付赔款额 4.5 亿两白银，分 39 年还清，本息共计 10 亿两，并以关税<br>和盐税等作抵押</li></ul><ol start="2"><li>划定北京东交民巷为使馆界，允许各国驻兵保护，不准中国人在界内居住</li><li>拆毁天津大沽口到北京沿线设防的炮台，允许列强各国派驻兵驻扎北京到山海<br>关铁路沿线要地</li><li>清政府保证严禁人民参加反帝运动</li><li>外国认为各个通商章程中应修之处或其他应办的通商事项，清政府概允商议</li><li>惩办“首祸诸臣”</li><li>改总理各国事务衙门为外务部，班列六部之前</li><li>清政府对德、日道歉</li></ol></li><li><p>签订原因</p><ul><li>八国联军侵华（1900年）</li></ul></li><li><p>后果</p><ul><li>《辛丑条约》的签订，进一步加强了帝国主义对中国的全面控制和掠夺， 表明清政府已完全成为帝国主义统治中国的工具，标志着中国已完全沦为半殖民地半封建社会。</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611152153485.png" alt="image-20220611152153485"></p><h2 id="2-早期的维新思想"><a href="#2-早期的维新思想" class="headerlink" title="2. 早期的维新思想"></a>2. 早期的维新思想</h2><p>P40</p><h3 id="鸦片战争前后"><a href="#鸦片战争前后" class="headerlink" title="鸦片战争前后"></a>鸦片战争前后</h3><p>(1) <strong>林则徐</strong>： 他组织翻译西方书刊，编成<strong>《四洲志》</strong>， 睁眼看世界第一人。<br>(2) <strong>魏源</strong>： 《海国图志》，<strong>师夷长技以制夷</strong>。主张学习外国先进的<strong>军事和科学</strong>技术。<br>(3) <strong>郑观应</strong>(19世纪70年代后）： 不仅主张学习西方的科学技术．同时<strong>也要求吸纳西方的政治、经济学说</strong>。（具有比较强烈的反对外国侵略、希望中国独立富强的爱国思想以及具有一定程度反对封建专制的民主思想；在《盛世危言》中提出大力发展民族工商业，同西方国家进行“商战”，设立议院，实行“君民共主”制度等主张。这些主张具有重要的思想启蒙的意义。）</p><h3 id="甲午战争后：-救亡思想"><a href="#甲午战争后：-救亡思想" class="headerlink" title="甲午战争后： 救亡思想"></a>甲午战争后： 救亡思想</h3><p>(1) <strong>严复</strong>： 喊出<strong>“救亡”</strong>口号。用“物竞天择“ “适者生存”的社会进化论思想，为这种危机意识和民族意识提供了理论根据。<br>(2) <strong>孙中山</strong>喊出了“<strong>振兴中华</strong>”的时代最强音</p><p>(3) <strong>梁启超，康有为</strong>: <strong>救亡图存和振兴中华</strong></p><h2 id="3-太平天国运动失败的原因"><a href="#3-太平天国运动失败的原因" class="headerlink" title="3. 太平天国运动失败的原因"></a>3. 太平天国运动失败的原因</h2><p>P47</p><p>(1) <strong>农民不是先进生产力的代表，具有小农局限性</strong>（根本原因） ，因而无法从根本上<br>提出完整的、正确的政治纲领和社会改革方案。<br>(2) 后期领导集团腐败分裂，领导集团的一些人在生活上追求享乐，在政治上争权夺利。<br>(3) 太平天国在<em><em>军事战略上出现了巨大失误</em><br>(4) <strong>没有科学指导思想</strong>。指导思想即</em>*拜上帝教教义**不能指导甚至误导斗争</p><p>(5) <strong>未能正确对待儒学</strong>，笼统排斥或保留糟粕</p><p>(6) <strong>对西方侵略者没有达到理性认识</strong>。对资本主义侵略性认识不足</p><ul><li>太平天国起义及其失败表明，在半殖民地半封建的中国，农民具有伟大的革命潜力；但它自身不能担负起领导反帝反封建斗争取得胜利的重任。单纯的农民战争不可能完成争取民族独立和人民解放的历史任务。</li></ul><blockquote><ol><li>阶级限制，缺少理论和纲领</li><li>领导集团腐败分裂</li><li>军事战略失误</li><li>宗教限制性，不能指导甚至误导斗争</li><li>未能正确对待传统儒学，笼统排斥或保留糟粕</li><li>未能正确分析敌我态势，对资本主义侵略性认识不足</li></ol></blockquote><h2 id="4-洋务运动的历史作用"><a href="#4-洋务运动的历史作用" class="headerlink" title="4. 洋务运动的历史作用"></a>4. 洋务运动的历史作用</h2><p>P50</p><p>(1) <strong>促进早期工业和民族资本主义发展</strong>。（提出自强求富的主张，集中力量优先发展军事工业。发展民用企业）<br>(2)<strong>开启中国近代教育</strong>，开阔视野和眼界。（开办新式学堂，官派留学生，翻译自然科学书籍）</p><p>(3) <strong>使社会风气和价值观念开始变化</strong>。有利于资本主义经济发展和社会风气的改变。</p><p>(4) <strong>是中国近代化的开端</strong>。</p><blockquote><ol><li>促进早期工业和民族资本主义发展</li><li>开启中国近代教育，利用近代自然科学开阔眼界</li><li>冲击传统观念，有利于资本主义经济发展，改变社会风气</li></ol></blockquote><h2 id="5-戊戌变法的内容和意义"><a href="#5-戊戌变法的内容和意义" class="headerlink" title="5. 戊戌变法的内容和意义"></a>5. 戊戌变法的内容和意义</h2><p>P55</p><p>1898年</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ol><li>政治方面：改革行政机构，裁撤闲散、重叠机构；裁汰冗员，澄清吏治，提倡<br>廉政；提倡向皇帝上书言事；准许旗人自谋生计，取消他们享受国家供养的特<br>权。（但是，<strong>在光绪皇帝发布的新政诏令中，并没有采纳维新派多次提出的开</strong><br><strong>国会等政治主张。这些政令和措施并未触及封建制度的根本，所要推行的是一</strong><br><strong>种十分温和的不彻底的改革方案。</strong>）</li><li>经济方面：保护、奖励农工商业和交通采矿业，中央设立农工商总局与铁路矿<br>务总局，各省设立商务局；提倡开办实业，奖励发明创造；注重农业发展，提<br>倡西法垦殖，建立新式农场；广办邮政，修筑铁路；开办商学、商报，设立商<br>会等各类组织；改革财政，编制国家预决算。</li><li>军事方面：裁减旧式绿营兵，改练新式陆军；采用西洋兵制，练洋操，习洋枪<br>等。</li><li>文化教育方面：创设京师大学堂，各省书院改为高等学堂，在各设立中、小<br>学堂；提倡西学，废除八股，改试策论，开经济特科；设立译书局，翻译外国<br>书籍，派人出国留学；奖励新著，奖励创办报刊，准许自由组织学会。</li></ol><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>P56</p><p>(1) 戊戌维新运动是一次<strong>爱国救亡运动</strong>，推动了中华民族的觉醒。<br>(2) 戊戌维新运动是一场<strong>资产阶级性质的政治改革运动</strong>， 在政治、经济等领域一定程度上<strong>冲击了封建制度</strong>。<br>(3) 戊戌维新运动是一场<strong>思想启蒙运动</strong>。 宣传自由平等、社会进化观念、批判封建君权以及封建伦理、促进了民主思想的传播；</p><p>(4)对中国近代教育的发展起了积极的推动作用。维新派主张采用西方近代教育制度，兴办新式学堂。</p><p>(5) 戊戌变法在<strong>改革社会风习方面也提出新的主张</strong>。比如主张废除各处吸食鸦片及妇女裹足等恶俗陋习</p><h2 id="6-（清末）革命和改良的辩论"><a href="#6-（清末）革命和改良的辩论" class="headerlink" title="6. （清末）革命和改良的辩论"></a>6. （清末）革命和改良的辩论</h2><p>P66</p><h3 id="为什么辩"><a href="#为什么辩" class="headerlink" title="为什么辩"></a>为什么辩</h3><p>20世纪初我国民族危机加深，社会矛盾激化，清政府已陷入无法照旧统治下去的境地，以孙中山等为首的资产阶级革命派迅速发展壮大。在资产阶级民主革命思潮广泛传播、革命形势日益成熟的时候，<strong>康有为、梁启超</strong>等人坚持走改良道路，反对用革命手段推翻清朝统治。&#x2F;&#x2F; <strong>1905 年至 1907 年</strong>间，围绕中国究竟是采用革命手段还是改良方式这个问题，革命派与改良派展开了一场大论战。</p><h3 id="辩什么"><a href="#辩什么" class="headerlink" title="辩什么"></a>辩什么</h3><ul><li><strong>要不要以革命手段推翻清王朝（ 核心）</strong><ul><li>改良派：革命会引起下层社会暴乱，招致外国的干涉、瓜分。不能革命，只能改良、立宪。</li><li>革命派：<ol><li>清政府是帝国主义的“鹰犬”，只有通过革命，才能“免瓜分之祸”，获得民族独立和社会进步。</li><li>与革命的牺牲相比，不革命下，清王朝统治给人民带来的牺牲更大</li><li>人们在革命过程中的付出，是以换取历史的进步作为补偿的。革命本身正是为了建设，破坏与建设是革命的两个方面。</li></ol></li></ul></li><li><strong>要不要推翻帝制，实行共和。</strong><ul><li>改良派：中国“国民恶劣”“智力低下”，没有实行民主共和政治的能力。因此，只能实行君主立宪。</li><li>革命派：不是“国民恶劣”，而是“政府恶劣”。民主共和是大势所趋，人心所向。只有“兴民权改民主”，才是中国的唯一出路。</li></ul></li><li><strong>要不要进行社会革命。</strong><ul><li>改良派：反对土地国有，反对平均地权。他们认为土地问题不是中国最重要的问题，不存在社会革命的可能。社会革命只会导致中国的大动乱。主张土地国有是危害国本，并表示在这个问题上“宁死不让”。</li><li>革命派：中国存在着严重的“地主强权”“地权失平”的现象。必须通过平均地权以实现土地国有，在进行政治革命的同时实现社会革命，才能避免贫富不均等社会问题的岀现。</li></ul></li></ul><h3 id="什么人在辩"><a href="#什么人在辩" class="headerlink" title="什么人在辩"></a>什么人在辩</h3><ul><li><p><strong>资产阶级革命派（孙中山等人）</strong>和<strong>资产阶级改良派（康、梁等坚持走改良道路的人）</strong>。是<strong>同一阶级内部不同派别的论战</strong>。</p></li><li><p>注意与维新运动的第一次论战相比较。</p><ul><li>两次论战相同点是内容都为3 个方面，维新派都参与了论战。</li><li>两次论战的不同点是第一次为不同阶级的论战，即资产阶级思想与封这主义思想在中国的笫一次正面交锋；第二次为同一阶级内部不同派别的论战。记住“革命派“永远是主张民主、革命、共和即可。</li></ul></li></ul><h2 id="7-同盟会"><a href="#7-同盟会" class="headerlink" title="7. 同盟会"></a>7. 同盟会</h2><p>P64</p><h3 id="兴起"><a href="#兴起" class="headerlink" title="兴起"></a>兴起</h3><ul><li><strong>名词解释</strong>：于<strong>1905年</strong>、孙中山、黄兴等人以<strong>兴中会</strong>和<strong>华兴会</strong>为基础在日本成立，同盟会以<strong>《民报》为机关报</strong>，是近代中国第一个领导<strong>资产阶级革命的全国性政党</strong>，标志着中国资产阶级民主革命进入新阶段。政治纲领是<strong>“驱除鞑虏，恢复中华，创立民国，平均地权”</strong>。孙将纲领概括为三民主义：民族，民权，民生</li></ul><blockquote><p>但是，同盟会纲领中的民族主义没有从正面鲜明地提出反对帝国主义的主张。当时的革命派对于帝国主义的本质认识不清，害怕帝国主义干涉，甚至幻想以承认不平等条约“继续有效”为条件来换取列强对自己的支持。同时，他们也没有明确地把汉族军阀、官僚、地主作为革命对象，从而给了这部分人后来从内部和外部破坏革命以可乘之机。</p></blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>1894年11月，孙在檀香山组建了第一个革命团体兴中会</li><li>1895年，孙在广州策划武装起义，失败后流亡海外，继续从事反清革命活动</li><li>在资产阶级革命思想的传播过程中，资产阶级革命团体也在各地次第成立。从1904年开始，出现了十多个革命团体，其中最重要的有华兴会、科学补习所、光复会、岳王会等。</li></ul><h2 id="8-辛亥革命"><a href="#8-辛亥革命" class="headerlink" title="8. 辛亥革命"></a>8. 辛亥革命</h2><p>P68</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li>爆发于1911年，辛亥革命是<strong>资产阶级领导</strong>的以<strong>反对封建君主专制制度、建立资产阶级共和国为目的的革命</strong>，是一次比较完全意义上的资产阶级民主革命。</li><li>在近代历史上，辛亥革命是中国人民为救亡图存、振兴中华而奋起革命的一个里程<br>碑，它使中国发生了历史性的巨变，具有伟大的历史意义。</li><li>1911 年 10 月 10 日晚，<strong>武昌首义</strong>取得胜利，之后，清王朝迅速土崩瓦解。1912 年 2 月 12 日，清帝被迫退位。在中国延续了两千多年的封建帝制终于覆灭。、</li><li>中华民国临时政府宣告成立 1911 年底，孙中山被选举为临时大总统。1912 年 1 月 1 日，孙中山在南京宣誓就职，改国号为中华民国，定 1912 年为民国元年，并成立中华民国临时政府。</li><li>1912 年 3 月，临时参议院颁布《中华民国临时约法》（以下简称《临时约法》）。<br>这是中国历史上第一部具有资产阶级共和国宪法性质的法典。</li></ul><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><ul><li><strong>民族危机加深，社会矛盾激化。</strong>20世纪初，帝国主义列强在迫使中国签订《辛丑条约》，中国彻底沦为半殖民半封建社会。中国人民为救亡图存而前赴后继的顽强斗争</li><li>清末“新政“破产预备立宪并没有能够挽救清王朝，反而激化了社会矛盾，加重了危机。主要原因在于，清政府改革的根本目的是延续其反动统治。</li><li><strong>民族资本主义初步发展，形成了资产阶级革命派</strong>， 其骨干是一批资产阶级、小资产阶级知识分子</li></ul><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li>民主、共和、革命</li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>民族资产阶级领导的、比较完整的、真正意义上的资产阶级民主革命</li></ul><h3 id="意义-1"><a href="#意义-1" class="headerlink" title="意义"></a>意义</h3><p>(1) 是中国人民<strong>为救亡图存、振兴中华</strong>而奋起革命的一个里程碑，它使中国发生了历史性的巨变，具有伟大的历史意义。<br>(2) <strong>推翻了</strong>封建势力的政治代表、帝国主义在中国的代理人清王朝的统治，沉重打击了中外反动势力。<br>(3) <strong>结束了中国两千多年封建杜会的君主专制制度</strong>，建立了中国历史上第一个资产阶级共和政府，使民主共和的观念开始深入人心<br>(4)推动了中国人民的<strong>思想解放</strong>，激发了人民的爱国热悄和民族觉醒，打开了思想进步的闸门。<br>(5)推动了中国的<strong>社会变革</strong>， 促使中国的社会经济、思想习惯和社会风俗等方面发生了新的积极变化。<br>(6)不仅在一定程度上打击了帝国主义的侵略势力，而且推动了亚洲各国民族解放运动的高涨。</p><h3 id="失败原因"><a href="#失败原因" class="headerlink" title="失败原因"></a>失败原因</h3><p>(1) 从根本上说：在帝国主义时代．在半殖民地半封建的中国，<strong>资本主义的建国方案是行不通的</strong><br>(2) 主观方面来说：<strong>资产阶级革命派本身有许多弱点和错误</strong>（根源于民族资产阶级的软弱性． 妥协性）</p><h2 id="9-五四运动"><a href="#9-五四运动" class="headerlink" title="9. 五四运动"></a>9. 五四运动</h2><p>P106，108</p><p><strong>名词解释</strong>：是1<strong>919年5月4日</strong>发生在北京的一场以青年学生为主，广大群众、市民、工商人士等阶层共同参与的，通过<strong>示威游行、罢工等多种形式进行的爱国运动</strong>。五四运动的直接导火索是巴黎和会的外交失利，1919年5月4日北京学生在天安门前游行示威，1919年6月5日起，上海工人开始罢工抗议。最终迫于人民群众的压力，北洋政府不得不罢免亲日派官僚曹汝霖等的职务。中国政府代表也没有出席巴黎和约的签字仪式。五四运动的直接斗争目标得到了实现。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li><strong>巴黎和会的外交失利（直接导火线）</strong>——<strong>北京学生游行示威</strong>（<strong>1919年5月4日</strong>，北京大学等十几所学校的学生在天安门前示威游行）——<strong>上海工人罢工抗议</strong>（1919年6月5日起）—— 迫于人民群众的压力，北洋政府不得不于 6 月 10 日宣布罢免亲日派官僚曹汝霖、章宗祥、陆宗舆的职务。6 月 28 日，中国政府代表也没有出席巴黎和约的签字仪式。五四运动的直接斗争目标得到了实现。</li><li>(1) 参与人： 学生群众，后来发展为有工人阶级、小资产阶级和资产阶级参加的全国范割的革命运动。<br>(2) 两个转向：斗争的主力由学生转向了工人，运动的中心由北京转到了上海。</li></ul><h3 id="意义-2"><a href="#意义-2" class="headerlink" title="意义"></a>意义</h3><ul><li><p>1.一次彻底的<strong>反帝反封建运动</strong></p><p>2.一次真正的<strong>群众运动</strong></p><p>3.促进了<strong>马克思主义在中国的传播</strong>以及与工人运动的结合——为共产党的成立作了思想以及干部上的准备</p><p>4.<strong>新民主主义革命的开端</strong></p></li></ul><h2 id="10-中国共产主义革命"><a href="#10-中国共产主义革命" class="headerlink" title="10. 中国共产主义革命"></a>10. 中国共产主义革命</h2><ul><li><p>（重点）</p></li><li><p>国民大革命（1925 - 1927） </p></li><li><p>土地革命时期（1927 - 1937）</p><ul><li>1927 - 南昌起义<ul><li>打响了武装反抗国民党反动统治的第一枪。建军的开始，党指挥枪原则的发端。</li></ul></li><li>1927 - 秋收起义<ul><li>第一次公开打出“工农革命军”的旗帜，之后创建井冈山革命根据地</li></ul></li><li>1927 - 广州起义<ul><li>对国民党屠杀政策的英勇反击</li></ul></li></ul></li><li><p>八七会议（1927年）</p><p>(1) 彻底清算了陈独秀右倾机会主义错误。<br>(2) 确定了土地革命和武装反抗国民党反动统治的总方针， 会议还提<br>出了“整顿改编自己的队伍，纠正过去严重的错误，而找着新的道路”的<br>任务。<br>(3) 会议选出了以撒秋白为首的中央临时政治局（毛泽东在会上提<br>出：枪杆子里出政权）</p></li><li><p>古田会议（1929年）</p><p>(1) 确立了思想建党、政治建军原则． 必须绝对服从共产党的领导，必须担负打仗、筹款和做群众工作的任务，必须加强政治工作。<br>(2) 强调必须加强思想和政治路线的教育．纠正党内的错误思想<br>(3) 古田会议决议创造性地解决了在农村环境中、在党组织和军队以农民为主要成分的环境下，如何从加强思想建设入手，保待党的无产阶级先锋队性质和建设党领导的新型人民军队的问题｀这是人民军队完全区别与一切旧军队的政治特质和根本优势， 对于中国革命新道路的开辟和坚持具有重要的意义。</p></li><li><p>中国共产党建立政权：</p><ul><li>1931 年11 月成立了中华苏维埃共和国临时中央政府，毛泽东当选为主席。中华苏维埃共和国实行工农兵代表大会制度。</li></ul></li><li><p>遵义会议</p><p>(1) 解决了当时具有决定意义的军事问题和组织问题。由张闻天代替博古负总的责任，成立了由周恩来、毛泽东、王稼祥组成的新的“ 三人团”，全权负责红军的军事行动。<br>(2) 标志着中国共产党在政治上走向成熟： 同共产国际的联系中断的情况下独立自主地作出的决策。<br>(3) 开始确立以毛泽东为代表的马克思主义的正确路线在中共中央的领导地位<br>(4) 挽救了中国共产党、挽救了中国工农红军、挽救了中国革命，是中国共产党历史上一个生死攸关的转折点。</p></li></ul><h3 id="长征"><a href="#长征" class="headerlink" title="长征"></a>长征</h3><p>P143</p><p><strong>名词解释</strong>：土地革命战争时期，<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E5%B7%A5%E5%86%9C%E7%BA%A2%E5%86%9B/425591">中国工农红军</a>主力撤离长江南北各苏区，转战两年，到达陕甘苏区的战略转移行动。</p><p><strong>1934年10月</strong>，第五次反“围剿”失败后，中央主力红军为摆脱国民党军队的包围追击，被迫实行战略性转移，退出中央根据地，进行长征。</p><ul><li><p>缘起</p><ul><li>国民党从1930 年起， 下令＂困剿”革命根据地。前四次反“ 围剿”在毛泽东指挥下，取得了胜利。<strong>但是第五次反“围剿”由于执行了以王明为代表的“左”倾教条主义路线而失败，最后不得不进行战略转移——长征。</strong></li></ul></li><li><p>经过</p><ul><li>1934年10月，第五次反“围剿”失败后，中央主力红军为摆脱国民党军队的包围追击，被迫实行战略性转移，退出中央根据地，进行长征。</li><li>长征的两次会师<br>( 1 ) 1935年11 月初，中央红军在陕北吴起镇同红十五军团会合，中国共产党所领导的革命力县有了新的落脚点和战略基地。至此，中央红军的<strong>二万五千里</strong>长征胜利结束。<br>( 2) 1936年10月，红二、四方面军先后同红一方面军在甘肃会宁、静宁将台堡（今屈宁夏回族自治区）会师。至此， 三大主力红军的长征胜利结束。</li></ul></li><li><p><strong>长征的意义</strong><br>(1) 宣告了国民党反动派消灭中国共产党和红军的图谋彻底失败。<br>(2) 宣告了中国共产党和红军肩负着民族希望顺利实现了北上抗日的战略转移。<br>(3) 实现了中国共产党和中国革命事业从挫折走向胜利的伟大转折。</p></li><li><p>为什么叫长征</p><ul><li><strong>二万五千里</strong>长征</li></ul></li></ul><h2 id="11-抗日战争中日本方面"><a href="#11-抗日战争中日本方面" class="headerlink" title="11. 抗日战争中日本方面"></a>11. 抗日战争中日本方面</h2><ul><li>（重点）</li></ul><h3 id="918事变"><a href="#918事变" class="headerlink" title="918事变"></a>918事变</h3><p><strong>名词解释</strong>：1931年9月18日日本关东军突然袭击沈阳，以武力侵占东北的事件。是日本帝国主义侵华的开端。九·一八事变也标志着世界反法西斯战争的起点，揭开了第二次世界大战东方战场的序幕</p><p>1931年9月18日——关东军——柳条湖——炮轰北大营（炸毁沈阳柳条湖附近日本修筑的南满铁路路轨，并嫁祸于中国军队，日军以此为借口，炮轰中国东北军北大营）</p><p>蒋介石——攘外必先安内——使得日本侵略者更加肆无忌惮地进攻中国</p><h3 id="华北事变"><a href="#华北事变" class="headerlink" title="华北事变"></a>华北事变</h3><p><strong>名词解释</strong>：1935 年日本侵略军蚕食侵犯华北地区的一系列事件的统称，日本在华北制造一系列事端，向中国政府提出使华北政权“特殊化”的要求。中国政府在<strong>河北、察哈尔</strong>两省的主权大部丧失，华北成为日军可以自由岀人的“真空地带”。接着，日方又策动<strong>华北五省</strong>（河北、察哈尔、绥远、山西、山东）<strong>两市</strong>（北平、天津）“防共自治运动”，制造傀儡政权。</p><h3 id="卢沟桥事变"><a href="#卢沟桥事变" class="headerlink" title="卢沟桥事变"></a>卢沟桥事变</h3><ul><li><p><strong>名词解释</strong>：1937 年 7 月 7 日，驻丰台日军一个中队在卢沟桥以北举行军事演习。日军借口一名士兵失踪，要求进入宛平县城搜查，遭到拒绝后，即炮轰宛平城，向卢沟桥的中国驻军进攻。日本全面侵华战争由此开始。</p></li><li><p>1937年7月7日——宛平，驻丰台日军</p><p>“七七事变”是全民族抗战的开始，在东方开辟了世界第一个大规模的反法西斯战场</p><p>（1937.7.7夜，驻丰台日军一中队在卢沟桥以北举行军事演习。日军借口一名士兵失踪，要求进入宛平县城搜查，遭拒后，炮轰宛平城，进攻中国驻军。日本全面侵华战争由此开始。）</p></li></ul><h2 id="12-抗日战争中中国方面"><a href="#12-抗日战争中中国方面" class="headerlink" title="12. 抗日战争中中国方面"></a>12. 抗日战争中中国方面</h2><h3 id="抗日民族统一战线"><a href="#抗日民族统一战线" class="headerlink" title="抗日民族统一战线"></a>抗日民族统一战线</h3><p>P157</p><ul><li>形成过程<ul><li>1.<strong>九一八事变</strong>后，抗日救亡运动在全国兴起。</li><li>（华北事变后，中日民族矛盾进一步激化。在中国共产党关于救亡图存、全民抗战的号召和中共地下党组织的领导下，1935 年 12 月 9 日，北平学生举行声势浩大的抗日游行，喊出“反对华北自治”、“打倒日本帝国主义”、“停止内战，一致对外”等口号，遭到国民党军警镇压。12 月 16 日，北平学生和市民一万多人在天桥召开市民大会。会后，举行了更大规模的示威游行。）</li><li>2.<strong>华北事变后</strong>，中日民族矛盾进一步激化，<strong>1935年</strong>爆发<strong>一二·九</strong>运动。它促进了中华民族的觉醒，标志着中国人民抗日救亡运动新高潮的到来。</li><li>3.<strong>1935年12月</strong>，中共中央在<strong>瓦窑堡会议</strong>中，提出了在抗日的条件下与民族资产阶级重建统一战线的新政策。抗日民族统一战线正式被提出</li><li>4.<strong>1936年12月</strong>，<strong>西安事变的和平解决</strong>： 成为时局转换的枢纽。十年内战的局面由此结束，国内和平基本实现</li><li>5.<strong>1937年2月</strong> 中共中央致电<strong>国民党五届三中全会</strong>， 提出停止内战、一致对外等五项要求。全会表示同意国共两党进行谈判， 并在会议文件上第一次写上了“抗日”的字样。</li><li>6.<strong>1937年 七七事变</strong>爆发第二天，中国共产党通电全国，号召全中国同胞团结起来抵抗日本侵略。8月，国共两党达成将红军主力改编成国民革命军<strong>第八路军</strong>（简称八路军，不久改称第十八集团军）等协议。</li><li>7.<strong>1937年9月</strong>，<strong>《中共中央为公布国共合作宣言》</strong>发表；蒋介石发表实际承认共产党合法地位的谈话，以国共两党第二次合作为基础的抗日民族统 一战线正式形成</li></ul></li></ul><h3 id="西安事变"><a href="#西安事变" class="headerlink" title="西安事变"></a>西安事变</h3><ul><li>缘起和过程<ul><li>蒋介石他于 <strong>1936 年 12 月</strong>初到达西安，逼迫张学良、杨虎城攻打陕甘的红军。12 日凌晨，<strong>张学良、杨虎城</strong>（在对蒋介石“哭谏”无效的情况下，）为了实现停止内战、共同抗日，（毅然实行“兵谏”，）<strong>扣留了蒋介石</strong>。这就是西安事变。</li><li>中国共产党派周恩来等到西安，并参加张、杨同南京方面代表宋美龄、宋子文的和平谈判。蒋介石被迫作出了<strong>停止“剿共”、联合红军抗日</strong>等六项承诺。</li></ul></li><li>历史作用<ul><li>西安事变的和平解决成为<strong>时局转换的枢纽</strong>，十年内战的局面由此结束，<strong>国内和平基本实现</strong>。</li></ul></li></ul><h2 id="13-论持久战"><a href="#13-论持久战" class="headerlink" title="13. 论持久战"></a>13. 论持久战</h2><p>P162</p><ul><li>什么背景下写作<ul><li>抗日战争是一场弱国对强国的战争，战争的基本走势怎样？应当坚持什么样的战略方针？这是必须首先回答的一个重要问题</li><li><strong>1938 年</strong> 5 月至 6 月间，毛泽东发表《论持久战》的讲演，总结抗战 10 个月来的经验，系统地阐明了持久抗战的总方针。</li></ul></li><li>内容<ul><li>日本强，中国弱，<strong>强弱对比决定了抗战只能是持久战</strong></li><li>日本是<strong>小国</strong>，发动的是<strong>退步、野蛮</strong>的侵略战争，中国是<strong>大国</strong>，进行的是<strong>进步的、正义</strong>的反侵略战争，中国已经有了代表中华民族和中国人民根本利益的、在政治上成熟的中国共产党及其领导的抗日根据地和人民军队，<strong>最后胜利将属于中国</strong></li><li>强调“<strong>兵民是胜利之本</strong>”，战胜日本的侵略，必须进行人民战争</li><li>科学<strong>预测</strong>了抗日战争的<strong>发展进程</strong>：战略防御——战略相持——战略反攻<strong>三个阶段</strong></li><li>揭示了抗战的<strong>发展规律</strong>和<strong>坚持抗战争取胜利必须实行</strong>的战略方针，对全国抗战的战略指导起到了积极作用</li></ul></li></ul><h2 id="14-重庆谈判"><a href="#14-重庆谈判" class="headerlink" title="14. 重庆谈判"></a>14. 重庆谈判</h2><p>P183 P185</p><ul><li><p>缘起</p><ul><li>战后的政治形势，总的说来，对中国人民实现建设新中国的目标是有利的。在国际上，帝国主义遭到削弱，社会主义国家、民族解放运动的力量有了新的发展，世界反动势力已经难以集中起来干涉中国革命。在国内，中国人民的觉悟程度、组织程度空前提高，经过整风学习，中国共产党在毛泽东思想的基础上达到了高度的团结。中国人民克服一切困难，实现其基本历史要求的时机已经到来。</li><li>国民党统治集团作为大地主、大资产阶级的政治代表，其根本目标是使战后的中国回复到战前的状态，即坚持蒋介石的独裁统治，继续走半殖民地半封建社会的老路。由于中国共产党及其领导的人民革命力量的存在和发展，是它实现上述目标的主要障碍，还在抗战的中期、后期，蒋介石就开始采取避战观战以便保存实力、准备发动反共内战的方针。抗战刚胜利，中国就面临着内战的危险。</li><li>以武力消灭共产党及其领导的人民军队和解放区政权，是蒋介石集团的既定方针。由于全国人民强烈要求和平、反对内战，由于国民党的军队大部分远在西南、西北后方，要把它们运往内战前线、完成内战部署需要相当的时间，由于国际上苏联、美国等都表示希望中国能够实行和平建国，因此，蒋介石在积极准备内战的同时，又表示愿意与中共进行和平谈判。（其目的，一是以此敷衍国内外舆论，掩盖其正在进行的内战准备；二是诱使中共交出人民军队和解放区政权，以期不战而控制全中国；三是如果谈判不成，即放手发动内战，并把战争责任转嫁给中国共产党。）</li><li>国民党的反共方针得到了美国政府的支持。</li><li>中国共产党争取和平民主的方针<ul><li>中国共产党曾经希望通过和平的途径对中国进行政治社会的改革，逐步向建设新中国这个目标迈进。因为，中国人民在经历了长期的战争之后，有和平建国的强烈要求，中国共产党应当充分考虑人民群众的这种愿望。同时，由于人民力量强大，加上其他条件，中国共产党估计，造成国共两党合作（加上民主同盟等）、和平发展的新阶段的可能性是存在的。中国共产党应当努力争取中国出现这种局面。</li><li>还在 1945 年 5 月中共召开七大时，毛泽东就提出，对蒋介石拟采取“洗脸”政策而不是“砍头”政策。8 月 24 日，毛泽东根据时局变化进一步指岀，抗战结束，和平建设阶段开始。中央正考虑同国民党进行谈判，避免内战，实现和平建国。8 月 25 日，中共中央在对时局的宣言中明确提岀<strong>“和平、民主、团结”</strong>的口号。</li></ul></li></ul></li></ul><hr><p>  精简版缘起：</p><ul><li><p>蒋介石保存实力，准备发动反共内战的方针；国民党军队远在后方，蒋希望争取完成军队内战部署的实践；全国人民渴望和平反对内战，美苏希望中国和平建国。故蒋一边积极备战，一边表示愿意和中共和谈</p></li><li><p>蒋介石希望：敷衍舆论，掩盖内战准备；诱使共产党交出军队和解放区政权；谈判不成即发动内战，让共产党承担责任</p></li><li><p>美国希望：让蒋成为其在亚洲的主要支持者以稳定亚洲战线；遏制苏联；维护美国在中国的殖民主义利益</p></li><li><p>共产党希望：和平建国；国共合作、和平发展的新阶段存在可能（和平、民主、团结的口号）</p></li><li><p>经过</p><ul><li><p><strong>1945.5</strong>，召开<strong>七大</strong>时，毛提出对蒋介石采取“洗脸”而不是“砍头”政策。<strong>8.24</strong>，毛指出抗战结束，和平建设阶段开始。中央正<strong>考虑同国民党进行谈判，实现和平建国</strong>。<strong>8.25</strong>，中共中央在对时局的宣言中明确提出“<strong>和平、民主、团结</strong>”的口号。</p><p><strong>1945.8.14&#x2F;20&#x2F;23</strong>，蒋介石<strong>3次电邀</strong>毛到重庆共商“国际国内各种重要问题”。<strong>8.28</strong>，毛与周恩来，王若飞<strong>赴重庆谈判</strong>。<strong>10.10</strong>，双方签署<strong>《政府与中共代表会谈纪要》，即“双十协定”</strong>，确认和平建国基本方针，同意“长期合作，坚决避免内战”。<strong>1946.1.10</strong>，国共双方<strong>下达停战令</strong>，同一天，<strong>政治协商会议</strong>在重庆开幕。中共推动政协会议达成了政府组织、国民大会、和平建国纲领、宪法草案、军事问题五项协议。</p></li></ul></li><li><p>内容</p><ul><li>1945 年10月10日“ 双十协定”， 确认和平建国的方针。同意“长期合作，坚决避免内战” 。</li><li>1946年1月， 中共推动政协会议达成了政府组织、国民大会、和平建国纲领、宪法草案、军事问题五项协议。这些决议贯彻了和平民主原则，勋认了和平建国方针，确定了国会制、内阁制和省自治的政治制度。</li><li>不过， 政协的上述协议及其他协议，还不是新民主主义性质的。但它有利于冲破蒋介石的独裁统治和实行民主政治．有利千和平建国、因而在相当程度上是有利千人民的</li></ul></li></ul><h2 id="15-三大战役"><a href="#15-三大战役" class="headerlink" title="15. 三大战役"></a>15. 三大战役</h2><ul><li>在毛泽东和中共中央军委的领导和指挥下，在人民群众的热烈支援下，中国人民解放军先后发动了辽沈、淮海、平津三大战役。</li><li><strong>辽沈战役</strong>自 1948 年 9 月 12 日开始至 11 月 2 日结束，历时 52 天。东北野战军<br>（第四野战军）主力 70 万人在林彪（司令员）、罗荣桓（政委）领导下，共歼敌 47.2万人。</li><li><strong>淮海战役</strong>自 1948 年 11 月 6 日开始至 1949 年 1 月 10 日结束，历时 66 天。华<br>东野战军（第三野战军）、中原野战军（第二野战军）以及地方武装共 60 万人，在由刘伯承（二野总司令）、陈毅（三野司令员兼政委）、邓小平（二野政委）、粟裕（三野副司令员兼第二副政委）、谭震林（三野第一副政委）组成的总前委（邓小平为书记）领导下，歼敌 55.5 万人。</li><li><strong>平津战役</strong>自 1948 年 11 月 29 日开始至 1949 年 1 月 31 日结束，历时 64 天。人<br>关作战的东北野战军、华北解放军主力与地方武装共 100 万人，在由林彪、罗荣桓、聂荣臻（司令员）组成的平津前线总前委领导下，歼灭和改编国民党军队 52 万余人。</li><li><strong>意义</strong>：三大战役基本摧毁国民党赖以维持反动统治的主要军事力量。三大战役，无论是战争的规模还是取得的成果，在中国战争史上是空前的，在世界战争史上也是罕见的。这是人民战争的胜利，是毛泽东军事思想的胜利。</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220611174307800.png" alt="image-20220611174307800"></p><h2 id="16-毛泽东论十大关系"><a href="#16-毛泽东论十大关系" class="headerlink" title="16. 毛泽东论十大关系"></a>16. 毛泽东论十大关系</h2><ul><li>（重点），以21年为准&#x2F; 2021 P215</li></ul><ol><li>在<strong>重工业和轻工业、农业</strong>的关系问题上，要用多发展一些农业、轻工业的办法<br>来发展重工业（重工业仍是重点）</li><li>在<strong>沿海工业</strong>和<strong>内地工业</strong>的关系问题上，要充分利用和发展沿海的工业基地，以<br>便更有力量来发展和支持内地工业；新建工业放内地，一是平衡布局，二是利<br>于备战。</li><li>在<strong>经济建设</strong>和<strong>国防建设</strong>的关系问题上，在强调加强国防建设的重要性时，提出<br>把军政费用降到一个适当的比例，增加经济建设费用。只有把经济建设发展得<br>更快了，国防建设才能够有更大的进步；</li><li>在<strong>国家、生产单位</strong>和<strong>生产者个人</strong>的关系问题上，三者的利益必须兼顾，不能只<br>顾一头，既要提倡艰苦奋斗，又要关心群众生活；变苏联的“义务交售制”为<br>缩小工农业剪刀差和等价交换。</li><li>在<strong>中央和地方</strong>的关系问题上，要在巩固中央统一领导的前提下，扩大地方的权<br>力，让地方办更多的事情，发挥中央和地方两个积极性。（中央不同地方商量<br>不冒下命令）</li><li>在<strong>汉族与少数民族</strong>的关系问题上，要着重反对大汉族主义，也要反对地方民族<br>主义，要诚心诚意地积极帮助少数民族发展经济建设和文化建设；（汉族“人<br>口众多”，少数民族“地大物博”）</li><li>在<strong>党和非党</strong>的关系问题上，共产党和民主党派要长期共存，互相监督；（民主<br>党派中的很多人是不同程度的反对派）</li><li>在<strong>革命和反革命</strong>的关系问题上，必须分清敌我，化消极因素为积极因素；（给<br>反革命分子以自新的机会）</li><li>在<strong>是非关系问题</strong>上，对犯错误的同志要实行“惩前毖后，治病救人”的方针，<br>要允许人家犯错误，允许并帮助他们改正错误；</li><li>在<strong>中国和外国</strong>的关系问题上，要学习一切民族、一切国家的长处，包括资本主<br>义国家先进的科学技术和科学管理方法，要反对不加分析地一概排斥或一概照<br>搬。</li></ol><ul><li>一个基本方针： 调动一切积极因素为社会主义事业服务。</li></ul><p>《论十大关系》是中国开始探索自己的社会主义建设道路的标志，它在新的历史条件下从经济方面和政治方面提出了新的指导方针，为中共八大的召开作了理论准备。</p><h2 id="17-7000人大会"><a href="#17-7000人大会" class="headerlink" title="17. 7000人大会"></a>17. 7000人大会</h2><p>2018 P261 &#x2F; 2021 P222</p><ul><li><strong>1962年1、2月间，扩大的中共中央工作会议（即“七千人大会”）</strong>在北京召开。<strong>刘少奇</strong>代表中央提出的书<strong>面报告草稿</strong>，总结了 <strong>“大跃进”</strong>以来经济建设工作的经验教训，分析了产生<strong>缺点错误</strong>的原因。</li><li><strong>毛泽东</strong>着重阐述了民主集中制的极端重要性，并带头做了自我批评（，特别强调在社会主义建设上，我们还有很大的<strong>盲目性</strong>，今后要下苦功夫调查研究，弄清楚社会主义经济的规律。要使中国赶上和超过世界上最先进的资本主义国家，没有一百多年的时间是不行的。这是党中央和毛泽东对社会主义建设长期性的进一步认识。）</li><li><strong>邓小平、周恩来</strong>分别代表中央书记处和国务院在大会上作自我批评，并提出恢复党的优良传统和克服目前困难的主要办法。</li><li>意义：这次会议发扬了党内的<strong>民主</strong>和<strong>自我批评</strong>精神，统一了全党的认识，对动员全党团结奋斗战胜困难起了极其重要的作用。</li></ul><h2 id="18-四个现代化目标"><a href="#18-四个现代化目标" class="headerlink" title="18. 四个现代化目标"></a>18. 四个现代化目标</h2><p>2021 P223</p><ul><li>背景：当国民经济调整工作取得巨大成就的时候，党适时提出了新的奋斗目标。</li><li>内容：<strong>1964年</strong>底，<strong>周恩来</strong>在<strong>三届全国人大一次会议上</strong>郑重提出实现“四个现代化”的历史任务，即“在不太长的历史时期内，把我国建设成为一个具<strong>有现代农业、现代工业、现代国防和现代科学技术</strong>的社会主义强国，赶上和超过世界先进水平”</li><li><strong>分两步走实现现代化的战略构想</strong>，即从第三个五年计划开始，<strong>第一步</strong>，经过二个五年计划时期，建立一个独立的比较完整的工业体系和国民经济体系；<strong>第二步</strong>，全面实现农业、工业、国防和科学技术的现代化，使中国经济走在世界前列</li><li>意义：“四个现代化”从此成为党和全国各族人民的共同奋斗目标，成为凝聚和团结全国各族人民不懈奋斗的强大精神力量。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 整理重点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coursera: ML04-高级算法与工程</title>
      <link href="/article/Coursera-Machine-Learning-04/"/>
      <url>/article/Coursera-Machine-Learning-04/</url>
      
        <content type="html"><![CDATA[<h1 id="高级算法与工程"><a href="#高级算法与工程" class="headerlink" title="高级算法与工程"></a>高级算法与工程</h1><p>Machine Learning - Android Ng</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221005220433978.png" alt="image-20221005220433978" /><h2 id="4-1-评价-ml-系统"><a href="#4-1-评价-ml-系统" class="headerlink" title="4.1. 评价 ml 系统"></a>4.1. 评价 ml 系统</h2><ul><li>计算测试误差的函数就是减去正则化项的损失函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912140823902.png" alt="image-20220912140823902"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912141619989.png" alt="image-20220912141619989"></p><h3 id="4-1-1-选择模型"><a href="#4-1-1-选择模型" class="headerlink" title="4.1.1. 选择模型"></a>4.1.1. 选择模型</h3><ul><li>把数据集分为训练集、测试集和交叉验证集<ul><li>中心思想：更加公平（不是更加准确）</li></ul></li><li>先选择交叉验证误差最小的模型</li><li>可以使用测试集误差来代表泛化误差，评估模型的泛化误差</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912143933334.png" alt="image-20220912143933334"></p><p><em>训练集在不同的模型上拟合出每个模型的最优 WB_，_交叉验证集用来选择不同的模型_，_测试集用来检验该模型的好坏效果（误差）</em></p><h3 id="4-1-2-诊断模型"><a href="#4-1-2-诊断模型" class="headerlink" title="4.1.2. 诊断模型"></a>4.1.2. 诊断模型</h3><ul><li><p>如何决定第二步做什么，以提高学习的效果</p></li><li><p>方法：观察算法的偏差和方差（Bias and Variance）</p></li><li><p>$J_{train}$很高时，往往意味着 Bias 高（欠拟合）</p></li><li><p>$J_{cv}$高时，且$J_{cv}$比$J_{train}$高很多时，往往意味着 Variance 高（过拟合）</p></li></ul><p>$J_{cv}$和$J_{train}$都比较低时，是比较理想的</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912145232640.png" alt="image-20220912145232640"></p><h3 id="4-1-4-选择正则化参数-λ"><a href="#4-1-4-选择正则化参数-λ" class="headerlink" title="4.1.4. 选择正则化参数 λ"></a>4.1.4. 选择正则化参数 λ</h3><p>λ ~ w 的值 ~ J</p><ul><li>测试过程如下，选择$J_{cv}$最小的模型</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912150559968.png" alt="image-20220912150559968"></p><ul><li>λ 和$J$的关系</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912150827232.png" alt="image-20220912150827232"></p><h3 id="4-1-4-如何评价模型错误率"><a href="#4-1-4-如何评价模型错误率" class="headerlink" title="4.1.4. 如何评价模型错误率"></a>4.1.4. 如何评价模型错误率</h3><ul><li>与其直接看误差，不如以人类水平为基准进行评判</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912151316029.png" alt="image-20220912151316029"></p><h4 id="4-1-4-1-性能基准"><a href="#4-1-4-1-性能基准" class="headerlink" title="4.1.4.1. 性能基准"></a>4.1.4.1. 性能基准</h4><ul><li>人类水平（常用于非结构化数据，如图像、语音、文本）</li><li>竞争对手的算法表现</li><li>经验</li></ul><hr><ul><li>基准线水平</li><li>训练误差($J_{train}$)</li><li>交叉验证误差($J_{cv}$)</li><li>前两者之间的差 indicates <strong>bias</strong>，后两者之间的差 indicates <strong>variance</strong></li></ul><p>一般 4%以上的差距就认为很大了</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912151730402.png" alt="image-20220912151730402"></p><h3 id="4-1-5-学习曲线"><a href="#4-1-5-学习曲线" class="headerlink" title="4.1.5. 学习曲线"></a>4.1.5. 学习曲线</h3><h4 id="4-1-5-1-debug-算法的方法"><a href="#4-1-5-1-debug-算法的方法" class="headerlink" title="4.1.5.1. debug 算法的方法"></a>4.1.5.1. debug 算法的方法</h4><table><thead><tr><th>方法</th><th>解决</th></tr></thead><tbody><tr><td>更多训练集</td><td>高方差</td></tr><tr><td>尝试更小的特征集</td><td>高方差</td></tr><tr><td>增加特征</td><td>高偏差</td></tr><tr><td>增加多项式项数</td><td>高偏差</td></tr><tr><td>减少 λ</td><td>高偏差</td></tr><tr><td>增加 λ</td><td>高方差</td></tr></tbody></table><hr><h4 id="4-1-5-2-神经网络应用"><a href="#4-1-5-2-神经网络应用" class="headerlink" title="4.1.5.2. 神经网络应用"></a>4.1.5.2. 神经网络应用</h4><p>我们往往需要在 keep a balance between bias and variance. 但是神经网络给我们提供了一个全新的视角和方法。它可以自动帮我们完成权衡。具体解释如下：</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912152954919.png" alt="image-20220912152954919"></p><ul><li>tf 代码</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220912153956951.png" alt="image-20220912153956951"></p><h4 id="4-1-5-误差分析"><a href="#4-1-5-误差分析" class="headerlink" title="4.1.5 误差分析"></a>4.1.5 误差分析</h4><ul><li>人工检查 100 个数据集，并将它们按照共同特征分类</li><li>然后进行一些针对性补丁，比如添加一些更加具有针对性的数据集</li></ul><h2 id="4-2-数据增强"><a href="#4-2-数据增强" class="headerlink" title="4.2. 数据增强"></a>4.2. 数据增强</h2><ul><li>Data argumentation</li><li>通过已有的训练集来进行新的训练：比如把训练集 A image 进行一些变化，然后重新进行训练（人为的增大训练集）<ul><li>注意：对数据所作的改变和扭曲，应该是测试集中噪声或变形的代表<ul><li>随机无意义的噪声和扭曲是没有意义的</li></ul></li></ul></li><li>广泛的应用于图像和音频中</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913145331970.png" alt="image-20220913145331970"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913145418719.png" alt="image-20220913145418719"></p><h2 id="4-3-迁移学习"><a href="#4-3-迁移学习" class="headerlink" title="4.3. 迁移学习"></a>4.3. 迁移学习</h2><ul><li>可以用来自不同任务的数据完成学习</li><li>应对数据少或数据难以获取的情况</li></ul><p>以下图为例：先在有 1 million 个数据的训练集上训练出可以识别 1000 个类别的神经网络（比如猫、狗等等…），随后保持上述神经网络除了 output 层外的参数不变（把上述神经网络除了 output 层 copy 一遍），迁移到拟训练的数据集上进行训练。训练有两种选择：</p><ul><li>只训练 output 层的参数</li><li>训练所有参数。但是以 copy 的神经网络参数作为初始值</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913151057762.png" alt="image-20220913151057762"></p><ul><li>先在大型数据集上进行训练，然后在较小的数据集上进一步参数调优，这两个步骤称为<strong>监督预训练</strong>（supervised pretraining）</li><li>然后运行梯度下降等算法在新数据集上，进行<strong>微调</strong>（fine tuning）</li></ul><p>需要注意的是：预训练的神经网络必须和最终需要的神功网络是同一类型的。比如要训练图像相关的神经网络，必须使用图像相关的预训练神经网络</p><h2 id="4-4-构建-ml-系统的周期"><a href="#4-4-构建-ml-系统的周期" class="headerlink" title="4.4. 构建 ml 系统的周期"></a>4.4. 构建 ml 系统的周期</h2><ol><li>确定项目范围</li><li>收集数据</li><li>训练模型</li><li>部署模型</li></ol><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913152206879.png" alt="image-20220913152206879"></p><h3 id="4-4-1-MLOps"><a href="#4-4-1-MLOps" class="headerlink" title="4.4.1. MLOps"></a>4.4.1. MLOps</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913153544268.png" alt="image-20220913153544268"></p><ul><li>有点类似 DevOps</li></ul><h2 id="4-5-数据倾斜"><a href="#4-5-数据倾斜" class="headerlink" title="4.5. 数据倾斜"></a>4.5. 数据倾斜</h2><ul><li>评价一个罕见类的学习算法性能<ul><li>构造混淆矩阵（2 * 2 矩阵）</li><li>精度（Precision）：评价算法是否准确：当算法诊断有病时，确诊的概率</li><li>召回率（Recall）：评价算法对真正病人是否有用（样本中的正例有多少被预测正确了或找的全）</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913155045987.png" alt="image-20220913155045987"></p><h3 id="4-5-1-Trade-off-between-P-and-R"><a href="#4-5-1-Trade-off-between-P-and-R" class="headerlink" title="4.5.1. Trade off between P and R"></a>4.5.1. Trade off between P and R</h3><p>提高 threshold 会提高 Precision，降低 Recall</p><ul><li>建议根据具体的应用场景进行权衡</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913160656496.png" alt="image-20220913160656496"></p><h4 id="4-5-1-1-F-score"><a href="#4-5-1-1-F-score" class="headerlink" title="4.5.1.1. F score"></a>4.5.1.1. F score</h4><ul><li>权衡 Recall 和 Precision 的参数</li></ul><p>$$<br>F_1 \ scrore &#x3D; \frac{1}{\frac{1}{2}(\frac{1}{P} + \frac{1}{R})} &#x3D; 2\frac{PR}{P+R}<br>$$</p><ul><li>这个式子会关注二者中较小的部分（其实就是 P 和 R 的调和平均值）</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220913161128892.png" alt="image-20220913161128892"></p><h2 id="4-6-决策树"><a href="#4-6-决策树" class="headerlink" title="4.6. 决策树"></a>4.6. 决策树</h2><ul><li>Decision Tree</li></ul><h3 id="4-6-1-步骤"><a href="#4-6-1-步骤" class="headerlink" title="4.6.1. 步骤"></a>4.6.1. 步骤</h3><ul><li>选择根节点的特征</li><li>选择在每个节点上区分的特征（为了最大化的分类，保证分类纯度 purity）</li><li>何时停止树的划分（stop splitting）<ul><li>当结点里 100%都是同一类</li><li>当分裂（split）结点会导致树超过最大深度</li><li>当分裂（split）后对纯度产生的增益小于阈值（threshold）</li><li>当结点里 examples 的数量小于阈值（threshold）</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914111707277.png" alt="image-20220914111707277"></p><h3 id="4-6-2-熵"><a href="#4-6-2-熵" class="headerlink" title="4.6.2. 熵"></a>4.6.2. 熵</h3><ul><li>entropy</li><li>度量样本不纯程度</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914112420889.png" alt="image-20220914112420889"></p><p>$$<br>p_0 \ &#x3D; \ 1\ - \ p_1 \<br>H(p_1) &#x3D; -p_1log_2(p_1) - p_0log_2(p_0) \<br>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  &#x3D; -p_1log_2(p_1) - (1-p_1)log_2(1-P_1) \<br>Note: 0log(0) &#x3D; 0<br>$$</p><h4 id="4-6-2-1-如何利用熵度量-node"><a href="#4-6-2-1-如何利用熵度量-node" class="headerlink" title="4.6.2.1. 如何利用熵度量 node"></a>4.6.2.1. 如何利用熵度量 node</h4><ul><li>使用加权平均。因为我们认为分到了较多 examples 的分支的熵是更重要的</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914113505023.png" alt="image-20220914113505023"></p><h4 id="4-6-2-2-信息增益"><a href="#4-6-2-2-信息增益" class="headerlink" title="4.6.2.2. 信息增益"></a>4.6.2.2. 信息增益</h4><p>根节点的熵 - 子节点的加权平均熵</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914113723924.png" alt="image-20220914113723924"></p><ul><li>计算公式</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914113852006.png" alt="image-20220914113852006"></p><h3 id="4-6-4-Decision-Tree-Learning"><a href="#4-6-4-Decision-Tree-Learning" class="headerlink" title="4.6.4. Decision Tree Learning"></a>4.6.4. Decision Tree Learning</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914114051924.png" alt="image-20220914114051924"></p><ul><li>building decision tree 是一个递归过程</li></ul><h3 id="4-6-5-one-hot-编码"><a href="#4-6-5-one-hot-编码" class="headerlink" title="4.6.5. one-hot 编码"></a>4.6.5. one-hot 编码</h3><p>用于处理不止 2 种取值的离散变量</p><ul><li>如果一个分类特征有 k 种可能的取值，那么把这 k 种特征按照 0、1 进行编码取值</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914120302571.png" alt="image-20220914120302571"></p><ul><li><p>如果看任何一行，总有一个特征是 1，因此称之为 one-hot（独热）编码</p></li><li><p>one-hot 编码不仅适用于决策树，还适用于神经网络</p></li></ul><h3 id="4-6-6-处理连续变量"><a href="#4-6-6-处理连续变量" class="headerlink" title="4.6.6. 处理连续变量"></a>4.6.6. 处理连续变量</h3><ul><li><p>对连续变量进行划分处理（分类），即将连续变量区间设置阈值，将其分为 2 个子集</p></li><li><p>分类的标准是谁贡献了更大的信息增益</p></li><li><p>一般划分值的候选方法是：将值 list 排序，然后取所有值之间的中点</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914140944926.png" alt="image-20220914140944926"></p><h2 id="4-7-回归预测中的决策树"><a href="#4-7-回归预测中的决策树" class="headerlink" title="4.7. 回归预测中的决策树"></a>4.7. 回归预测中的决策树</h2><ul><li>决策树会根据叶子结点中样本数据的平均值做出预测</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914141648061.png" alt="image-20220914141648061"></p><ul><li><p>在回归预测中，决定结点选择哪种划分策略的标准不再是熵，而是<strong>带权方差</strong>（variance）</p></li><li><p>就像最终决策树的衡量公式是信息增益，我们在这里计算的也实际上是方差减少量</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914142137648.png" alt="image-20220914142137648"></p><h2 id="4-8-决策树集合"><a href="#4-8-决策树集合" class="headerlink" title="4.8. 决策树集合"></a>4.8. 决策树集合</h2><ul><li><p>使用单个决策树的缺点是：其对数据的微小变化非常敏感。(一旦数据微小变化，那么结点的信息增益可能会变化很多，从而导致决策树变的完全不同)</p><ul><li>解决方法：构建更多的决策树，即决策树集合，使得预测结果更健壮</li></ul></li><li><p>使用树集合，然后都运行数据，进行预测。多数的结果即为预测结果。</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914143400270.png" alt="image-20220914143400270"></p><h3 id="4-8-1-有放回抽样"><a href="#4-8-1-有放回抽样" class="headerlink" title="4.8.1. 有放回抽样"></a>4.8.1. 有放回抽样</h3><ul><li>Sampling with replacement</li></ul><h3 id="4-8-2-随机森林算法"><a href="#4-8-2-随机森林算法" class="headerlink" title="4.8.2. 随机森林算法"></a>4.8.2. 随机森林算法</h3><h4 id="4-8-2-1-袋装决策树算法"><a href="#4-8-2-1-袋装决策树算法" class="headerlink" title="4.8.2.1. 袋装决策树算法"></a>4.8.2.1. 袋装决策树算法</h4><ul><li>对于一个大小为 m 的训练集<ul><li>使用有放回抽样获得同样大小为 m 的训练集，然后训练出一个决策树</li><li>重复以上过程直到训练出需要的决策树数量（一般是 100，记为**<em>B</em>**）</li></ul></li><li>问题<ul><li>根节点及其附近的特征仍然相似</li><li>导致算法不够精确，需要改进</li></ul></li></ul><h4 id="4-8-2-2-改进成随机森林算法"><a href="#4-8-2-2-改进成随机森林算法" class="headerlink" title="4.8.2.2. 改进成随机森林算法"></a>4.8.2.2. 改进成随机森林算法</h4><ul><li>在每个结点中，当需要选择一个特征来 split node 时，如果有 n 个特征可以选择，那么我们每次<strong>随机选择</strong>k（k &lt; n ）个特征构成 n 个特征的子集，让算法在这个子集中进行选择（即计算信息增益然后进行 split）</li><li>比单一决策树更健壮的原因是：随机森林算法探索了更多训练集微小变化的可能，能够对有放回取样过程导致的所有数据变化进行平均，使得训练出来的模型更 robust</li></ul><h3 id="4-8-3-XGBoost-增强决策树算法"><a href="#4-8-3-XGBoost-增强决策树算法" class="headerlink" title="4.8.3. XGBoost 增强决策树算法"></a>4.8.3. XGBoost 增强决策树算法</h3><ul><li>非常类似于针对性训练，比如刻意训练不熟练的一段，而不是总是训练整首曲子</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914150804159.png" alt="image-20220914150804159"></p><ul><li>XGBoost（eXtreme Gradient Boosting）<ul><li>增强决策树的一种开源实现</li><li>高效</li><li>对默认拆分条件有很好的选择</li><li>内置正则化以防止过拟合</li><li>和 dl 一样，是算法竞赛的热门算法</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220914151101334.png" alt="image-20220914151101334"></p><h2 id="4-9-决策树和神经网络的使用时机"><a href="#4-9-决策树和神经网络的使用时机" class="headerlink" title="4.9. 决策树和神经网络的使用时机"></a>4.9. 决策树和神经网络的使用时机</h2><ul><li>决策树和树集合<ul><li>对表格化（结构化）tabular（structured）数据表现很好</li><li>不建议在非结构化数据上使用（图像、音频、文本）</li><li>训练迅速</li><li>小的决策树可能是人类可以理解的（可解释性）</li></ul></li><li>神经网络<ul><li>对结构化和非结构化数据都表现良好</li><li>比决策树慢（训练时长等）</li><li>可以使用迁移学习（而决策树不行）</li><li>当构建多个模型共同协作的系统时，神经网络模型更容易串在一起（决策树一次只能训练一个）</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coursera: ML03-深度学习</title>
      <link href="/article/Coursera-Machine-Learning-03/"/>
      <url>/article/Coursera-Machine-Learning-03/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><p>Machine Learning - Android Ng</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221005220433978.png" alt="image-20221005220433978" /><h2 id="3-1-神经网络概论"><a href="#3-1-神经网络概论" class="headerlink" title="3.1. 神经网络概论"></a>3.1. 神经网络概论</h2><ul><li><p>尝试模仿（mimic）人脑</p></li><li><p>用处</p><ul><li>speech -&gt; images -&gt; text(NLP) -&gt; …</li></ul></li><li><p>每个神经元接受一些输入，做一些计算，然后将输出送给下一个神经元</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909155125086.png" alt="image-20220909155125086"></p><ul><li>可以将神经元分为不同层（layer），每层接受相似的输入，输出不同的结果</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909164348707.png" alt="image-20220909164348707"></p><ul><li><p>神经网络不需要自己进行特征工程，中间的隐藏层即通过输入初始特征来输出更好的特征</p></li><li><p>需要自己决定的是神经网络的架构：即有多少层，每层有多少神经元</p></li></ul><h3 id="3-1-1-一些-notation"><a href="#3-1-1-一些-notation" class="headerlink" title="3.1.1. 一些 notation"></a>3.1.1. 一些 notation</h3><ul><li>方括号上标代表第 x 层</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220910172611765.png" alt="image-20220910172611765"></p><ul><li>每层接受的输入向量上标是上一层的</li><li>$a^{[0]}$一般表示输入向量</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911170844379.png" alt="image-20220911170844379"></p><h3 id="3-1-2-forward-propagation"><a href="#3-1-2-forward-propagation" class="headerlink" title="3.1.2. forward propagation"></a>3.1.2. forward propagation</h3><ul><li>前向传播</li><li>从神经网络层自左向右传播</li></ul><h2 id="3-2-TensorFlow-介绍"><a href="#3-2-TensorFlow-介绍" class="headerlink" title="3.2. TensorFlow 介绍"></a>3.2. TensorFlow 介绍</h2><h3 id="3-2-1-Demo"><a href="#3-2-1-Demo" class="headerlink" title="3.2.1. Demo"></a>3.2.1. Demo</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">200.0</span>, <span class="number">17.0</span>]])</span><br><span class="line"><span class="comment"># Dense是神经网络一种层的名字</span></span><br><span class="line">layer_1 = Dense(units=<span class="number">3</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line"><span class="comment"># a1是一个1 * 3矩阵（张量），通过a1.numpy()可以把它转换为numpy矩阵</span></span><br><span class="line">a1 = layer_1(x)</span><br><span class="line">layer_2 = Dense(units=<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">a2 = layer_2(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Threshold</span></span><br><span class="line"><span class="keyword">if</span> a2 &gt;= <span class="number">0.5</span></span><br><span class="line">yhat = <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    yhat = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 法2</span></span><br><span class="line">layer_1 = Dense(units=<span class="number">3</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">layer_2 = Dense(units=<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">model = Sequential([layer_1, layer_2 ])</span><br><span class="line">x = np.array([[]])</span><br><span class="line">y = np.array([[]])</span><br><span class="line">model.<span class="built_in">compile</span>(...)</span><br><span class="line">model.fit(x,y)</span><br><span class="line">model.predict(x_new)</span><br></pre></td></tr></table></figure><h3 id="3-2-2-Tf-的数据格式"><a href="#3-2-2-Tf-的数据格式" class="headerlink" title="3.2.2. Tf 的数据格式"></a>3.2.2. Tf 的数据格式</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911175020421.png" alt="image-20220911175020421"></p><h3 id="3-2-3-Tensor（张量）"><a href="#3-2-3-Tensor（张量）" class="headerlink" title="3.2.3. Tensor（张量）"></a>3.2.3. Tensor（张量）</h3><ul><li>可以近似理解为一种矩阵</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911175521941.png" alt="image-20220911175521941"></p><h2 id="3-3-Python-向前传播的原理"><a href="#3-3-Python-向前传播的原理" class="headerlink" title="3.3. Python 向前传播的原理"></a>3.3. Python 向前传播的原理</h2><ul><li>forward prop</li><li>手写全连接层（full connected）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dense</span>(<span class="params">a_in, W, b, g</span>):</span><br><span class="line">    units = W.shape[<span class="number">1</span>]</span><br><span class="line">    a_out = np.zeros(units)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(units):</span><br><span class="line">        <span class="comment"># W[:,j]是提取出W第j列的写法</span></span><br><span class="line">        <span class="comment"># 通常：大写字母用来表示矩阵，小写字母用来表示向量</span></span><br><span class="line">        w = W[:,j]</span><br><span class="line">        z = np.dot(w, a_in) + b[j]</span><br><span class="line">        a_out[j] = g(z)</span><br><span class="line">    <span class="keyword">return</span> a_out</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sequential</span>(<span class="params">x</span>):</span><br><span class="line">    a1 = dense(x, W1, b1)</span><br><span class="line">    a2 = dense(a1, W2, b2)</span><br><span class="line">    a3 = dense(a2, W3, b3)</span><br><span class="line">    a4 = dense(a3, W4, b4)</span><br><span class="line">    f_x = a4</span><br><span class="line">    <span class="keyword">return</span> f_x</span><br></pre></td></tr></table></figure><h2 id="3-4-AI-和神经网络的关系"><a href="#3-4-AI-和神经网络的关系" class="headerlink" title="3.4. AI 和神经网络的关系"></a>3.4. AI 和神经网络的关系</h2><h3 id="3-4-1-ANI-和-AGI"><a href="#3-4-1-ANI-和-AGI" class="headerlink" title="3.4.1. ANI 和 AGI"></a>3.4.1. ANI 和 AGI</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911194524599.png" alt="image-20220911194524599"></p><h3 id="3-4-2-The-“one-learning-algorithm”-hypothesis"><a href="#3-4-2-The-“one-learning-algorithm”-hypothesis" class="headerlink" title="3.4.2. The “one learning algorithm” hypothesis"></a>3.4.2. The “one learning algorithm” hypothesis</h3><p>科学家发现人脑的可塑性非常强：非常小的一片人脑区域就能做很多事情，比如当把图像输给听觉区域时，听觉区域又会学会识别图像。这带来一个假设：存在一种或几种算法，可以使得机器学习&#x2F;神经网络实现非常多的事情</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911195232097.png" alt="image-20220911195232097"></p><h2 id="3-5-算法中的向量化实现"><a href="#3-5-算法中的向量化实现" class="headerlink" title="3.5. 算法中的向量化实现"></a>3.5. 算法中的向量化实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.array([[<span class="number">200</span>, <span class="number">17</span>]])</span><br><span class="line">W = np.array([[<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>],</span><br><span class="line">              [-<span class="number">2</span>, <span class="number">4</span>, -<span class="number">6</span>]])</span><br><span class="line">B = np.array([[-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dense</span>(<span class="params">A_in, W, B, g</span>):</span><br><span class="line">    <span class="comment"># np.matmul = matrix multiplication</span></span><br><span class="line">    Z = np.matmul(A_in, W) + B</span><br><span class="line">    A_out = g(z)</span><br><span class="line">    <span class="keyword">return</span> A_out</span><br></pre></td></tr></table></figure><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911200229967.png" alt="image-20220911200229967"></p><ul><li><p>使用矩阵和向量运算的好处是：可以利用硬件进行并行计算，显著提高运算速度</p></li><li><p>在 TensorFlow 的约定中：一个样本的数据通常在矩阵的行中</p></li></ul><h2 id="3-6-TensorFlow-实现"><a href="#3-6-TensorFlow-实现" class="headerlink" title="3.6. TensorFlow 实现"></a>3.6. TensorFlow 实现</h2><ul><li>tf 编译模型的关键是定义损失函数</li><li>第一步：定义模型</li><li>第二步：使用损失函数编译模型</li><li>第三步：训练模型</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911200855784.png" alt="image-20220911200855784"></p><h3 id="3-6-1-前述基本步骤在-tf-中的对应"><a href="#3-6-1-前述基本步骤在-tf-中的对应" class="headerlink" title="3.6.1. 前述基本步骤在 tf 中的对应"></a>3.6.1. 前述基本步骤在 tf 中的对应</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911201643919.png" alt="image-20220911201643919"></p><ul><li>tf 的 model.fi 通过反向传播实现了梯度下降</li></ul><h2 id="3-7-激活函数详解"><a href="#3-7-激活函数详解" class="headerlink" title="3.7. 激活函数详解"></a>3.7. 激活函数详解</h2><ul><li>一些激活函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911203411855.png" alt="image-20220911203411855"></p><h3 id="3-7-1-ReLU"><a href="#3-7-1-ReLU" class="headerlink" title="3.7.1. ReLU"></a>3.7.1. ReLU</h3><ul><li>Rectified Linear Unit 修正线性单元</li><li>计算速度比 sigmoid 更快</li><li>只有左端是趋于 flat 的，因此在梯度下降时比 sigmoid 更有优势，学习速度更快</li><li>一般作为隐藏层的默认激活函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911203303924.png" alt="image-20220911203303924"></p><h3 id="3-7-2-softmax"><a href="#3-7-2-softmax" class="headerlink" title="3.7.2. softmax"></a>3.7.2. softmax</h3><ul><li>逻辑回归的泛化</li><li>针对多分类环境</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911205212945.png" alt="image-20220911205212945"></p><h4 id="3-7-2-1-softmax-函数的损失函数"><a href="#3-7-2-1-softmax-函数的损失函数" class="headerlink" title="3.7.2.1. softmax 函数的损失函数"></a>3.7.2.1. softmax 函数的损失函数</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911205507260.png" alt="image-20220911205507260"></p><ul><li>可以和 sigmoid 类比，$a_j$越接近 1，损失越小，这会刺激$a_j$不断接近 1</li></ul><h3 id="3-7-3-如何选择激活函数"><a href="#3-7-3-如何选择激活函数" class="headerlink" title="3.7.3. 如何选择激活函数"></a>3.7.3. 如何选择激活函数</h3><ul><li>sigmoid：二元分类问题，因为神经网络在学习 y&#x3D;1 的概率</li><li>linear：回归</li><li>ReLU：回归，且结果是非负值</li></ul><h3 id="3-7-4-为什么我们需要激活函数"><a href="#3-7-4-为什么我们需要激活函数" class="headerlink" title="3.7.4. 为什么我们需要激活函数"></a>3.7.4. 为什么我们需要激活函数</h3><ul><li>简单来说，如果我们不使用激活函数，那么所有神经网络将变成如同线性回归般的简单计算。多层神经网络不能提供提升计算复杂特征的能力，也不能学习任何比线性函数更复杂的东西，违背了我们创造神经网络的初衷</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911204521409.png" alt="image-20220911204521409"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911204532625.png" alt="image-20220911204532625"></p><h2 id="3-8-多分类"><a href="#3-8-多分类" class="headerlink" title="3.8. 多分类"></a>3.8. 多分类</h2><ul><li>y 是离散的，且可能的取值大于 2 种</li><li>使用 softmax 激活函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911210538665.png" alt="image-20220911210538665"></p><ul><li>softmax 函数在这里和其他激活函数的区别是，softmax 函数一次性算出$a_1, a_2, …, a_i$的所有值，并计算出它们的概率。而其他激活函数仅仅只是一次计算出一个。</li></ul><h3 id="3-8-1-使用-tf-实现"><a href="#3-8-1-使用-tf-实现" class="headerlink" title="3.8.1. 使用 tf 实现"></a>3.8.1. 使用 tf 实现</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911210704162.png" alt="image-20220911210704162"></p><ul><li>一种 tf 实现的版本，但是实际上有更好的版本。因此</li></ul><h4 id="3-8-1-1-优化计算精度"><a href="#3-8-1-1-优化计算精度" class="headerlink" title="3.8.1.1. 优化计算精度"></a>3.8.1.1. 优化计算精度</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911211123650.png" alt="image-20220911211123650"></p><ul><li>在输出层使用 linear 激活函数（目的是为了不先计算 a&#x2F;z，而是把整个式子放到最后再统一计算，避免了计算中间值而带来的精度误差），然后在 compile 选项里加上<code>from_logits=True</code></li></ul><h3 id="3-8-2-多标签分类问题"><a href="#3-8-2-多标签分类问题" class="headerlink" title="3.8.2. 多标签分类问题"></a>3.8.2. 多标签分类问题</h3><ul><li>multi-label classification problem</li><li>输出是一个标签向量，表示是否包含某个向量</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911212040447.png" alt="image-20220911212040447"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911212149890.png" alt="image-20220911212149890"></p><h2 id="3-9-Adam-算法"><a href="#3-9-Adam-算法" class="headerlink" title="3.9. Adam 算法"></a>3.9. Adam 算法</h2><ul><li><p>Adaptive Moment estimation，自适应矩估计</p></li><li><p>可以自动调整学习率$\alpha$</p></li><li><p>对于不同模型使用不同$\alpha$</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911212752093.png" alt="image-20220911212752093"></p><h3 id="3-9-1-使用"><a href="#3-9-1-使用" class="headerlink" title="3.9.1. 使用"></a>3.9.1. 使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential([</span><br><span class="line">    Dense(units=<span class="number">25</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">    Dense(units=<span class="number">15</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">    Dense(units=<span class="number">10</span>, activation=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=Adam(learning_rate=le-<span class="number">3</span>),                loss=SparseCategoricalCrossentropy(from_logits=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">model.fit(X,Y,epochs=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>在 compile 里面加一个优化器参数即可，然后设置一个默认的学习率</p><h2 id="3-10-Layer-Types"><a href="#3-10-Layer-Types" class="headerlink" title="3.10. Layer Types"></a>3.10. Layer Types</h2><h3 id="3-10-1-Dense-layer"><a href="#3-10-1-Dense-layer" class="headerlink" title="3.10.1. Dense layer"></a>3.10.1. Dense layer</h3><p>全连接层，接受前一层的所有激活，然后通过一个激活函数得到它自己的输出</p><h3 id="3-10-2-Convolutional-Layer"><a href="#3-10-2-Convolutional-Layer" class="headerlink" title="3.10.2. Convolutional Layer"></a>3.10.2. Convolutional Layer</h3><p>卷积层</p><ul><li><p>每一个神经元只关注**<em>part of</em>**前一层的输出</p></li><li><p>优点：</p><ul><li>计算更快</li><li>所需的训练数据更少，也更不容易过拟合</li></ul></li><li><p>例子<img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220911213905765.png" alt="image-20220911213905765"></p></li><li><p>可选择参数：每层的神经元数，每个神经元得到的输入数量</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coursera: ML02-逻辑回归与正则化</title>
      <link href="/article/Coursera-Machine-Learning-02/"/>
      <url>/article/Coursera-Machine-Learning-02/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑回归与正则化"><a href="#逻辑回归与正则化" class="headerlink" title="逻辑回归与正则化"></a>逻辑回归与正则化</h1><p>Machine Learning - Android Ng</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221005220433978.png" alt="image-20221005220433978" /><h2 id="2-1-逻辑回归"><a href="#2-1-逻辑回归" class="headerlink" title="2.1. 逻辑回归"></a>2.1. 逻辑回归</h2><ul><li>使用 0 和 1 来代表 negative 和 positive</li></ul><h3 id="2-1-1-Sigmoid-函数"><a href="#2-1-1-Sigmoid-函数" class="headerlink" title="2.1.1. Sigmoid 函数"></a>2.1.1. Sigmoid 函数</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908214617691.png" alt="image-20220908214617691"></p><ul><li>通常将函数作为输入，然后输出[0,1]</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908215053672.png" alt="image-20220908215053672"></p><h3 id="2-1-2-决策边界"><a href="#2-1-2-决策边界" class="headerlink" title="2.1.2. 决策边界"></a>2.1.2. 决策边界</h3><p>当我们把$wx+b$作为自变量输入 sigmoid 函数时，假设我们取 0.5 作为 sigmoid 函数的分界点（大于 0.5 认为是 positive，小于 0.5 认为是 negative），我们可以推导出：</p><p>$$<br>wx + b \gt 0<br>$$</p><p>是 positive，从而我们抽象出</p><p>$$<br>wx + b &#x3D; 0<br>$$</p><p>作为<strong>决策边界</strong></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908220316763.png" alt="image-20220908220316763"></p><p>当然决策边界也可以是非线性（多项的）</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908220441800.png" alt="image-20220908220441800"></p><h3 id="2-1-3-代价函数"><a href="#2-1-3-代价函数" class="headerlink" title="2.1.3. 代价函数"></a>2.1.3. 代价函数</h3><ul><li>关键之处是原来的平方误差损失函数作用在 sigmoid 函数后不再是凸函数了（convex-function），导致梯度下降不好作用。</li><li>因此需要找到一种是凸函数的代价函数</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908220902583.png" alt="image-20220908220902583"></p><ul><li>因此找到如下损失函数：</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908221515195.png" alt="image-20220908221515195"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908230028302.png" alt="image-20220908230028302"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908230124286.png" alt="image-20220908230124286"></p><h2 id="2-2-实现梯度下降"><a href="#2-2-实现梯度下降" class="headerlink" title="2.2. 实现梯度下降"></a>2.2. 实现梯度下降</h2><ul><li>梯度下降的大公式是一样的，但是求导的细节有不同 👇</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908230531967.png" alt="image-20220908230531967"></p><h2 id="2-3-过拟合"><a href="#2-3-过拟合" class="headerlink" title="2.3. 过拟合"></a>2.3. 过拟合</h2><ul><li><p>overfitting &#x2F; high variance</p></li><li><p>过于贴近训练集，导致实际预测结果的不准确（如下图右三）</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909141900666.png" alt="image-20220909141900666"></p><h3 id="2-3-1-debug-address-methods"><a href="#2-3-1-debug-address-methods" class="headerlink" title="2.3.1. debug &#x2F; address methods"></a>2.3.1. debug &#x2F; address methods</h3><ul><li>收集更多的训练数据</li><li>考虑使用较少的特征<ul><li>选择最相关的特征（最小的特征子集）</li><li>course 2 会学习自动特征的算法</li></ul></li><li>正则化（Regularization）<ul><li>保留所有的特征，但尽量避免它们产生过拟合</li><li>把一些特征的参数调小（接近 0）</li><li>是否正则化 b 对实际模型的影响不大（一般不正则化 b）</li></ul></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909142655263.png" alt="image-20220909142655263"></p><h2 id="2-4-正则化"><a href="#2-4-正则化" class="headerlink" title="2.4. 正则化"></a>2.4. 正则化</h2><ul><li><p>正则化的思想是：如果有很多特征，我全部使用的话可能会造成过拟合，而我也不知道哪些特征是重要的，哪些是不重要的，那么我就对所有的这些特征进行建模，并对他们进行正则化奖励或惩罚（penalize）。不重要的参数会被惩罚的非常小。从而得到不那么容易过拟合的模型</p></li><li><p>公式</p></li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909143702593.png" alt="image-20220909143702593"></p><ul><li>注意：λ 下面有分母 2m。这样可以保证当 m（训练集样本）增大时，先前的 λ 仍然有用</li><li>加入正则化后的 cost function，前一项是为了让模型拟合数据，而后一项是为了防止模型过拟合。参数 λ 平衡了这两个功能。我们往往需要选择一个权衡两者的 λ</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909144416958.png" alt="image-20220909144416958"></p><h2 id="2-5-加入正则化后的梯度下降"><a href="#2-5-加入正则化后的梯度下降" class="headerlink" title="2.5. 加入正则化后的梯度下降"></a>2.5. 加入正则化后的梯度下降</h2><h3 id="2-5-1-线性回归"><a href="#2-5-1-线性回归" class="headerlink" title="2.5.1. 线性回归"></a>2.5.1. 线性回归</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909144754578.png" alt="image-20220909144754578"></p><ul><li>加上正则化之后，使得每次梯度下降后的$w_j$下降一点点</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909152304619.png" alt="image-20220909152304619"></p><h3 id="2-5-2-逻辑回归"><a href="#2-5-2-逻辑回归" class="headerlink" title="2.5.2. 逻辑回归"></a>2.5.2. 逻辑回归</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909152918725.png" alt="image-20220909152918725"></p><ul><li>求导之后的梯度下降更新项和线性回归一模一样</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220909153007372.png" alt="image-20220909153007372"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coursera: ML01-概论与线性回归</title>
      <link href="/article/Coursera-Machine-Learning-01/"/>
      <url>/article/Coursera-Machine-Learning-01/</url>
      
        <content type="html"><![CDATA[<h1 id="概论与线性回归"><a href="#概论与线性回归" class="headerlink" title="概论与线性回归"></a>概论与线性回归</h1><p>Machine Learning - Android Ng</p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20221005220433978.png" alt="image-20221005220433978" /><h2 id="1-1-分类"><a href="#1-1-分类" class="headerlink" title="1.1. 分类"></a>1.1. 分类</h2><ul><li>监督学习</li><li>无监督学习</li><li>增强学习（reinforcement learning）</li></ul><h2 id="1-2-监督学习"><a href="#1-2-监督学习" class="headerlink" title="1.2. 监督学习"></a>1.2. 监督学习</h2><ul><li>supervised learning</li><li>通过给予机器正确的例子（包括答案）让其学习</li></ul><h3 id="1-2-1-回归"><a href="#1-2-1-回归" class="headerlink" title="1.2.1. 回归"></a>1.2.1. 回归</h3><ul><li>regression</li><li>从无限多个可能的 output 中预测一个结果（连续），output 一般是数字</li></ul><h3 id="1-2-2-分类算法"><a href="#1-2-2-分类算法" class="headerlink" title="1.2.2. 分类算法"></a>1.2.2. 分类算法</h3><ul><li>classification</li><li>和回归的区别是：只有两个或有限的可能的输出</li><li>预测类别，而类别不一定是数字</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220906145641543.png" alt="image-20220906145641543"></p><ul><li>上图例子（预测乳腺癌）中，只有肿瘤大小一个输入。但实际上可以有多个输入</li></ul><h2 id="1-3-无监督学习"><a href="#1-3-无监督学习" class="headerlink" title="1.3. 无监督学习"></a>1.3. 无监督学习</h2><ul><li>Unsupervised learning</li><li>在无监督学习中，得到的数据是无 label 的，即无结果</li><li>目的只是找到一些数据中的模式或结构，而不是得到什么具体的结论</li></ul><h3 id="1-3-1-聚类"><a href="#1-3-1-聚类" class="headerlink" title="1.3. 1. 聚类"></a>1.3. 1. 聚类</h3><ul><li>clustering</li><li>获取没有标签的 data，并试图自动将他们分到不同的类别（聚簇）中</li></ul><h3 id="1-3-2-异常检测"><a href="#1-3-2-异常检测" class="headerlink" title="1.3.2. 异常检测"></a>1.3.2. 异常检测</h3><ul><li>Anomaly detection</li></ul><h3 id="1-3-3-降维"><a href="#1-3-3-降维" class="headerlink" title="1.3.3. 降维"></a>1.3.3. 降维</h3><ul><li>Dimensionality reduction</li></ul><h2 id="1-4-线性回归模型"><a href="#1-4-线性回归模型" class="headerlink" title="1.4. 线性回归模型"></a>1.4. 线性回归模型</h2><ul><li>属于监督学习</li></ul><h4 id="1-4-1-数据表"><a href="#1-4-1-数据表" class="headerlink" title="1.4.1. 数据表"></a>1.4.1. 数据表</h4><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220906224237839.png" alt="image-20220906224237839"></p><h4 id="1-4-2-训练集"><a href="#1-4-2-训练集" class="headerlink" title="1.4.2. 训练集"></a>1.4.2. 训练集</h4><p>用来训练模型的数据，包括输入（变量、特征或输入特征）和输出（目标变量）</p><p>一些专业术语<img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220906224737300.png" alt="image-20220906224737300" style="zoom: 50%;" /><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220906225335017.png" alt="image-20220906225335017" style="zoom:50%;" /></p><h2 id="1-5-成本函数"><a href="#1-5-成本函数" class="headerlink" title="1.5. 成本函数"></a>1.5. 成本函数</h2><p>$$<br>J(w,b) &#x3D; \frac{1}{2m} \Sigma_{i&#x3D;1}^m (y_{hat}^{(i)} - y^{(i)})^2<br>$$</p><p>平方残差损失函数常常用于线性回归中。我们希望找到一个模型让损失函数最下</p><h2 id="1-6-梯度下降"><a href="#1-6-梯度下降" class="headerlink" title="1.6. 梯度下降"></a>1.6. 梯度下降</h2><ul><li>gradient descent</li></ul><p>$$<br>min_{w_1,….,w_n,b}J(W_1,W_2,…,W_n,b)<br>$$</p><p>对应多参数的损失函数，可以使用梯度下降找到使其最小的点。</p><p>注意：如果对于一些不是吊床形和碗形的图像，可能存在不止一个极小值</p><ul><li>选择一个 w 和 b 作为起始点</li><li>然后沿着斜率最陡的方向下降</li></ul><p>$$<br>w &#x3D; w - \alpha \frac{\alpha}{\alpha w}J(w,b)<br>$$</p><p>$$<br>b &#x3D; b - \alpha \frac{\alpha}{\alpha b}J(w,b)<br>$$</p><p>$\alpha$叫做学习率</p><ul><li>一个例子</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220907181123570.png" alt="image-20220907181123570"></p><h3 id="1-6-1-学习率"><a href="#1-6-1-学习率" class="headerlink" title="1.6.1. 学习率"></a>1.6.1. 学习率</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908120058580.png" alt="image-20220908120058580"></p><p>学习率太小：梯度下降太慢</p><p>学习率太大：可能无法收敛，反而发散</p><h4 id="1-6-1-1-如何选择好的学习率"><a href="#1-6-1-1-如何选择好的学习率" class="headerlink" title="1.6.1.1. 如何选择好的学习率"></a>1.6.1.1. 如何选择好的学习率</h4><ul><li>debug 梯度下降的方法是：将学习率设定为非常小，然后看迭代后 J 是否收敛（向极小值&#x2F;最小值逼近）</li></ul><h3 id="1-6-2-批量梯度下降"><a href="#1-6-2-批量梯度下降" class="headerlink" title="1.6.2. 批量梯度下降"></a>1.6.2. 批量梯度下降</h3><p>Batch gradient descent</p><p>‘Batch’的意思是梯度下降的每一步都使用所有的训练集</p><h3 id="1-6-3-矢量化"><a href="#1-6-3-矢量化" class="headerlink" title="1.6.3. 矢量化"></a>1.6.3. 矢量化</h3><ul><li>多元线性回归</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908171348625.png" alt="image-20220908171348625"></p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908172417233.png" alt="image-20220908172417233"></p><ul><li>矢量化快速的原因主要是可以理由计算机的并行硬件进行并行计算，而 for 循环只能在循环中一个个循环的计算。</li></ul><h3 id="1-6-4-多元回归的梯度下降"><a href="#1-6-4-多元回归的梯度下降" class="headerlink" title="1.6.4. 多元回归的梯度下降"></a>1.6.4. 多元回归的梯度下降</h3><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908193206271.png" alt="image-20220908193206271"></p><h2 id="1-7-正规方程法"><a href="#1-7-正规方程法" class="headerlink" title="1.7. 正规方程法"></a>1.7. 正规方程法</h2><ul><li><p>normal equation</p></li><li><p>只针对线性回归，不需要迭代即可求解 w 和 b 的方法</p></li><li><p>不适用其他方法</p></li><li><p>当 features 很大（&gt; 10000）时，处理很慢</p></li></ul><h2 id="1-8-特征缩放"><a href="#1-8-特征缩放" class="headerlink" title="1.8. 特征缩放"></a>1.8. 特征缩放</h2><ul><li>让梯度下降更快</li><li>让多维数据彼此之间的范围变得 comparable</li><li>归一化（mean normalization），让所有参数在[-1, 1]之间</li></ul><p>$$<br>x_i &#x3D; \frac{x_i - μ_i}{max - min}<br>$$</p><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908195407614.png" alt="image-20220908195407614"></p><ul><li>Z-scroe 归一化（normalization）</li><li>计算每个特征的标准差</li></ul><p>$$<br>X_i &#x3D; \frac{x_i - μ_i}{\sigma_i}<br>$$</p><ul><li>一样可以达到让所有参数在[-1, 1]之间</li></ul><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20220908195556934.png" alt="image-20220908195556934"></p><h2 id="1-9-检查梯度下降-work-well"><a href="#1-9-检查梯度下降-work-well" class="headerlink" title="1.9. 检查梯度下降 work well"></a>1.9. 检查梯度下降 work well</h2><ul><li><p>通过学习曲线（绘制 J-iteration 函数图像）观察函数变平的时候</p></li><li><p>通过自动收敛测试。其实很类似微积分证明极限的思想。当 J 每次增减小于 δ（极小）时，认为已经收敛</p></li></ul><h2 id="1-10-特征工程"><a href="#1-10-特征工程" class="headerlink" title="1.10. 特征工程"></a>1.10. 特征工程</h2><ul><li><p>Feature engineering</p></li><li><p>通过直觉来设计一个新特征，通常通过改变或结合已有特征来实现</p></li><li><p>选择正确且适当的特征是机器学习模型 work well 的重要前提</p></li></ul><h2 id="1-11-多项式回归"><a href="#1-11-多项式回归" class="headerlink" title="1.11. 多项式回归"></a>1.11. 多项式回归</h2><ul><li>Polynomial regression</li><li>即使用高次、开根等项进行回归拟合</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的博客之旅</title>
      <link href="/article/My-blog/"/>
      <url>/article/My-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="We-‘re-all-dream-catchers"><a href="#We-‘re-all-dream-catchers" class="headerlink" title="We ‘re all dream catchers"></a>We ‘re all dream catchers</h1><div align="center"><img src="https://img12.360buyimg.com/ddimg/jfs/t1/211882/23/840/1275331/616c428cE344ef7a9/75747b1c2a7151c3.jpg" alt="图片替换文本" width="90%" height="auto" align="center" /></div><blockquote><p><strong>1、缘起</strong></p></blockquote><div align="center"><img src="https://img14.360buyimg.com/ddimg/jfs/t1/211102/13/4596/3483452/616294f3E062d1039/173e374926c19dc3.jpg" alt="图片替换文本" width="400" height="240" align="center" /></div><p>   我还记得刚上大一时，曾受某位学长邀请，听关于博客搭建的讲座。讲座的具体内容我现在已经不记得了，但是作为纯正的计算机小白，我当时什么也听不懂。听讲座时那种如坐针毡的感觉我至今仍记忆犹新，而这种感觉也一直贯穿到我现在的计算机学习中（后话了，sigh🚬… 但我还是头铁听完了这场讲座。看着会后同年级的大佬和学长谈笑风生，交流技术细节，我倍感自己的渺小。但是从此，我也有了一颗想be strong的心，原来，自己要学的东西是如此之多。</p><blockquote><p><strong>2、出发</strong></p></blockquote><p>   时间就这样来到大一下学期的暑假。这个暑假我私人方面a lot of things happened（以后合适的时候我会在博客中写出来的），我整个人都浑浑噩噩的，每天都很绝望。But 生活毕竟还得继续，我在8月还得完成暑期社会实践。</p><p>   我很感谢5月的自己，狠下心来给8月的自己准备了一场社会实践来折腾。在和队友的忙碌中，我渐渐找回了自己的状态。也因为这场社会实践，接触了一些web开发的知识，开始真正意义上的成为GitHub的经常使用者。也正因为接触了web开发和GitHub，我更加了解到计算机世界的精彩绝妙，以及众多令人钦佩、孜孜不倦的大佬正在各个领域深耕。于是，我决定做点什么。</p><p>   就这样，我想起了一年前听过的那场讲座，那场我当时如听天书的讲座。“欸，不妨试一试，看看现在自己的知识能不能搭一个自己的博客。”</p><p>​        <em><strong>于是，我就开始了我的博客搭建之旅啦！</strong></em></p><blockquote><p><strong>3、实践</strong></p></blockquote><p>   经过搜索大佬博客、b站教程、GitHub开源大佬仓库，我决定采用Hexo框架 + yilia-plus主题搭建我的博客，并采用Github部署。</p><p>   2021年8月28日，我的博客正式部署到我自己的GitHub仓库上~~❀❀❀！！</p><p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/204954/7/10589/62850/61629112E04fb0dc5/728cc76fa499a783.png" alt="avatar"></p><p>   后续博客装修、更新过程我会写在《博客装修日志》中，本文到此结束，感谢阅读！</p><p>​</p><p>​——edited by Peng 2021-10-10 15:44</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎你，每一个到来的人</title>
      <link href="/article/Peng-s-Hello-World/"/>
      <url>/article/Peng-s-Hello-World/</url>
      
        <content type="html"><![CDATA[<h1 id="相信着，明天会更好"><a href="#相信着，明天会更好" class="headerlink" title="相信着，明天会更好"></a>相信着，明天会更好</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

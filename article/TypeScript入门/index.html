<!DOCTYPE html>
<html lang="en">

  <head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="Pengzna,blog" />
  <meta name="author" content="Pengzna" />
  <meta name="description" content="Pengzna 的博客" />
  
  
  <title>
    
      TypeScript ·入门 
      
      
    
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Montserrat|Roboto:400,400italic,600|Roboto+Mono" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">


  

  
    
<link rel="stylesheet" href="/css/post.css">

  

  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="/js/fancybox.js"></script>


<meta name="generator" content="Hexo 7.0.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
      <div class="header">
  <a href="/">Pengzna's blog</a>
</div>


      <p class="links">
  
    <a title="archives" target="" href="/archives/">
      <i class="iconfont icon-bookmark"></i>
    </a>
  
    <a title="github" target="_blank" href="https://github.com/Pengzna">
      <i class="iconfont icon-github"></i>
    </a>
  
    <a title="email" target="" href="">
      <i class="iconfont icon-envelope"></i>
    </a>
  
    <a title="linkedin" target="_blank" href="https://www.linkedin.com/in/pengzna/">
      <i class="iconfont icon-linkedin"></i>
    </a>
  
    <a title="wechat" target="_blank" href="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115013033249.png">
      <i class="iconfont icon-wechat"></i>
    </a>
  
</p>


      <div class="main">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->

<!-- LaTex Display -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>

<div class="post">
  <h3 class="date">
    Jul 25, 2022
  </h3>
  <h1>
    TypeScript ·入门
  </h1>
  <div class="content markdown-body">
    <h2 id="1-TypeScript-简介"><a href="#1-TypeScript-简介" class="headerlink" title="1. TypeScript 简介"></a>1. TypeScript 简介</h2><h3 id="1-1-TypeScript-与-JavaScript-的区别"><a href="#1-1-TypeScript-与-JavaScript-的区别" class="headerlink" title="1.1 TypeScript 与 JavaScript 的区别"></a>1.1 TypeScript 与 JavaScript 的区别</h3><table>
<thead>
<tr>
<th>TypeScript</th>
<th>JavaScript</th>
</tr>
</thead>
<tbody><tr>
<td>JavaScript 的超集用于解决大型项目的代码复杂性</td>
<td>一种脚本语言，用于创建动态网页。</td>
</tr>
<tr>
<td>可以在编译期间发现并纠正错误</td>
<td>作为一种解释型语言，只能在运行时发现错误</td>
</tr>
<tr>
<td>强类型，支持静态和动态类型</td>
<td>弱类型，没有静态类型选项</td>
</tr>
<tr>
<td>最终被编译成 JavaScript 代码，使浏览器可以理解</td>
<td>可以直接在浏览器中使用</td>
</tr>
<tr>
<td>支持模块、泛型和接口</td>
<td>不支持模块，泛型或接口</td>
</tr>
<tr>
<td>支持 ES3，ES4，ES5 和 ES6 等</td>
<td>不支持编译其他 ES3，ES4，ES5 或 ES6 功能</td>
</tr>
<tr>
<td>社区的支持仍在增长，而且还不是很大</td>
<td>大量的社区支持以及大量文档和解决问题的支持</td>
</tr>
</tbody></table>
<h3 id="1-2-获取-TypeScript"><a href="#1-2-获取-TypeScript" class="headerlink" title="1.2 获取 TypeScript"></a>1.2 获取 TypeScript</h3><p>命令行的 TypeScript 编译器可以使用 Node.js 包来安装。</p>
<p><strong>1.安装 TypeScript</strong></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>npm install -g typescript</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>2.编译 TypeScript 文件</strong></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>tsc helloworld.ts</span><br><span class="line"><span class="comment"># helloworld.ts =&gt; helloworld.js</span></span><br></pre></td></tr></table></figure>

<h2 id="2-TypeScript-基础类型"><a href="#2-TypeScript-基础类型" class="headerlink" title="2. TypeScript 基础类型"></a>2. TypeScript 基础类型</h2><h3 id="2-1-Boolean-类型"><a href="#2-1-Boolean-类型" class="headerlink" title="2.1 Boolean 类型"></a>2.1 Boolean 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let isDone: <span class="attr">boolean</span> = <span class="literal">false</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">isDone</span> = <span class="literal">false</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-Number-类型"><a href="#2-2-Number-类型" class="headerlink" title="2.2 Number 类型"></a>2.2 Number 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let count: <span class="attr">number</span> = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">count</span> = <span class="number">10</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-String-类型"><a href="#2-3-String-类型" class="headerlink" title="2.3 String 类型"></a>2.3 String 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let name: <span class="attr">string</span> = <span class="string">&quot;Semliker&quot;</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">name</span> = <span class="string">&#x27;Semlinker&#x27;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-Array-类型"><a href="#2-4-Array-类型" class="headerlink" title="2.4 Array 类型"></a>2.4 Array 类型</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let list: number<span class="section">[]</span> = <span class="section">[1, 2, 3]</span><span class="comment">;</span></span><br><span class="line">// ES5：var <span class="attr">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let list: Array&lt;number&gt; = <span class="section">[1, 2, 3]</span><span class="comment">; // Array&lt;number&gt;泛型语法</span></span><br><span class="line">// ES5：var <span class="attr">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-Enum-类型"><a href="#2-5-Enum-类型" class="headerlink" title="2.5 Enum 类型"></a>2.5 Enum 类型</h3><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。</p>
<h4 id="2-5-1-数字枚举"><a href="#2-5-1-数字枚举" class="headerlink" title="2.5.1.数字枚举"></a><strong>2.5.1.数字枚举</strong></h4><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  NORTH,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dir: <span class="attr">Direction</span> = Direction.NORTH<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。上面的枚举示例代码经过编译后会生成以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;NORTH&#x27;</span>] = <span class="number">0</span>)] = <span class="string">&#x27;NORTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;SOUTH&#x27;</span>] = <span class="number">1</span>)] = <span class="string">&#x27;SOUTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;EAST&#x27;</span>] = <span class="number">2</span>)] = <span class="string">&#x27;EAST&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[(<span class="title class_">Direction</span>[<span class="string">&#x27;WEST&#x27;</span>] = <span class="number">3</span>)] = <span class="string">&#x27;WEST&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;))</span><br><span class="line"><span class="keyword">var</span> dir = <span class="title class_">Direction</span>.<span class="property">NORTH</span></span><br></pre></td></tr></table></figure>

<p>当然我们也可以设置 NORTH 的初始值，比如：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  <span class="attr">NORTH</span> = <span class="number">3</span>,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-字符串枚举"><a href="#2-5-2-字符串枚举" class="headerlink" title="2.5.2.字符串枚举"></a>2.5.<strong>2.字符串枚举</strong></h4><p>在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  <span class="attr">NORTH</span> = <span class="string">&quot;NORTH&quot;</span>,</span><br><span class="line">  <span class="attr">SOUTH</span> = <span class="string">&quot;SOUTH&quot;</span>,</span><br><span class="line">  <span class="attr">EAST</span> = <span class="string">&quot;EAST&quot;</span>,</span><br><span class="line">  <span class="attr">WEST</span> = <span class="string">&quot;WEST&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码对于的 ES5 代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;NORTH&#x27;</span>] = <span class="string">&#x27;NORTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;SOUTH&#x27;</span>] = <span class="string">&#x27;SOUTH&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;EAST&#x27;</span>] = <span class="string">&#x27;EAST&#x27;</span></span><br><span class="line">  <span class="title class_">Direction</span>[<span class="string">&#x27;WEST&#x27;</span>] = <span class="string">&#x27;WEST&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-异构枚举"><a href="#2-5-3-异构枚举" class="headerlink" title="2.5.3.异构枚举"></a>2.5.<strong>3.异构枚举</strong></h4><p>异构枚举的成员值是数字和字符串的混合：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">enum Enum &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">  <span class="attr">C</span> = <span class="string">&quot;C&quot;</span>,</span><br><span class="line">  <span class="attr">D</span> = <span class="string">&quot;D&quot;</span>,</span><br><span class="line">  <span class="attr">E</span> = <span class="number">8</span>,</span><br><span class="line">  F,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码对于的 ES5 代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Enum</span></span><br><span class="line">;(<span class="keyword">function</span> (<span class="params">Enum</span>) &#123;</span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;A&#x27;</span>] = <span class="number">0</span>)] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;B&#x27;</span>] = <span class="number">1</span>)] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[<span class="string">&#x27;C&#x27;</span>] = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[<span class="string">&#x27;D&#x27;</span>] = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;E&#x27;</span>] = <span class="number">8</span>)] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&#x27;F&#x27;</span>] = <span class="number">9</span>)] = <span class="string">&#x27;F&#x27;</span></span><br><span class="line">&#125;)(<span class="title class_">Enum</span> || (<span class="title class_">Enum</span> = &#123;&#125;))</span><br></pre></td></tr></table></figure>

<p>通过观察上述生成的 ES5 代码，我们可以发现数字枚举相对字符串枚举多了 “反向映射”：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(Enum.A) <span class="comment">//输出：0</span></span><br><span class="line">console.<span class="built_in">log</span>(Enum[<span class="number">0</span>]) <span class="comment">// 输出：A</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-Any-类型"><a href="#2-6-Any-类型" class="headerlink" title="2.6 Any 类型"></a>2.6 Any 类型</h3><p>在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的<strong>顶级类型</strong>（也被称作全局超级类型）。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let notSure: <span class="attr">any</span> = <span class="number">666</span><span class="comment">;</span></span><br><span class="line"><span class="attr">notSure</span> = <span class="string">&quot;Semlinker&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">notSure</span> = <span class="literal">false</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><code>any</code> 类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由：TypeScript 允许我们对 <code>any</code> 类型的值执行任何操作，而无需事先执行任何形式的检查。比如：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">let value: any;</span><br><span class="line"></span><br><span class="line">value<span class="selector-class">.foo</span><span class="selector-class">.bar</span>; <span class="comment">// OK</span></span><br><span class="line">value<span class="selector-class">.trim</span>(); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">value</span>(); <span class="comment">// OK</span></span><br><span class="line">new <span class="built_in">value</span>(); <span class="comment">// OK</span></span><br><span class="line">value<span class="selector-attr">[0]</span><span class="selector-attr">[1]</span>; <span class="comment">// OK</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在许多场景下，这太宽松了。使用 <code>any</code> 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 <code>any</code> 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 <code>any</code> 带来的问题，TypeScript 3.0 引入了 <code>unknown</code> 类型。</p>
<h3 id="2-7-Unknown-类型"><a href="#2-7-Unknown-类型" class="headerlink" title="2.7 Unknown 类型"></a>2.7 Unknown 类型</h3><p>就像所有类型都可以赋值给 <code>any</code>，所有类型也都可以赋值给 <code>unknown</code>。这使得 <code>unknown</code> 成为 TypeScript 类型系统的另一种顶级类型（另一种是 <code>any</code>）。下面我们来看一下 <code>unknown</code> 类型的使用示例：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let value: unknown<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">value</span> = <span class="literal">true</span><span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = <span class="number">42</span><span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = <span class="string">&quot;Hello World&quot;</span><span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = []<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = &#123;&#125;<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = Math.random<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = null<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = undefined<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = new TypeError()<span class="comment">; // OK</span></span><br><span class="line"><span class="attr">value</span> = Symbol(<span class="string">&quot;type&quot;</span>)<span class="comment">; // OK</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对 <code>value</code> 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 <code>unknown</code> 的值赋值给其他类型的变量时会发生什么？</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let value: unknown<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let value1: <span class="attr">unknown</span> = value<span class="comment">; // OK</span></span><br><span class="line">let value2: <span class="attr">any</span> = value<span class="comment">; // OK</span></span><br><span class="line">let value3: <span class="attr">boolean</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value4: <span class="attr">number</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value5: <span class="attr">string</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value6: <span class="attr">object</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value7: any<span class="section">[]</span> = value<span class="comment">; // Error</span></span><br><span class="line">let value8: <span class="attr">Function</span> = value<span class="comment">; // Error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>unknown</code> 类型只能被赋值给 <code>any</code> 类型和 <code>unknown</code> 类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 <code>unknown</code> 类型的值。毕竟我们不知道变量 <code>value</code> 中存储了什么类型的值。</p>
<p>现在让我们看看当我们尝试对类型为 <code>unknown</code> 的值执行操作时会发生什么。以下是我们在之前 <code>any</code> 章节看过的相同操作：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">let value: unknown;</span><br><span class="line"></span><br><span class="line">value<span class="selector-class">.foo</span><span class="selector-class">.bar</span>; <span class="comment">// Error</span></span><br><span class="line">value<span class="selector-class">.trim</span>(); <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">value</span>(); <span class="comment">// Error</span></span><br><span class="line">new <span class="built_in">value</span>(); <span class="comment">// Error</span></span><br><span class="line">value<span class="selector-attr">[0]</span><span class="selector-attr">[1]</span>; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>将 <code>value</code> 变量类型设置为 <code>unknown</code> 后，这些操作都不再被认为是类型正确的。通过将 <code>any</code> 类型改变为 <code>unknown</code> 类型，我们已将允许所有更改的默认设置，更改为<strong>禁止任何更改</strong>。</p>
<h3 id="2-8-Tuple-类型"><a href="#2-8-Tuple-类型" class="headerlink" title="2.8 Tuple 类型"></a>2.8 Tuple 类型</h3><p>众所周知，数组一般由同种类型的值组成，<strong>但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组</strong>。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。</p>
<p>元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值。为了更直观地理解元组的概念，我们来看一个具体的例子：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let tupleType: <span class="section">[string, boolean]</span><span class="comment">;</span></span><br><span class="line"><span class="attr">tupleType</span> = [<span class="string">&quot;Semlinker&quot;</span>, <span class="literal">true</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>在上面代码中，我们定义了一个名为 <code>tupleType</code> 的变量，它的类型是一个类型数组 <code>[string, boolean]</code>，然后我们按照正确的类型依次初始化 tupleType 变量。与数组一样，我们可以通过下标来访问元组中的元素：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(tupleType[<span class="number">0</span>]); <span class="comment">// Semlinker</span></span><br><span class="line">console.<span class="built_in">log</span>(tupleType[<span class="number">1</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在元组初始化的时候，如果出现类型不匹配的话，比如：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">tupleType</span> = [<span class="literal">true</span>, <span class="string">&quot;Semlinker&quot;</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>此时，TypeScript 编译器会提示以下错误信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>]: <span class="type">Type</span> <span class="string">&#x27;true&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> assignable to <span class="built_in">type</span> <span class="string">&#x27;string&#x27;</span>.</span><br><span class="line">[<span class="number">1</span>]: <span class="type">Type</span> <span class="string">&#x27;string&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> assignable to <span class="built_in">type</span> <span class="string">&#x27;boolean&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>很明显是因为类型不匹配导致的。在元组初始化的时候，我们还必须提供<strong>每个属性的值</strong>，不然也会出现错误，比如：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">tupleType</span> = [<span class="string">&quot;Semlinker&quot;</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>此时，TypeScript 编译器会提示以下错误信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Property <span class="string">&#x27;1&#x27;</span> <span class="keyword">is</span> missing <span class="keyword">in</span> <span class="built_in">type</span> <span class="string">&#x27;[string]&#x27;</span> but required <span class="keyword">in</span> <span class="built_in">type</span> <span class="string">&#x27;[string, boolean]&#x27;</span>.</span><br></pre></td></tr></table></figure>

<h3 id="2-9-Void-类型"><a href="#2-9-Void-类型" class="headerlink" title="2.9 Void 类型"></a>2.9 Void 类型</h3><p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数返回值为void</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is my warning message&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码编译生成的 ES5 代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is my warning message&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，声明一个 void 类型的变量没有什么作用，因为它的值只能为 <code>undefined</code> 或 <code>null</code>：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let unusable: <span class="attr">void</span> = undefined<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-10-Null-和-Undefined-类型"><a href="#2-10-Null-和-Undefined-类型" class="headerlink" title="2.10 Null 和 Undefined 类型"></a>2.10 Null 和 Undefined 类型</h3><p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者有各自的类型分别为 <code>undefined</code> 和 <code>null</code>。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let u: <span class="attr">undefined</span> = undefined<span class="comment">;</span></span><br><span class="line">let n: <span class="attr">null</span> = null<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。<strong>然而，如果你指定了<code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自的类型。</strong></p>
<h3 id="2-11-Never-类型"><a href="#2-11-Never-类型" class="headerlink" title="2.11 Never 类型"></a>2.11 Never 类型</h3><p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如，<code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">controlFlowAnalysisWithNever</span>(<span class="params">foo: Foo</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里 foo 被收窄为 string 类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里 foo 被收窄为 number 类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// foo 在这里是 never</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">check</span>: <span class="built_in">never</span> = foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然而他忘记同时修改 <code>controlFlowAnalysisWithNever</code> 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 <code>boolean</code> 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保</p>
<p><code>controlFlowAnalysisWithNever</code> 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：<strong>使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。</strong></p>
<h2 id="3-TypeScript-断言"><a href="#3-TypeScript-断言" class="headerlink" title="3. TypeScript 断言"></a>3. TypeScript 断言</h2><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p>
<p>类型断言有两种形式：</p>
<h3 id="3-1-“尖括号”-语法"><a href="#3-1-“尖括号”-语法" class="headerlink" title="3.1. “尖括号” 语法"></a>3.1. “尖括号” 语法</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let someValue: <span class="attr">any</span> = <span class="string">&quot;this is a string&quot;</span><span class="comment">;</span></span><br><span class="line">let strLength: <span class="attr">number</span> = (&lt;string&gt;someValue).length<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-as-语法"><a href="#3-2-as-语法" class="headerlink" title="3.2. as 语法"></a>3.2. as 语法</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let someValue: <span class="attr">any</span> = <span class="string">&quot;this is a string&quot;</span><span class="comment">;</span></span><br><span class="line">let strLength: <span class="attr">number</span> = (someValue as string).length<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-类型守卫"><a href="#4-类型守卫" class="headerlink" title="4. 类型守卫"></a>4. 类型守卫</h2><blockquote>
<p>A type guard is some expression that performs a runtime check that guarantees the type in some scope. —— TypeScript 官方文档</p>
</blockquote>
<p>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。目前主要有四种的方式来实现类型保护：</p>
<h3 id="4-1-in-关键字"><a href="#4-1-in-关键字" class="headerlink" title="4.1 in 关键字"></a>4.1 in 关键字</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Admin</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">privileges</span>: <span class="built_in">string</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">startDate</span>: <span class="title class_">Date</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnknownEmployee</span> = <span class="title class_">Employee</span> | <span class="title class_">Admin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printEmployeeInformation</span>(<span class="params">emp: UnknownEmployee</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Name: &#x27;</span> + emp.<span class="property">name</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;privileges&#x27;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Privileges: &#x27;</span> + emp.<span class="property">privileges</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;startDate&#x27;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Start Date: &#x27;</span> + emp.<span class="property">startDate</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-typeof-关键字"><a href="#4-2-typeof-关键字" class="headerlink" title="4.2 typeof 关键字"></a>4.2 typeof 关键字</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>(padding + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>) + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>typeof</code> 类型保护只支持两种形式：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== typename</code>，<code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>， <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</p>
<h3 id="4-3-instanceof-关键字"><a href="#4-3-instanceof-关键字" class="headerlink" title="4.3 instanceof 关键字"></a>4.3 instanceof 关键字</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Padder</span> &#123;</span><br><span class="line">  <span class="title function_">getPaddingString</span>(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceRepeatingPadder</span> <span class="keyword">implements</span> <span class="title class_">Padder</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">getPaddingString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>(<span class="variable language_">this</span>.<span class="property">numSpaces</span> + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringPadder</span> <span class="keyword">implements</span> <span class="title class_">Padder</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">getPaddingString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">padder</span>: <span class="title class_">Padder</span> = <span class="keyword">new</span> <span class="title class_">SpaceRepeatingPadder</span>(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> <span class="title class_">SpaceRepeatingPadder</span>) &#123;</span><br><span class="line">  <span class="comment">// padder的类型收窄为 &#x27;SpaceRepeatingPadder&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-自定义类型保护的类型谓词"><a href="#4-4-自定义类型保护的类型谓词" class="headerlink" title="4.4 自定义类型保护的类型谓词"></a>4.4 自定义类型保护的类型谓词</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): x is <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">x: <span class="built_in">any</span></span>): x is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-联合类型和类型别名"><a href="#5-联合类型和类型别名" class="headerlink" title="5. 联合类型和类型别名"></a>5. 联合类型和类型别名</h2><h3 id="5-1-联合类型"><a href="#5-1-联合类型" class="headerlink" title="5.1 联合类型"></a>5.1 联合类型</h3><p>联合类型通常与 <code>null</code> 或 <code>undefined</code> 一起使用：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sayHello</span> = (<span class="params">name: <span class="built_in">string</span> | <span class="literal">undefined</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，这里 <code>name</code> 的类型是 <code>string | undefined</code> 意味着可以将 <code>string</code> 或 <code>undefined</code> 的值传递给<code>sayHello</code> 函数。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sayHello</span>(&quot;Semlinker&quot;);</span><br><span class="line"><span class="built_in">sayHello</span>(undefined);</span><br></pre></td></tr></table></figure>

<p>通过这个示例，你可以凭直觉知道类型 A 和类型 B 联合后的类型是同时接受 A 和 B 值的类型。</p>
<h3 id="5-2-可辨识联合"><a href="#5-2-可辨识联合" class="headerlink" title="5.2 可辨识联合"></a>5.2 可辨识联合</h3><p>TypeScript 可辨识联合（Discriminated Unions）类型，也称为代数数据类型或标签联合类型。<strong>它包含 3 个要点：可辨识、联合类型和类型守卫。</strong></p>
<p>这种类型的本质是结合联合类型和字面量类型的一种类型保护方法。<strong>如果一个类型是多个类型的联合类型，且多个类型含有一个公共属性，那么就可以利用这个公共属性，来创建不同的类型保护区块。</strong></p>
<p><strong>1.可辨识</strong></p>
<p>可辨识要求联合类型中的每个元素都含有一个单例类型属性，比如：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">enum CarTransmission &#123;</span><br><span class="line">  Automatic = <span class="number">200</span>,</span><br><span class="line">  Manual = <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Motorcycle &#123;</span><br><span class="line">  vType: <span class="string">&quot;motorcycle&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  make: number; <span class="comment">// year</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Car &#123;</span><br><span class="line">  vType: <span class="string">&quot;car&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  transmission: CarTransmission</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Truck &#123;</span><br><span class="line">  vType: <span class="string">&quot;truck&quot;</span>; <span class="comment">// discriminant</span></span><br><span class="line">  capacity: number; <span class="comment">// in tons</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们分别定义了 <code>Motorcycle</code>、 <code>Car</code> 和 <code>Truck</code> 三个接口，在这些接口中都包含一个 <code>vType</code> 属性，该属性被称为可辨识的属性，而其它的属性只跟特性的接口相关。</p>
<p><strong>2.联合类型</strong></p>
<p>基于前面定义了三个接口，我们可以创建一个 <code>Vehicle</code> 联合类型：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">type <span class="attr">Vehicle</span> = Motorcycle | Car | Truck<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>现在我们就可以开始使用 <code>Vehicle</code> 联合类型，对于 <code>Vehicle</code> 类型的变量，它可以表示不同类型的车辆。</p>
<p><strong>3.类型守卫</strong></p>
<p>下面我们来定义一个 <code>evaluatePrice</code> 方法，该方法用于根据车辆的类型、容量和评估因子来计算价格，具体实现如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">const <span class="attr">EVALUATION_FACTOR</span> = Math.PI<span class="comment">;</span></span><br><span class="line">function evaluatePrice(vehicle: Vehicle) &#123;</span><br><span class="line">  return vehicle.capacity * EVALUATION_FACTOR<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myTruck: <span class="attr">Truck</span> = &#123; vType: <span class="string">&quot;truck&quot;</span>, capacity: <span class="number">9.5</span> &#125;<span class="comment">;</span></span><br><span class="line">evaluatePrice(myTruck)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>对于以上代码，TypeScript 编译器将会提示以下错误信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Property <span class="string">&#x27;capacity&#x27;</span> does not exist on <span class="built_in">type</span> <span class="string">&#x27;Vehicle&#x27;</span>.</span><br><span class="line">Property <span class="string">&#x27;capacity&#x27;</span> does not exist on <span class="built_in">type</span> <span class="string">&#x27;Motorcycle&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>原因是在 Motorcycle 接口中，并不存在 <code>capacity</code> 属性，而对于 Car 接口来说，它也不存在 <code>capacity</code> 属性。那么，现在我们应该如何解决以上问题呢？这时，我们可以使用类型守卫。下面我们来重构一下前面定义的 <code>evaluatePrice</code> 方法，重构后的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">evaluatePrice</span>(<span class="params">vehicle: Vehicle</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (vehicle.<span class="property">vType</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;car&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.<span class="property">transmission</span> * <span class="variable constant_">EVALUATION_FACTOR</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;truck&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.<span class="property">capacity</span> * <span class="variable constant_">EVALUATION_FACTOR</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;motorcycle&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> vehicle.<span class="property">make</span> * <span class="variable constant_">EVALUATION_FACTOR</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，我们使用 <code>switch</code> 和 <code>case</code> 运算符来实现类型守卫，从而确保在 <code>evaluatePrice</code> 方法中，我们可以安全地访问 <code>vehicle</code> 对象中的所包含的属性，来正确的计算该车辆类型所对应的价格。</p>
<h3 id="5-3-类型别名"><a href="#5-3-类型别名" class="headerlink" title="5.3 类型别名"></a>5.3 类型别名</h3><p>类型别名用来给一个类型起个新名字。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">type <span class="attr">Message</span> = string | string[]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">greet</span> = (message: Message) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-交叉类型"><a href="#6-交叉类型" class="headerlink" title="6. 交叉类型"></a>6. 交叉类型</h2><p>TypeScript 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它<strong>包含了所需的所有类型的特性</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IWorker</span> &#123;</span><br><span class="line">  <span class="attr">companyId</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IStaff</span> = <span class="title class_">IPerson</span> &amp; <span class="title class_">IWorker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">staff</span>: <span class="title class_">IStaff</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;E1006&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">33</span>,</span><br><span class="line">  <span class="attr">companyId</span>: <span class="string">&#x27;EFT&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(staff)</span><br></pre></td></tr></table></figure>

<p>在上面示例中，我们首先为 IPerson 和 IWorker 类型定义了不同的成员，然后通过 <code>&amp;</code> 运算符定义了 IStaff 交叉类型，所以该类型同时拥有 IPerson 和 IWorker 这两种类型的成员。</p>
<h2 id="7-TypeScript-函数"><a href="#7-TypeScript-函数" class="headerlink" title="7. TypeScript 函数"></a>7. TypeScript 函数</h2><h3 id="7-1-TypeScript-函数与-JavaScript-函数的区别"><a href="#7-1-TypeScript-函数与-JavaScript-函数的区别" class="headerlink" title="7.1 TypeScript 函数与 JavaScript 函数的区别"></a>7.1 TypeScript 函数与 JavaScript 函数的区别</h3><table>
<thead>
<tr>
<th>TypeScript</th>
<th>JavaScript</th>
</tr>
</thead>
<tbody><tr>
<td>含有类型</td>
<td>无类型</td>
</tr>
<tr>
<td>箭头函数</td>
<td>箭头函数（ES2015）</td>
</tr>
<tr>
<td>函数类型</td>
<td>无函数类型</td>
</tr>
<tr>
<td>必填和可选参数</td>
<td>所有参数都是可选的</td>
</tr>
<tr>
<td>默认参数</td>
<td>默认参数</td>
</tr>
<tr>
<td>剩余参数</td>
<td>剩余参数</td>
</tr>
<tr>
<td>函数重载</td>
<td>无函数重载</td>
</tr>
</tbody></table>
<h3 id="7-2-箭头函数"><a href="#7-2-箭头函数" class="headerlink" title="7.2 箭头函数"></a>7.2 箭头函数</h3><p><strong>1.常见语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reading&#x27;</span>));</span><br><span class="line"></span><br><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function"><span class="params">title</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(title));</span><br><span class="line"></span><br><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">title, idx, arr</span>) =&gt;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(idx + <span class="string">&#x27;-&#x27;</span> + title);</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">myBooks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">title, idx, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(idx + <span class="string">&#x27;-&#x27;</span> + title);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>2.使用示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未使用箭头函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span></span><br><span class="line">  self.<span class="property">publishDate</span> = <span class="number">2016</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(self.<span class="property">publishDate</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">publishDate</span> = <span class="number">2016</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">publishDate</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-参数类型和返回类型"><a href="#7-3-参数类型和返回类型" class="headerlink" title="7.3 参数类型和返回类型"></a>7.3 参数类型和返回类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-函数类型"><a href="#7-4-函数类型" class="headerlink" title="7.4 函数类型"></a>7.4 函数类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数类型，然后再赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">IdGenerator</span>: <span class="function">(<span class="params">chars: <span class="built_in">string</span>, nums: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">IdGenerator</span> = createUserId</span><br></pre></td></tr></table></figure>

<h3 id="7-5-可选参数及默认参数"><a href="#7-5-可选参数及默认参数" class="headerlink" title="7.5 可选参数及默认参数"></a>7.5 可选参数及默认参数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可选参数：加个问号即可</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params">name: <span class="built_in">string</span>, id: <span class="built_in">number</span>, age?: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createUserId</span>(<span class="params"></span></span><br><span class="line"><span class="params">  name: <span class="built_in">string</span> = <span class="string">&#x27;Semlinker&#x27;</span>,</span></span><br><span class="line"><span class="params">  id: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  age?: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在声明函数时，可以通过 <code>?</code> 号来定义可选参数，比如 <code>age?: number</code> 这种形式。在实际使用时，需要注意的是可选参数要放在普通参数的后面，不然会导致编译错误。</p>
<h3 id="7-6-剩余参数"><a href="#7-6-剩余参数" class="headerlink" title="7.6 剩余参数"></a>7.6 剩余参数</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加...表示剩余参数</span></span><br><span class="line">function <span class="built_in">push</span>(array, ...items) &#123;</span><br><span class="line">  items<span class="selector-class">.forEach</span>(function (item) &#123;</span><br><span class="line">    array<span class="selector-class">.push</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="selector-tag">a</span> = <span class="selector-attr">[]</span>;</span><br><span class="line"><span class="built_in">push</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="7-7-函数重载"><a href="#7-7-函数重载" class="headerlink" title="7.7 函数重载"></a>7.7 函数重载</h3><p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: Combinable, b: Combinable</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">toString</span>() + b.<span class="title function_">toString</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，我们为 add 函数提供了多个函数类型定义，从而实现函数的重载。之后，可恶的错误消息又消失了，因为这时 result 变量的类型是 <code>string</code> 类型。在 TypeScript 中除了可以重载普通函数之外，我们还可以重载类中的成员方法。</p>
<p>方法重载是指在同一个类中方法同名，参数不同（参数类型不同、参数个数不同或参数个数相同时参数的先后顺序不同），调用时根据实参的形式，选择与它匹配的方法执行操作的一种技术。所以类中成员方法满足重载的条件是：在同一个类中，方法名相同且参数列表不同。下面我们来举一个成员方法重载的例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: number, <span class="attr">b</span>: number): number;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: <span class="keyword">string</span>, <span class="attr">b</span>: <span class="keyword">string</span>): <span class="keyword">string</span>;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: <span class="keyword">string</span>, <span class="attr">b</span>: number): <span class="keyword">string</span>;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: number, <span class="attr">b</span>: <span class="keyword">string</span>): <span class="keyword">string</span>;</span><br><span class="line">  <span class="title function_ invoke__">add</span>(<span class="attr">a</span>: Combinable, <span class="attr">b</span>: Combinable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof a === <span class="string">&quot;string&quot;</span> || typeof b === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.<span class="title function_ invoke__">toString</span>() + b.<span class="title function_ invoke__">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">calculator</span> = <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">result</span> = calculator.<span class="title function_ invoke__">add</span>(<span class="string">&quot;Semlinker&quot;</span>, <span class="string">&quot; Kakuqo&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，当 TypeScript 编译器处理函数重载时，它会查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。另外在 Calculator 类中，<code>add(a: Combinable, b: Combinable)&#123; &#125;</code> 并不是重载列表的一部分，因此对于 add 成员方法来说，我们只定义了四个重载方法。</p>
<h2 id="8-TypeScript-数组"><a href="#8-TypeScript-数组" class="headerlink" title="8. TypeScript 数组"></a>8. TypeScript 数组</h2><h3 id="8-1-数组解构"><a href="#8-1-数组解构" class="headerlink" title="8.1 数组解构"></a>8.1 数组解构</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> five_array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">;[x, y, z] = five_array</span><br></pre></td></tr></table></figure>

<h3 id="8-2-数组展开运算符"><a href="#8-2-数组展开运算符" class="headerlink" title="8.2 数组展开运算符"></a>8.2 数组展开运算符</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let <span class="attr">two_array</span> = [<span class="number">0</span>, <span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">let <span class="attr">five_array</span> = [...two_array, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-数组遍历"><a href="#8-3-数组遍历" class="headerlink" title="8.3 数组遍历"></a>8.3 数组遍历</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">colors</span>: <span class="built_in">string</span>[] = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> colors) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-TypeScript-对象"><a href="#9-TypeScript-对象" class="headerlink" title="9. TypeScript 对象"></a>9. TypeScript 对象</h2><h3 id="9-1-对象解构"><a href="#9-1-对象解构" class="headerlink" title="9.1 对象解构"></a>9.1 对象解构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Semlinker&quot;</span>,</span><br><span class="line">  gender: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> &#123; name, gender &#125; = person;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-对象展开运算符"><a href="#9-2-对象展开运算符" class="headerlink" title="9.2 对象展开运算符"></a>9.2 对象展开运算符</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Semlinker&quot;</span>,</span><br><span class="line">  gender: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line">  address: <span class="string">&quot;Xiamen&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装对象</span></span><br><span class="line"><span class="keyword">let</span> personWithAge = &#123; ...person, age: <span class="number">33</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取除了某些项外的其它项</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, ...rest &#125; = person;</span><br></pre></td></tr></table></figure>

<h2 id="10-TypeScript-接口"><a href="#10-TypeScript-接口" class="headerlink" title="10. TypeScript 接口"></a>10. TypeScript 接口</h2><p>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。</p>
<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于<a href="https://link.juejin.cn/?target=https://ts.xcatliu.com/advanced/class-and-interfaces.html%23%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状（Shape）」进行描述。</p>
<h3 id="10-1-对象的形状"><a href="#10-1-对象的形状" class="headerlink" title="10.1 对象的形状"></a>10.1 对象的形状</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let Semlinker: Person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Semlinker&quot;</span>,</span><br><span class="line">  age: <span class="number">33</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="10-2-可选-只读属性"><a href="#10-2-可选-只读属性" class="headerlink" title="10.2 可选 | 只读属性"></a>10.2 可选 | 只读属性</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只读属性用于限制只能在<strong>对象刚刚创建的时候修改其值</strong>。此外 TypeScript 还提供了 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">let a: number<span class="section">[]</span> = <span class="section">[1, 2, 3, 4]</span><span class="comment">;</span></span><br><span class="line">let ro: ReadonlyArray&lt;number&gt; = a<span class="comment">;</span></span><br><span class="line">ro<span class="section">[0]</span> = 12<span class="comment">; // error!</span></span><br><span class="line">ro.push(5)<span class="comment">; // error!</span></span><br><span class="line"><span class="attr">ro.length</span> = <span class="number">100</span><span class="comment">; // error!</span></span><br><span class="line"><span class="attr">a</span> = ro<span class="comment">; // error!</span></span><br></pre></td></tr></table></figure>

<h2 id="11-TypeScript-类"><a href="#11-TypeScript-类" class="headerlink" title="11. TypeScript 类"></a>11. TypeScript 类</h2><h3 id="11-1-类的属性与方法"><a href="#11-1-类的属性与方法" class="headerlink" title="11.1 类的属性与方法"></a>11.1 类的属性与方法</h3><p>在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。</p>
<p>在 TypeScript 中，我们可以通过 <code>Class</code> 关键字来定义一个类：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="keyword">static</span> <span class="attr">cname</span>: <span class="built_in">string</span> = <span class="string">&#x27;Greeter&#x27;</span></span><br><span class="line">  <span class="comment">// 成员属性</span></span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数 - 执行初始化操作</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getClassName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Class name is Greeter&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成员方法</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>那么成员属性与静态属性，成员方法与静态方法有什么区别呢？这里无需过多解释，我们直接看一下以下编译生成的 ES5 代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Greeter</span> = <span class="comment">/** <span class="doctag">@class</span> */</span> (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 构造函数 - 执行初始化操作</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Greeter</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">greeting</span> = message</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="title class_">Greeter</span>.<span class="property">getClassName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Class name is Greeter&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 成员方法</span></span><br><span class="line">  <span class="title class_">Greeter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="title class_">Greeter</span>.<span class="property">cname</span> = <span class="string">&#x27;Greeter&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Greeter</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">var</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="11-2-访问器"><a href="#11-2-访问器" class="headerlink" title="11.2 访问器"></a>11.2 访问器</h3><p>在 TypeScript 中，我们可以通过 <code>getter</code> 和 <code>setter</code> 方法来实现数据的封装和有效性校验，防止出现异常数据。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">&#x27;Hello TypeScript&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_fullName</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_fullName</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">newName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">&#x27;Hello TypeScript&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_fullName</span> = newName</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error: Unauthorized update of employee!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> <span class="title class_">Employee</span>()</span><br><span class="line">employee.<span class="property">fullName</span> = <span class="string">&#x27;Semlinker&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (employee.<span class="property">fullName</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(employee.<span class="property">fullName</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-3-类的继承"><a href="#11-3-类的继承" class="headerlink" title="11.3 类的继承"></a>11.3 类的继承</h3><p>继承 (Inheritance) 是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。</p>
<p>继承是一种 <a href="https://link.juejin.cn/?target=https://zh.wikipedia.org/wiki/Is-a">is-a </a>关系：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172916651d29ba48~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>在 TypeScript 中，我们可以通过 <code>extends</code> 关键字来实现继承：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = theName</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snake</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">move</span>(<span class="params">distanceInMeters = <span class="number">5</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Slithering...&#x27;</span>)</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">move</span>(distanceInMeters)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> <span class="title class_">Snake</span>(<span class="string">&#x27;Sammy the Python&#x27;</span>)</span><br><span class="line">sam.<span class="title function_">move</span>()</span><br></pre></td></tr></table></figure>

<h3 id="11-4-ECMAScript-私有字段"><a href="#11-4-ECMAScript-私有字段" class="headerlink" title="11.4 ECMAScript 私有字段"></a>11.4 ECMAScript 私有字段</h3><p>在 TypeScript 3.8 版本就开始支持<strong>ECMAScript 私有字段</strong>，使用方式如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  #<span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.#name&#125;</span>!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> semlinker = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Semlinker&#x27;</span>)</span><br><span class="line"></span><br><span class="line">semlinker.#name</span><br><span class="line"><span class="comment">//     ~~~~~</span></span><br><span class="line"><span class="comment">// Property &#x27;#name&#x27; is not accessible outside class &#x27;Person&#x27;</span></span><br><span class="line"><span class="comment">// because it has a private identifier.</span></span><br></pre></td></tr></table></figure>

<p>与常规属性（甚至使用 <code>private</code> 修饰符声明的属性）不同，私有字段要牢记以下规则：</p>
<ul>
<li>私有字段以 <code>#</code> 字符开头，有时我们称之为私有名称；</li>
<li>每个私有字段名称都唯一地限定于其包含的类；</li>
<li>不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；</li>
<li>私有字段不能在包含的类之外访问，甚至不能被检测到。</li>
</ul>
<h2 id="12-TypeScript-泛型"><a href="#12-TypeScript-泛型" class="headerlink" title="12. TypeScript 泛型"></a>12. TypeScript 泛型</h2><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>
<p><strong>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</strong></p>
<p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p>
<p>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p>
<h3 id="12-1-泛型接口"><a href="#12-1-泛型接口" class="headerlink" title="12.1 泛型接口"></a>12.1 泛型接口</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">interface GenericIdentityFn<span class="operator">&lt;</span><span class="built_in">T</span><span class="operator">&gt;</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">(</span>arg<span class="operator">:</span> <span class="built_in">T</span><span class="punctuation">)</span><span class="operator">:</span> <span class="built_in">T</span>;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="12-2-泛型类"><a href="#12-2-泛型类" class="headerlink" title="12.2 泛型类"></a>12.2 泛型类</h3><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">  zeroValue: T<span class="comment">;</span></span><br><span class="line">  add: (x: T, y: T) =&gt; T<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="attr">myGenericNumber</span> = new GenericNumber&lt;number&gt;()<span class="comment">;</span></span><br><span class="line"><span class="attr">myGenericNumber.zeroValue</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="attr">myGenericNumber.add</span> = function (x, y) &#123;</span><br><span class="line">  return x + y<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="12-3-泛型变量"><a href="#12-3-泛型变量" class="headerlink" title="12.3 泛型变量"></a>12.3 泛型变量</h3><p>对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：</p>
<ul>
<li>T（Type）：表示一个 TypeScript 类型</li>
<li>K（Key）：表示对象中的键类型</li>
<li>V（Value）：表示对象中的值类型</li>
<li>E（Element）：表示元素类型</li>
</ul>
<h3 id="12-4-泛型工具类型"><a href="#12-4-泛型工具类型" class="headerlink" title="12.4 泛型工具类型"></a>12.4 泛型工具类型</h3><p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍 Partial 工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。</p>
<h4 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a><strong>1.typeof</strong></h4><p>在 TypeScript 中，<code>typeof</code> 操作符可以用来获取一个变量声明或对象的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">sem</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;semlinker&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sem</span> = <span class="keyword">typeof</span> sem <span class="comment">// -&gt; Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toArray</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [x]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Func</span> = <span class="keyword">typeof</span> toArray <span class="comment">// -&gt; (x: number) =&gt; number[]</span></span><br></pre></td></tr></table></figure>

<h4 id="2-keyof"><a href="#2-keyof" class="headerlink" title="2.keyof"></a><strong>2.keyof</strong></h4><p><code>keyof</code> 操作符可以用来一个对象中的所有 key 值：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> K1 = keyof Person; // <span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="built_in">type</span> K2 = keyof Person[]; // <span class="string">&quot;length&quot;</span> | <span class="string">&quot;toString&quot;</span> | <span class="string">&quot;pop&quot;</span> | <span class="string">&quot;push&quot;</span> | <span class="string">&quot;concat&quot;</span> | <span class="string">&quot;join&quot;</span></span><br><span class="line"><span class="built_in">type</span> K3 = keyof &#123; [x: <span class="built_in">string</span>]: Person &#125;;  // <span class="built_in">string</span> | number</span><br></pre></td></tr></table></figure>

<h4 id="3-in"><a href="#3-in" class="headerlink" title="3.in"></a><strong>3.in</strong></h4><p><code>in</code> 用来遍历枚举类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> Keys = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Obj =  &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: <span class="built_in">any</span></span><br><span class="line">&#125; // -&gt; &#123; a: <span class="built_in">any</span>, b: <span class="built_in">any</span>, c: <span class="built_in">any</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-infer"><a href="#4-infer" class="headerlink" title="4.infer"></a><strong>4.infer</strong></h4><p>在条件类型语句中，可以用 <code>infer</code> 声明一个类型变量并且对它进行使用。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">type ReturnType<span class="operator">&lt;</span><span class="built_in">T</span><span class="operator">&gt;</span> <span class="operator">=</span> <span class="built_in">T</span> extends <span class="punctuation">(</span></span><br><span class="line">  ...args<span class="operator">:</span> <span class="built_in">any</span><span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">)</span> <span class="operator">=</span><span class="operator">&gt;</span> infer R <span class="operator">?</span> R <span class="operator">:</span> <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<p>以上代码中 <code>infer R</code> 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p>
<p><strong>5.extends</strong></p>
<p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">interface ILengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ILengthwise</span>&gt;<span class="params">(arg: T)</span></span>: T &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">arg</span>.length);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arg</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">loggingIdentity</span>(<span class="number">3</span>);  <span class="comment">// Error, number doesn&#x27;t have a .length property</span></span><br></pre></td></tr></table></figure>

<p>这时我们需要传入符合约束类型的值，必须包含必须的属性：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">loggingIdentity</span>(&#123;<span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>6.Partial</strong></p>
<p><code>Partial&lt;T&gt;</code> 的作用就是将某个类型里的属性全部变为可选项 <code>?</code>。</p>
<p><strong>定义：</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"> <span class="operator">*</span> node_modules<span class="operator">/</span>typescript<span class="operator">/</span>lib<span class="operator">/</span>lib.es5.d.ts</span><br><span class="line"> <span class="operator">*</span> Make <span class="built_in">all</span> properties <span class="keyword">in</span> <span class="built_in">T</span> optional</span><br><span class="line"> <span class="operator">*</span><span class="operator">/</span></span><br><span class="line">type Partial<span class="operator">&lt;</span><span class="built_in">T</span><span class="operator">&gt;</span> <span class="operator">=</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">[</span>P <span class="keyword">in</span> keyof <span class="built_in">T</span><span class="punctuation">]</span><span class="operator">?</span><span class="operator">:</span> <span class="built_in">T</span><span class="punctuation">[</span>P<span class="punctuation">]</span>;</span><br><span class="line"><span class="punctuation">&#125;</span>;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，首先通过 <code>keyof T</code> 拿到 <code>T</code> 的所有属性名，然后使用 <code>in</code> 进行遍历，将值赋给 <code>P</code>，最后通过 <code>T[P]</code> 取得相应的属性值。中间的 <code>?</code> 号，用于将所有属性变为可选。</p>
<p><strong>示例：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line">  title: <span class="keyword">string</span>;</span><br><span class="line">  description: <span class="keyword">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTodo</span>(<span class="params">todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">todo1</span> = &#123;</span><br><span class="line">  title: <span class="string">&quot;organize desk&quot;</span>,</span><br><span class="line">  description: <span class="string">&quot;clear clutter&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">todo2</span> = <span class="title function_ invoke__">updateTodo</span>(todo1, &#123;</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&quot;throw out trash&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的 <code>updateTodo</code> 方法中，我们利用 <code>Partial&lt;T&gt;</code> 工具类型，定义 <code>fieldsToUpdate</code> 的类型为 <code>Partial&lt;Todo&gt;</code>，即：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   title?: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">   description?: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
  
    
      <a id="older" class="blog-nav" href="/article/DOM%E5%A4%8D%E4%B9%A0%E5%8F%8A%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/">OLDER&nbsp;&gt;</a>
      
        
          <a id="newer" class="blog-nav" href="/article/%E5%9F%BA%E4%BA%8ERedis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%AE%9E%E7%8E%B0IM%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">&lt;&nbsp;NEWER</a>
          
            
</div>
        <div class="footer">
  
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/Pengzna">Copyright © Pengzna 2021-present</a>
        
    </div>
  
</div>

      </div>

      <div class="back-to-top hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



      
  <div class="search-icon" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-box">
        <div class="search-title">
          <!-- <span class="search-icon-input">
            <a href="javascript: void(0)">
              <i class="iconfont icon-search"></i>
            </a>
          </span> -->
          
            <input type="text" class="search-input" id="search-input" placeholder="搜索">
          
          <span class="search-close-icon" id="search-close-icon">
            <a href="javascript: void(0)">
              <i class="iconfont icon-close"></i>
            </a>
          </span>
        </div>
        <div class="search-result" id="search-result"></div>
      </div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    // inputArea.onclick = function() {
    //   getSearchFile()
    //   this.onclick = null
    // }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        inputArea.focus()
        getSearchFile()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'><span></ul>";
      // $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'><h2>" + orig_data_title + "</h2></a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<h3 class=\"search-result-abstract\">" + match_content + "...</h3>"
                }
                str += "<hr></li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/leedom92/hexo-theme-leedom#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </body>
</html>

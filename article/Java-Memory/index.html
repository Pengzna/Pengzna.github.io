<!DOCTYPE html>
<html lang="en">

  <head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="Pengzna,blog" />
  <meta name="author" content="Pengzna" />
  <meta name="description" content="Pengzna 的博客" />
  
  
  <title>
    
      Java 进程内存占用及可观测性调研&amp;内存异常排查最佳实践 
      
      
    
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Montserrat|Roboto:400,400italic,600|Roboto+Mono" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">


  

  
    
<link rel="stylesheet" href="/css/post.css">

  

  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="/js/fancybox.js"></script>


<meta name="generator" content="Hexo 7.0.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
      <div class="header">
  <a href="/">Pengzna's blog 👋</a>
</div>


      <p class="links">
  
    <a title="archives" target="" href="/archives/">
      <i class="iconfont icon-bookmark"></i>
    </a>
  
    <a title="github" target="_blank" href="https://github.com/Pengzna">
      <i class="iconfont icon-github"></i>
    </a>
  
    <a title="email" target="_blank" href="mailto:junzhi.pengzna@gmail.com">
      <i class="iconfont icon-envelope"></i>
    </a>
  
    <a title="linkedin" target="_blank" href="https://www.linkedin.com/in/pengzna/">
      <i class="iconfont icon-linkedin"></i>
    </a>
  
    <a title="wechat" target="_blank" href="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115013033249.png">
      <i class="iconfont icon-wechat"></i>
    </a>
  
</p>


      <div class="main">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->

<!-- LaTex Display -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>

<div class="post">
  <h3 class="date">
    Nov 26, 2023
  </h3>
  <h1>
    Java 进程内存占用及可观测性调研&内存异常排查最佳实践
  </h1>
  <div class="content markdown-body">
    <p>在以往实践中 IoTDB 团队对 Java 内存发现了一些问题：</p>
<ol>
<li>IoTDB 的实际占用内存超过了我们「以往认知 」的 “堆内存 + <code>MAX_DIRECT_MEMORY_SIZE</code>”</li>
<li>堆外内存泄漏，亟需堆外内存管理的最佳实践</li>
</ol>
<p>本文从上述问题出发，以 Java 进程（JVM）的视角，调研其所占内存。力求把「概念」理清，并探究「监控」手段和「最佳实践」，最终达到「补齐」IoTDB 目前相关板块的目的。</p>
<p><strong>注：作为调研工作，本文大量参考互联网资料（均放在了结尾的 Reference 里），亦有作者的思考与总结。文档难免有疏忽错误，欢迎大家批评指正！可以通过博客上方的 github、邮箱或微信联系我。</strong></p>
<h1 id="【概念】Java-进程所用内存"><a href="#【概念】Java-进程所用内存" class="headerlink" title="【概念】Java 进程所用内存"></a>【概念】Java 进程所用内存</h1><p>开门见山，先画出 Java 进程所占内存图：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126224519210.png" alt="image-20231126224519210"></p>
<p>可以看到：</p>
<ul>
<li>JVM 的内存被分为了不同的区域，主要由 Java 堆内存、非堆内存组成，在 Linux 上，JVM 通过 glibc 与 OS 进行内存分配与去配。</li>
<li>我们分析 Java 进程所占内存，可以从上图的各个板块着手切入。</li>
</ul>
<p>我们从 Java 提供的原生内存监控工具 Native Memory Tracking(NMT) 切入，一一介绍上图中所涉及的内存板块。这里贴出一段 NMT 的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Total: reserved=10575644KB, committed=443024KB</span><br><span class="line">-                 Java Heap (reserved=8323072KB, committed=192512KB)</span><br><span class="line">                            (mmap: reserved=8323072KB, committed=192512KB) </span><br><span class="line"> </span><br><span class="line">-                     Class (reserved=1050202KB, committed=10522KB)</span><br><span class="line">                            (classes <span class="comment">#15409)</span></span><br><span class="line">                            (  instance classes <span class="comment">#14405, array classes #1004)</span></span><br><span class="line">                            (malloc=1626KB <span class="comment">#33495) </span></span><br><span class="line">                            (mmap: reserved=1048576KB, committed=8896KB) </span><br><span class="line">                            (  Metadata:   )</span><br><span class="line">                            (    reserved=57344KB, committed=57216KB)</span><br><span class="line">                            (    used=56968KB)</span><br><span class="line">                            (    waste=248KB =0.43%)</span><br><span class="line">                            (  Class space:)</span><br><span class="line">                            (    reserved=1048576KB, committed=8896KB)</span><br><span class="line">                            (    used=8651KB)</span><br><span class="line">                            (    waste=245KB =2.75%)</span><br><span class="line"> </span><br><span class="line">-                    Thread (reserved=669351KB, committed=41775KB)</span><br><span class="line">                            (thread <span class="comment">#653)</span></span><br><span class="line">                            (stack: reserved=667648KB, committed=40072KB)</span><br><span class="line">                            (malloc=939KB <span class="comment">#3932) </span></span><br><span class="line">                            (arena=764KB <span class="comment">#1304)</span></span><br><span class="line"> </span><br><span class="line">-                      Code (reserved=50742KB, committed=17786KB)</span><br><span class="line">                            (malloc=1206KB <span class="comment">#9495) </span></span><br><span class="line">                            (mmap: reserved=49536KB, committed=16580KB) </span><br><span class="line">.... 后面省略</span><br></pre></td></tr></table></figure>

<p>可以看到，Java 进程所占内存项有 Java Heap、Class、Thread、Code 等等。</p>
<p>除了 Native Memory Tracking 记录的内存使用，还有两种内存 <strong>Native Memory Tracking 没有记录</strong>，那就是：</p>
<ul>
<li>MMap Buffer：文件映射内存</li>
<li>JNI 方法里的内存分配</li>
</ul>
<p>这些内存项可以分为：「Java 堆内存」和「非（Java）堆内存」。后文将基于这一分类展开，一一进行介绍。</p>
<h2 id="Java-堆内存"><a href="#Java-堆内存" class="headerlink" title="Java 堆内存"></a>Java 堆内存</h2><p><strong>Java</strong> <strong>堆内存</strong>，所有 Java 对象分配占用内存的来源，由 JVM GC 管理回收。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//堆内存占用，reserve 了 8323072KB，当前 commit 了 192512KB 用于实际使用</span><br><span class="line">Java Heap (reserved=8323072KB, committed=192512KB) </span><br><span class="line">          (mmap: reserved=8323072KB, committed=192512KB)</span><br><span class="line">          //堆内存都是通过 mmap 系统调用方式分配的</span><br></pre></td></tr></table></figure>

<p>需要注意的是：<strong>堆</strong>这个词可以指代很多，操作系统里有堆；JVM 中有堆；Java 中还有 native 堆（C heap）</p>
<ul>
<li>我们一般说的「堆内存」在 Java 开发语境下指的是「Java 堆内存」</li>
<li>而 C heap 虽然也可以叫「堆内存」，但在 Java 开发语境下实际上习惯被划分到「非堆内存」</li>
</ul>
<p>因此为了严谨，本文对于 Java 开发语境下的「堆内存」统一叫为「Java 堆内存」</p>
<p>JVM 堆内存是分代的，分为 Young、Old Generation。</p>
<p>我们经常看到的可能是 <code>Xmx</code> 以及 <code>Xms</code> 这两个参数：</p>
<ul>
<li><code>Xmx</code>：对应 <strong>最大堆大小</strong> <code>MaxHeapSize</code></li>
<li><code>Xms</code>：相当于同时设置<strong>最小堆*大小</strong><code>MinHeapSize</code> 和<strong>初始堆大小</strong><code>InitialHeapSize</code></li>
</ul>
<p><em>这部分大家经常打交道，都比较熟悉，不多赘述。</em></p>
<h2 id="非堆内存"><a href="#非堆内存" class="headerlink" title="非堆内存"></a>非堆内存</h2><h3 id="什么是非堆内存-堆外内存？"><a href="#什么是非堆内存-堆外内存？" class="headerlink" title="什么是非堆内存&#x2F;堆外内存？"></a>什么是非堆内存&#x2F;堆外内存？</h3><p>这里要明晰一个概念：</p>
<p><strong>非<em>堆内存</em>：</strong>是指不受到 Java 堆垃圾回收直接管理的内存。</p>
<ul>
<li>从 JVM 内存模型角度来看，甚至方法区也属于非堆内存（即使在主流 JVM 实现中，方法区内部包含堆内存实现），包括 Java 方法栈区内存和 native 内存等都属于非堆内存。</li>
</ul>
<p><strong>堆外<em>内存</em>：</strong>理论上语义等同于非堆内存。<strong>但笔者在调研时，发现实际上很多语境下特指 DirectMemory（java.nio.DirectByteBuffer）</strong></p>
<p>二者有区别！为了明确概念，避免混淆<strong>，</strong>本文中：</p>
<ol>
<li>非堆内存是指不受到 Java 托管堆垃圾回收管理的内存</li>
<li>堆外内存特指 DirectMemory（native heap）</li>
</ol>
<h4 id="堆外内存有什么好处？"><a href="#堆外内存有什么好处？" class="headerlink" title="堆外内存有什么好处？"></a>堆外内存有什么好处？</h4><p>使用堆外内存（DirectMemory）的好处主要有以下两个：</p>
<ul>
<li>避免堆内内存 Full GC 造成的 stop-the-world 延迟，当然也可以降低 OOM 风险，前提是要妥善管理堆外内存</li>
<li>绕过用户态到内核态的切换，实现高效数据读写，如<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/193cae9cbf07">零拷贝和内存映射</a>。（一般 nio 中它可以减少一次 Java 堆向native 堆做的内存拷贝以及可以直接做 Memory Mapping 以提高速度。）</li>
</ul>
<p>因此 Spark、Flink、Kafka 等这些鼎鼎大名的大数据组件都会积极地使用堆外内存，Netty 也有大量使用。</p>
<p><strong>补充：</strong></p>
<ol>
<li><strong>为什么堆外<em>内存</em>能提高</strong> <strong>I&#x2F;O</strong> <strong>效率？</strong></li>
</ol>
<ul>
<li>因为从堆内向磁盘&#x2F;网卡读写数据时，数据会被先复制到堆外内存，然后堆外内存的数据被拷贝到硬件，如下图所示，直接写入堆外内存可避免堆内到堆外的一次数据拷贝。</li>
</ul>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126224721428.png" alt="image-20231126224721428"></p>
<ol>
<li><strong>为什么<em>操作系统</em>一定要将 Java 数据拷贝到堆外<em>内存</em>再进行</strong> <strong>I&#x2F;O</strong> <strong>呢？</strong></li>
</ol>
<p>这是由于<code>write、read</code>等函数进行系统调用时，参数传的是内存地址，而 JVM 进行 GC 时，会对 Java 堆进行碎片整理，移动对象在内存中的位置，进而导致内存地址的变化。如果在 I&#x2F;O 操作进行中发生了 GC，内存地址发生变化，I&#x2F;O 操作的数据就全乱套了。而堆外内存是不受 GC 控制的，因此需要把数据拷贝到堆外内存之后再进行 I&#x2F;O 操作。</p>
<p>（R 大在知乎上有更详细的回答，感兴趣的可以看下）</p>
<blockquote>
<p>这里其实是在迁就 OpenJDK 里的 HotSpot VM 的一点实现细节。</p>
<p>HotSpot VM 里的 GC 除了 CMS 之外都是要移动对象的，是所谓“compacting GC”。</p>
<p>如果要把一个Java里的 byte[] 对象的引用传给native代码，让native代码直接访问数组的内容的话，就必须要保证native代码在访问的时候这个 byte[] 对象不能被移动，也就是要被“pin”（钉）住。</p>
<p>可惜 HotSpot VM 出于一些取舍而决定不实现单个对象层面的 object pinning，要 pin 的话就得暂时禁用 GC——也就等于把整个 Java 堆都给 pin 住。</p>
<p>所以 Oracle&#x2F;Sun JDK &#x2F; OpenJDK 的这个地方就用了点绕弯的做法。它假设把 HeapByteBuffer 背后的 byte[] 里的内容拷贝一次是一个时间开销可以接受的操作，同时假设真正的 I&#x2F;O 可能是一个很慢的操作。</p>
<p>于是它就先把 HeapByteBuffer 背后的 byte[] 的内容拷贝到一个 DirectByteBuffer 背后的 native memory去，这个拷贝会涉及 sun.misc.Unsafe.copyMemory() 的调用，背后是类似 memcpy() 的实现。<strong>这个操作本质上是会在整个拷贝过程中暂时不允许发生</strong> <strong>GC</strong> <strong>的。</strong></p>
<p>然后数据被拷贝到 native memory 之后就好办了，就去做真正的 I&#x2F;O，把 DirectByteBuffer 背后的 native memory 地址传给真正做 I&#x2F;O 的函数。这边就不需要再去访问 Java 对象去读写要做 I&#x2F;O 的数据了。</p>
</blockquote>
<h3 id="非堆内存有哪些？"><a href="#非堆内存有哪些？" class="headerlink" title="非堆内存有哪些？"></a>非堆内存有哪些？</h3><p>承接上文 NMT 的各项补充展开说明。此处整理各网络资料：</p>
<ol>
<li><strong>Java Class</strong>，JVM 将类文件加载到内存中用于后续使用所占用的空间，注意是 JVM C++ 层面的内存占用，主要包括类文件中在 JVM 解析为 C++ 的 Klass 类（Klass 是 JVM 源码中的一个 C++ 类，可以理解为类在 JVM 中的内存形式）以及相关元素，对应的 Java 反射类 Class 还是在堆内存空间中。</li>
</ol>
<ul>
<li><p>包含两部分：</p>
<ul>
<li><p>一是 metadata，被<code>-XX:MaxMetaspaceSize</code>限制最大大小。对应我们比较熟悉的 <strong>Metaspace</strong>。</p>
</li>
<li><p>二是 class space，被<code>-XX:CompressedClassSpaceSize</code>限制最大大小。对应我们比较熟悉的 <strong>Compressed Class Space。</strong></p>
</li>
<li><p>对于 metaspace 和 compressed class space，补充说明：</p>
</li>
<li><blockquote>
<p>元空间保存的数据，目前分为两大类：</p>
<ul>
<li><strong>Java 类数据</strong>：即加载的 Java 类对应 JVM 中的 Klass 对象，但是这个 Klass 对象中存储的很多数据都是指针，具体的数据存储属于非 Java 类数据，一般非 Java 类数据远比 Java 类数据占用空间大。</li>
<li><strong>非 Java 类数据</strong>：即被 Klass 对象引用的一些数据，例如：类中的各种方法，注解，执行采集与统计信息、静态变量等等。</li>
</ul>
<p>如果是 64 位的 JVM 虚拟机，并且开启了压缩类指针(-XX:+UseCompressedClassPointers，默认是开启的)，那么元空间会被划分成两部分：</p>
<ul>
<li><strong>类元空间</strong>：存储上面说的<strong>Java 类数据</strong>的空间（compressed class space）</li>
<li><strong>数据元空间</strong>：存储上面说的<strong>非 Java 类数据</strong>的空间（metaspace）</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reserved、committed、used 含义，后文有详细介绍 ：Java 内存占用分类 &amp; 观测手段 调研</span></span><br><span class="line"><span class="comment">// reserved: 在 Java 进程虚拟地址空间中保留的内存空间，但是没有分配到物理内存中。</span></span><br><span class="line"><span class="comment">// 通过 OS 的 page fault 来实际分配到物理内存（RAM 或 swap space）</span></span><br><span class="line"><span class="comment">// committed: 已经分配并与物理内存关联的内存空间，Java 进程可以被保证并直接使用。</span></span><br><span class="line"><span class="comment">// used: Java 进程实际已经使用的内存，通常 ≤ committed 大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 是类元空间总占用，reserve 了 1050202KB，当前 commit 了 10522KB 用于实际使用</span></span><br><span class="line"><span class="comment">// 总共 reserved 1050202KB = mmap reserved 1048576KB + malloc 1626KB</span></span><br><span class="line"><span class="comment">// 总共 committed 10522KB = mmap committed 8896KB + malloc 1626KB</span></span><br><span class="line"><span class="title class_">Class</span> (reserved=1050202KB, committed=10522KB)</span><br><span class="line">            (classes #<span class="number">15409</span>) <span class="comment">// 一共加载了 15409 个类</span></span><br><span class="line">            (  instance classes #<span class="number">14405</span>, array classes #<span class="number">1004</span>) <span class="comment">// 其中 14405 个实体类，1004 个数组类</span></span><br><span class="line">            (malloc=1626KB #<span class="number">33495</span>) <span class="comment">// 通过 malloc 系统调用方式一共分配了 1626KB，一共调用了 33495 次 malloc</span></span><br><span class="line">            (<span class="attr">mmap</span>: reserved=1048576KB, committed=8896KB) <span class="comment">// 通过 mmap 系统调用方式 reserve 了 1048576KB，当前 commit 了 8896KB 用于实际使用</span></span><br><span class="line">            (  <span class="title class_">Metadata</span>:   )<span class="comment">// 注意，MetaData 这块不属于类元空间，属于数据元空间</span></span><br><span class="line">            (    reserved=57344KB, committed=57216KB) <span class="comment">// 数据元空间当前 reserve 了 57344KB，commit 了 57216KB 用于实际使用</span></span><br><span class="line">            (    used=56968KB) <span class="comment">// 但是实际从 MetaChunk 的角度去看使用，只有 56968KB 用于实际数据的分配，有 248KB 的浪费</span></span><br><span class="line">            (    waste=248KB =<span class="number">0.43</span>%)</span><br><span class="line">            (  <span class="title class_">Class</span> <span class="attr">space</span>:)</span><br><span class="line">            (    reserved=1048576KB, committed=8896KB) <span class="comment">// 类元空间当前 reserve 了 1048576KB，commit 了 8896KB 用于实际使用</span></span><br><span class="line">            (    used=8651KB) <span class="comment">// 但是实际从 MetaChunk 的角度去看使用，只有 8651KB 用于实际数据的分配，有 245KB 的浪费</span></span><br><span class="line">            (    waste=245KB =<span class="number">2.75</span>%)</span><br><span class="line"><span class="title class_">Shared</span> <span class="keyword">class</span> <span class="title class_">space</span> (reserved=12032KB, committed=12032KB) <span class="comment">// 共享类空间，当前 reserve 了 12032KB，commit 了 12032KB 用于实际使用，这块其实属于上面 Class 的一部分</span></span><br><span class="line">            (<span class="attr">mmap</span>: reserved=12032KB, committed=12032KB) </span><br><span class="line"><span class="title class_">Module</span> (reserved=403KB, committed=403KB) <span class="comment">// 加载并记录模块占用空间，当前 reserve 了 403KB，commit 了 403KB 用于实际使用</span></span><br><span class="line">            (malloc=403KB #<span class="number">2919</span>) </span><br><span class="line"><span class="title class_">Metaspace</span> (reserved=57606KB, committed=57478KB) <span class="comment">// 等价于上面 Class 中的 MetaChunk（除了 malloc 的部分），当前 reserve 了 57606KB，commit 了 57478KB 用于实际使用</span></span><br><span class="line">            (malloc=262KB #<span class="number">180</span>) </span><br><span class="line">            (<span class="attr">mmap</span>: reserved=57344KB, committed=57216KB) </span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>Symbol：</strong>加载类的时候，有很多字符串信息，不同类的字符串信息可能会重复。所以统一放入符号表复用。 包含 SymbolTable:（存储 names signatures）和 StringTable:（存储 interned strings）。可以通过<code>-XX:+PrintStringTableStatistics</code>打印具体的信息</li>
</ol>
<ul>
<li>StringTable 这个数据结构的大小受<code>-XX:StringTableSize</code>限制，但总内存大小不受限制。</li>
</ul>
<blockquote>
<p>StringTable 是一个本地固定大小的哈希表，其用来保存内部字符串。<code>String.intern()</code> 被调用时会往 StringTable 插入一个 String（若该 String 不存在）</p>
<p>我们能够通过-XX:StringTableSize 标志配置 StringTable 的大小，-XX:StringTableSize 的含义是：Number of buckets in the interned String table</p>
<p>该参数主要 trade off 了哈希碰撞概率和哈希表内存大小，参数越大，StringTable 占用内存越大，但插入速度越快。参数越小，StringTable 占用内存越小，但由于哈希碰撞插入速度慢。</p>
<p>（<a target="_blank" rel="noopener" href="https://www.baeldung.com/native-memory-tracking-in-jvm%E3%80%81https://www.baeldung.com/java-string-pool%EF%BC%89">https://www.baeldung.com/native-memory-tracking-in-jvm、https://www.baeldung.com/java-string-pool）</a></p>
<p>经过经过实测和调研，从 Java 7u40 到 JDK11 <strong>默认大小</strong>是 60013 ，JDK11及其之后是 65536。下图是 JDK 17 的默认大小：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126224803251.png"></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Symbol</span> (reserved=18629KB, committed=18629KB)(malloc=16479KB #<span class="number">445877</span>) <span class="comment">// 通过 malloc 系统调用方式一共分配了 16479KB，一共调用了 445877 次 malloc(arena=2150KB #1) //通过 arena 系统调用方式一共分配了 2150KB，一共调用了 1 次 arena</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>Thread：线程占用*内存</strong>，主要是每个线程的线程栈，一般也主要关注线程栈占用空间，其他的管理线程占用的空间很小，可以忽略不计。</li>
</ol>
<blockquote>
<p>JVM 中比较消耗内存的数据区域之一，它与每个线程同时创建。 线程栈存储局部变量和部分结果，在方法调用中发挥着重要作用。根据 Oracle jdk 官网的说明，默认线程堆栈大小取决于平台，在大多数现代 64位操作系统中（Linux、<em>MacOS</em>），为 <strong>1 MB</strong>（jdk8、11、17 均一致）</p>
<p>（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html%E3%80%81https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE%E3%80%81https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html%EF%BC%89">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html、https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE、https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html）</a></p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126224803251.png" alt="image-20231126224803251"></p>
</blockquote>
<ul>
<li><p>每个线程栈占用大小受<code>-Xss</code>限制，但是总大小没有限制，当线程数量没有限制时，分配给堆栈的总内存实际上是无限的。</p>
<ul>
<li>如果该值设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢出的可能性更大。</li>
<li>如果该值设置过大，可能会影响系统整体的内存。</li>
</ul>
</li>
<li><p>-Xss 调优：JVM 的默认值一般偏高（1M），意在保证不受线程栈溢出的影响。<strong>可以根据项目情况和经验调小。</strong></p>
<ul>
<li>调研网络资料，建议栈深度设置在 3000-5000（调用深度）即 -Xss256K 或 -Xss512K，一般 512K 设置的比较多（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/243064867%EF%BC%89">https://zhuanlan.zhihu.com/p/243064867）</a></li>
<li>实验显示，-Xss512K 时，较简单的函数调研（无参）可以支持 16979 的调用深度（<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1888586%EF%BC%89">https://cloud.tencent.com/developer/article/1888586）</a></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//总共 reserve 了 669351KB，commit 了 41775KB</span></span><br><span class="line"><span class="title class_">Thread</span> (reserved=669351KB, committed=41775KB)</span><br><span class="line">    (thread #<span class="number">653</span>)<span class="comment">//当前线程数量是 653，每个线程栈大小是 1M，固 reserved 是 653 * 1024 = 667648KB，当前 commit 了 40072KB 用于实际使用</span></span><br><span class="line">    (<span class="attr">stack</span>: reserved=667648KB, committed=40072KB) <span class="comment">//线程栈占用的空间：我们没有指定 Xss，默认是 1MB</span></span><br><span class="line">    (malloc=939KB #<span class="number">3932</span>) <span class="comment">//通过 malloc 系统调用方式一共分配了 939KB，一共调用了 3932 次 malloc</span></span><br><span class="line">    (arena=764KB #<span class="number">1304</span>)  <span class="comment">//通过 JVM 内部 Arena 分配的内存，一共分配了 764KB，一共调用了 1304 次 Arena 分配</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>Code：</strong><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU4ODM1NjY5NQ==&mid=2247484493&idx=1&sn=676fe0aa750dc99c5712aac26b74f933&chksm=fddf4975caa8c063ca69f2ce7a109c7ac15b2becde8811ffb7e7c0b9976c8c77fa30d0cf2edf&token=1373220626&lang=zh_CN#rd">JIT 编译器</a>编译后（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/355304828">C1 C2 编译器</a>优化）的代码占用空间</li>
</ol>
<ul>
<li>受<code>-XX:ReservedCodeCacheSize</code>限制，主要对应我们比较熟悉的 <strong>Code Cache</strong></li>
</ul>
<blockquote>
<p>为了在不同的平台上运行 JVM 字节码，JIT 编译器需要将代码编译转换为机器码。</p>
<p>当 JVM 编译字节码到汇编指令时，它保存这些指令在一个特殊的非堆区域，该区域称为 <em>CodeCache</em>。JVM 可以像管理其他区域一样管理 CodeCache。<code>-XX:InitialCodeCacheSize</code> 和 <code>-XX:ReservedCodeCacheSize</code> 标记决定了CodeCache 的初始值和可能的最大值。</p>
<ul>
<li>根据 Oracle jdk 官网说明，initialCodeCacheSize 的默认值取决于平台，但不能比 OS 的 minimal page size 更小。对于 Unix和 windows，默认大小是 500KB</li>
<li>默认最大 Code Cache 大小为 240 MB； 如果使用选项 -XX:-TieredCompilation 禁用分层编译，则默认大小为 48 MB。 <code>-XX:ReservedCodeCacheSize</code> 的限制为 2 GB， 否则会产生错误。</li>
<li>如果 Code cache 内存占用超过上限，会停止JIT编译。同时还会收到 “CodeCache is full… The compiler has been disabled” 之类的告警消息</li>
</ul>
<p>（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html%E3%80%81https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html%E3%80%81https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html%EF%BC%89">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html、https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html、https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html）</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Code</span> (reserved=50742KB, committed=17786KB)</span><br><span class="line">(malloc=1206KB #<span class="number">9495</span>) </span><br><span class="line">(<span class="attr">mmap</span>: reserved=49536KB, committed=16580KB) </span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>Compiler：</strong>JIT 编译器(C1 C2 编译器)本身占用的空间和标记占用的内存，不受限制，一般比较小。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Compiler</span> (reserved=159KB, committed=159KB)</span><br><span class="line">(malloc=29KB #<span class="number">813</span>) </span><br><span class="line">(arena=131KB #<span class="number">3</span>)   </span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>Arena 数据结构占用空间</strong>，所有通过 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/439269671">arena </a>方式分配的内存。我们看到 Native Memory Tracking 中有很多通过 arena 分配的内存，这个就是管理 Arena 数据结构占用空间。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Arena</span> <span class="title class_">Chunk</span> (reserved=187KB, committed=187KB)(malloc=187KB) </span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>JVM</strong> <strong>Tracing 占用*内存</strong>，所有采集占用的内存。包括 JVM perf 以及 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/122247741">JFR</a> 占用的空间，如果开启了 JFR 则主要是 JFR 占用的内存。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Tracing</span> (reserved=32KB, committed=32KB)(arena=32KB #<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><strong>JVM</strong> <strong>GC</strong> <strong>需要的数据结构与记录信息占用的空间</strong>，例如垃圾回收需要的 CardTable，标记数，区域划分记录，还有标记 GC Root 等等。这块内存可能会比较大，尤其是对于那种专注于低延迟的 GC，例如 ZGC。（ZGC 是一种以空间换时间的思路，提高 CPU 消耗与内存占用，但是消灭全局暂停）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GC</span> (reserved=370980KB, committed=69260KB)(malloc=28516KB #<span class="number">8340</span>) </span><br><span class="line">(<span class="attr">mmap</span>: reserved=342464KB, committed=40744KB) </span><br></pre></td></tr></table></figure>

<ol start="9">
<li><strong>Direct Buffer &amp; Other</strong>：直接内存。在 NMT 中表现为 “Other”，意为：其他占用 (不是 JVM 本身而是操作系统的某些系统调用导致额外占的空间)。此项为我们大多数使用的非堆内存，也是「堆外内存」一词通常所指。</li>
</ol>
<ul>
<li>这里说的堆外内存主要针对 <code>java.nio.DirectByteBuffer</code>，这些对象的创建过程会通过 Unsafe 接口直接通过 <code>os::malloc</code> 来分配内存，然后将内存的起始地址和大小存到 <code>java.nio.DirectByteBuffer</code> 对象里，这样就可以直接操作这些内存。这些内存要么在 DirectByteBuffer 回收掉之后才有机会被回收，要么被程序员手动回收。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Other</span> (reserved=12348KB, committed=12348KB)(malloc=12348KB #<span class="number">14</span>) </span><br></pre></td></tr></table></figure>

<p>还有两项 NMT 没有列出，但非常重要的堆外内存：</p>
<ol start="10">
<li><strong>MMap</strong> <strong>Buffer</strong>：Java 文件映射内存大小，也是我们在 I&#x2F;O 中经常用到的非堆内存，可以通过 JMX 监控</li>
</ol>
<blockquote>
<p>Java 中的内存映射缓存区（Memory-mapped buffer）是一种将文件或文件的一部分直接映射到程序内存中的技术。简单来说，内存映射缓存区允许 Java 程序在处理文件时像处理一个非常大的字节数组一样进行操作，而不用担心过多的 I&#x2F;O 负担或频繁的磁盘访问。</p>
</blockquote>
<ol start="11">
<li><strong>Native 分配：</strong>即直接调用 malloc 分配的，如 JNI 调用、磁盘与网络 io 操作等，可通过 pmap 命令、malloc_stats 函数观测。</li>
</ol>
<p><strong>以下几种堆外<em>内存</em>比较小，我们一般不会关心：</strong></p>
<ol start="12">
<li><p><strong>Logging：</strong>写 JVM 日志占用的内存</p>
<ol>
<li>日志是指<code> -Xlog</code> 参数指定的日志输出</li>
<li>Java 17 之后引入了异步 JVM 日志<code>-Xlog:async</code>（<a target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8229517%EF%BC%89">https://bugs.openjdk.org/browse/JDK-8229517）</a></li>
</ol>
<ul>
<li>「异步日志」是指写日志动作与主应用程序是异步的，降低了写日志开销</li>
<li>异步日志所需的 buffer 也在这里</li>
</ul>
</li>
</ol>
<blockquote>
<p>日志用法：<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html#xlog-usage-examples">https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html#xlog-usage-examples</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Logging</span> (reserved=5KB, committed=5KB)(malloc=5KB #<span class="number">216</span>) </span><br></pre></td></tr></table></figure>

<ol start="13">
<li><strong>Arguments：</strong>JVM 参数占用内存，我们需要保存并处理当前的 JVM 参数以及用户启动 JVM 的是传入的各种参数（有时候称为 flag）。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Arguments</span> (reserved=31KB, committed=31KB)(malloc=31KB #<span class="number">90</span>) </span><br></pre></td></tr></table></figure>

<ol start="14">
<li><strong>Safepoint：</strong>JVM 安全点占用内存，是固定的两页内存（这个页大小与操作系统相关），用于 JVM 安全点的实现，不会随着 JVM 运行时的内存占用而变化。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Safepoint</span> (reserved=8KB, committed=8KB)(<span class="attr">mmap</span>: reserved=8KB, committed=8KB) </span><br></pre></td></tr></table></figure>

<ol start="15">
<li><strong>Synchronization：</strong>Java 同步机制（例如 <code>synchronized</code>，还有 AQS 的基础 <code>LockSupport</code>）底层依赖的 C++ 的数据结构，系统内部的 mutex 等占用的内存。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Synchronization</span> (reserved=56KB, committed=56KB)(malloc=56KB #<span class="number">789</span>)</span><br></pre></td></tr></table></figure>

<ol start="16">
<li><strong>Serviceability：</strong>JVM TI 相关内存。</li>
</ol>
<blockquote>
<p>JVMTI 是 Java 虚拟机工具接口（Java Virtual Machine Tool Interface）的缩写。它是 Java 虚拟机（JVM）的一部分，提供了一组 API，使开发人员可以开发自己的 Java 工具和代理程序，以监视、分析和调试 Java 应用程序。</p>
<p>JVMTI API 是一组 C&#x2F;C++ 函数，可以通过 JVM TI Agent Library 和 JVM 进行交互。开发人员可以使用 JVMTI API 开发自己的 JVM 代理程序或工具，以监视和操作 Java 应用程序。例如，可以使用 JVMTI API 开发性能分析工具、代码覆盖率工具、内存泄漏<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/tools?from_column=20065&from=20065">检测工具</a>等等。</p>
</blockquote>
<ul>
<li>这里的内存就是调用了 JVMTI API 之后 JVM 为了生成数据占用的内存<strong>。</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Serviceability</span> (reserved=1KB, committed=1KB)(malloc=1KB #<span class="number">18</span>) </span><br></pre></td></tr></table></figure>

<ol start="17">
<li><strong>String Deduplication：</strong>Java 字符串去重占用内存。</li>
</ol>
<ul>
<li>这是一种字符串去重的机制，该机制只有在 G1GC 中才能使用（<a target="_blank" rel="noopener" href="https://openjdk.org/jeps/192%EF%BC%89%EF%BC%8C%E6%89%80%E4%BB%A5%E9%BB%98%E8%AE%A4%E6%98%AF%E5%85%B3%E9%97%AD%E7%9A%84%E3%80%82%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87">https://openjdk.org/jeps/192），所以默认是关闭的。可以通过</a> <code>-XX:+UseStringDedupl``ication</code> + <code>-XX:UseG1GC</code>来启用。</li>
</ul>
<blockquote>
<p><strong>String Deduplication 实现</strong>：</p>
<ul>
<li>当 G1 工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的 string 对象。</li>
<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。当有空闲 CPU 周期可用时，该线程会扫描堆，查找重复的字符串。</li>
<li>使用一个 hashtable 来记录所有的被 string 对象使用的不重复的 char 数组。当去重的时候，会查这个 hashtable，来看堆上是否已经存在一个一模一样的 char 数组。当找到两个具有相同值的不同 string 时 ，将对它们进行重复数据删除。<ul>
<li>仅处理在一定的最小 GC 周期数（默认为 3 个）后幸存下来的字符串，以避免在非常短命的对象上浪费精力，从统计上看，这些对象很有可能成为垃圾。</li>
</ul>
</li>
<li>如果存在一模一样的 char 数组，string 对象会被调整为引用那个数组，释放对原来数组的引用，最终被 G1 回收掉。</li>
<li>如果不存在，char 数组会被插入到 hashtable，这样以后其他相同的字符串可以共享该数组。</li>
</ul>
<p><strong>与 string.intern() 的区别</strong></p>
<ul>
<li>String Deduplication：如果有 1000 个不同的 String 对象，它们都具有相同的内容“abc”，JVM 可以让它们在内部共享相同的 char[]，但是仍然有 1000 个不同的 String 对象。</li>
<li>String.intern()：使用 intern()，将只有一个 String 对象。 因此，如果关心节省内存，那么 intern() 会更好。 它将节省空间以及 GC 时间。但缺点是有时需要手动调用 <code>intern()</code></li>
</ul>
<p>（<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/32854968/java-8-string-deduplication-vs-string-intern%E3%80%81https://dzone.com/articles/duplicate-strings-how-to-get-rid-of-them-and-save%E3%80%81[JEP">https://stackoverflow.com/questions/32854968/java-8-string-deduplication-vs-string-intern、https://dzone.com/articles/duplicate-strings-how-to-get-rid-of-them-and-save、[JEP</a> 192: String Deduplication in G1](<a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/192)%EF%BC%89">http://openjdk.java.net/jeps/192)）</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span> <span class="title class_">Deduplication</span> (reserved=1KB, committed=1KB)(malloc=1KB #<span class="number">8</span>) </span><br></pre></td></tr></table></figure>

<ol start="18">
<li><strong>Internal：</strong>JVM 内部不属于其他类别的内存占用，不会很大</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Internal</span> (reserved=1373KB, committed=1373KB)(malloc=1309KB #<span class="number">6135</span>) </span><br><span class="line">(<span class="attr">mmap</span>: reserved=64KB, committed=64KB) </span><br></pre></td></tr></table></figure>

<ol start="19">
<li><strong>Native Memory Tracking*：</strong>开启 Native Memory Tracking 本身消耗的内存</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Native</span> <span class="title class_">Memory</span> <span class="title class_">Tracking</span> (reserved=8426KB, committed=8426KB)(malloc=325KB #<span class="number">4777</span>) </span><br><span class="line">(tracking overhead=8102KB)</span><br></pre></td></tr></table></figure>

<h3 id="非堆内存与-GC"><a href="#非堆内存与-GC" class="headerlink" title="非堆内存与 GC"></a>非堆内存与 GC</h3><p><strong>结论：</strong>理论上非堆内存中，只有 DirectBuffer（堆外内存）可以被 gc 回收。其他部分都直接由操作系统&#x2F; native 库管理。在编程中：</p>
<ul>
<li>对于 DirectBuffer ，要注意结合<code>-XX:MaxDirectMemorySize</code>与 full gc 控制内存泄漏问题，必要时手动管理</li>
<li>对于其他非堆内存，要手动做好内存分配去配（malloc&#x2F;free）管理</li>
</ul>
<p>由于 DirectBuffer（堆外内存）可以通过 JVM 的 DirectBuffer 对象管理，<strong>因此</strong> <strong>gc</strong> <strong>可以通过回收 D<em>i</em>rectBuffer 对象来回收其关联的堆外内存</strong>。这也是为什么会有如下现象：</p>
<blockquote>
<p>DirectByteBuffer 对象本身其实是很小的，但是它后面可能关联了一个非常大的堆外内存，因此我们通常称之为<strong>『冰山对象』。</strong></p>
<p>ygc 时会将新生代里的不可达的 DirectByteBuffer 对象及其堆外内存回收，但是无法对 old 里的 DirectByteBuffer 对象及其堆外内存进行回收。因此如果有大量的 DirectByteBuffer 对象移到了 old，但是又一直没有做 full gc，而只进行 ygc，且 -XX:MaxDirectMemory 没有正确设置，那么可能会发生堆外内存泄漏。</p>
</blockquote>
<blockquote>
<p><strong>补充问题：</strong>对于 g1 这种 mixed gc 也可以回收老年代 region 的 gc 算法，是不是这个问题会缓解很多？</p>
<p><strong>实验：</strong>手动添加 100_000_00 次堆外内存，每次添加 1024B，同时手动添加 10_000 次堆内存以触发 mixed gc&#x2F;full gc，并将堆外内存晋升到老年代。对比 CMS 和 G1 的堆外内存回收情况。</p>
<p><strong>环境：</strong>-XX:+UseG1GC&#x2F;-XX:+UseConcMarkSweepGC -Xmx4g -XX:MaxDirectMemorySize&#x3D;2g </p>
<p><strong>结论</strong> (将两种 GC 下，堆外内存 used 情况画成折线图)<strong>：</strong></p>
<ul>
<li><strong>在<em>内存</em>低负载情况下（x 轴 1471 之前），G1 对于堆外内存的控制优于</strong> <strong>CMS*。</strong>猜测这是由于此时两种 GC 的 full gc 都不多，而 G1 的 mixed gc 能回收老年代 region，CMS 的 young gc 则不行，因此 G1 表现优于 CMS</li>
<li><strong>在<em>内存</em>高负载情况下（x 轴 1471 之后），*CMS</strong> <strong>对于堆外内存的控制优于 G1。</strong>猜测这是由于此时负载太高了，CMS 主要进行 full gc。而 G1 在 full gc 之余，优先会 mixed gc，而 mixed gc 对于内存的回收效果显然不如 full gc，因此 CMS 表现优于 G1</li>
</ul>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225137581.png" alt="image-20231126225137581"></p>
</blockquote>
<p>因此我们认为：对于堆外内存，只有 full gc 或者 System.gc() 才能比较彻底的回收，一旦一直触发不了 fullgc 或 System.gc()，后果会比较严重。</p>
<p>糟糕的是如果 JVM 分配的堆内存空间很大，以至于很少发生老年代的 GC （或者 Full GC），可能会导致一些 <code>DirectByteBuffer</code> 对象虽然已经处于不可达的状态但是却长时间无法被 GC 掉。然后这些对象会一直持有其指向的堆外内存，直到下面的清理方法被调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((DirectBuffer)buf).cleaner().clean();</span><br></pre></td></tr></table></figure>

<p>虽然 GC 会销毁 DirectByteBuffer 之前调用该方法，但是，如上所述，它可能为时已晚。</p>
<p>如果我们对管理堆外内存的代码了如指掌，则可以显式调用上述方法。 否则，防止堆外内存过度使用的方法是减小堆内存的大小从而使得 GC 更加频繁，或者依赖<code>-XX:MaxDirectMemorySize</code>的 OOM 检查进行 System.gc()<strong>。</strong></p>
<blockquote>
<p><strong>实验验证：</strong>在机器上指定 G1 GC（JDK 11），不断手动添加堆外内存。通过控制 -Xmx 和 -XX:MaxDirectMemory 来研究堆外内存受 GC 的影响。</p>
<p><strong>实验代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 通过 JMX 打印内存信息 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMemInfo</span><span class="params">()</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;==================================Mem===================================&quot;</span>);</span><br><span class="line">  ManagementFactory.getPlatformMXBeans(MemoryPoolMXBean.class).stream()</span><br><span class="line">      .forEach(</span><br><span class="line">          e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name: &quot;</span> + e.getName() + <span class="string">&quot; / info: &quot;</span> + e.getUsage());</span><br><span class="line">          &#125;);</span><br><span class="line">  ManagementFactory.getPlatformMXBeans(BufferPoolMXBean.class).stream()</span><br><span class="line">      .forEach(</span><br><span class="line">          e -&gt; &#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                <span class="string">&quot;name: &quot;</span></span><br><span class="line">                    + e.getName()</span><br><span class="line">                    + <span class="string">&quot; total: &quot;</span></span><br><span class="line">                    + e.getTotalCapacity()</span><br><span class="line">                    + <span class="string">&quot; used: &quot;</span></span><br><span class="line">                    + e.getMemoryUsed());</span><br><span class="line">          &#125;);</span><br><span class="line">  System.out.println(<span class="string">&quot;==================================GC===================================&quot;</span>);</span><br><span class="line">  ManagementFactory.getPlatformMXBeans(GarbageCollectorMXBean.class).stream()</span><br><span class="line">      .forEach(</span><br><span class="line">          e -&gt; &#123;</span><br><span class="line">            System.out.println(e.getName() + <span class="string">&quot;: &quot;</span> + e.getCollectionTime());</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException, IOException &#123;</span><br><span class="line">  List&lt;<span class="type">byte</span>[]&gt; heapMem = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100_000_00</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 通过增加 heap mem 来触发 full gc 或 mixed gc（G1）</span></span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      heapMem.add(bytes);</span><br><span class="line">      printMemInfo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 手动不断分配堆外内存</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  printMemInfo();</span><br></pre></td></tr></table></figure>

<p><strong>结果如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// 限制最大堆内存 2G，堆外内存 1G</span><br><span class="line">name: CodeHeap <span class="string">&#x27;non-nmethods&#x27;</span> / info: init = <span class="number">2555904</span>(2496K) used = <span class="number">1121280</span>(1095K) committed = <span class="number">2555904</span>(2496K) <span class="built_in">max</span> = <span class="number">5849088</span>(5712K)</span><br><span class="line">name: Metaspace / info: init = <span class="number">0</span>(0K) used = <span class="number">8045576</span>(7857K) committed = <span class="number">8519680</span>(8320K) <span class="built_in">max</span> = -<span class="number">1</span>(-1K)</span><br><span class="line">name: CodeHeap <span class="string">&#x27;profiled nmethods&#x27;</span> / info: init = <span class="number">2555904</span>(2496K) used = <span class="number">1836672</span>(1793K) committed = <span class="number">2555904</span>(2496K) <span class="built_in">max</span> = <span class="number">122896384</span>(120016K)</span><br><span class="line">name: Compressed Class Space / info: init = <span class="number">0</span>(0K) used = <span class="number">747256</span>(729K) committed = <span class="number">917504</span>(896K) <span class="built_in">max</span> = <span class="number">1073741824</span>(1048576K)</span><br><span class="line">name: G1 Eden Space / info: init = <span class="number">27262976</span>(26624K) used = <span class="number">60817408</span>(59392K) committed = <span class="number">247463936</span>(241664K) <span class="built_in">max</span> = -<span class="number">1</span>(-1K)</span><br><span class="line">name: G1 Old Gen / info: init = <span class="number">241172480</span>(235520K) used = <span class="number">251638016</span>(245740K) committed = <span class="number">729808896</span>(712704K) <span class="built_in">max</span> = <span class="number">2147483648</span>(2097152K)</span><br><span class="line">name: G1 Survivor Space / info: init = <span class="number">0</span>(0K) used = <span class="number">34603008</span>(33792K) committed = <span class="number">34603008</span>(33792K) <span class="built_in">max</span> = -<span class="number">1</span>(-1K)</span><br><span class="line">name: CodeHeap <span class="string">&#x27;non-profiled nmethods&#x27;</span> / info: init = <span class="number">2555904</span>(2496K) used = <span class="number">871168</span>(850K) committed = <span class="number">2555904</span>(2496K) <span class="built_in">max</span> = <span class="number">122912768</span>(120032K)</span><br><span class="line">name: mapped total: <span class="number">0</span> used: <span class="number">0</span></span><br><span class="line">name: direct total: <span class="number">659278848</span> used: <span class="number">659278848</span></span><br><span class="line"></span><br><span class="line">// 限制最大堆内存 512M，堆外内存 1G</span><br><span class="line">name: CodeHeap <span class="string">&#x27;non-nmethods&#x27;</span> / info: init = <span class="number">2555904</span>(2496K) used = <span class="number">1120000</span>(1093K) committed = <span class="number">2555904</span>(2496K) <span class="built_in">max</span> = <span class="number">5849088</span>(5712K)</span><br><span class="line">name: Metaspace / info: init = <span class="number">0</span>(0K) used = <span class="number">8051904</span>(7863K) committed = <span class="number">8519680</span>(8320K) <span class="built_in">max</span> = -<span class="number">1</span>(-1K)</span><br><span class="line">name: CodeHeap <span class="string">&#x27;profiled nmethods&#x27;</span> / info: init = <span class="number">2555904</span>(2496K) used = <span class="number">1885056</span>(1840K) committed = <span class="number">2555904</span>(2496K) <span class="built_in">max</span> = <span class="number">122896384</span>(120016K)</span><br><span class="line">name: Compressed Class Space / info: init = <span class="number">0</span>(0K) used = <span class="number">747256</span>(729K) committed = <span class="number">917504</span>(896K) <span class="built_in">max</span> = <span class="number">1073741824</span>(1048576K)</span><br><span class="line">name: G1 Eden Space / info: init = <span class="number">27262976</span>(26624K) used = <span class="number">157286400</span>(153600K) committed = <span class="number">191889408</span>(187392K) <span class="built_in">max</span> = -<span class="number">1</span>(-1K)</span><br><span class="line">name: G1 Old Gen / info: init = <span class="number">241172480</span>(235520K) used = <span class="number">187691464</span>(183292K) committed = <span class="number">319815680</span>(312320K) <span class="built_in">max</span> = <span class="number">536870912</span>(524288K)</span><br><span class="line">name: G1 Survivor Space / info: init = <span class="number">0</span>(0K) used = <span class="number">3145728</span>(3072K) committed = <span class="number">3145728</span>(3072K) <span class="built_in">max</span> = -<span class="number">1</span>(-1K)</span><br><span class="line">name: CodeHeap <span class="string">&#x27;non-profiled nmethods&#x27;</span> / info: init = <span class="number">2555904</span>(2496K) used = <span class="number">840192</span>(820K) committed = <span class="number">2555904</span>(2496K) <span class="built_in">max</span> = <span class="number">122912768</span>(120032K)</span><br><span class="line">name: mapped total: <span class="number">0</span> used: <span class="number">0</span></span><br><span class="line">name: direct total: <span class="number">452782080</span> used: <span class="number">452782080</span></span><br></pre></td></tr></table></figure>

<p>可以看到：当堆内存阈值变小时，GC 更加频繁，堆外内存得到了更好的回收。但是这是以减小堆内存为代价。</p>
<p><strong>对于 IoTDB 的启示是：</strong></p>
<ul>
<li>在保证堆内存够用的前提下， -Xmx 尽量小对于堆外内存回收是有用的。</li>
<li>尽管如此，对于堆外内存，手动管理回收是更安全的方式。即在合适的时机（如 close() 方法）调用<code>DirectByteBuffer.getCleaner().clean()</code>，手动清理堆外内存，而不是交给 GC（finalize() 方法）</li>
</ul>
</blockquote>
<p>我们通常通过<code>-XX:MaxDirectMemorySize</code>来指定最大的堆外内存大小，当使用达到了阈值的时候将调用System.gc 来做一次 full gc，以此来回收掉没有被使用的堆外内存。</p>
<ul>
<li>因此不要轻易显示关闭 System.gc()</li>
</ul>
<h2 id="Java-进程内存占用-“misunderstanding”"><a href="#Java-进程内存占用-“misunderstanding”" class="headerlink" title="Java 进程内存占用 “misunderstanding”"></a>Java 进程内存占用 “misunderstanding”</h2><p>明晰了 Java 内存组成，但实际观测时还是会发现：Java 实际占用内存与认知存在一定差距。这是因为存在一些“misunderstanding”：</p>
<h3 id="JVM-commit-的内存与实际占用内存的差异"><a href="#JVM-commit-的内存与实际占用内存的差异" class="headerlink" title="JVM commit 的内存与实际占用内存的差异"></a>JVM commit 的内存与实际占用内存的差异</h3><p>首先明确 commit、reserve 等概念，对这些比较熟悉的可以直接跳到下一部分了（<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31173374/why-does-a-jvm-report-more-committed-memory-than-the-linux-process-resident-set%EF%BC%9B%E7%BF%BB%E8%AF%91%E8%B5%B7%E6%9D%A5%E6%80%BB%E6%84%9F%E8%A7%89%E4%B8%8D%E5%A4%AA%E5%87%86%E7%A1%AE%EF%BC%8C%E5%B0%B1%E7%9B%B4%E6%8E%A5%E8%B4%B4%E8%8B%B1%E6%96%87%E4%BA%86%EF%BC%89">https://stackoverflow.com/questions/31173374/why-does-a-jvm-report-more-committed-memory-than-the-linux-process-resident-set；翻译起来总感觉不太准确，就直接贴英文了）</a></p>
<ol>
<li><strong>JVM</strong> <strong>自身监控工具里常见的<em>内存</em>概念：</strong></li>
</ol>
<p><strong>Used</strong> <strong>Heap</strong>: the amount of memory occupied by live objects according to the last GC</p>
<p><strong>Reserved</strong>: The total address range that has been pre-mapped via <code>mmap</code> for a particular memory pool. The <em>reserved</em> memory consists of <code>PROT_NONE</code> mappings, which are guaranteed to not be backed by physical memory</p>
<blockquote>
<p>“PROT” 是 Linux 里的概念，意为 protection，表示的是对内存映射区域的保护，包括 PROT_READ（可读），PROT_WRITE（可写）， PROT_EXEC（可执行）和 PROT_NONE，即既不可读也不可写更不可执行</p>
<p>意思就是说，reserved 是通过 PROT_NONE 分配的内存，即在虚存中分配的空间在 kernel 的 vma structs 有 entries，因此不会被其他 mmap&#x2F;malloc calls 所使用。如果其他进程访问这些 reserved 的内存会造成 page fault（SIGSEGV）</p>
</blockquote>
<p><strong>Committed</strong>: Address ranges that have been mapped with something other than PROT_NONE. They may or may not be backed by physical or swap due to lazy allocation and paging. </p>
<p>Committed-but-not-backed-by-storage memory has been mapped with - for example - <code>PROT_READ | PROT_WRITE</code> but accessing it still causes a page fault. But that page fault is silently handled by the kernel by backing it with actual memory and returning to execution as if nothing happened.</p>
<ol>
<li><strong>Linux 监控 Java 进程，常见的<em>内存</em>概念：</strong></li>
</ol>
<p><strong>Resident</strong>: Pages which are currently in physical RAM. This means code, stacks, part of the committed memory pools but also portions of mmaped files which have recently been accessed and allocations outside the control of the JVM.（即真实使用的物理内存）</p>
<p><strong>Virtual</strong>: The sum of all virtual address mappings. Covers committed, reserved memory pools but also mapped files or shared memory. This number is rarely informative since the JVM can reserve very large address ranges in advance or mmap large files.（就是说这个数值没啥参考价值）</p>
<p>我们经常可以在各种监控工具（JMX、上文提到的 NMT 等）看到 JVM commit 的内存。实际上 JVM commit 的内存与在 Linux OS 上的实际占用内存（RSS）是有差异的：</p>
<p>JVM 中大块内存，基本都是先 reserve 一大块，之后 commit 其中需要的一小块，然后开始读写处理内存。</p>
<ol>
<li>commit 之后，<strong>内存<em>并不是立刻被分配了</em>物理内存*，而是真正往内存中 store 东西（写动作）的时候，才会真正映射物理内存，如果是 load 读取也是可能不映射物理内存的。（所谓 lazy allocation）</strong></li>
<li>还有的差异，主要来源于在 <strong>uncommit 之后，系统可能还没有来的及将这块<em>物理内存</em>真正回收。</strong></li>
</ol>
<p>所以，JVM 认为自己 commit 的内存，与实际系统分配的物理内存，可能是有差异的：可能 JVM 认为自己 commit 的内存比系统分配的物理内存多。</p>
<h3 id="为什么啥都没干，JVM-启动后内存一直在涨"><a href="#为什么啥都没干，JVM-启动后内存一直在涨" class="headerlink" title="为什么啥都没干，JVM 启动后内存一直在涨"></a>为什么啥都没干，JVM 启动后内存一直在涨</h3><p>有的时候这是正常的，原因正是 1.3.1 所提到的。</p>
<blockquote>
<p>比如：如果你使用的是 SerialGC，ParallelGC 或者 CMS GC，老年代的内存在有对象晋升到老年代之前，可能是不会映射物理内存的，虽然这块内存已经被 commit 了。如果你用的是 ZGC，G1GC，或者 ShenandoahGC，那么内存用的会更激进些（主要因为分区算法划分导致内存被写入），这是你在换 GC 之后看到物理内存内存快速上涨的原因之一。</p>
</blockquote>
<p>假如 JVM 为堆申请的内存是 4.8G，JVM commit 了 4.8G。但在启动后 JVM 一开始可能实际只使用了 3G 内存，由于前面刚提到的 lazy allocation 机制，导致剩下的 1.8G 是不会映射物理内存的，虽然这块内存已经被 commit 了， Linux 实际只分配了 3G。</p>
<p>然后在 gc 时，由于会复制存活对象到堆的空闲部分，如果正好复制到了以前未使用过的区域，就又会触发 Linux 进行内存分配，故一段时间内内存占用会越来越多，直到堆的所有区域都被 touch 到。</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225202704.png" alt="image-20231126225202704"></p>
<p>而通过添加JVM参数<code>-XX:+AlwaysPreTouch</code>（默认关闭），可以在 Commit 内存后立刻写入 0 来强制操作系统分配内存，使得堆区域全都被分配物理内存。而由于 Java 进程主要活动在堆内，故后续内存就不会有很大变化了。</p>
<ul>
<li>这种优化叫做 <strong>“pre-zeroing”</strong>，即将内存全部预填 0，减少页分配开销，<a target="_blank" rel="noopener" href="https://www.cse.iitd.ernet.in/~sbansal/pubs/hawkeye.pdf">这篇论文</a>有详细描述</li>
</ul>
<p><strong>无此参数可以提高<em>内存</em>利用度</strong>，<strong>加此参数则会使应用运行得更稳定。</strong></p>
<blockquote>
<ul>
<li>在 jdk9 以前，<strong>理论上</strong> AlwaysPreTouch 打开后会降低项目启动时间1~2个数量级（<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a8356d03ac8f%EF%BC%89%E3%80%82%E5%9C%A8">https://www.jianshu.com/p/a8356d03ac8f）。在</a> jdk9 及之后，由于 jvm 对 preTouch 加入了并行优化（<a target="_blank" rel="noopener" href="https://bugs.openjdk.org/browse/JDK-8157952%EF%BC%89%EF%BC%8CAlwaysPreTouch">https://bugs.openjdk.org/browse/JDK-8157952），AlwaysPreTouch</a> 对项目启动时间的影响大幅降低。</li>
</ul>
<p><strong>AlwaysPreTouch 对 IoTDB 启动性能影响的实验：</strong></p>
<ol>
<li>环境：Mac M2 pro JDK 8&#x2F;11</li>
</ol>
<ul>
<li>ConfigNode：1068ms（加 AlwaysPreTouch）</li>
<li>DataNode：1369ms（加 AlwaysPreTouch）</li>
<li>ConfigNode：999ms（不加 AlwaysPreTouch）</li>
<li>DataNode：1374ms（不加 AlwaysPreTouch）</li>
</ul>
<ol>
<li>环境：fit 服务器 JDK 8</li>
</ol>
<ul>
<li>ConfigNode：1044ms（加 AlwaysPreTouch）</li>
<li>DataNode：1349ms（加 AlwaysPreTouch）</li>
<li>ConfigNode：1031ms（不加 AlwaysPreTouch）</li>
<li>DataNode：1430ms（不加 AlwaysPreTouch）</li>
</ul>
<p><strong>结论：</strong>对 IoTDB 的启动几乎没有性能开销影响，对运行时理论没有性能开销。</p>
</blockquote>
<h3 id="glibc-内存去配机制对-JVM-的影响"><a href="#glibc-内存去配机制对-JVM-的影响" class="headerlink" title="glibc 内存去配机制对 JVM 的影响"></a>glibc 内存去配机制对 JVM 的影响</h3><p>JVM 等原生应用程序调用的 malloc、free 函数，实际是由基础 C 库 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/428216764">glibc</a> 提供的，而 linux 系统则提供了 brk、mmap、munmap 这几个系统调用来分配虚拟内存，所以 libc 的 malloc、free 函数实际是基于这些系统调用实现的。</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225215844.png" alt="image-20231126225215844"></p>
<p>由于系统调用有一定的开销，为减小开销，glibc 实现了一个类似内存池的机制，在 free 函数调用时将内存块缓存起来不归还给 linux，直到缓存内存量到达一定条件才会实际执行归还内存的系统调用。</p>
<blockquote>
<p>节选自 glibc 资料：</p>
<p>用户调用 free 函数释放内存的时候，ptmalloc 并不会立即将其归还操作系统，而是将其放入空闲链表 (bins) 中，这样下次再调用 malloc 函数申请内存的时候，就会从 bins 中取出一块返回，这样就避免了频繁调用系统调用函数，从而降低内存分配的开销。</p>
</blockquote>
<p>因此，<strong>Java 进程占用<em>内存</em>有时比<em>理论上</em>要大些，一定程度上是正常的。（这点对于理解 Java 进程在<em>操作系统</em>中的占用内存非常重要）</strong></p>
<h3 id="glibc-Allocator-的负面影响-RSS-以-64MB-为增量进行递增"><a href="#glibc-Allocator-的负面影响-RSS-以-64MB-为增量进行递增" class="headerlink" title="glibc Allocator 的负面影响: RSS 以 64MB 为增量进行递增"></a>glibc Allocator 的负面影响: RSS 以 64MB 为增量进行递增</h3><p>这是最不容易发现但是可能导致堆外内存不符合预期的情况。在笔者调研时，中英文互联网均有这种 case：pmap 时，发现 java 进程分配了大量 64 MB 大小的内存块。</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225229675.png" alt="image-20231126225229675"></p>
<p>这是由于 Linux 中，glibc 对具有大量并发线程的程序进行了优化，通过避免竞争调高了程序运行速度。而提速是通过为每一个核来维护一个内存池达到的。</p>
<p>这种优化方式的本质是：操作系统会为给定的进程捕获（抢占）内存，<strong>每个内存块的大小为</strong> <strong>64MB</strong>，这样的内存块被叫做 arena，glibc 再根据应用需要将 arena 切割为小块进行实际分配。当使用 pmap 分析进程内存时，这些清晰可见（如上图）</p>
<p>每一个 arena 都只能由特定的 CPU-Core 来进行访问，所以在同一时间点至多会有一个线程会进行访问。然后每个 arena 内部通过 malloc 来使用内存空间。每个 CPU-Core 至多可以分配一定数量的 arena，默认是 8 个。</p>
<p><strong>但是在这些 arena 占用的大量<em>内存</em>中，应用程序真正使用的内存量可能很少</strong>。如果应用程序拥有很多的线程数量，并且执行程序的机器CPU核数也很多，那么通过分配 arena 这种方式占用的内存总量可能非常大。比如在CPU核数为16的机器上，arena 占用的内存量会达到 16 * 8 * 64 MB &#x3D; 8GB。</p>
<p>映射到 Java 程序上，就是：<strong>JVM</strong> <strong>实际只需要一小部分<em>内存</em>，但是</strong> <strong>RSS</strong> <strong>不断增长的问题就会显现出来。因此会导致 Java 实际使用的内存小于 Linux 系统分配的内存。</strong></p>
<p>解决：</p>
<ol>
<li>可以通过<code>MALLOC_ARENA_MAX</code>环境变量来调整arena的最大数量，加上这个环境变量启动 java 进程。并且可以通过<code>cat /proc/&lt;JVM_PID&gt;/environ</code>来检查是否配置成功。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Some versions of glibc use an arena memory allocator that causes</span></span><br><span class="line"><span class="comment"># virtual memory usage to explode. Tune the variable down to prevent</span></span><br><span class="line"><span class="comment"># vmem explosion.</span></span><br><span class="line"><span class="built_in">export</span> MALLOC_ARENA_MAX=<span class="variable">$&#123;MALLOC_ARENA_MAX:-4&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是 <a href="https://link.juejin.cn/?target=https://bugzilla.redhat.com/show_bug.cgi?id=799327">Linux的一个BUG</a> 表明设置<code>MALLOC_ARENA_MAX</code>可能无法生效。不过这个问题已经在 <code>glibc 2.12</code> 版本进行了修复（参考<a href="https://link.juejin.cn/?target=https://access.redhat.com/errata/RHSA-2012:0058">Linux update release notes mentioning  BZ#769594</a>），如果使用的仍旧是未修复版本，那么需要注意这一点。</p>
</blockquote>
<ol>
<li>替换 glibc 为碎片整理更友好的 tcmalloc(google) 和 jemalloc(facebook)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 用法：</span><br><span class="line">LD_PRELOAD=/usr/local/lib/libtcmalloc.so java -jar xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>Redis 使用了 tcmalloc 和 jemalloc 作为内存管理库的 option，在 zmalloc.c 源码中可以看到 redis 用二者覆盖了 glibc（<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010144805/article/details/80353851%EF%BC%89">https://blog.csdn.net/u010144805/article/details/80353851）</a></li>
</ul>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225246701.png" alt="image-20231126225246701"></p>
<ul>
<li>甚至 Redis 直接内置了 jemalloc 的源码，作为 deps 来覆盖 glibc。虽然 Redis 默认用 glibc，但从 Redis 源码的注释中可以看到，Redis 团队是鼓励使用 jemalloc 的</li>
</ul>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225304091.png" alt="image-20231126225304091"></p>
<p>调研时，也发现互联网不乏喊 glibc 坑爹的声音，关于 tcmalloc、jemalloc 与 glibc 的性能对比测试比比皆是（<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/54823155%EF%BC%89%EF%BC%8C%E5%9F%BA%E6%9C%AC%E5%9D%87%E8%A1%A8%E6%98%8E">https://www.zhihu.com/question/54823155），基本均表明</a> tcmalloc、jemalloc 不仅碎片整理比 glibc 优越，性能也有优势😳。</p>
<p>以下两点比较少见，主要贴出来供参考学习，感兴趣的可以看看</p>
<h3 id="DirectByteBuffer-的-capacity-之和大于-MaxDirectMemorySize"><a href="#DirectByteBuffer-的-capacity-之和大于-MaxDirectMemorySize" class="headerlink" title="DirectByteBuffer 的 capacity 之和大于 MaxDirectMemorySize"></a>DirectByteBuffer 的 capacity 之和大于 MaxDirectMemorySize</h3><p>有时我们设置了<code>-XX:MaxDirectMemorySize</code>，但是统计时将所有 DirectByteBuffer 对象的 capacity 加起来发现大于了<code>-XX:MaxDirectMemorySize</code>。</p>
<p>关注 DirectByteBuffer 里的这两个函数：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225318178.png" alt="image-20231126225318178"></p>
<p><code>slice</code>是从一块已知的内存里取出剩下的一部分，用一个新的 DirectByteBuffer 对象指向它，而 <code>duplicate</code> 就是创建一个现有 DirectByteBuffer 的全新副本，各种指针都一样。</p>
<ul>
<li><strong>这两个函数 IoTDB 都有用到</strong></li>
</ul>
<p>从这两个函数创建出来的 DirectByteBuffer 实际上指向的是已存在的堆外内存（相当于复用）。所以如果我们做统计的时候如果仅仅将所有 DirectByteBuffer 对象的 capacity 加起来，那可能会导致算出来的结果偏大不少。</p>
<p><strong>因此我们统计的时候可以注意这点，不要简单 add 所有DirectByteBuffer 对象的</strong> <strong>capacity*。</strong></p>
<h3 id="MaxDirectMemorySize-与-RealDirectMemoryBufferSize"><a href="#MaxDirectMemorySize-与-RealDirectMemoryBufferSize" class="headerlink" title="MaxDirectMemorySize 与 RealDirectMemoryBufferSize"></a>MaxDirectMemorySize 与 RealDirectMemoryBufferSize</h3><p>首先明确：<code>-XX:MaxDirectMemorySize</code>是如何限制 DirectMemory 的？</p>
<p>我们从 java 层面创建 DirectByteBuffer 对象，一般都是通过 ByteBuffer 的 allocateDirect 方法</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225331048.png" alt="image-20231126225331048"></p>
<p>这个方法会调用该构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap));</span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个构造函数里的<code>Bits.reserveMemory(size, cap)</code>方法会做堆外内存的阈值 check</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// These methods should be called whenever direct memory is allocated or</span></span><br><span class="line"><span class="comment">// freed.  They allow the user to control the amount of direct memory</span></span><br><span class="line"><span class="comment">// which a process may access.  All sizes are specified in bytes.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reserveMemory</span><span class="params">(<span class="type">long</span> size, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!memoryLimitSet &amp;&amp; VM.isBooted()) &#123;</span><br><span class="line">        maxMemory = VM.maxDirectMemory();</span><br><span class="line">        memoryLimitSet = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// optimist!</span></span><br><span class="line">    <span class="keyword">if</span> (tryReserveMemory(size, cap)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">JavaLangRefAccess</span> <span class="variable">jlra</span> <span class="operator">=</span> SharedSecrets.getJavaLangRefAccess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retry while helping enqueue pending Reference objects</span></span><br><span class="line">    <span class="comment">// which includes executing pending Cleaner(s) which includes</span></span><br><span class="line">    <span class="comment">// Cleaner(s) that free direct buffer memory</span></span><br><span class="line">    <span class="keyword">while</span> (jlra.tryHandlePendingReference()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReserveMemory(size, cap)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger VM&#x27;s Reference processing</span></span><br><span class="line">    System.gc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a retry loop with exponential back-off delays</span></span><br><span class="line">    <span class="comment">// (this gives VM some time to do it&#x27;s job)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sleepTime</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sleeps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tryReserveMemory(size, cap)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sleeps &gt;= MAX_SLEEPS) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!jlra.tryHandlePendingReference()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(sleepTime);</span><br><span class="line">                    sleepTime &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                    sleeps++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// no luck</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>(<span class="string">&quot;Direct buffer memory&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">            <span class="comment">// don&#x27;t swallow interrupts</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法会检查已经分配的内存是否超过阈值，如是，会触发一次 gc 动作，并重新做一次分配，如果还是超过阈值，那将会抛出 OOM，因此分配动作会失败。</p>
<p><strong>结论</strong>：只有通过 <code>DirectByteBuffer(int cap)</code> 构造函数分配的堆外内存，会被检查并受<code>MaxDirectMemorySize</code>限制。</p>
<p>那么如果通过其他构造函数分配堆外内存，显然就不会受<code>MaxDirectMemorySize</code>的限制，比如：</p>
<p>在 jvm 里可以通过 jni 方法回调 DirectByteBuffer 的构造函数，这个构造函数是</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225345248.png" alt="image-20231126225345248"></p>
<p>而调用这个构造函数的 jni 方法是<code>NewDirectByteBuffer</code></p>
<p>想象这么种情况，我们写了一个 native 方法，里面分配了一块内存，同时通过上面这个方法和一个 DirectByteBuffer 对象关联起来，那从 java 层面来看这个 DirectByteBuffer 确实是一个有效的占有不少 native 内存的对象，但是这个对象后面关联的内存完全绕过了<code>MaxDirectMemorySize</code> 的 check。所以造成：明明设置了<code>MaxDirectMemorySize</code>，但是发现 DirectByteBuffer 关联的堆外内存其实是大于它的。</p>
<ul>
<li>IoTDB 的依赖 [zstd-jni](<a target="_blank" rel="noopener" href="https://github.com/search?q=repo:luben/zstd-jni">https://github.com/search?q=repo%3Aluben%2Fzstd-jni</a> newDirectByteBuffer&amp;type&#x3D;code) 有声明该 jni 方法，不过 IoTDB 并未调用。这里贴出来主要参考学习~</li>
</ul>
<h1 id="【监控】如何监控？"><a href="#【监控】如何监控？" class="headerlink" title="【监控】如何监控？"></a>【监控】如何监控？</h1><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225358955.png" alt="image-20231126225358955"></p>
<h2 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h2><ol>
<li>使用 MemoryPoolMXBean 监控分代堆内存 + Code Cache + Metaspace</li>
</ol>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225411976.png" alt="image-20231126225411976"></p>
<ol start="2">
<li>使用BufferPoolMXBean 监控 Direct + mmap</li>
</ol>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225424076.png" alt="image-20231126225424076"></p>
<ol start="3">
<li><strong>缺点：</strong>对于非堆内存的监控不全，只覆盖了 code cache、metaspace、direct、mapped。</li>
</ol>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ol>
<li>直接读取 <code>java.nio.Bits</code> 来监控 direct 的 <code>TOTAL_CAPACITY</code>与<code>RESERVE_MEMORY</code>。<strong>实测跟</strong> <strong>JMX</strong> <strong>的</strong> <code>total</code>、<code>used</code> <strong>效果一致</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Class&lt;?&gt; c = Class.forName(<span class="string">&quot;java.nio.Bits&quot;</span>);</span><br><span class="line">  <span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;RESERVED_MEMORY&quot;</span>);</span><br><span class="line">  field1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;TOTAL_CAPACITY&quot;</span>);</span><br><span class="line">  field2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (c) &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">total</span> <span class="operator">=</span> ((AtomicLong) field2.get(<span class="literal">null</span>)).get();</span><br><span class="line">    <span class="type">long</span> <span class="variable">reserve</span> <span class="operator">=</span> ((AtomicLong) field1.get(<span class="literal">null</span>)).get();</span><br><span class="line">    System.out.println(total + <span class="string">&quot; &quot;</span> + reserve);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="Java-工具"><a href="#Java-工具" class="headerlink" title="Java 工具"></a>Java 工具</h3><h4 id="Jmap"><a href="#Jmap" class="headerlink" title="Jmap"></a>Jmap</h4><p>互联网上有非常丰富的资料，可以自行参考</p>
<ul>
<li><strong>优点：</strong>随时使用；没有性能损耗；适合监控堆内存，还可以监控类加载情况等，功能强大，可以找出 OOM 瓶颈</li>
<li><strong>缺点：</strong>对非堆内存的监控有欠缺，只能看到 Metaspace 的内存情况</li>
</ul>
<h4 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h4><p>互联网上有非常丰富的资料，可以自行参考</p>
<ul>
<li><strong>优点：</strong>功能强大，可以找出 OOM 到底在哪个类发生</li>
<li><strong>缺点：</strong>对 native 等非堆内存的监控有欠缺</li>
</ul>
<h4 id="Jcmd"><a href="#Jcmd" class="headerlink" title="Jcmd"></a>Jcmd</h4><ol>
<li>监控堆内存使用信息（G1 GC）和 Metaspace</li>
</ol>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225520870.png" alt="image-20231126225520870"></p>
<ol start="2">
<li>监控 Code Cache</li>
</ol>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225533541.png" alt="image-20231126225533541"></p>
<ol start="3">
<li>查看堆使用情况的统计信息</li>
</ol>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225548347.png" alt="image-20231126225548347"></p>
<ol start="4">
<li>打印 native memory（非堆内存）信息，即使用 NMT，见下节。</li>
</ol>
<ul>
<li><strong>优点：</strong>各种命令高低搭配，堆内非堆都能很好的监控到</li>
<li><strong>缺点：</strong>非堆内存的详细监控需要开启 NMT，会带来性能损失且不支持热加载</li>
</ul>
<h4 id="Native-Memory-Tracking（NMT）"><a href="#Native-Memory-Tracking（NMT）" class="headerlink" title="Native Memory Tracking（NMT）"></a>Native Memory Tracking（NMT）</h4><ol>
<li><strong>开启：</strong>使用 <code>-XX:NativeMemoryTracking=``summary</code> 可以用于开启 NMT，其中该值默认为 off，可以设置为 summary 或者 detail 来开启；<strong>开启的话，大概会增加 5%-10% 的性能消耗</strong></li>
<li><strong>使用：</strong>使用<code>jcmd pid VM.native_memory</code> 可以查看，后面可以加 summary 或者 detail，如果是开启 summary 的，就只能使用 summary；其中 scale 参数可以指定展示的单位，可以为 KB 或者 MB 或者 GB</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jcmd &lt;pid&gt; VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># summary: 分类内存使用情况.</span></span><br><span class="line"><span class="comment"># detail: 详细内存使用情况，除了summary信息之外还包含了虚拟内存使用情况。</span></span><br><span class="line"><span class="comment"># baseline: 创建内存使用快照，方便和后面做对比</span></span><br><span class="line"><span class="comment"># summary.diff: 和上一次baseline的summary对比</span></span><br><span class="line"><span class="comment"># detail.diff: 和上一次baseline的detail对比</span></span><br><span class="line"><span class="comment"># shutdown: 关闭NMT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例：</span></span><br><span class="line">jcmd 1 VM.native_memory summary</span><br><span class="line">jcmd 1 VM.native_memory summary scale=MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 baseline</span></span><br><span class="line">jcmd 1 VM.native_memory baseline</span><br><span class="line">Baseline succeeded</span><br><span class="line"></span><br><span class="line"><span class="comment"># diff 对比 baseline</span></span><br><span class="line">jcmd 1 VM.native_memory summary.diff</span><br></pre></td></tr></table></figure>

<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225607661.png" alt="image-20231126225607661"></p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225618197.png" alt="image-20231126225618197"></p>
<ul>
<li><strong>优点：</strong>非常全，各项都能很好的监控到；能监控到 memory map，拿到内存地址。</li>
<li><strong>缺点：</strong>必须在 JVM 启动时添加参数开启，不支持热加载；有 5-10% 的性能损失</li>
</ul>
<h4 id="Verbose"><a href="#Verbose" class="headerlink" title="Verbose"></a>Verbose</h4><p>在调试程序时，有时需要查看程序加载的类、内存回收情况、调用的本地接口等。这时候就需要 <code>-verbose</code> 命令。</p>
<ol>
<li>直接在 VM 参数添加</li>
<li>也可以在命令行输入 <code>java -verbose:xxx</code>来查看</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-verbose:class 查看类加载情况</span><br><span class="line">-verbose:gc 查看虚拟机中内存回收情况</span><br><span class="line">-verbose:jni 查看本地方法调用的情况</span><br></pre></td></tr></table></figure>

<p>作用：可以用来排查异常类加载情况、本地接口异常调用等（这些通常是内存泄漏、内存异常的凶手）</p>
<p>例：对 configNode 使用 -verbose:class：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225632258.png" alt="image-20231126225632258"></p>
<h3 id="系统工具（Linux）"><a href="#系统工具（Linux）" class="headerlink" title="系统工具（Linux）"></a>系统工具（Linux）</h3><p>对于 native 层面的内存分配和排查，Java 层面的工具已经不适合。此时需要 Linux 系统层面的工具进行排查。</p>
<p>以下提到的工具都可以结合起来使用。有一个真实案例，将下列工具组合运用，非常牛逼丝滑：</p>
<p><a target="_blank" rel="noopener" href="https://heapdump.cn/article/2640702">https://heapdump.cn/article/2640702</a></p>
<h4 id="pmap"><a href="#pmap" class="headerlink" title="pmap"></a>pmap</h4><p>用法：<code>pmap &lt;选项&gt; pid</code></p>
<ol>
<li>快速检查占用较大的内存</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pmap -x 1 | sort -nrk3 | less </span><br></pre></td></tr></table></figure>

<ol>
<li>检查一段时间后新增了哪些内存段，或哪些变大了。在不同的时间点多次保存 pmap 命令的输出，然后通过文本对比工具查看两个时间点内存段分布的差异。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pmap -x 1 &gt; pmap-`date +%F-%H-%M-%S`.log</span><br></pre></td></tr></table></figure>

<p>pmap 的输出如下：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225657607.png" alt="image-20231126225657607"></p>
<p>可以发现，进程申请的所有虚拟内存段，都在pmap中能够找到，相关字段解释如下：</p>
<ul>
<li>Address：表示此内存段的起始地址</li>
<li>Kbytes：表示此内存段的大小(ps：这是虚拟内存)</li>
<li>RSS：表示此内存段实际分配的物理内存，这是由于Linux是延迟分配内存的，进程调用malloc时Linux只是分配了一段虚拟内存块，直到进程实际读写此内存块中部分时，Linux会通过缺页中断真正分配物理内存。</li>
<li>Dirty：此内存段中被修改过的内存大小，使用mmap系统调用申请虚拟内存时，可以关联到某个文件，也可不关联，当关联了文件的内存段被访问时，会自动读取此文件的数据到内存中，若此段某一页内存数据后被更改，即为Dirty，而对于非文件映射的匿名内存段(anon)，此列与RSS相等。</li>
<li>Mode：内存段是否可读(r)可写(w)可执行(x)</li>
<li>Mapping：内存段映射的文件，匿名内存段显示为anon，非匿名内存段显示文件名(加-p可显示全路径)。</li>
</ul>
<p>pmap 的作用通常是：<strong>查看<em>内存</em>分配情况，找出异常内存；根据内存地址，比对 strace 内存请求的具体申请额度；根据内存地址，比对</strong> <strong>NMT</strong> <strong>中的内存地址，找出异常内存。</strong></p>
<h4 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h4><p>作用1：<strong>已知异常内存地址的情况下，查看异常内存内容</strong></p>
<ol>
<li><code>gdp -pid pid</code> 进入GDB</li>
<li>使用命令<code>dump memory mem.bin startAddress endAddress</code> dump内存，其中 startAddress 和 endAddress 可以从 &#x2F;proc&#x2F;pid&#x2F;**aps 中查找。</li>
<li>使用<code>strings mem.bin</code>查看 dump 的内容。</li>
</ol>
<p>作用2：<strong>检查被</strong> <strong>glibc</strong> <strong>内存*分配器缓存的内存</strong> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看glibc内存分配情况，会输出到进程标准错误中</span></span><br><span class="line">gdb -q -batch -ex <span class="string">&#x27;call malloc_stats()&#x27;</span> -p pid</span><br></pre></td></tr></table></figure>

<p>glibc 实现了 malloc_trim 函数，通过 brk 或 madvise 系统调用，归还被 glibc 缓存的内存，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回收glibc缓存的内存</span></span><br><span class="line">gdb -q -batch -ex <span class="string">&#x27;call malloc_trim(0)&#x27;</span> -p pid </span><br></pre></td></tr></table></figure>

<h4 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h4><p>向 os 追踪申请内存请求（系统调用），常见用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace -f -e &quot;brk,mmap,munmap&quot; -p pid</span><br></pre></td></tr></table></figure>

<p>作用：<strong>查到异常申请<em>内存</em>请求的</strong> <strong>pid*，从而通过</strong> <strong>jstack</strong> <strong>等分析工具，具体分析该 id 线程的<em>调用栈</em>等行为</strong></p>
<p>缺点：必须在项目启动时 strace 才能达到比较好的追踪效果</p>
<h1 id="【最佳实践】如何控制-Java-进程所占内存"><a href="#【最佳实践】如何控制-Java-进程所占内存" class="headerlink" title="【最佳实践】如何控制 Java 进程所占内存"></a>【最佳实践】如何控制 Java 进程所占内存</h1><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p><strong>使用</strong> <strong>JVM</strong> <strong>参数控制</strong></p>
<ul>
<li><code>Xmx</code>：对应 <strong>最大堆大小</strong> <code>MaxHeapSize</code></li>
<li><code>Xms</code>：相当于同时设置<strong>最小堆*大小</strong><code>MinHeapSize</code> 和<strong>初始堆大小</strong><code>InitialHeapSize</code></li>
<li><code>-XX:+AlwaysPreTouch</code>：对于只运行 IoTDB 的机器，内存本来就都是给 IoTDB 用的，建议加上此参数，避免 Linux touch 内存的开销，让内存更稳定。</li>
</ul>
<h2 id="非堆内存-1"><a href="#非堆内存-1" class="headerlink" title="非堆内存"></a>非堆内存</h2><ol>
<li><strong>使用</strong> <strong>JVM</strong> <strong>参数控制</strong></li>
</ol>
<ul>
<li><code>-Xss</code>：每个线程 stack 的大小</li>
<li><code>-XX:MaxDirectMemorySize</code>：控制直接内存大小</li>
<li><code>-XX:MaxMetaspaceSize</code>：控制数据元信息区大小</li>
<li><code>-XX:CompressedClassSpaceSize</code>：控制类元信息区大小</li>
<li><code>-XX:ReservedCodeCacheSize</code>：Code cache 区最大内存</li>
<li><code>-Djdk.nio.maxCachedBufferSize</code>：限制每个线程缓存 <code>DirectByteBuffer</code> 的 size</li>
<li>避免使用<code>-XX:+DisableExplicitGC</code>：JVM 实现中：<code>-XX:MaxMetaspaceSize</code>的阈值检查依赖 System.gc()。禁用 System.gc() 会导致更容易 OOM。</li>
</ul>
<ol>
<li><strong>native 代码分配上妥善处理</strong></li>
</ol>
<ul>
<li>主要指使用 Unsafe 类或者 NIO 相关类直接管理内存时，需要妥善做好内存的分配去配，防止内存泄漏<ul>
<li>常见的实现是结合 try-with-resource，在 close 函数中释放内存，达到类似 C++ RAII 的效果<ul>
<li>在合适的时机（close）调用 <code>DirectByteBuffer.getCleaner().clean()</code>，手动清理堆外内存，而不是交给 GC（finalize）</li>
</ul>
</li>
<li>在堆外内存使用频繁的场合，不要擅自开启 <code>-XX:+DisableExplicitGC</code> 开关进行“优化”。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>冰山对象</strong> <strong>GC</strong></li>
</ol>
<ul>
<li>主要指 DirectByteBuffer</li>
</ul>
<h1 id="【总结】本调研旨在解决的问题"><a href="#【总结】本调研旨在解决的问题" class="headerlink" title="【总结】本调研旨在解决的问题"></a>【总结】本调研旨在解决的问题</h1><h2 id="为什么设置-Xmx6g，但是-java-进程内存占用达到-8g？（数字随便举的）"><a href="#为什么设置-Xmx6g，但是-java-进程内存占用达到-8g？（数字随便举的）" class="headerlink" title="为什么设置-Xmx6g，但是 java 进程内存占用达到 8g？（数字随便举的）"></a>为什么设置-Xmx6g，但是 java 进程内存占用达到 8g？（数字随便举的）</h2><blockquote>
<p>镜像问题：为什么 MAX_DIRECT_MEMORY_SIZE + 堆内内存 比实际进程占用内存大？</p>
</blockquote>
<ol>
<li>因为有非堆内存，且非堆内存除了 Direct buffer 还包括 Code Cache，MetaSpace 等。</li>
</ol>
<p>​      Java 进程内存占用 &#x3D; 堆内存 + 非堆内存（DirectMemory + Metaspace + … )</p>
<ol>
<li>由于 glibc 内存去配机制，Java 实际占用内存会比理论上大些</li>
<li>由于 glibc 内存分配机制，Java 实际分配到的物理内存会比真实使用的内存大些</li>
</ol>
<h2 id="非堆内存如何管理？"><a href="#非堆内存如何管理？" class="headerlink" title="非堆内存如何管理？"></a>非堆内存如何管理？</h2><p>可参考前文</p>
<h2 id="堆内存如何管理？"><a href="#堆内存如何管理？" class="headerlink" title="堆内存如何管理？"></a>堆内存如何管理？</h2><p>可参考前文</p>
<h1 id="排查-Java-内存相关最佳实践"><a href="#排查-Java-内存相关最佳实践" class="headerlink" title="排查 Java 内存相关最佳实践"></a>排查 Java 内存相关最佳实践</h1><h2 id="如何排查-Java-应用在线上到底占用了多少内存？"><a href="#如何排查-Java-应用在线上到底占用了多少内存？" class="headerlink" title="如何排查 Java 应用在线上到底占用了多少内存？"></a>如何排查 Java 应用在线上到底占用了多少内存？</h2><ol>
<li><strong>查看 IoTDB 占用的*物理内存</strong><ol>
<li>top 等命令</li>
<li>System 面板</li>
</ol>
</li>
<li><strong>查看 IoTDB 进程各模块占用内存</strong><ol>
<li>堆内存：jmap、jcmd、System 面板等</li>
<li>非堆内存：<ol>
<li>推荐：<strong>NMT</strong>（查看绝大部分） + <strong>System 面板</strong>（查看 mapped memory）+ <strong>pmap</strong>（查看 native 内存）+ <strong>gdb</strong>（查看 glibc 缓存内存），以上组合拳可以覆盖本文提到的所有相关内存。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="内存异常（OOM-RSS-远超预期等），如何定位哪部分内存是凶手？"><a href="#内存异常（OOM-RSS-远超预期等），如何定位哪部分内存是凶手？" class="headerlink" title="内存异常（OOM&#x2F;RSS 远超预期等），如何定位哪部分内存是凶手？"></a>内存异常（OOM&#x2F;RSS 远超预期等），如何定位哪部分内存是凶手？</h2><p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231126225726087.png" alt="image-20231126225726087"></p>
<ol>
<li><strong>首先结合异常信息看 System 面板</strong>，定位是不是<strong>堆内存*的问题</strong><ol>
<li><strong>如果是</strong> <strong>OOM*：</strong>报错 OutOfMemoryError: Direct Buffer Memory：是 Direct Memory 泄漏，跳到第三步。OutOfMemoryError: GC limit、OutOfMemoryError: Heap size 等是堆内存泄漏，跳到第二步</li>
<li><strong>如果是 Java 进程</strong> <strong>RSS</strong> <strong>远大于理论<em>内存</em>：</strong>一般不是堆内存的问题。根据经验，一般是：<ul>
<li>某些自定义的 native 代码造成了内存泄漏，对应第四步。</li>
<li><code>DirectByteBuffer</code> 的问题，对应第三步。<ul>
<li>这些对象实例可能是由应用程序显示的创建（例如通过某些第三方库）</li>
<li>也可能是由 JDK 内部使用<code>HeapByteBuffer</code> 的 I&#x2F;O 线程自动创建和缓存在 threadlocal 里，如果创造了很多通过这样的线程， 并且每个线程使用的 buffer 很大，那么最终 Java 进程可能占用大量的堆外内存，看起来就像发生了内存泄漏一样</li>
</ul>
</li>
<li>操作系统存在问题，对应第五步。<ul>
<li>如果是操作系统的原因的话，那么在通过<code>pmap</code>工具输出的日志中应该会存在众多大小为 64MB 的内存块分配，如果 64M 问题不是很显然，那么就需要检查自定义的本地代码（nmt 等手段）</li>
</ul>
</li>
</ul>
</li>
<li>System 面板看各 memory 是否符合预期，可以定位是否为堆内存的问题。</li>
</ol>
</li>
<li><strong>如果是<em>堆内存</em>的问题</strong><ol>
<li>使用 jmap、jprofiler 等手段 dump 内存，进一步查看到底是哪些对象积压</li>
<li>使用 jmap、GC log 等手段查看 gc 情况，看看是不是 full gc 不及时等问题。如是，需要调整 GC 的相关 VM options</li>
</ol>
</li>
<li><strong>如果是 DirectMemory</strong><ol>
<li>查看 MaxDirectMemorySize 是不是设置妥当</li>
<li>如 MaxDirectMemorySize 设好了，查看 heap 中 DirectByteBuffer 对象的积压&#x2F;创建情况，可以通过 dump heap、verbose 等手段实现。有可能是 DirectByteBuffer 没有被及时 clean 导致 DirectMemory 增大</li>
</ol>
</li>
<li><strong>如果不是</strong> <strong>heap</strong> <strong>也不是 DirectMemory</strong><ol>
<li>建议加上 nmt，复现 OOM 场景，进一步查看到底是哪块区域内存异常<ul>
<li>Metaspace、code cache 等，如果它们异常了，重新设置对应的 VM options 即可</li>
</ul>
</li>
</ol>
</li>
<li><strong>如果</strong> <strong>nmt</strong> <strong>各项都正常</strong><ol>
<li>可能是 native 或者 glibc 等 JVM 不能控制的部分在搞鬼，这时候需要使用 linux 的工具了</li>
<li>先 pmap，查看是不是 glibc 64M 内存的问题。<ul>
<li>一般来说，64M 问题不会导致 OOM 这么严重的 exception，只会让 Java 进程超额申请它所需要的内存。也就是说，64M 可能只是压死骆驼的最后一根稻草，但并不是 OOM 真正的罪魁祸首。如果想解决 64M 问题的话，可以参考前文的解决方案</li>
</ul>
</li>
<li><code>pmap -x 1 | sort -nrk3 | less</code> ，依次排查较大的内存块。<ul>
<li>尝试用 gdb 等工具 dump 这些内存，看看里面是什么内容，往往能找到异常类的信息<ul>
<li>可以参考 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7176056215074504762%E3%80%81https://heapdump.cn/article/4044805">https://juejin.cn/post/7176056215074504762、https://heapdump.cn/article/4044805</a></li>
</ul>
</li>
<li>结合 strace 等工具深度跟踪内存分配轨迹，揪出凶手<ul>
<li>可以参考 <a target="_blank" rel="noopener" href="https://heapdump.cn/article/2640702">https://heapdump.cn/article/2640702</a></li>
</ul>
</li>
</ul>
</li>
<li>最后查看 glibc 内存分配情况，<code>gdb -q -batch -ex &#39;call malloc_stats()&#39; -p pid</code> ，看看是不是 glibc 缓存未归还操作系统的问题。<ul>
<li>如是，调用<code>gdb -q -batch -ex &#39;call malloc_trim(0)&#39; -p pid</code>归还 glibc 的缓存<ul>
<li>malloc_trim 有概率会导致 JVM Crash，使用的时候需要小心</li>
<li>可以参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/652545321">https://zhuanlan.zhihu.com/p/652545321</a></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ol>
<li><a target="_blank" rel="noopener" href="http://lovestblog.cn/blog/2016/08/29/oom/">http://lovestblog.cn/blog/2016/08/29/oom/</a></li>
<li><a target="_blank" rel="noopener" href="http://lovestblog.cn/blog/2016/10/29/metaspace/">http://lovestblog.cn/blog/2016/10/29/metaspace/</a></li>
<li><a target="_blank" rel="noopener" href="http://lovestblog.cn/blog/2016/06/29/ooc-offheap/">http://lovestblog.cn/blog/2016/06/29/ooc-offheap/</a></li>
<li><a target="_blank" rel="noopener" href="http://lovestblog.cn/blog/2015/05/12/direct-buffer/">http://lovestblog.cn/blog/2015/05/12/direct-buffer/</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1666640">https://cloud.tencent.com/developer/article/1666640</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1408384">https://cloud.tencent.com/developer/article/1408384</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2315755">https://cloud.tencent.com/developer/article/2315755</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2277333?areaId=106001">https://cloud.tencent.com/developer/article/2277333?areaId=106001</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7225875600644407357">https://juejin.cn/post/7225875600644407357</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7225874698906615864">https://juejin.cn/post/7225874698906615864</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7225879698952486972">https://juejin.cn/post/7225879698952486972</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904168549777421">https://juejin.cn/post/6844904168549777421</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7067170332917923854">https://juejin.cn/post/7067170332917923854</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6854573220733911048">https://juejin.cn/post/6854573220733911048</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7078624931826794503">https://juejin.cn/post/7078624931826794503</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7176056215074504762">https://juejin.cn/post/7176056215074504762</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/342770702">https://zhuanlan.zhihu.com/p/342770702</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/652545321">https://zhuanlan.zhihu.com/p/652545321</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/428216764">https://zhuanlan.zhihu.com/p/428216764</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/432258798">https://zhuanlan.zhihu.com/p/432258798</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/55529827">https://www.zhihu.com/question/55529827</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/58943470">https://www.zhihu.com/question/58943470</a></li>
<li><a target="_blank" rel="noopener" href="https://heapdump.cn/article/2906673">https://heapdump.cn/article/2906673</a></li>
<li><a target="_blank" rel="noopener" href="https://heapdump.cn/article/2614172">https://heapdump.cn/article/2614172</a></li>
<li><a target="_blank" rel="noopener" href="https://heapdump.cn/article/2640702">https://heapdump.cn/article/2640702</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/pingnanlee/article/details/51984058">https://blog.csdn.net/pingnanlee/article/details/51984058</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/renfufei/article/details/115165919">https://blog.csdn.net/renfufei/article/details/115165919</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.skyofit.com/archives/478">https://learn.skyofit.com/archives/478</a></li>
<li><a target="_blank" rel="noopener" href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</a></li>
<li><a target="_blank" rel="noopener" href="https://haslab.org/2020/12/06/hawkeye.html">https://haslab.org/2020/12/06/hawkeye.html</a></li>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/troubleshooting-problems-with-native-off-heap-memo">https://dzone.com/articles/troubleshooting-problems-with-native-off-heap-memo</a></li>
<li><a target="_blank" rel="noopener" href="https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31173374/why-does-a-jvm-report-more-committed-memory-than-the-linux-process-resident-set">https://stackoverflow.com/questions/31173374/why-does-a-jvm-report-more-committed-memory-than-the-linux-process-resident-set</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/41468670/difference-in-used-committed-and-max-heap-memory">https://stackoverflow.com/questions/41468670/difference-in-used-committed-and-max-heap-memory</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2440434/whats-the-difference-between-reserved-and-committed-memory">https://stackoverflow.com/questions/2440434/whats-the-difference-between-reserved-and-committed-memory</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/71366522/how-does-java-guarateee-reserved-memory">https://stackoverflow.com/questions/71366522/how-does-java-guarateee-reserved-memory</a></li>
<li><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html">https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></li>
</ol>

  </div>
  
    
      <a id="older" class="blog-nav" href="/article/Metric-System/">OLDER&nbsp;&gt;</a>
      
        
          <a id="newer" class="blog-nav" href="/article/JVM-GC-Tuning/">&lt;&nbsp;NEWER</a>
          
            
</div>
        <div class="footer">
  
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/Pengzna">Copyright © Pengzna 2021-present</a>
        
    </div>
  
</div>

      </div>

      <div class="back-to-top hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



      
  <div class="search-icon" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-box">
        <div class="search-title">
          <!-- <span class="search-icon-input">
            <a href="javascript: void(0)">
              <i class="iconfont icon-search"></i>
            </a>
          </span> -->
          
            <input type="text" class="search-input" id="search-input" placeholder="搜索">
          
          <span class="search-close-icon" id="search-close-icon">
            <a href="javascript: void(0)">
              <i class="iconfont icon-close"></i>
            </a>
          </span>
        </div>
        <div class="search-result" id="search-result"></div>
      </div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    // inputArea.onclick = function() {
    //   getSearchFile()
    //   this.onclick = null
    // }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        inputArea.focus()
        getSearchFile()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'><span></ul>";
      // $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'><h2>" + orig_data_title + "</h2></a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<h3 class=\"search-result-abstract\">" + match_content + "...</h3>"
                }
                str += "<hr></li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/leedom92/hexo-theme-leedom#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </body>
</html>

<!DOCTYPE html>
<html lang="en">

  <head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="Pengzna,blog" />
  <meta name="author" content="Pengzna" />
  <meta name="description" content="Pengzna 的博客" />
  
  
  <title>
    
      JVM GC 调研与 Apache IoTDB GC 可观测性建设 
      
      
    
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Montserrat|Roboto:400,400italic,600|Roboto+Mono" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">


  

  
    
<link rel="stylesheet" href="/css/post.css">

  

  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="/js/fancybox.js"></script>


<meta name="generator" content="Hexo 7.0.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
      <div class="header">
  <a href="/">Pengzna's blog 👋</a>
</div>


      <p class="links">
  
    <a title="archives" target="" href="/archives/">
      <i class="iconfont icon-bookmark"></i>
    </a>
  
    <a title="github" target="_blank" href="https://github.com/Pengzna">
      <i class="iconfont icon-github"></i>
    </a>
  
    <a title="email" target="_blank" href="mailto:junzhi.pengzna@gmail.com">
      <i class="iconfont icon-envelope"></i>
    </a>
  
    <a title="linkedin" target="_blank" href="https://www.linkedin.com/in/pengzna/">
      <i class="iconfont icon-linkedin"></i>
    </a>
  
    <a title="wechat" target="_blank" href="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115013033249.png">
      <i class="iconfont icon-wechat"></i>
    </a>
  
</p>


      <div class="main">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->

<!-- LaTex Display -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>

<div class="post">
  <h3 class="date">
    Aug 30, 2023
  </h3>
  <h1>
    JVM GC 调研与 Apache IoTDB GC 可观测性建设
  </h1>
  <div class="content markdown-body">
    <h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>本文是作者在调研改进 IoTDB JVM GC 监控板块时产出的相关 wiki，主要包含 GC 基本知识、不同 JDK 下的 GC 算法细节，以及设计改进 IoTDB JVM GC 监控板块时的思路等内容。本文旨在优化 IoTDB 现有 GC 监控系统，结合实际生产需要，扩充现有 metric 指标，使其针对不同 JDK 的 GC Collector 能更精准、高效的进行监控。</p>
<blockquote>
<ol>
<li><p>JVM GC 是一个浩瀚的系统领域，本文仅于皮毛处探讨，起抛砖引玉之效。如有错误，敬请指出，欢迎各位大佬通过邮件或微信与我进一步交流！</p>
</li>
<li><p>本文引用、整合了大量互联网资料（文字、图片），同时也有自己的探究、实验和思考。感谢所有互联网大佬的无私分享，结尾给出了所有的 Reference 链接。</p>
</li>
</ol>
</blockquote>
<p>在系统工程设计之外，为了更好地帮助理解，<strong>本文涉及以下相关概念</strong>，读者可提前<strong>按需浏览：</strong></p>
<ul>
<li>GC 基本知识，具体可参见【2. GC 基础】</li>
<li>常见的 GC 收集器以及它们的基本特点，具体可参见【3. GC 收集器、10. 其他】</li>
<li>如何判断 GC 异常，具体可参见【4. GC 异常的判断】</li>
</ul>
<h2 id="2-GC-基础"><a href="#2-GC-基础" class="headerlink" title="2. GC 基础"></a>2. GC 基础</h2><h3 id="2-1-JVM-内存划分"><a href="#2-1-JVM-内存划分" class="headerlink" title="2.1. JVM 内存划分"></a>2.1. JVM 内存划分</h3><p>此部分是后续监控指标设计的依据，因此详细介绍：</p>
<p>JVM 内存中的对象，大致可以分为两大类：一类对象，他们的生命周期很短暂，比如局部变量、临时对象等。另一类对象则会存活很久，比如用户应用程序中 DB 长连接中的 Connection 对象。为了对这两类对象分别高效回收，JVM 的内存使用<strong>分代思想</strong>进行划分。</p>
<p>以 Java 8 的内存结构为例：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115174532651.png" alt="image-20231115174532651"></p>
<p>可以看到，JVM 的内存被分为了不同的区域。GC 主要工作在 Heap 区和 MetaSpace 区（上图蓝色部分），而在 GC 的主要工作区，<strong>内存又被分为了不同的代际</strong>。下面这张表格简单描述了我们主要需要关注的区域：</p>
<table>
<thead>
<tr>
<th><strong>分代名</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Young Generation（Eden + Survivor）</td>
<td>新生代主要分为两个部分：<strong>Eden 区</strong>和 <strong>Survivor 区</strong>，其中 Survivor 区又可以分为两个部分，<strong>S0 和S1</strong>。该区域中，相对于老年代空间较小，对象的生存周期短，GC 频繁。</td>
</tr>
<tr>
<td>Old Generation（Tenured）</td>
<td>老年代整体空间较大，对象的生命周期长，存活率高，回收不频繁。</td>
</tr>
<tr>
<td><em><strong>@Deprecated</strong></em>Permanent</td>
<td>永久代又称为方法区，存储着类和接口的元信息以及 interned 的字符串信息。在 JDK8 中被元空间取代。</td>
</tr>
<tr>
<td>MetaSpace</td>
<td>JDK8 以后引入，方法区也存在于元空间。</td>
</tr>
</tbody></table>
<p>在 Java 程序中，常见的垃圾回收器，打印内存区域结果如下：</p>
<ul>
<li>G1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">G1 Eden Space <span class="comment">// young</span></span><br><span class="line">G1 Old Gen <span class="comment">// old</span></span><br><span class="line">G1 Survivor Space <span class="comment">// young</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ParNewGC + CMS</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Par Eden Space <span class="comment">// young</span></span><br><span class="line">Par Survivor Space <span class="comment">// young</span></span><br><span class="line">CMS Old Gen <span class="comment">// old</span></span><br></pre></td></tr></table></figure>

<ul>
<li>SerialGC</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Tenured Gen <span class="comment">// old</span></span><br><span class="line">Eden Space <span class="comment">// young</span></span><br><span class="line">Survivor Space <span class="comment">// young</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ParallelGC + ParallelOldGC</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PS Old Gen <span class="comment">// old</span></span><br><span class="line">PS Survivor Space <span class="comment">// young</span></span><br><span class="line">PS Eden Space <span class="comment">// young</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Shenandoah</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shenandoah <span class="comment">// non-generational</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ZGC</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ZHeap <span class="comment">// non-generational</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-GC-收集过程"><a href="#2-2-GC-收集过程" class="headerlink" title="2.2. GC 收集过程"></a>2.2. GC 收集过程</h3><p>基于上述分代内存，JVM 使用<strong>分代垃圾回收算法</strong>（当然，JDK 11 以后的某些新收集器使用非代际垃圾回收算法，这些会在后文中提到），其大致执行过程如下：</p>
<ul>
<li>初始态：对象分配在 Eden 区，S0、S1 区几乎为空。</li>
<li>随着程序的运行，越来越多的对象被分配在 Eden 区。</li>
<li>当 Eden 放不下时，就会发生 <strong>MinorGC</strong>（即 YoungGC），此时，会先标识出不可达的垃圾对象，然后将可达的对象移动到 S0 区，并将不可达的对象清理掉。这时候，Eden 区就是空的了。在这个过程中，使用了标记清理算法及复制算法。</li>
<li>随着 Eden 放不下时，会再次触发 minorGC，和上一步一样，先标记。这个时候，Eden 和 S0 区可能都有垃圾对象了，而 S1 区是空的。这个时候，会直接将 Eden 和 S0 区的对象直接搬到S1区，然后将Eden 与 S0 区的垃圾对象清理掉。经历这一轮的 MinorGC 后，Eden 与 S0 区为空。</li>
<li>随着程序的运行，Eden 空间会被分配殆尽，这时会重复刚才 MinorGC 的过程，不过此时，S0 区是空的，S0 和 S1 区域会互换，此时存活的对象会从 Eden 和 S1 区，向S0 区移动。然后 Eden 和 S1 区中的垃圾会被清除，这一轮完成之后，这两个区域为空。</li>
<li>在程序运行过程中，虽然大多数对象都会很快消亡，但仍然存在一些存活时间较长的对象，对于这些对象，<strong>在 S0 和 S1 区中反复移动</strong>，会造成一定的性能开销，降低 GC 的效率。因此引入了对象晋升的行为。</li>
<li>当对象在新生代的 Eden、S0、S1 区域之间，每次从一个区域移动到另一个区域时，年龄都会加一，在达到一定的阈值后，如果该对象仍然存活，该对象将会晋升到老年代。</li>
<li>如果老年代也被分配完毕后，就会出现 <strong>MajorGC（即Full GC）</strong>，由于老年代通常对象比较多，因此标记-整理算法的耗时较长，因此会出现 <strong>STW</strong> 现象，因此大多数应用都会尽量减少或者避免出现 Full GC 的原因。</li>
</ul>
<p>需要特别说明的是：对于一个新分配的对象，如果 Eden 区放不下，但是老年代可以放下时，该对象会被直接分配到老年代，不会按照上述从新生代晋升到老年代。</p>
<p>上面提到了一些如<strong>「复制算法」、「不可达」</strong>、<strong>「标记-整理」</strong>等概念，这里引用网络资料进行一一简单介绍：</p>
<h4 id="2-2-1-识别垃圾"><a href="#2-2-1-识别垃圾" class="headerlink" title="2.2.1. 识别垃圾"></a>2.2.1. 识别垃圾</h4><ul>
<li><strong>引用计数法（Reference Counting）：</strong> 对每个对象的引用进行计数，每当有一个地方引用它时计数器 +1、引用失效则 -1，引用的计数放到对象头中，大于 0 的对象被认为是存活对象。虽然循环引用的问题可通过 Recycler 算法解决，但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较低，早期的编程语言会采用此算法。</li>
<li><strong>可达性分析，又称引用链法（Tracing GC）：</strong> 从 GC Root 开始进行对象搜索，可以被搜索到的对象即为可达对象，此时还不足以判断对象是否存活&#x2F;死亡，需要经过多次标记才能更加准确地确定，整个连通图之外的对象便可以作为垃圾被回收掉。目前 Java 中主流的虚拟机均采用此算法。</li>
</ul>
<h4 id="2-2-2-收集算法"><a href="#2-2-2-收集算法" class="headerlink" title="2.2.2. 收集算法"></a>2.2.2. 收集算法</h4><p>自从有自动内存管理出现之时就有的一些收集算法，不同的收集器也是在不同场景下进行组合。</p>
<ul>
<li><strong>Mark-Sweep（标记-清除）：</strong> 回收过程主要分为两个阶段，第一阶段为追踪（Tracing）阶段，即从 GC Root 开始遍历对象图，并标记（Mark）所遇到的每个对象，第二阶段为清除（Sweep）阶段，即回收器检查堆中每一个对象，并将所有未被标记的对象进行回收，整个过程不会发生对象移动。整个算法在不同的实现中会使用三色抽象（Tricolour Abstraction）、位图标记（BitMap）等技术来提高算法的效率，存活对象较多时较高效。</li>
</ul>
<div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115174549490.png" alt="image-20231115174549490" style="zoom:33%;" /></div>

<ul>
<li><strong>Copying（复制）：</strong> 该算法是为了解决标记-清除算法效率低下、GC 之后空间不连续的问题。该算法将空间分为两个大小相同的 From 和 To 两个半区，同一时间只会使用其中一个，每次进行回收时将一个半区的存活对象通过复制的方式转移到另一个半区。复制算法可以通过碰撞指针的方式进行快速地分配内存，但是也存在着空间利用率不高（只有一半）的缺点，另外就是存活对象比较大时复制的成本比较高。</li>
</ul>
<div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115174612759.png" alt="image-20231115174612759" style="zoom: 40%;" /></div>

<ul>
<li><strong>Mark-Compact （标记-整理）：</strong> 这个算法的主要目的就是解决在非移动式回收器中都会存在的碎片化问题，也分为两个阶段，第一阶段与 Mark-Sweep 类似，标记哪些对象死亡，哪些对象被引用，第二阶段则会对存活对象按照整理顺序（Compaction Order）进行整理。</li>
</ul>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115180028849.png" alt="image-20231115180028849"></p>
<p>在 JDK 8 中，默认情况下采用分代垃圾回收策略，其中新生代使用标记-复制算法，老年代使用标记-整理算法。</p>
<p>这是因为老年代<strong>长生命周期</strong>对象多，如果使用复制算法会十分低效。</p>
<ul>
<li>三种算法在是否移动对象、空间和时间方面的一些对比，假设存活对象数量为 <em>L</em>、堆空间大小为 <em>H</em>，则：</li>
</ul>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115180015502.png" alt="image-20231115180015502"></p>
<p>把 mark、sweep、compaction、copying 这几种动作的耗时放在一起看，大致有这样的关系：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115180005979.png" alt="image-20231115180005979"></p>
<p>虽然 compaction 与 copying 都涉及移动对象，但取决于具体算法，compaction 可能要先计算一次对象的目标地址，然后修正指针，最后再移动对象。copying 则可以把这几件事情合为一体来做，所以可以快一些。另外，<strong>还需要留意</strong> <strong>GC</strong> <strong>带来的开销不能只看 Collector 的耗时，还得看 Allocator</strong> 。如果能保证内存没碎片，分配就可以用 pointer bumping 方式，只需要挪一个指针就完成了分配，非常快。而如果内存有碎片就得用 freelist 之类的方式管理，分配速度通常会慢一些。</p>
<ul>
<li><strong>Generational Collection(分代收集)算法</strong></li>
</ul>
<p>分代收集算法根据对象的生存周期，将堆分为新生代(<code>Young</code>)和老年代(<code>Tenur</code>)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用<strong>复制算法</strong>。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用<strong>标记-整理</strong>或者<strong>标记-清除</strong>。</p>
<h2 id="3-GC-收集器"><a href="#3-GC-收集器" class="headerlink" title="3. GC 收集器"></a>3. GC 收集器</h2><p>这里枚举一下各 JDK 版本支持的 GC 收集器，作为快速了解。针对具体常用收集器的调研可参见【10. 其他】</p>
<p>根据 JDK 版本支持的策略，JDK 8、JDK 11 和 JDK 17 是目前长期支持的版本。目前这3个版本共支持7个垃圾回收器，分别是</p>
<ol>
<li><strong>SerialGC</strong></li>
<li><strong>Parallel</strong> <strong>GC</strong></li>
<li><strong>CMS</strong></li>
<li><strong>G1</strong></li>
<li><strong>Shenandoah</strong> <strong>GC</strong></li>
<li><strong>ZGC</strong></li>
<li><strong>Epsilon</strong>（实验特性，仅支持分配不回收，实际场景中不会采用）</li>
</ol>
<p>CMS 仅在 JDK 8 和 JDK 11 中支持，ZGC 在 JDK11 中为实验特性，在 JDK 17 中为正式产品，Shenandoah 在JDK 17 中为正式产品，Epsilon 在 JDK 11 和 JDK 17 中为实验特性。</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175821783.png" alt="image-20231115175821783"></p>
<h3 id="3-1-分代收集器"><a href="#3-1-分代收集器" class="headerlink" title="3.1. 分代收集器"></a>3.1. 分代收集器</h3><ul>
<li><strong>ParNew：</strong> 一款多线程的收集器，采用复制算法，主要工作在 Young 区，可以通过 <code>-XX:ParallelGCThreads</code> 参数来控制收集的线程数，整个过程都是 STW 的，常与 CMS 组合使用。</li>
<li><strong>CMS</strong>： 以获取最短回收停顿时间为目标，采用「标记-清除」算法，分 4 大步进行垃圾收集，其中初始标记和重新标记会 STW ，多数应用于互联网站或者 B&#x2F;S 系统的服务器端上。虽然在 JDK9 被标记弃用，JDK14 被删除，<strong>但仍经常使用。</strong></li>
</ul>
<h3 id="3-2-分区收集器"><a href="#3-2-分区收集器" class="headerlink" title="3.2. 分区收集器"></a>3.2. 分区收集器</h3><ul>
<li><strong>G1：</strong> 一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能地满足垃圾收集暂停时间的要求。<strong>经常使用。</strong></li>
<li><strong>ZGC：</strong> JDK11 中推出的一款低延迟垃圾回收器，适用于大内存低延迟服务的内存管理和回收，SPECjbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68 ms，停顿时间远胜于 G1 和 CMS。<strong>近期也经常见到应用。</strong></li>
<li><strong>Shenandoah：</strong> 由 Red Hat 的一个团队负责开发，与 G1 类似，基于 Region 设计的垃圾收集器，但不需要 Remember Set 或者 Card Table <em>（都是 G1 中的数据结构）</em>来记录跨 Region 引用，停顿时间和堆的大小没有任何关系。停顿时间与 ZGC 接近。</li>
</ul>
<h2 id="4-GC-异常的判断"><a href="#4-GC-异常的判断" class="headerlink" title="4. GC 异常的判断"></a>4. GC 异常的判断</h2><h3 id="4-1-评价标准"><a href="#4-1-评价标准" class="headerlink" title="4.1. 评价标准"></a>4.1. 评价标准</h3><p>这里引用美团技术团队的文章，美团在生产实践中发现如下指标比较重要：</p>
<ul>
<li><strong>延迟（Latency）：</strong> 也可以理解为最大停顿时间，即垃圾收集过程中一次 STW 的最长时间，越短越好，一定程度上可以接受频次的增大，GC 技术的主要发展方向。</li>
<li><strong>吞吐量（Throughput）：</strong> 应用系统的生命周期内，由于 GC 线程会占用 Mutator 当前可用的 CPU 时钟周期，吞吐量即为 Mutator 有效花费的时间占系统总运行时间的百分比，例如系统运行了 100 min，GC 耗时 1 min，则系统吞吐量为 99%，吞吐量优先的收集器可以接受较长的停顿。</li>
</ul>
<p>目前各大互联网公司的系统基本都更追求低延时，避免一次 GC 停顿的时间过长对用户体验造成损失，衡量指标需要结合一下应用服务的 SLA，主要如下两点来判断：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175939344.png" alt="image-20231115175939344"></p>
<p>简而言之，即为**一次停顿的时间不超过应用服务的 TP9999，GC的吞吐量不小于 99.99%**。</p>
<blockquote>
<p>TP9999: 即 Top Percentile 99.99%，保证 99.99% 的网络服务可用的最低耗时</p>
</blockquote>
<p>举个例子，假设某个服务 A 的 TP9999 为 80 ms，平均 GC 停顿为 30 ms，那么该服务的最大停顿时间最好不要超过 80 ms，GC 频次控制在 5 min 以上一次。如果满足不了，那就需要调优或者通过更多资源来进行并联冗余。</p>
<p>备注：除了这两个指标之外还有 Footprint（资源量大小测量）、反应速度等指标，互联网这种实时系统追求低延迟，而很多嵌入式系统则追求 Footprint。</p>
<p>个人认为：作为时序数据库，IoTDB 追求低延时、异常可告警的需求和互联网公司系统这方面的需求大致吻合，因此可以将上述指标映射到 IoTDB 的 JVM GC 监控系统中作为参考。</p>
<h3 id="4-2-GC-Cause"><a href="#4-2-GC-Cause" class="headerlink" title="4.2. GC Cause"></a>4.2. GC Cause</h3><p>个人了解到，IoTDB 目前在某些实际环境有一些异常 GC，<strong>而要分析异常 GC，先要读懂 GC Cause</strong>，即 JVM 什么样的条件下选择进行 GC 操作，具体 Cause 的分类可以参考 Hotspot 源码：src&#x2F;share&#x2F;vm&#x2F;gc&#x2F;shared&#x2F;gcCause.hpp 和 src&#x2F;share&#x2F;vm&#x2F;gc&#x2F;shared&#x2F;gcCause.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GCCause::to_string</span><span class="params">(GCCause::Cause cause)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (cause) &#123;</span><br><span class="line">    <span class="keyword">case</span> _java_lang_system_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;System.gc()&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _full_gc_alot:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;FullGCAlot&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _scavenge_alot:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ScavengeAlot&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _allocation_profiler:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Allocation Profiler&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _jvmti_force_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;JvmtiEnv ForceGarbageCollection&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _gc_locker:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;GCLocker Initiated GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _heap_inspection:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Heap Inspection Initiated GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _heap_dump:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Heap Dump Initiated GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _wb_young_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;WhiteBox Initiated Young GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _update_allocation_context_stats_inc:</span><br><span class="line">    <span class="keyword">case</span> _update_allocation_context_stats_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Update Allocation Context Stats&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _no_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;No GC&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _allocation_failure:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Allocation Failure&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _tenured_generation_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Tenured Generation Full&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _metadata_GC_threshold:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Metadata GC Threshold&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_generation_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Generation Full&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_initial_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Initial Mark&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_final_remark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Final Remark&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_concurrent_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;CMS Concurrent Mark&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _old_generation_expanded_on_last_scavenge:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Old Generation Expanded On Last Scavenge&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _old_generation_too_full_to_scavenge:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Old Generation Too Full To Scavenge&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _adaptive_size_policy:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Ergonomics&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _g1_inc_collection_pause:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;G1 Evacuation Pause&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _g1_humongous_allocation:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;G1 Humongous Allocation&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _last_ditch_collection:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Last ditch collection&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _last_gc_cause:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ILLEGAL VALUE - last gc cause - ILLEGAL VALUE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;unknown GCCause&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ShouldNotReachHere</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>具体每种 Cause 的含义，可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lbh_paopao/article/details/120269135">https://blog.csdn.net/lbh_paopao/article/details/120269135</a></li>
</ul>
<p>对于以上 Cause，这里还是引用美团技术团队在业界实践的经验：</p>
<blockquote>
<p>重点需要关注的几个GC Cause：</p>
<ul>
<li><strong>System.gc()：</strong> 手动触发GC操作。</li>
<li><strong>CMS（如果使用的是 CMS 收集器的话）：</strong> CMS GC 在执行过程中的一些动作，重点关注 CMS Initial Mark 和 CMS Final Remark 两个 STW 阶段。</li>
<li><strong>Promotion Failure：</strong> Old 区没有足够的空间分配给 Young 区晋升的对象（即使总可用内存足够大，此处特指  CMS）。</li>
<li><strong>Concurrent</strong> <strong>Mode Failure（如果使用的是</strong> <strong>CMS</strong> <strong>收集器的话）：</strong> CMS GC 运行期间，Old 区预留的空间不足以分配给新的对象，此时收集器会发生退化，严重影响 GC 性能。</li>
<li><strong>GCLocker Initiated GC</strong>： 如果线程执行在 JNI 临界区时，刚好需要进行 GC，此时 GC Locker 将会阻止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。</li>
</ul>
</blockquote>
<h2 id="5-启示"><a href="#5-启示" class="headerlink" title="5. 启示"></a>5. 启示</h2><p>通过以上的基础调研，可以对 IoTDB JVM GC 监控系统的设计得出如下启示：</p>
<ol>
<li>收纳 <strong>延迟（Latency）和吞吐量（Throughput）</strong>作为 metric（可通过直接收集指标或间接计算得出），可以考虑使用 Timer 对每一个 GC Cause 记录 Duration，将 Cause 和 Duration 绑定起来一起记录，从而对 GC 异常分析有据可循。</li>
</ol>
<ul>
<li>期望大致效果如下：可以看到一段时间内应用 GC Cause 的集合以及 GC Duration 相关信息。</li>
</ul>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175800875.png" alt="image-20231115175800875"></p>
<ol>
<li>由于不同的 GC 收集器对内存的划分不同（对不同区域内存的行为也不同），因此需要针对不同 GC 收集器<strong>定制化 Memory usage 监控指标。</strong></li>
<li>某些 GC 收集器包含 concurrent phase（具体可以查看【10.其他】）。由于它们的 concurrent phase 并不 stw，导致 JMX 的 <strong>GcInfo.getDuration()</strong> 的<strong>实际值比应用程序的停止时间更长</strong>（因为它们把并发阶段也算进去了）。因此对于某些特殊收集器（如涉及到并行 GC），需要<strong>定制化指标计算方式，防止指标计算失准。</strong></li>
</ol>
<h2 id="6-现有监控工具及框架"><a href="#6-现有监控工具及框架" class="headerlink" title="6. 现有监控工具及框架"></a>6. 现有监控工具及框架</h2><p>功能大同小异，主要是使用体验上的差别，此处不赘述，仅罗列以扫盲。</p>
<h3 id="6-1-框架"><a href="#6-1-框架" class="headerlink" title="6.1. 框架"></a>6.1. 框架</h3><ul>
<li>集成框架（内置 JVM GC 监控模块）Micormeter、Dropwizard</li>
</ul>
<h3 id="6-2-命令行终端"><a href="#6-2-命令行终端" class="headerlink" title="6.2. 命令行终端"></a>6.2. 命令行终端</h3><ul>
<li>jps、jinfo、jstat、jstack、jmap、jcmd、arthas 等</li>
</ul>
<h3 id="6-3-可视化界面"><a href="#6-3-可视化界面" class="headerlink" title="6.3. 可视化界面"></a>6.3. 可视化界面</h3><ul>
<li>JConsole、GCHisto、GCViewer、JProfiler 等</li>
</ul>
<p>本文参考了以上项目关注的指标和设计方法。部分项目在 Github 有源码，感兴趣的读者可自行查阅。</p>
<h2 id="7-JMX-运行时指标收集工具"><a href="#7-JMX-运行时指标收集工具" class="headerlink" title="7. JMX - 运行时指标收集工具"></a>7. JMX - 运行时指标收集工具</h2><p>在实际的 Java 应用中，常常见到开发者通过添加 VM 参数<code>-XX:+PrintGC</code>、<code>-XX:+PrintHeapAtGC</code>等来获取 GC 相关信息。<strong>那么如何用代码的形式在运行时显式获取这些信息呢？</strong>答案是使用 <strong>JVM 提供的相应 api（JMX）。</strong></p>
<p>我们可以利用 JMX 提供的一些钩子函数，获得我们想要的信息，<strong>理论上来说，通过 JMX，我们可以自己手搓<code>-XX:+PrintGC</code>等的相关功能</strong>。接下来以 GC Info 为例，详细介绍一下 JMX 的相关概念和快速使用。</p>
<h3 id="7-1-什么是-JMX？"><a href="#7-1-什么是-JMX？" class="headerlink" title="7.1. 什么是 JMX？"></a>7.1. 什么是 JMX？</h3><blockquote>
<p>Java Management Extensions（<strong>JMX</strong>）技术是 Java SE 平台的标准功能，提供了一种简单的、标准的监控和管理资源的方式，对于如何定义一个资源给出了明确的结构和设计模式，主要用于监控和管理 Java 应用程序运行状态、设备和资源信息、Java 虚拟机运行情况等信息。 JMX 是可以动态的，所以也可以在资源创建、安装、实现时进行动态监控和管理，JDK 自带的 jconsole 就是使用 JMX 技术实现的监控工具。</p>
</blockquote>
<p>使用 JMX 技术时，通过定义一个被称为 <strong>MBean</strong> 或 <strong>MXBean</strong> 的 Java 对象来表示要管理指定的资源，然后可以把资源信息注册到 <strong>MBean Server</strong> 对外提供服务。MBean Server 充当了对外提供服务和对内管理 MBean 资源的代理功能，如此优雅的设计让 MBean 资源管理和 MBean Server 代理完全独立开，使之可以自由的控制 MBean 资源信息。</p>
<h3 id="7-2-资源管理-MBean"><a href="#7-2-资源管理-MBean" class="headerlink" title="7.2. 资源管理 MBean"></a>7.2. 资源管理 MBean</h3><p>在 JMX 中， 使用 <strong>MBean</strong> 或 <strong>MXBean</strong> 来表示一个资源（下面简称 MBean），访问和管理资源也都是通过 MBean，所以 MBean 往往包含着资源的<strong>属性和操作方法</strong>。</p>
<p>JMX 已经对 JVM 进行了多维度资源检测，所以可以轻松启动 JMX 代理来访问内置的 JVM 资源检测，从而通过 JMX 技术远程监控和管理 JVM。下表列出了一些 JMX 中的资源接口：</p>
<table>
<thead>
<tr>
<th><strong>资源接口</strong></th>
<th><strong>管理的资源</strong></th>
<th><strong>Object Name</strong></th>
<th><strong>VM</strong> <strong>中的实例个数</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ClassLoadingMXBean</td>
<td>类加载</td>
<td>java.lang:type&#x3D; ClassLoading</td>
<td>1个</td>
</tr>
<tr>
<td>CompilationMXBean</td>
<td>汇编系统</td>
<td>java.lang:type&#x3D; Compilation</td>
<td>0 个或1个</td>
</tr>
<tr>
<td><strong>GarbageCollectorMXBean</strong>（本文主要关注的）</td>
<td><em><strong>垃圾收集</strong></em></td>
<td><em><strong>java.lang:type&#x3D; GarbageCollector, name&#x3D;collectorName</strong></em></td>
<td><em><strong>1个或更多</strong></em></td>
</tr>
<tr>
<td>LoggingMXBean</td>
<td>日志系统</td>
<td>java.util.logging:type &#x3D;Logging</td>
<td>1个</td>
</tr>
<tr>
<td><strong>MemoryManagerMXBean</strong></td>
<td><strong>内存池</strong></td>
<td><strong>java.lang: typeMemoryManager, name&#x3D;managerName</strong></td>
<td><strong>1个或更多</strong></td>
</tr>
<tr>
<td><strong>MemoryPoolMXBean</strong></td>
<td><strong>内存</strong></td>
<td><strong>java.lang: type&#x3D; MemoryPool, name&#x3D;poolName</strong></td>
<td><strong>1个或更多</strong></td>
</tr>
<tr>
<td><strong>MemoryMXBean</strong></td>
<td><strong>内存系统</strong></td>
<td><strong>java.lang:type&#x3D; Memory</strong></td>
<td><strong>1个</strong></td>
</tr>
<tr>
<td>OperatingSystemMXBean</td>
<td>操作系统</td>
<td>java.lang:type&#x3D; OperatingSystem</td>
<td>1个</td>
</tr>
<tr>
<td>RuntimeMXBean</td>
<td>运行时系统</td>
<td>java.lang:type&#x3D; Runtime</td>
<td>1个</td>
</tr>
<tr>
<td>hreadMXBean</td>
<td>线程系统</td>
<td>java.lang:type&#x3D; Threading</td>
<td>1个</td>
</tr>
</tbody></table>
<h3 id="7-2-JMX-的具体使用"><a href="#7-2-JMX-的具体使用" class="headerlink" title="7.2. JMX 的具体使用"></a>7.2. JMX 的具体使用</h3><ol>
<li>根据上面的信息，我们可以根据 JMX 内置的 MBean 获取系统信息，<strong>本文的</strong> <strong>JVM</strong> <strong>GC</strong> <strong>监控使用了此方法。</strong></li>
</ol>
<p>实例：获得<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">堆内存</a>和非堆内存的大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">monitorMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Memory:&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="type">MemoryMXBean</span> <span class="variable">mmbean</span> <span class="operator">=</span> ManagementFactory.getMemoryMXBean();</span><br><span class="line">        <span class="type">MemoryUsage</span> <span class="variable">hmu</span> <span class="operator">=</span> mmbean.getHeapMemoryUsage();</span><br><span class="line">        sb.append(<span class="string">&quot;[HeapMemoryUsage:&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot; Used=&quot;</span> + formatBytes(hmu.getUsed()));</span><br><span class="line">        sb.append(<span class="string">&quot; Committed=&quot;</span> + formatBytes(hmu.getCommitted()));</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">MemoryUsage</span> <span class="variable">nhmu</span> <span class="operator">=</span> mmbean.getNonHeapMemoryUsage();</span><br><span class="line">        sb.append(<span class="string">&quot;[NonHeapMemoryUsage:&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot; Used=&quot;</span> + formatBytes(nhmu.getUsed()));</span><br><span class="line">        sb.append(<span class="string">&quot; Committed=&quot;</span> + formatBytes(nhmu.getCommitted()));</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们甚至可以自己按需写一个 MBean 注册到 JMX 中，以供外部使用。<strong>（实际上在 IoTDB 中经常能够见到这样的应用）</strong></li>
</ul>
<p>MBean 的编写必须遵守 JMX 的设计规范，MBean 很像一个特殊的 Java Bean，它需要一个接口和一个实现类。MBean 资源接口总是以 MBean 或者 MXBean 结尾，实现类则要以接口去掉 MBean 或 MXBean 之后的名字来命名。</p>
<p>MBean 资源需要注册到 MBean Server 进行代理才可以暴露给外部进行调用，所以我们想要通过远程管理我们自定义的 MyMemory 资源，需要先进行资源代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 MBean Server</span></span><br><span class="line"><span class="type">MBeanServer</span> <span class="variable">platformMBeanServer</span> <span class="operator">=</span> ManagementFactory.getPlatformMBeanServer();</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="type">ObjectName</span> <span class="variable">objectName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectName</span>(MBeanName);</span><br><span class="line">platformMBeanServer.registerMBean(your_mbean, objectName);</span><br></pre></td></tr></table></figure>

<h4 id="7-3-1-监听器模式——Notification"><a href="#7-3-1-监听器模式——Notification" class="headerlink" title="7.3.1. 监听器模式——Notification"></a>7.3.1. 监听器模式——Notification</h4><p>JMX API 定义了一种机制，使得 MBeans 能够生成通知 Notification，比如通知一个状态改变、一个检测到的事件或者问题，系统状态，GC 事件。通知的作用是主动通知远程客户端。例如程序出现异常，CPU使用率过高，出现了死锁等。这时程序能事件触发主动发送给远程客户端，将这些问题记录下来，或者执行一些其他的报警操作。<strong>本文的</strong> <strong>JVM</strong> <strong>GC 监控使用了此方法。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javax.management.Notification</span><br><span class="line">public class NotificationBroadcasterSupport implements NotificationEmitter &#123;</span><br><span class="line">    ...</span><br><span class="line">    public MBeanNotificationInfo[] getNotificationInfo()&#123;...&#125;</span><br><span class="line">    public void sendNotification(Notification notification)&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个 MBean 生成通知必须实现接口 <code>NotificationEmitter</code> 或者扩展 <code>NotificationBroadcasterSupport</code></li>
<li>Notification 监听器必须实现 <code>NotificationListener</code> 接口</li>
</ul>
<p>其中，本文重点关注 GC 相关的 Info，通过阅读源码得知 **<code>GarbageCollectionNotificationInfo</code>**（ notification）的数据结构如下：</p>
<table>
<thead>
<tr>
<th><strong>属性名</strong></th>
<th><strong>类型</strong></th>
<th><strong>注释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>gcName</td>
<td>java.lang.String</td>
<td>如: G1 Old Generation,G1 Young Generation等</td>
</tr>
<tr>
<td>gcAction</td>
<td>java.lang.String</td>
<td>标识是哪个 gc 动作，一般为：end of major GC，end of minor GC 等，分别表示老年代和新生代的 gc 结束。</td>
</tr>
<tr>
<td>gcCause</td>
<td>java.lang.String</td>
<td>引起 gc 的原因,如：System.gc()，Allocation Failure，G1 Humongous Allocation等</td>
</tr>
<tr>
<td>gcInfo</td>
<td>javax.management.openmbean.CompositeData</td>
<td>gc 的详细信息，见下表</td>
</tr>
</tbody></table>
<p>通过阅读 openjdk 官网手册和源码，我们可以得知 <strong><code>GCInfo</code></strong> 详细信息如下：</p>
<table>
<thead>
<tr>
<th><strong>属性名</strong></th>
<th><strong>类型</strong></th>
<th><strong>注释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>java.lang.Long</td>
<td>标识这个收集器进行了几次 gc（垃圾回收事件的 ID）</td>
</tr>
<tr>
<td>startTime</td>
<td>java.lang.Long</td>
<td>gc 的开始时间</td>
</tr>
<tr>
<td>endTime</td>
<td>java.lang.Long</td>
<td>gc 的结束时间</td>
</tr>
<tr>
<td>memoryUsageBeforeGc</td>
<td>javax.management.openmbean.TabularData</td>
<td>gc 前内存情况</td>
</tr>
<tr>
<td>memoryUsageAfterGc</td>
<td>javax.management.openmbean.TabularData</td>
<td>gc 后内存情况</td>
</tr>
</tbody></table>
<p>以 GC 为例，最简单的 <code>NotificationListener</code> 使用如下：</p>
<ul>
<li>该程序实现了：当发生 GC 时，自动读取 GC 时间、GC 原因、相关内存池前后使用情况等相关信息（见 <code>map</code> 变量）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GarbageNotificationListener</span> <span class="keyword">implements</span> <span class="title class_">NotificationListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNotification</span><span class="params">(Notification notification, Object handback)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">notifType</span> <span class="operator">=</span> notification.getType();</span><br><span class="line">        <span class="keyword">if</span> (notifType.equals(GarbageCollectionNotificationInfo.GARBAGE_COLLECTION_NOTIFICATION)) &#123;</span><br><span class="line">            <span class="type">CompositeData</span> <span class="variable">cd</span> <span class="operator">=</span> (CompositeData) notification.getUserData();</span><br><span class="line">            <span class="type">GarbageCollectionNotificationInfo</span> <span class="variable">info</span> <span class="operator">=</span> GarbageCollectionNotificationInfo.from(cd);</span><br><span class="line">            <span class="type">GcInfo</span> <span class="variable">gcInfo</span> <span class="operator">=</span> info.getGcInfo();</span><br><span class="line">            HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;duration&quot;</span>, gcInfo.getDuration());</span><br><span class="line">            map.put(<span class="string">&quot;id&quot;</span>, gcInfo.getId());</span><br><span class="line">            map.put(<span class="string">&quot;UsageAfterGc&quot;</span>, gcInfo.getMemoryUsageAfterGc());</span><br><span class="line">            map.put(<span class="string">&quot;UsageBeforeGc&quot;</span>, gcInfo.getMemoryUsageBeforeGc());</span><br><span class="line">            map.put(<span class="string">&quot;GcAction&quot;</span>, info.getGcAction());</span><br><span class="line">            map.put(<span class="string">&quot;GcCause&quot;</span>, info.getGcCause());</span><br><span class="line">            map.put(<span class="string">&quot;GcName&quot;</span>, info.getGcName());</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-监控方案设计"><a href="#8-监控方案设计" class="headerlink" title="8. 监控方案设计"></a>8. 监控方案设计</h2><h3 id="8-1-push-base"><a href="#8-1-push-base" class="headerlink" title="8.1. push base"></a>8.1. push base</h3><blockquote>
<p>参考：org.apache.cassandra.service.GCInspector、<em>io.micrometer.core.instrument.binder.jvm.JvmGcMetrics</em></p>
<p>IoTDB 实现类：</p>
<ul>
<li>org.apache.iotdb.metrics.metricsets.jvm.JvmGcMetrics</li>
</ul>
</blockquote>
<p><strong>思路：</strong>利用 JMX 的 notification 机制，实现一个 Listener 对 GC 进行监听。每次 JVM 发生 GC 时，接受 JVM 主动发送的 GcInfo，从中解析出相应的信息（具体查看【9. 监控指标设计】）</p>
<p><strong>核心方法：</strong>可查看源码，此处不再赘述</p>
<p><strong>注意点：</strong></p>
<ul>
<li>包含并发过程 GC 的 duration 需要采用特别的计算方式，因为 GcInfo.getDuration() 得到的 duration 比实际 stw 的时间长（把并发标记的时间也算上去了）</li>
<li>一些 GC 如 G1 会在 minor GC 时减小 old gen memory 的 size，需要对其进行追踪</li>
<li>需要对非代际 GC 和 分代 GC 分别监控</li>
</ul>
<p><strong>与 IoTDB 整合的实现效果：</strong></p>
<div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175714192.png" alt="image-20231115175714192" style="zoom:50%;" /></div>

<h3 id="8-2-pull-base"><a href="#8-2-pull-base" class="headerlink" title="8.2. pull base"></a>8.2. pull base</h3><blockquote>
<p>参考：org.apache.hadoop.util.GcTimeMonitor</p>
<p>IoTDB 实现类：</p>
<ul>
<li>org.apache.iotdb.commons.service.metric.JvmGcMetrics </li>
<li>org.apache.iotdb.commons.service.metric.GcTimeAlerter</li>
</ul>
</blockquote>
<p><strong>思路：</strong>在<strong>设定好的频率</strong>下，不断 pull JMX 中的 GC 信息。该 metric 类将监视 JVM 在指定观察窗口（例如1分钟）内的 GC 暂停时间的百分比。用户可以<strong>提供一个钩子</strong>（hook），当这个百分比超过<strong>指定的阈值</strong>（例如 70%）时，将会调用该钩子进行告警、处理等操作。</p>
<p><strong>核心方法：</strong><code>calculateGCTimePercentageWithinObservedInterval()</code> 在设定好的频率下不停运行。假设调用该方法的时刻是 <code>startTs</code>，那么该方法将计算 [<code>startTs</code> - <code>observerWindowMs</code>，<code>startTs</code>] 时间窗口下的 <code>GcTime</code>、<code>GcCount</code></p>
<ul>
<li>方法内部：统计所有 collector 的 <code>GcTime</code> 和 <code>GcCount</code>，并将该次统计信息保存到一个循环缓冲区里，并更新该缓冲区的开始和结束索引以跟踪最早和最新的 GC 暂停时间戳。<ul>
<li>注意从最早的时间戳开始累加 GcTime 时，需要考虑 <code>startTs</code> - <code>observerWindowMs</code> <strong>之前</strong>发生并延续到[<code>startTs</code> - <code>observerWindowMs</code>，<code>startTs</code>] 时间窗口下的 GC。这时我们只需要统计该时间窗口下的 Gc，<strong>舍弃</strong><code>startTs</code> - <code>observerWindowMs</code> 之前的 GC 时间。</li>
</ul>
</li>
</ul>
<p><strong>告警处理：</strong>当在指定观察窗口内的 GC 暂停时间百分比超过指定的阈值（例如 70%）时，将会调用<code>org.apache.iotdb.commons.service.metric.GcTimeAlerter</code>进行告警、处理等操作。用户可以在此部分自定义代码，比如打日志、清理内存等。（目前只实现了简单的 <code>logger.warn()</code> 告警功能，如下图）</p>
<blockquote>
<p><strong>目前实现的 Alerter 效果：</strong></p>
<ul>
<li>打印当前异常时间</li>
<li>打印当前时间窗口内，GC 时间所占比例（类似吞吐量）</li>
<li>打印当前时间窗口内，累计 GC 时间</li>
<li>打印当前时间窗口的起始时间</li>
<li>打印当前时间窗口的时长（默认为 1 分钟，如果 IoTDB 启动还没满 1 分钟，那么该值为 IoTDB 的累计运行时间）</li>
</ul>
</blockquote>
<p><strong>与 IoTDB 整合的实现效果：</strong></p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175656708.png" alt="image-20231115175656708"></p>
<h3 id="8-3-测试方法"><a href="#8-3-测试方法" class="headerlink" title="8.3. 测试方法"></a>8.3. 测试方法</h3><p>IDEA 3c3d（3个 ConfigNode、3个 DataNode） 环境下，在 IoTDB ConfigNode 和 DataNode 启动时开启一个添加内存的线程，并可以按需 System.gc()。通过观察日志和 <code>curl localhost:9091/metrics</code> 观察指标。以 IoTDB ConfigNode 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  LOGGER.info(</span><br><span class="line">      <span class="string">&quot;&#123;&#125; environment variables: &#123;&#125;&quot;</span>,</span><br><span class="line">      ConfigNodeConstant.GLOBAL_NAME,</span><br><span class="line">      ConfigNodeConfig.getEnvironmentVariables());</span><br><span class="line">  LOGGER.info(</span><br><span class="line">      <span class="string">&quot;&#123;&#125; default charset is: &#123;&#125;&quot;</span>,</span><br><span class="line">      ConfigNodeConstant.GLOBAL_NAME,</span><br><span class="line">      Charset.defaultCharset().displayName());</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ConfigNodeCommandLine</span>().doMain(args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">          () -&gt; &#123;</span><br><span class="line">            List&lt;<span class="type">byte</span>[]&gt; byteList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">              <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">              byteList.add(bytes);</span><br><span class="line">              <span class="comment">// 可以手动 GC，也可以让系统自动 GC 直至 heap overflow</span></span><br><span class="line"><span class="comment">//              if (i % 10 == 0) &#123;</span></span><br><span class="line"><span class="comment">//                System.gc();</span></span><br><span class="line"><span class="comment">//              &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      .start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-监控指标设计"><a href="#9-监控指标设计" class="headerlink" title="9. 监控指标设计"></a>9. 监控指标设计</h2><h3 id="9-1-push-base"><a href="#9-1-push-base" class="headerlink" title="9.1. push base"></a>9.1. push base</h3><table>
<thead>
<tr>
<th><strong>metric</strong></th>
<th><strong>Type</strong></th>
<th><strong>Monitor Approach</strong></th>
<th><strong>Tips</strong></th>
</tr>
</thead>
<tbody><tr>
<td>jvm_gc_max_data_size_bytes</td>
<td>AutoGauge</td>
<td>JMX</td>
<td>长生命周期内存池 (old gen &amp; perm gen(Metaspace)  最大内存大小</td>
</tr>
<tr>
<td>jvm_gc_live_data_size_bytes</td>
<td>AutoGauge</td>
<td>notification update</td>
<td>长生命周期内存池已使用大小</td>
</tr>
<tr>
<td>jvm_gc_young_memory_allocated_bytes</td>
<td>Counter</td>
<td>notification update</td>
<td>年轻代内存池已分配对象大小</td>
</tr>
<tr>
<td>jvm_gc_old_memory_allocated_bytes</td>
<td>Counter</td>
<td>notification update</td>
<td>年老代内存池直接分配的对象大小（不包括晋升的对象）</td>
</tr>
<tr>
<td>jvm_gc_non_gen_memory_allocated_bytes</td>
<td>Counter</td>
<td>notification update</td>
<td>非代际内存池已分配的对象大小</td>
</tr>
<tr>
<td>jvm_gc_memory_promoted_bytes</td>
<td>Counter</td>
<td>notification update</td>
<td>移动到 old gen 的对象大小</td>
</tr>
<tr>
<td>jvm_gc_pause</td>
<td>Timer</td>
<td>notification update</td>
<td>具体 GC cause 下的 GC 暂停时间<strong>（将不同</strong> <strong>GC</strong> <strong>的 cause 跟每次 GC 的 duration 绑定，Timer 还可以统计各 cause 的频率）</strong></td>
</tr>
<tr>
<td>jvm_zgc_pauses_count</td>
<td>Counter</td>
<td>notification update</td>
<td><strong>ZGC</strong> pauses 的次数</td>
</tr>
<tr>
<td>jvm_zgc_cycles_count</td>
<td>Counter</td>
<td>notification update</td>
<td><strong>ZGC</strong> circles 的次数</td>
</tr>
</tbody></table>
<h3 id="9-2-pull-base"><a href="#9-2-pull-base" class="headerlink" title="9.2. pull base"></a>9.2. pull base</h3><table>
<thead>
<tr>
<th><strong>metric</strong></th>
<th><strong>Type</strong></th>
<th><strong>Monitor Approach</strong></th>
<th><strong>Tips</strong></th>
</tr>
</thead>
<tbody><tr>
<td>jvm_gc_accumulated_time</td>
<td>Alerter 日志打印</td>
<td>JMX + 累加计算</td>
<td>在指定时间窗口内，GC 总时间，单位毫秒<strong>，支持 ZGC</strong></td>
</tr>
<tr>
<td>observation_window_start_time</td>
<td>Alerter 日志打印</td>
<td>计算</td>
<td>指定时间窗口的起始时间</td>
</tr>
<tr>
<td>observation_window_end_time</td>
<td>Alerter 日志打印</td>
<td>计算</td>
<td>指定时间窗口的结束时间</td>
</tr>
<tr>
<td>observation_window_time</td>
<td>Alerter 日志打印</td>
<td>计算</td>
<td>指定时间窗口的总时长，默认为 1 min。如果 IoTDB 启动还没满 1 分钟，那么该值为 IoTDB 的累计运行时间</td>
</tr>
<tr>
<td>jvm_gc_accumulated_time_percentage</td>
<td>AutoGauge</td>
<td>jvm_gc_accumulated_time &#x2F; total_time</td>
<td>在指定时间窗口内，GC 时间所占的比例（类似吞吐量的概念）。若超过 threshold，进行告警<strong>（可选）</strong></td>
</tr>
</tbody></table>
<h2 id="10-其他"><a href="#10-其他" class="headerlink" title="10. 其他"></a>10. 其他</h2><p>在实际场景中，<strong>G1 和</strong> <strong>CMS</strong> <strong>使用的较多</strong>，而 <strong>ZGC 作为内存不分代的新型垃圾回收器代表</strong>，也有必要被研究。尽管这些算法的具体执行细节难以监控追踪，但我们仍可以了解它们。这里做一个简单整理，更深入可以阅读资料或者查看 hotspot 源码。</p>
<h3 id="10-1-CMS-经久不衰的常用回收器"><a href="#10-1-CMS-经久不衰的常用回收器" class="headerlink" title="10.1. CMS - 经久不衰的常用回收器"></a>10.1. CMS - 经久不衰的常用回收器</h3><blockquote>
<p>CMS（Concurrent Mark Sweep）垃圾回收器是第一个关注 GC 停顿时间的垃圾收集器。 在这之前的垃圾回收器，要么就是串行垃圾回收方式，要么就是关注系统吞吐量。这样的垃圾回收器对于强交互的程序很不友好，而 CMS 垃圾回收器的出现，则打破了这个尴尬的局面。因此，CMS 垃圾回收器诞生之后就受到了大家的欢迎，导致现在还有非常多的应用还在继续使用它。</p>
</blockquote>
<p>CMS 垃圾回收器之所以能够实现对 GC 停顿时间的控制，其本质来源于对「根可达算法」的改进，即三色标记算法。在 CMS 垃圾回收器出现之前，无论是 Serious 垃圾回收器，还是 ParNew 垃圾回收器，亦或是 Parallel Scavenge 垃圾回收器，他们在进行垃圾回收的时候都需要 Stop the World，即无法实现垃圾回收线程与用户线程并发执行。而 CMS 垃圾回收器通过<strong>三色标记算法，</strong>实现了垃圾回收线程<strong>与用户线程并发执行</strong>，从而极大地降低了系统响应时间，提高了强交互应用程序的体验。</p>
<h4 id="10-1-1-三色标记算法"><a href="#10-1-1-三色标记算法" class="headerlink" title="10.1.1. 三色标记算法"></a>10.1.1. 三色标记算法</h4><p>三色标记法将对象的颜色分为了黑、灰、白，三种颜色。</p>
<p>「白色」：该对象没有被标记过。（对象垃圾）</p>
<p>「灰色」：该对象已经被标记过了，但该对象下的属性没有全被标记完。（GC 需要从此对象中去寻找垃圾）</p>
<p>「黑色」：该对象已经被标记过了，且该对象下的属性也全部都被标记过了。（程序所需要的对象）</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175630425.png" alt="image-20231115175630425"></p>
<h5 id="10-1-2-算法流程"><a href="#10-1-2-算法流程" class="headerlink" title="10.1.2. 算法流程"></a>10.1.2. 算法流程</h5><p>从 GC Root 开始沿着他们的对象向下查找，用黑灰白的规则，标记出所有跟 GC Root 相连接的对象，扫描一遍结束后，一般需要进行一次短暂的 STW，再次进行扫描，此时因为黑色对象的属性都也已经被标记过了，所以只需找出灰色对象并顺着继续往下标记（且因为大部分的标记工作已经在第一次并发的时候发生了，所以灰色对象数量会很少，标记时间也会短很多）, 此时程序继续执行，GC 线程扫描所有的内存，找出扫描之后依旧被标记为白色的对象（垃圾）并清除。具体流程如下</p>
<ol>
<li>首先创建三个集合：白、灰、黑。</li>
<li>将所有对象放入白色集合中。</li>
<li>然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入灰色集合。</li>
<li>之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</li>
<li>重复 4 直到灰色中无任何对象</li>
<li>通过 write-barrier 检测对象有变化，重复以上操作</li>
<li>收集所有白色对象（垃圾）</li>
</ol>
<h5 id="10-1-3-存在问题"><a href="#10-1-3-存在问题" class="headerlink" title="10.1.3. 存在问题"></a>10.1.3. 存在问题</h5><ol>
<li><strong>浮动垃圾</strong>：并发标记的过程中，若一个已经被标记成黑色或者灰色的对象，突然变成了垃圾，由于不会再对黑色标记过的对象重新扫描，所以不会被发现，那么这个对象不是白色的但是不会被清除，重新标记也不能从 GC Root 中去找到，所以成为了浮动垃圾，「浮动垃圾对系统的影响不大，留给下一次 GC 进行处理即可」。</li>
<li><strong>对象漏标问题（需要的对象被回收）</strong>：并发标记的过程中，一个业务线程将一个未被扫描过的白色对象断开引用成为垃圾（删除引用），同时黑色对象引用了该对象（增加引用）（这两部可以不分先后顺序）；因为黑色对象的含义为其属性都已经被标记过了，重新标记也不会从黑色对象中去找，导致该对象被程序所需要，却又要被 GC 回收，此问题会导致系统出现问题，对此「CMS 对增加引用环节进行处理（Increment Update），G1 则对删除引用环节进行处理 (SATB)（这里不做详细介绍，可以自行查阅）」</li>
</ol>
<h4 id="10-1-2-与用户线程并发执行-GC"><a href="#10-1-2-与用户线程并发执行-GC" class="headerlink" title="10.1.2. 与用户线程并发执行 GC"></a>10.1.2. 与用户线程并发执行 GC</h4><p><strong>主要</strong>分为4个阶段（注意，该部分在 G1 回收器中也能窥见思想和相似应用）</p>
<ul>
<li><strong>初始标记（CMS initial mark）</strong>，指的是寻找所有被 GCRoots 引用的对象，该阶段需要「Stop the World」。 这个步骤仅仅只是标记一下 GC Roots 能直接关联到的对象，并不需要做整个引用的扫描，因此速度很快。</li>
</ul>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175606653.png" alt="image-20231115175606653"></p>
<ul>
<li><strong>并发标记（CMS concurrent mark）</strong>，指的是对「初始标记阶段」标记的对象进行整个引用链的扫描，该阶段不需要「Stop the World」。 对整个引用链做扫描需要花费非常多的时间，因此通过垃圾回收线程与用户线程并发执行，可以降低垃圾回收的时间，从而降低系统响应时间。但这也带来了一些问题，即：并发标记的时候，引用可能发生变化，因此可能发生漏标（本应该被标记的对象，没有被正确地标记颜色，导致不应该回收的对象被回收）和多标（本不该被标记的对象，被错误地标记颜色，导致应该被回收的对象没有被回收）了。</li>
</ul>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175554390.png" alt="image-20231115175554390"></p>
<ul>
<li><strong>重新标记（CMS remark）</strong>，指的是对「并发标记」阶段出现的问题进行校正，该阶段需要「Stop the World」。 正如并发标记阶段说到的，由于垃圾回收算法和用户线程并发执行，虽然能降低响应时间，但是会发生漏标和多标的问题。所以对于 CMS 回收器来说，它需要这个阶段来做一些校验，解决并发标记阶段发生的问题。</li>
<li><strong>并发清除（CMS concurrent sweep）</strong>，指的是将标记为垃圾的对象进行清除，该阶段不需要「Stop the World」。 在这个阶段，垃圾回收线程与用户线程可以并发执行，因此并不影响用户的响应时间。</li>
</ul>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175542197.png" alt="image-20231115175542197"></p>
<p>从上面的描述步骤中我们可以看出：CMS 之所以能极大地降低 GC 停顿时间，本质上是将原本冗长的引用链扫描进行切分。通过 GC 线程与用户线程并发执行，加上重新标记校正的方式，减少了垃圾回收的时间。</p>
<h3 id="10-2-G1-CMS-的替代者-Java-9-默认回收器"><a href="#10-2-G1-CMS-的替代者-Java-9-默认回收器" class="headerlink" title="10.2. G1 - CMS 的替代者 | Java 9 默认回收器"></a>10.2. G1 - CMS 的替代者 | Java 9 默认回收器</h3><h4 id="10-2-1-内存模型"><a href="#10-2-1-内存模型" class="headerlink" title="10.2.1. 内存模型"></a>10.2.1. 内存模型</h4><p>传统的 GC 收集器将连续的内存空间划分为新生代、老年代和永久代（JDK8 去除了永久代，引入了元空间 Metaspace），这种划分的特点是各代的存储地址（逻辑地址，下同）是连续的。如下图所示：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175528545.png" alt="image-20231115175528545"></p>
<p>而G1的各代存储地址是<strong>不连续的</strong>，每一代都使用了 n 个不连续的<strong>大小相同</strong>的 Region，每个 Region 占有一块连续的虚拟内存地址（<strong>但内存仍是分代际的，只是分散在不连续的 Region 中</strong>）。如下图所示：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175518344.png" alt="image-20231115175518344"></p>
<p>这里为了帮助理解，再贴一张 CMS（传统收集器） 和 G1 的内存分布图：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175504522.png" alt="image-20231115175504522"></p>
<p>在上面的图中，注意到还有一些 Region 标明了 H，它代表 Humongous，这表示这些 Region 存储的是巨大对象（humongous object，H-obj），即大小 ≥ region 一半的对象。H-obj 有如下几个特征：</p>
<ul>
<li>H-obj 直接分配到了 old gen，防止了反复拷贝移动。</li>
<li>H-obj 在 global concurrent marking 阶段的 cleanup 和 full GC 阶段回收。</li>
<li>在分配 H-obj 之前先检查是否超过 initiating heap occupancy percent 和 the marking threshold（G1 的相关参数，可通过 VM 参数设定）, 如果超过的话，就启动 global concurrent marking，为的是提早回收，防止 evacuation failures 和 full GC。</li>
</ul>
<blockquote>
<p>为了减少连续 H-objs 分配对 GC 的影响，需要把大对象变为普通的对象，建议增大 Region size。</p>
</blockquote>
<p>一个 Region 的大小可以通过参数<code> -XX:G1HeapRegionSize</code> 设定，取值范围从 1M 到 32M，且是2的指数。如果不设定，那么 G1 会根据 Heap 大小自动决定</p>
<p>每一个分配的 Region，都可以分成两个部分，已分配的和未被分配的。它们之间的界限被称为 top。总体上来说，把一个对象分配到 Region 内，只需要简单增加 top 的值。这个做法实际上就是 bump-the-pointer。过程如下：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175448522.png" alt="image-20231115175448522"></p>
<p>Region 可以说是 G1 回收器一次回收的最小单元。即每一次回收都是回收 N 个 Region。这个 N 是多少，主要受到 G1 回收的效率和用户设置的<strong>软实时目标</strong><em>（用户可以指定<strong>垃圾回收</strong>时间的限时，G1会努力在这个时限内完成垃圾回收，但是G1并不担保每次都能在这个时限内完成垃圾回收。通过设定一个合理的目标，可以让达到90%以上的垃圾回收时间都在这个时限内。）</em>有关。每一次的回收，G1 会选择可能回收最多垃圾的 Region 进行回收。与此同时，G1 回收器会维护一个空间 Region 的链表。每次回收之后的 Region 都会被加入到这个链表中。</p>
<h4 id="10-2-2-GC-模式"><a href="#10-2-2-GC-模式" class="headerlink" title="10.2.2. GC 模式"></a>10.2.2. GC 模式</h4><p>G1提供了两种GC模式，<strong>Young GC</strong> 和 <strong>Mixed GC</strong>，两种都是完全 Stop The World 的，下面依次简单介绍：</p>
<blockquote>
<p>补充论据：为什么 Young GC 和 Mixed GC 都是 stw 的？</p>
<p><strong>结论：几乎所有收集器的所有回收策略（Young、Mixed、Full）都会 stw，只是停顿时间不同。</strong></p>
<ol>
<li>什么情况&#x2F;操作会 STW<ol>
<li>以 G1 为例。引用《深入理解 Java 虚拟机》，G1 的运行过程有4个步骤：<ul>
<li>初始标记：标记 GC Roots 的可达对象以及其他一些指针修改操作。<strong>GC Roots 的对象扫描操作是 stw 的，尽管停顿时间很短。</strong>因为如果与用户线程并行，会存在漏扫、错扫等问题</li>
<li>并发标记，不 stw</li>
<li>最终标记：<strong>很显然是 stw 的</strong>，因为是为了修正并发标记时可能发生的漏标错标问题，所以必须暂停用户线程以保证正确性。</li>
<li>筛选回收：负责更新 Region 的统计数据，制定回收计划。可以自由的选择任意多个 Region 构成回收集，然后把决定回收的那部分 Region 复制到空的 Region 中，再清理掉整个旧 Region 的空间（即标记-复制算法）。<strong>由于操作涉及存活对象的移动，必须 stw。</strong></li>
</ul>
</li>
<li>让我们把粒度再变细一点，在 GC 操作中，以下情况会 stw：<ul>
<li><strong>根节点枚举</strong>。因为必须 Root scan 必须在一个能保障一致性的快照中才能得以进行，否则无法保证正确性，尽管现在可达性分析算法中的查找引用链过程已经能够做到和用户线程并发。</li>
<li><strong>存活对象的移动</strong>。常发生在标记-复制、标记-整理算法的对象清理过程中</li>
</ul>
</li>
</ol>
</li>
<li>Young GC、Mixed GC、Full GC 过程中发生了什么？<ol>
<li>GC 无论是发生在哪个区域（哪个 region），基本过程都类似，都需要有<strong>扫描和标记的环节（如枚举根节点）</strong>来找出需要被回收&#x2F;复制的对象，如果涉及标记-整理算法，如 Full GC ，还需要整理内存。<strong>这些环节都需要 stw 来保证正确性。</strong>所以我们说所有种类的 GC 都 stw<strong>，</strong>只是 stw 的时间不同。</li>
</ol>
</li>
<li>验证论据<ol>
<li><p>提出 G1 的论文：<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/abs/10.1145/1029873.1029879">Garbage-first garbage collection | Proceedings of the 4th international symposium on Memory manageme</a></p>
<ul>
<li>文中 section 3.4 提到：In <strong>fully-young generational mode</strong>, we maintain a dynamic estimate of the number of young-generation regions that <strong>leads to an evacuation pause</strong> that meets the pause time bound, and initiate a pause whenever this number of young regions is allocated. For steady-state applications, this leads to a natural period between evacuation pauses. Note that we can meet the soft real-time goal only if this period exceeds its time slice. <strong>In partially-young mode</strong>, on the other hand, <strong>we do evacuation pauses</strong> as often as the soft real-time goal allows. Doing pauses at the maximum allowed frequency minimizes the number of young regions collected in those pauses, and therefore maximizes the number of non-young regions that may be added to the collection set.</li>
<li>具体的论述与 GC 的停顿时间预测有关，此处不展开赘述。但我们可以从作者的论述看出：Young GC 和 Mixed GC 都会有 <strong>evacuation pauses。</strong></li>
<li>那么什么是 evacuation pause 呢？论文的 section 2.4 给出了定义：At appropriate points (described in section 3.4), <strong>we stop the mutator threads and perform an evacuation pause.</strong></li>
<li>由此可以感性的认知：G1 的 young GC 和 mixed GC 是会 stw 的。</li>
</ul>
</li>
<li><p>源码：G1 触发 Young GC 后，会执行一个叫 do_collection_pause 的方法，方法签名如下：</p>
</li>
<li><pre><code class="C++">HeapWord* G1CollectedHeap::do_collection_pause(size_t word_size,
                                               unsigned int gc_count_before,
                                               bool* succeeded,
                                               GCCause::Cause gc_cause) &#123;
  // 记录 gc 停顿
  g1_policy()-&gt;record_stop_world_start();
  // gc 操作任务类,第三个参数表示本次 gc 是不是老年代并发 gc
  VM_G1IncCollectionPause op(gc_count_before,
                             word_size,
                             false, /* should_initiate_conc_mark */
                             g1_policy()-&gt;max_pause_time_ms(),
                             gc_cause);
  // 真正的停顿方法在 VMThread::execute(&amp;op) 中
  VMThread::execute(&amp;op);
                                                
  HeapWord* result = op.result();
  bool ret_succeeded = op.prologue_succeeded() &amp;&amp; op.pause_succeeded();
                                                
  *succeeded = ret_succeeded;
                                                
  return result;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. do_collection_pause 会在 VMThread::execute(&amp;op) 里会产生停顿，再来看这个方法：</span><br><span class="line">5. ```C++</span><br><span class="line">   void VMThread::execute(VM_Operation* op) &#123;</span><br><span class="line">     Thread* t = Thread::current();</span><br><span class="line">     // 判断当前线程是否是 vm 线程</span><br><span class="line">     if (!t-&gt;is_VM_thread()) &#123;</span><br><span class="line">       // 跳过这里，其实这里的逻辑是当前不是 vm 线程是 java 线程或者 watcher 线程</span><br><span class="line">       // 会先将任务放到一个 queue 中，之后再执行</span><br><span class="line">       ......</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       // 如果是 vm 线程则会进入这里</span><br><span class="line">       ......</span><br><span class="line">       HandleMark hm(t);</span><br><span class="line">       _cur_vm_operation = op;</span><br><span class="line">       // 判断任务是否需要在安全点执行且当前是否在安全点</span><br><span class="line">       if (op-&gt;evaluate_at_safepoint() &amp;&amp; !SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">         // 如果不是安全点,则等待所有线程进入安全点,然后把线程暂时挂起</span><br><span class="line">         // 这个类中有个状态 _state,所有 java 线程转换线程状态时会去判断这个状态然后</span><br><span class="line">         // 决定是否 block</span><br><span class="line">         SafepointSynchronize::begin();</span><br><span class="line">         // 开始任务, op 是刚刚传入的 VM_G1IncCollectionPause 操作任务类</span><br><span class="line">         // evaluate() 方法最后会调用 gc 操作任务类的 doit() 方法</span><br><span class="line">         op-&gt;evaluate();</span><br><span class="line">         // 安全点结束</span><br><span class="line">         SafepointSynchronize::end();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         // 是安全点则直接执行</span><br><span class="line">         op-&gt;evaluate();</span><br><span class="line">       &#125;</span><br><span class="line">                                                   </span><br><span class="line">       if (op-&gt;is_cheap_allocated()) delete op;</span><br><span class="line">                                                   </span><br><span class="line">       _cur_vm_operation = prev_vm_operation;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>该方法会判断线程是否都进入安全区（安全区概念参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/371699670%EF%BC%8C%E8%AF%A5%E9%97%AE%E9%A2%98%E9%AB%98%E8%B5%9E%E5%9B%9E%E7%AD%94%E6%AF%94%E8%BE%83%E5%85%A8%E9%9D%A2%E7%9A%84%E9%98%90%E8%BF%B0%E4%BA%86%E5%AE%89%E5%85%A8%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%8C%BA%E5%8F%97%E7%94%A8%E7%9A%84%EF%BC%89%EF%BC%8C%E5%A6%82%E6%98%AF%EF%BC%8C%E6%89%A7%E8%A1%8C">https://www.zhihu.com/question/371699670，该问题高赞回答比较全面的阐述了安全区的概念，挺受用的），如是，执行</a> op-&gt;evaluate() 以 stw。实际上，<strong>SafepointSynchronize::begin() 方法内包括了准备进入安全点到所有 java 线程 Block 的过程，此时 Young</strong> <strong>GC</strong> <strong>的全局停顿开始了</strong>。因此，Young GC 是 stw 的。</p>
</li>
<li><p>Mixed GC 和 Full GC 由于涉及到老年代内存对象的回收，需要根节点枚举、对象复制整理等操作，显然是 stw 的，此处不再从源码角度赘述。</p>
</li>
</ol>
</li>
</ol>
<ul>
<li>Reference：<ul>
<li><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/abs/10.1145/1029873.1029879">Garbage-first garbage collection | Proceedings of the 4th international symposium on Memory manageme</a></li>
<li>深入理解 Java 虚拟机（第三版）</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/114293273">JVM源码分析之G1垃圾收集器分析一</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/528819545">细节炸裂！阿里大佬深入探究G1源码之YoungGC技术</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a860MHz/article/details/97799282">JVM G1 源码分析(五)- 新生代回收YGC_g1 新生代_860MHz的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a860MHz/article/details/98062558">JVM G1 源码分析(六)- 混合式GC_g1 混合gc_860MHz的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a860MHz/article/details/98494732">JVM G1 源码分析(七)- Full GC_jvm g1 full gc 触发参数_860MHz的博客-CSDN博客CSDN博客</a></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>Young GC：选定所有年轻代里的 Region。通过控制年轻代的 region 个数，即年轻代内存大小，来控制 young GC的时间开销。</li>
<li>Mixed GC：选定所有年轻代里的 Region，外加根据 global concurrent marking 统计得出收集收益高的若干老年代 Region。在用户指定的开销目标范围内尽可能选择收益高的老年代 Region。</li>
</ul>
<p>由上面的描述可知，Mixed GC 不是 full GC，它只能回收部分老年代的 Region，如果 mixed GC 实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行 Mixed GC，就会使用 serial old GC（full GC）来收集整个 GC heap。所以我们可以知道，<strong>G1 是不提供 full GC 的</strong>。</p>
<p>此外，Young GC 和 Mixed GC 都是基于「标记-复制算法」的</p>
<p>上文中，多次提到了<strong>「global</strong> <strong>concurrent</strong> <strong>marking」</strong>，它的执行过程类似 CMS，但是不同的是，在 G1 GC 中，它主要是为 Mixed GC 提供标记服务的，并不是一次 GC 过程的一个必须环节。global concurrent marking 的执行过程分为四个步骤：</p>
<ol>
<li><strong>初始标记（initial mark，STW）</strong>。它标记了从 GC Root 开始直接可达的对象。</li>
<li><strong>并发标记（Concurrent Marking）</strong>。这个阶段从 GC Root 开始对 heap 中的对象标记，标记线程与应用程序线程并行执行，并且收集各个 Region 的存活对象信息。 </li>
<li><strong>重新标记（Remark，STW）</strong>。标记那些在并发标记阶段发生变化的对象，将被回收。</li>
<li><strong>清除垃圾（Cleanup）</strong>。清除空 Region（没有存活对象的），加入到 free list。</li>
</ol>
<p>第一阶段 initial mark 是共用了 Young GC 的暂停，这是因为他们可以复用 root scan 操作，所以可以说 global concurrent marking 是伴随 Young GC 而发生的。第四阶段 Cleanup 只是回收了没有存活对象的 Region，所以它并不需要 STW。</p>
<p>那什么时候发生 Mixed GC 呢？其实是由一些参数控制着的，另外也控制着哪些老年代 Region 会被选入 Collection Set（<em>Collection Set（CSet），记录了 GC 要收集的 Region 集合，集合里的 Region 可以是任意年代的</em>）。</p>
<ul>
<li>G1HeapWastePercent：在 global concurrent marking 结束之后，我们可以知道 old gen regions 中有多少空间要被回收，在每次 YGC 之后和再次发生 Mixed GC 之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生Mixed GC。</li>
<li>G1MixedGCLiveThresholdPercent：old generation region 中的存活对象的占比，只有在此参数之下，才会被选入CSet。</li>
<li>G1MixedGCCountTarget：一次 global concurrent marking 之后，最多执行 Mixed GC 的次数。</li>
<li>G1OldCSetRegionThresholdPercent：一次 Mixed GC 中能被选入 CSet 的最多 old generation region 数量。</li>
</ul>
<blockquote>
<p>由于篇幅限制，这里就只整理了对理解 G1 比较重要的 region 概念以及 GC 模式。其实 G1 还有其它的专有算法以及数据结构，比如停顿预测、Remember Set、SATB 等，感兴趣的读者可以自行搜索。</p>
</blockquote>
<h3 id="10-3-ZGC-基于非代际内存的最新回收器"><a href="#10-3-ZGC-基于非代际内存的最新回收器" class="headerlink" title="10.3. ZGC - 基于非代际内存的最新回收器"></a>10.3. ZGC - 基于非代际内存的最新回收器</h3><p>ZGC（The Z Garbage Collector）是 JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：</p>
<ul>
<li>停顿时间不超过10ms；</li>
<li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</li>
<li>支持 8MB~4TB 级别的堆（未来支持 16TB）</li>
</ul>
<h4 id="10-3-1-内存模型"><a href="#10-3-1-内存模型" class="headerlink" title="10.3.1. 内存模型"></a>10.3.1. 内存模型</h4><p>ZGC 与传统的 CMS、G1 不同、它没有分代的概念，只有类似 G1 的 Region 概念，ZGC 的 Region 可以具有如下图所示的大中下三类容量：</p>
<ul>
<li>小型 Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。</li>
<li>中型 Region（Medium Region）：容量固定为32MB，用于放置大于256KB但是小于4MB的对象。</li>
<li>大型 Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型 Region 中会存放一个大对象，这也预示着虽然名字叫“大型 Region”，但它的实际容量完全有可能小于中型 Region，最小容量可低至4MB。大型 Region 在 ZGC 的实现中是不会被重分配的（重分配是ZGC的一种处理动作，用于复制对象的收集器阶段）因为复制大对象的代价非常高。</li>
</ul>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175430186.png" alt="image-20231115175430186"></p>
<p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用「标记-复制」算法，不过 ZGC 对该算法做了重大改进：ZGC 在标记、转移和重定位阶段几乎都是并发的，这是 ZGC 实现停顿时间小于10ms目标的最关键原因。</p>
<p>ZGC 垃圾回收周期如下图所示：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175414710.png" alt="image-20231115175414710"></p>
<p>ZGC只有三个STW阶段：<strong>初始标记</strong>，<strong>再标记</strong>，<strong>初始转移</strong>。其中，初始标记和初始转移分别都只需要扫描所有 GC Roots，其处理时间和 GC Roots 的数量成正比，一般情况耗时非常短；再标记阶段 STW 时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC 几乎所有暂停都只依赖于 GC Roots 集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与 ZGC 对比，G1 的转移阶段完全 STW 的，且停顿时间随存活对象的大小增加而增加。</p>
<p>Java 实测打印 ZGC 的内存池结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CodeHeap <span class="string">&#x27;non-nmethods&#x27;</span></span><br><span class="line">Metaspace</span><br><span class="line">ZHeap</span><br><span class="line">CodeHeap <span class="string">&#x27;profiled nmethods&#x27;</span></span><br><span class="line">Compressed Class Space</span><br><span class="line">CodeHeap <span class="string">&#x27;non-profiled nmethods&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="10-3-2-关键技术"><a href="#10-3-2-关键技术" class="headerlink" title="10.3.2. 关键技术"></a>10.3.2. 关键技术</h4><p>ZGC 通过<strong>着色指针</strong>和<strong>读屏障技术</strong>，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着 GC 线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在 ZGC 中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM 是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。</p>
<p><strong>着色指针</strong></p>
<blockquote>
<p>着色指针是一种将信息存储在指针中的技术。</p>
</blockquote>
<p>ZGC仅支持64位系统，它把64位虚拟地址空间划分为多个子空间，如下图所示：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175350372.png" alt="image-20231115175350372"></p>
<p>其中，[0~4TB) 对应Java堆，[4TB ~ 8TB) 称为 M0 地址空间，[8TB ~ 12TB) 称为 M1 地址空间，[12TB ~ 16TB) 预留未使用，[16TB ~ 20TB) 称为 Remapped 空间。</p>
<p>当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址。ZGC 同时会为该对象在 M0、M1 和 Remapped 地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但<strong>这三个空间在同一时间有且只有一个空间有效</strong>。ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低 GC 停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。后面将详细介绍这三个空间的切换过程。</p>
<p>与上述地址空间划分相对应，ZGC 实际仅使用64位地址空间的第0<del>41位，而第42</del>45位存储元数据，第47~63位固定为0。</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175338597.png" alt="image-20231115175338597"></p>
<p>ZGC将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。</p>
<p><strong>读屏障</strong></p>
<blockquote>
<p>读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。</p>
</blockquote>
<p>读屏障示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> obj.FieldA   <span class="comment">// 从堆中读取引用，需要加入屏障</span></span><br><span class="line">&lt;Load barrier&gt;</span><br><span class="line"><span class="type">Object</span> <span class="variable">p</span> <span class="operator">=</span> o  <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line">o.dosomething() <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br></pre></td></tr></table></figure>

<p>ZGC 中读屏障的代码作用：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。</p>
<p>接下来详细介绍ZGC一次垃圾回收周期中地址视图的切换过程：</p>
<ul>
<li><strong>初始化</strong>：ZGC初始化之后，整个内存空间的地址视图被设置为 Remapped。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。</li>
<li><strong>并发标记阶段</strong>：第一次进入标记阶段时视图为 M0，如果对象被 GC 标记线程或者应用线程访问过，那么就将对象的地址视图从 Remapped 调整为 M0。所以，在标记阶段结束之后，对象的地址要么是 M0视图，要么是 Remapped。如果对象的地址是 M0 视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。</li>
<li><strong>并发转移阶段</strong>：标记结束后就进入转移阶段，此时地址视图再次被设置为 Remapped。如果对象被 GC转移线程或者应用线程访问过，那么就将对象的地址视图从 M0 调整为 Remapped。</li>
</ul>
<p>其实，在标记阶段存在两个地址视图 M0 和 M1，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了区别前一次标记和当前标记。也即，第二次进入并发标记阶段后，地址视图调整为 M1，而非M0。</p>
<p>着色指针和读屏障技术不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中；而在 ZGC 中，只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快。</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175323045.png" alt="image-20231115175323045"></p>
<h3 id="10-4-其他分享"><a href="#10-4-其他分享" class="headerlink" title="10.4. 其他分享"></a>10.4. 其他分享</h3><h4 id="10-4-1-如何调试-GC-的-notification-线程？"><a href="#10-4-1-如何调试-GC-的-notification-线程？" class="headerlink" title="10.4.1. 如何调试 GC 的 notification 线程？"></a>10.4.1. 如何调试 GC 的 notification 线程？</h4><p>JDK 8、11 的 notification 是 Service Thread 在做，这个 Thread 不能被 idea 捕获，无法正常调试；</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175301099.png" alt="image-20231115175301099"></p>
<p>解决：JDK 17 里 notification 的 handle 由 Notification Thread 负责，可以被 idea 捕获，把 JDK 换成 17 之后就可以切换到 Notification Thread 调试 handleNotification </p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175243105.png" alt="image-20231115175243105"></p>
<h4 id="10-4-2-GC-使用参数"><a href="#10-4-2-GC-使用参数" class="headerlink" title="10.4.2. GC 使用参数"></a>10.4.2. GC 使用参数</h4><table>
<thead>
<tr>
<th>Collector</th>
<th>Option</th>
</tr>
</thead>
<tbody><tr>
<td>指定年轻代为Serial收集器</td>
<td>-XX:+UseSerialGC</td>
</tr>
<tr>
<td>指定老年代为Serial收集器</td>
<td>‐XX:+UseSerialOldGC</td>
</tr>
<tr>
<td>指定年轻代为ParNew收集器</td>
<td>‐XX:+UseParNewGC</td>
</tr>
<tr>
<td>指定年轻代为 Parallel 收集器</td>
<td>‐XX:+UseParallelGC</td>
</tr>
<tr>
<td>指定老年代为 Parallel 收集器</td>
<td>‐XX:+UseParallelOldGC</td>
</tr>
<tr>
<td>指定老年代为 CMS 收集器</td>
<td>‐XX:+UseConcMarkSweepGC</td>
</tr>
<tr>
<td>G1</td>
<td>‐XX:+UseG1GC</td>
</tr>
<tr>
<td>ZGC</td>
<td>-XX:+UseZGC</td>
</tr>
</tbody></table>
<p>IDEA 使用：在 VM options 添加即可</p>
<div align="center"><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175206555.png" alt="image-20231115175206555" style="zoom:60%;" /></div>

<h4 id="10-4-3-JMX-可以监控-G1-的-mixed-GC-吗？"><a href="#10-4-3-JMX-可以监控-G1-的-mixed-GC-吗？" class="headerlink" title="10.4.3. JMX 可以监控 G1 的 mixed GC 吗？"></a>10.4.3. JMX 可以监控 G1 的 mixed GC 吗？</h4><p>不能。实验过程如下：</p>
<p><strong>可以看到，对于同一次 GC，JVM自带的 GC log 显示是 mixed GC，但 JMX 显示为 minor GC。</strong></p>
<ul>
<li>猜测：由于 mixed GC 在 hotspot 源码中是由 YGC 触发，所以 JMX 为了简化将 YGC 和 mixed GC 统一视为 minor GC。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[GC pause (G1 Evacuation Pause) (mixed), <span class="number">0.0237647</span> secs]</span><br><span class="line">   [Parallel <span class="type">Time</span>: <span class="number">22.2</span> ms, GC Workers: <span class="number">9</span>]</span><br><span class="line">      [GC Worker <span class="keyword">Start</span> (ms): Min: <span class="number">10897.2</span>, Avg: <span class="number">10899.3</span>, Max: <span class="number">10900.4</span>, Diff: <span class="number">3.3</span>]</span><br><span class="line">      [Ext Root Scanning (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.1</span>, Max: <span class="number">0.4</span>, Diff: <span class="number">0.3</span>, Sum: <span class="number">0.7</span>]</span><br><span class="line">      [<span class="keyword">Update</span> RS (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">1.1</span>, Max: <span class="number">4.3</span>, Diff: <span class="number">4.3</span>, Sum: <span class="number">9.8</span>]</span><br><span class="line">         [Processed Buffers: Min: <span class="number">0</span>, Avg: <span class="number">1.6</span>, Max: <span class="number">6</span>, Diff: <span class="number">6</span>, Sum: <span class="number">14</span>]</span><br><span class="line">      [Scan RS (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>, Sum: <span class="number">0.1</span>]</span><br><span class="line">      [Code Root Scanning (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>, Sum: <span class="number">0.0</span>]</span><br><span class="line">      [Object <span class="keyword">Copy</span> (ms): Min: <span class="number">7.4</span>, Avg: <span class="number">8.6</span>, Max: <span class="number">8.8</span>, Diff: <span class="number">1.4</span>, Sum: <span class="number">77.2</span>]</span><br><span class="line">      [Termination (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">1.3</span>, Max: <span class="number">10.3</span>, Diff: <span class="number">10.3</span>, Sum: <span class="number">11.8</span>]</span><br><span class="line">         [Termination Attempts: Min: <span class="number">1</span>, Avg: <span class="number">397.3</span>, Max: <span class="number">588</span>, Diff: <span class="number">587</span>, Sum: <span class="number">3576</span>]</span><br><span class="line">      [GC Worker Other (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>, Sum: <span class="number">0.1</span>]</span><br><span class="line">      [GC Worker Total (ms): Min: <span class="number">8.9</span>, Avg: <span class="number">11.1</span>, Max: <span class="number">19.0</span>, Diff: <span class="number">10.2</span>, Sum: <span class="number">99.7</span>]</span><br><span class="line">      [GC Worker <span class="keyword">End</span> (ms): Min: <span class="number">10909.3</span>, Avg: <span class="number">10910.4</span>, Max: <span class="number">10919.3</span>, Diff: <span class="number">10.0</span>]</span><br><span class="line">   [Code Root Fixup: <span class="number">0.0</span> ms]</span><br><span class="line">   [Code Root Purge: <span class="number">0.0</span> ms]</span><br><span class="line">   [Clear CT: <span class="number">0.1</span> ms]</span><br><span class="line">   [Other: <span class="number">1.5</span> ms]</span><br><span class="line">      [Choose CSet: <span class="number">0.0</span> ms]</span><br><span class="line">      [<span class="keyword">Ref</span> Proc: <span class="number">1.2</span> ms]</span><br><span class="line">      [<span class="keyword">Ref</span> Enq: <span class="number">0.0</span> ms]</span><br><span class="line">      [Redirty Cards: <span class="number">0.1</span> ms]</span><br><span class="line">      [Humongous Register: <span class="number">0.1</span> ms]</span><br><span class="line">      [Humongous Reclaim: <span class="number">0.0</span> ms]</span><br><span class="line">      [<span class="keyword">Free</span> CSet: <span class="number">0.0</span> ms]</span><br><span class="line">   [Eden: <span class="number">46080.0</span>K(<span class="number">46080.0</span>K)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">0.0</span>B(<span class="number">48128.0</span>K) Survivors: <span class="number">7168.0</span>K<span class="operator">-</span><span class="operator">&gt;</span><span class="number">7168.0</span>K Heap: <span class="number">1043.1</span>M(<span class="number">1049.0</span>M)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">1044.6</span>M(<span class="number">1098.0</span>M)]</span><br><span class="line"> [Times: <span class="keyword">user</span><span class="operator">=</span><span class="number">0.05</span> sys<span class="operator">=</span><span class="number">0.01</span>, <span class="type">real</span><span class="operator">=</span><span class="number">0.02</span> secs] </span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.446</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> <span class="keyword">end</span> <span class="keyword">of</span> minor GC</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> minor GC: <span class="operator">-</span> <span class="number">45</span> (G1_Evacuation_Pause) <span class="keyword">start</span>: <span class="number">2023</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">58</span>:<span class="number">54.422</span>, <span class="keyword">end</span>: <span class="number">2023</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">58</span>:<span class="number">54.445</span></span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [G1 <span class="keyword">Old</span> Gen] init:<span class="number">235520</span>K; used:<span class="number">24.1</span><span class="operator">%</span>(<span class="number">1014924</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">25.3</span><span class="operator">%</span>(<span class="number">1062540</span>K); committed: <span class="number">24.2</span><span class="operator">%</span>(<span class="number">1017856</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">25.4</span><span class="operator">%</span>(<span class="number">1065984</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [Code Cache] init:<span class="number">2496</span>K; used:<span class="number">1.9</span><span class="operator">%</span>(<span class="number">2586</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1.9</span><span class="operator">%</span>(<span class="number">2586</span>K); committed: <span class="number">2.0</span><span class="operator">%</span>(<span class="number">2624</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">2.0</span><span class="operator">%</span>(<span class="number">2624</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [G1 Survivor Space] init:<span class="number">0</span>K; used:<span class="number">7168</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">7168</span>K); committed: <span class="number">7168</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">7168</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [Compressed Class Space] init:<span class="number">0</span>K; used:<span class="number">0.0</span><span class="operator">%</span>(<span class="number">777</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0.0</span><span class="operator">%</span>(<span class="number">777</span>K); committed: <span class="number">0.0</span><span class="operator">%</span>(<span class="number">896</span>K) <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0.0</span><span class="operator">%</span>(<span class="number">896</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [Metaspace] init:<span class="number">0</span>K; used:<span class="number">6965</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">6965</span>K); committed: <span class="number">7296</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">7296</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span>         [G1 Eden Space] init:<span class="number">26624</span>K; used:<span class="number">46080</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span>K); committed: <span class="number">49152</span>K <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">51200</span>K)</span><br><span class="line"><span class="number">17</span>:<span class="number">58</span>:<span class="number">54.447</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> duration:<span class="number">23</span>ms, throughput:<span class="number">96.4</span><span class="operator">%</span></span><br></pre></td></tr></table></figure>

<p><strong>测试参数：</strong></p>
<p>这里有一个 trick：由于 G1 的特点，我们希望能平缓的增加内存，使得 G1 「来得及」进行垃圾回收，触发 mixed GC，而不是触发 full GC。因此需要对 JVM 进行调参，同时测试代码中需要延缓内存消耗速度。</p>
<blockquote>
<p>-XX:+PrintGCDetails -XX:+UseG1GC -XX:InitiatingHeapOccupancyPercent&#x3D;20 &#x2F;&#x2F; 默认值为 40，是触发 mixed GC 的堆内存占用 threshold，这里调低一点，防止 full GC -XX:G1HeapWastePercent&#x3D;5 &#x2F;&#x2F; 当整个堆可回收的百分比小于该阈值时，Java HotSpot VM不会启动Mixed GC。默认值为10％。这里同理，调低一点防止 full GC</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">          <span class="comment">// manually add heap usage</span></span><br><span class="line">          List&lt;<span class="type">byte</span>[]&gt; byteList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">          <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">10000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 为了尽量少的触发 Full GC 而触发 mixed GC，需要减缓内存消耗速度</span></span><br><span class="line">                Thread.sleep(TimeUnit.MILLISECONDS.toMillis(<span class="number">100</span>));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            byteList.add(bytes);</span><br><span class="line">            i++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    .start();</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="10-4-4-Duration-的计算准确性"><a href="#10-4-4-Duration-的计算准确性" class="headerlink" title="10.4.4. Duration 的计算准确性"></a>10.4.4. Duration 的计算准确性</h4><p>这里贴一个详细的例子来说明：涉及并发 GC 时，JMX notification 提供的 duration 比实际 duration 大。</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175146661.png" alt="image-20231115175146661"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[GC pause (G1 Evacuation Pause) (mixed), <span class="number">0.0162640</span> secs]</span><br><span class="line">   [Parallel <span class="type">Time</span>: <span class="number">15.6</span> ms, GC Workers: <span class="number">9</span>]</span><br><span class="line">      [GC Worker <span class="keyword">Start</span> (ms): Min: <span class="number">9212.1</span>, Avg: <span class="number">9214.5</span>, Max: <span class="number">9215.2</span>, Diff: <span class="number">3.1</span>]</span><br><span class="line">      [Ext Root Scanning (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.1</span>, Max: <span class="number">0.6</span>, Diff: <span class="number">0.6</span>, Sum: <span class="number">0.6</span>]</span><br><span class="line">      [<span class="keyword">Update</span> RS (ms): Min: <span class="number">0.9</span>, Avg: <span class="number">2.0</span>, Max: <span class="number">3.2</span>, Diff: <span class="number">2.2</span>, Sum: <span class="number">18.0</span>]</span><br><span class="line">         [Processed Buffers: Min: <span class="number">1</span>, Avg: <span class="number">2.1</span>, Max: <span class="number">4</span>, Diff: <span class="number">3</span>, Sum: <span class="number">19</span>]</span><br><span class="line">      [Scan RS (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.1</span>, Max: <span class="number">0.3</span>, Diff: <span class="number">0.3</span>, Sum: <span class="number">1.1</span>]</span><br><span class="line">      [Code Root Scanning (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>, Sum: <span class="number">0.0</span>]</span><br><span class="line">      [Object <span class="keyword">Copy</span> (ms): Min: <span class="number">9.3</span>, Avg: <span class="number">10.2</span>, Max: <span class="number">10.7</span>, Diff: <span class="number">1.4</span>, Sum: <span class="number">92.0</span>]</span><br><span class="line">      [Termination (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.4</span>, Max: <span class="number">0.5</span>, Diff: <span class="number">0.5</span>, Sum: <span class="number">3.3</span>]</span><br><span class="line">         [Termination Attempts: Min: <span class="number">1</span>, Avg: <span class="number">449.8</span>, Max: <span class="number">606</span>, Diff: <span class="number">605</span>, Sum: <span class="number">4048</span>]</span><br><span class="line">      [GC Worker Other (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.1</span>, Diff: <span class="number">0.1</span>, Sum: <span class="number">0.4</span>]</span><br><span class="line">      [GC Worker Total (ms): Min: <span class="number">12.2</span>, Avg: <span class="number">12.8</span>, Max: <span class="number">15.2</span>, Diff: <span class="number">3.1</span>, Sum: <span class="number">115.4</span>]</span><br><span class="line">      [GC Worker <span class="keyword">End</span> (ms): Min: <span class="number">9227.3</span>, Avg: <span class="number">9227.3</span>, Max: <span class="number">9227.4</span>, Diff: <span class="number">0.1</span>]</span><br><span class="line">   [Code Root Fixup: <span class="number">0.0</span> ms]</span><br><span class="line">   [Code Root Purge: <span class="number">0.0</span> ms]</span><br><span class="line">   [Clear CT: <span class="number">0.1</span> ms]</span><br><span class="line">   [Other: <span class="number">0.5</span> ms]</span><br><span class="line">      [Choose CSet: <span class="number">0.0</span> ms]</span><br><span class="line">      [<span class="keyword">Ref</span> Proc: <span class="number">0.2</span> ms]</span><br><span class="line">      [<span class="keyword">Ref</span> Enq: <span class="number">0.0</span> ms]</span><br><span class="line">      [Redirty Cards: <span class="number">0.1</span> ms]</span><br><span class="line">      [Humongous Register: <span class="number">0.1</span> ms]</span><br><span class="line">      [Humongous Reclaim: <span class="number">0.0</span> ms]</span><br><span class="line">      [<span class="keyword">Free</span> CSet: <span class="number">0.0</span> ms]</span><br><span class="line">   [Eden: <span class="number">38912.0</span>K(<span class="number">38912.0</span>K)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">0.0</span>B(<span class="number">40960.0</span>K) Survivors: <span class="number">6144.0</span>K<span class="operator">-</span><span class="operator">&gt;</span><span class="number">6144.0</span>K Heap: <span class="number">880.2</span>M(<span class="number">886.0</span>M)<span class="operator">-</span><span class="operator">&gt;</span><span class="number">882.2</span>M(<span class="number">928.0</span>M)]</span><br><span class="line"> [Times: <span class="keyword">user</span><span class="operator">=</span><span class="number">0.08</span> sys<span class="operator">=</span><span class="number">0.02</span>, <span class="type">real</span><span class="operator">=</span><span class="number">0.02</span> secs] </span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">58.092</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> <span class="keyword">end</span> <span class="keyword">of</span> minor GC</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">58.092</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> minor GC: <span class="operator">-</span> <span class="number">41</span> (G1_Evacuation_Pause) <span class="keyword">start</span>: <span class="number">2023</span><span class="number">-07</span><span class="number">-26</span> <span class="number">10</span>:<span class="number">48</span>:<span class="number">58.074</span>, <span class="keyword">end</span>: <span class="number">2023</span><span class="number">-07</span><span class="number">-26</span> <span class="number">10</span>:<span class="number">48</span>:<span class="number">58.091</span></span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">58.092</span> [Service Thread] INFO org.apache.iotdb.metrics.jvm.GCListenerTest <span class="operator">-</span> duration:<span class="number">17</span>ms, throughput:<span class="number">96.4</span><span class="operator">%</span></span><br></pre></td></tr></table></figure>

<p>可以看到：这里发生了 mixed GC，有部分 old genertaion 内存被回收。由于 old generation 的回收有一部分 phase 和用户线程并发，这里 JMX notification 提供的 duration 17ms 大于实际的 duration（GC log 打印）16.2ms。</p>
<blockquote>
<p>实测这里的误差比较小，在 Millisecond 的粒度，很多时候看不出来误差。然而误差仍然是存在的。</p>
</blockquote>
<p>当涉及并发 GC（某些阶段可以和用户线程并发执行，如 G1 old generation）的 duration 时，JMX notification 提供的 duration 实际上比准确的 duration 要大。因此此时需要换一种计算方式：主动向 gcBean 获取总回收时间，通过作差算出现在所需的运算时间。</p>
<h5 id="10-4-4-1-源码说明"><a href="#10-4-4-1-源码说明" class="headerlink" title="10.4.4.1. 源码说明"></a>10.4.4.1. 源码说明</h5><p><strong>结论</strong>：</p>
<ul>
<li>JMX 提供了两种得到 GC duration 的 api，一种是 notification 的 gcInfo，一种是向 GarbageCollectorMXBean 拉取累计 GC 时间，作差算出 duration。前者在涉及并发 GC 的时候 duration 有点不准确。</li>
<li>GarbageCollectorMXBean 的 getCollectionTime() 方法计算的是 GC pause 的时间，如果 GC 包含与用户线程并发的部分，不会被计算入 getCollectionTime() 中。因此这种方法算出来的 GC duration 是准确的 stw 时间。</li>
</ul>
<p>接下来看看为什么 GarbageCollectorMXBean 的 getCollectionTime() 方法获取的是准确的 stw 时间。</p>
<p>首先来看看 java 上该方法的签名：</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175127154.png" alt="image-20231115175127154"></p>
<p>深入 getCollectionTime()，发现是 native 方法</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175112530.png" alt="image-20231115175112530"></p>
<p>查看 openjdk 源码，native 方法签名如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jlong JNICALL <span class="title">Java_sun_management_GarbageCollectorImpl_getCollectionTime</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *env, jobject mgr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jmm_interface-&gt;<span class="built_in">GetLongAttribute</span>(env, mgr, JMM_GC_TIME_MS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是返回 JMM_GC_TIME_MS 变量，继续追踪，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">get_gc_attribute</span><span class="params">(GCMemoryManager* mgr, jmmLongAttribute att)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (att) &#123;</span><br><span class="line">  <span class="keyword">case</span> JMM_GC_TIME_MS:</span><br><span class="line">    <span class="keyword">return</span> mgr-&gt;<span class="built_in">gc_time_ms</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> JMM_GC_COUNT:</span><br><span class="line">    <span class="keyword">return</span> mgr-&gt;<span class="built_in">gc_count</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> JMM_GC_EXT_ATTRIBUTE_INFO_SIZE:</span><br><span class="line">    <span class="comment">// current implementation only has 1 ext attribute</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">0</span>, <span class="string">&quot;Unrecognized GC attribute&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该变量通过 mgr-&gt;gc_time_ms() 获取，mgr 是 GCMemoryManager，这个类的签名如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GCMemoryManager</span> : <span class="keyword">public</span> MemoryManager &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> We should unify the GCCounter and GCMemoryManager statistic</span></span><br><span class="line">  <span class="type">size_t</span>       _num_collections;</span><br><span class="line">  elapsedTimer _accumulated_timer;</span><br><span class="line">  GCStatInfo*  _last_gc_stat;</span><br><span class="line">  Mutex*       _last_gc_lock;</span><br><span class="line">  GCStatInfo*  _current_gc_stat;</span><br><span class="line">  <span class="type">int</span>          _num_gc_threads;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">bool</span> _notification_enabled;</span><br><span class="line">  <span class="type">bool</span>         _pool_always_affected_by_gc[MemoryManager::max_num_pools];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">GCMemoryManager</span>(<span class="type">const</span> <span class="type">char</span>* name);</span><br><span class="line">  ~<span class="built_in">GCMemoryManager</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_pool</span><span class="params">(MemoryPool* pool)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_pool</span><span class="params">(MemoryPool* pool, <span class="type">bool</span> always_affected_by_gc)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">pool_always_affected_by_gc</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">num_memory_pools</span>(), <span class="string">&quot;Invalid index&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> _pool_always_affected_by_gc[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span>   <span class="title">initialize_gc_stat_info</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span>   <span class="title">is_gc_memory_manager</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="function">jlong  <span class="title">gc_time_ms</span><span class="params">()</span>                   </span>&#123; <span class="keyword">return</span> _accumulated_timer.<span class="built_in">milliseconds</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">gc_count</span><span class="params">()</span>                     </span>&#123; <span class="keyword">return</span> _num_collections; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span>    <span class="title">num_gc_threads</span><span class="params">()</span>               </span>&#123; <span class="keyword">return</span> _num_gc_threads; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span>   <span class="title">set_num_gc_threads</span><span class="params">(<span class="type">int</span> count)</span>  </span>&#123; _num_gc_threads = count; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span>   <span class="title">gc_begin</span><span class="params">(<span class="type">bool</span> recordGCBeginTime, <span class="type">bool</span> recordPreGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">bool</span> recordAccumulatedGCTime)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span>   <span class="title">gc_end</span><span class="params">(<span class="type">bool</span> recordPostGCUsage, <span class="type">bool</span> recordAccumulatedGCTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">bool</span> recordGCEndTime, <span class="type">bool</span> countCollection, GCCause::Cause cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">bool</span> allMemoryPoolsAffected, <span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span>        <span class="title">reset_gc_stat</span><span class="params">()</span>   </span>&#123; _num_collections = <span class="number">0</span>; _accumulated_timer.<span class="built_in">reset</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy out _last_gc_stat to the given destination, returning</span></span><br><span class="line">  <span class="comment">// the collection count. Zero signifies no gc has taken place.</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">get_last_gc_stat</span><span class="params">(GCStatInfo* dest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_notification_enabled</span><span class="params">(<span class="type">bool</span> enabled)</span> </span>&#123; _notification_enabled = enabled; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_notification_enabled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _notification_enabled; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以发现，最终 gc_time 是 _accumulated_timer 来记录的。这个 timer 是通过记录 start 和 end 时间，将 end 和 start 时间作差进行计时的。</p>
<p>那 start 和 end 时间是在哪里记录的呢？继续跟进发现在 gc_begin() 和 gc_end() 方法里。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GCMemoryManager::gc_begin</span><span class="params">(<span class="type">bool</span> recordGCBeginTime, <span class="type">bool</span> recordPreGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">bool</span> recordAccumulatedGCTime)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(_last_gc_stat != <span class="literal">nullptr</span> &amp;&amp; _current_gc_stat != <span class="literal">nullptr</span>, <span class="string">&quot;Just checking&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (recordAccumulatedGCTime) &#123;</span><br><span class="line">    _accumulated_timer.<span class="built_in">start</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// _num_collections now increases in gc_end, to count completed collections</span></span><br><span class="line">  <span class="keyword">if</span> (recordGCBeginTime) &#123;</span><br><span class="line">    _current_gc_stat-&gt;<span class="built_in">set_index</span>(_num_collections+<span class="number">1</span>);</span><br><span class="line">    _current_gc_stat-&gt;<span class="built_in">set_start_time</span>(Management::<span class="built_in">timestamp</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GCMemoryManager::gc_end</span><span class="params">(<span class="type">bool</span> recordPostGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> recordAccumulatedGCTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> recordGCEndTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> countCollection,</span></span></span><br><span class="line"><span class="params"><span class="function">                             GCCause::Cause cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> allMemoryPoolsAffected,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> <span class="type">char</span>* message)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (recordAccumulatedGCTime) &#123;</span><br><span class="line">    _accumulated_timer.<span class="built_in">stop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (recordGCEndTime) &#123;</span><br><span class="line">    _current_gc_stat-&gt;<span class="built_in">set_end_time</span>(Management::<span class="built_in">timestamp</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 gc_begin() 和 gc_end() 方法是何时调用呢？继续跟进，省去一些中间 wrapper，最终可以发现是在 TraceMemoryManagerStats 这个类里调用。该类签名如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TraceMemoryManagerStats::<span class="built_in">TraceMemoryManagerStats</span>(GCMemoryManager* gc_memory_manager,</span><br><span class="line">                                                 GCCause::Cause cause,</span><br><span class="line">                                                 <span class="type">const</span> <span class="type">char</span>* end_message,</span><br><span class="line">                                                 <span class="type">bool</span> allMemoryPoolsAffected,</span><br><span class="line">                                                 <span class="type">bool</span> recordGCBeginTime,</span><br><span class="line">                                                 <span class="type">bool</span> recordPreGCUsage,</span><br><span class="line">                                                 <span class="type">bool</span> recordPeakUsage,</span><br><span class="line">                                                 <span class="type">bool</span> recordPostGCUsage,</span><br><span class="line">                                                 <span class="type">bool</span> recordAccumulatedGCTime,</span><br><span class="line">                                                 <span class="type">bool</span> recordGCEndTime,</span><br><span class="line">                                                 <span class="type">bool</span> countCollection) &#123;</span><br><span class="line">  <span class="built_in">initialize</span>(gc_memory_manager, cause, end_message,</span><br><span class="line">             allMemoryPoolsAffected, recordGCBeginTime, recordPreGCUsage,</span><br><span class="line">             recordPeakUsage, recordPostGCUsage, recordAccumulatedGCTime,</span><br><span class="line">             recordGCEndTime, countCollection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for a subclass to create then initialize an instance before invoking</span></span><br><span class="line"><span class="comment">// the MemoryService</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraceMemoryManagerStats::initialize</span><span class="params">(GCMemoryManager* gc_memory_manager,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         GCCause::Cause cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> <span class="type">char</span>* end_message,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> allMemoryPoolsAffected,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordGCBeginTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordPreGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordPeakUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordPostGCUsage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordAccumulatedGCTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> recordGCEndTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> countCollection)</span> </span>&#123;</span><br><span class="line">  _gc_memory_manager = gc_memory_manager;</span><br><span class="line">  _cause = cause;</span><br><span class="line">  _end_message = end_message;</span><br><span class="line">  _allMemoryPoolsAffected = allMemoryPoolsAffected;</span><br><span class="line">  _recordGCBeginTime = recordGCBeginTime;</span><br><span class="line">  _recordPreGCUsage = recordPreGCUsage;</span><br><span class="line">  _recordPeakUsage = recordPeakUsage;</span><br><span class="line">  _recordPostGCUsage = recordPostGCUsage;</span><br><span class="line">  _recordAccumulatedGCTime = recordAccumulatedGCTime;</span><br><span class="line">  _recordGCEndTime = recordGCEndTime;</span><br><span class="line">  _countCollection = countCollection;</span><br><span class="line"></span><br><span class="line">  MemoryService::<span class="built_in">gc_begin</span>(_gc_memory_manager, _recordGCBeginTime, _recordAccumulatedGCTime,</span><br><span class="line">                          _recordPreGCUsage, _recordPeakUsage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TraceMemoryManagerStats::~<span class="built_in">TraceMemoryManagerStats</span>() &#123;</span><br><span class="line">  MemoryService::<span class="built_in">gc_end</span>(_gc_memory_manager, _recordPostGCUsage, _recordAccumulatedGCTime,</span><br><span class="line">                        _recordGCEndTime, _countCollection, _cause, _allMemoryPoolsAffected,</span><br><span class="line">                        _end_message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重点来了</strong>：TraceMemoryManagerStats 在初始化时调用 gc_begin() 来记录开始时间，在析构时调用 gc_end() 记录结束时间。也就是说，TraceMemoryManagerStats 的生命周期长度等于记录的 <strong>GC 时间。在 JVM 中，在需要记录 GC duration 的地方声明一个 TraceMemoryManagerStats 对象就可以达到记录时间的目的，如果某些 GC phases，如 G1 的并发标记阶段，不需要记录 GC duration，那么就不会声明 TraceMemoryManagerStats 对象。</strong></p>
<p>接下来追踪该对象在哪里被声明，哪里被析构。继续跟进，发现对于 G1，G1MonitoringScape 类 wrap 了 TraceMemoryManagerStats 对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Scope object for java.lang.management support.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">G1MonitoringScope</span> : <span class="keyword">public</span> StackObj &#123;</span><br><span class="line">  G1MonitoringSupport* _monitoring_support;</span><br><span class="line">  TraceCollectorStats _tcs;</span><br><span class="line">  TraceMemoryManagerStats _tms;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">G1MonitoringScope</span>(G1MonitoringSupport* monitoring_support,</span><br><span class="line">                    CollectorCounters* collection_counters,</span><br><span class="line">                    GCMemoryManager* gc_memory_manager,</span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span>* end_message,</span><br><span class="line">                    <span class="type">bool</span> all_memory_pools_affected = <span class="literal">true</span>);</span><br><span class="line">  ~<span class="built_in">G1MonitoringScope</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>继续跟进，发现 G1 有三个类记录了 G1MonitoringScope 对象。换句话来说，只要声明了这三个类，就等于声明了 TraceMemoryManagerStats 对象，而后者会随着初始化和析构记录 gc 时间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">G1YoungGCMonitoringScope::<span class="built_in">G1YoungGCMonitoringScope</span>(G1MonitoringSupport* monitoring_support,</span><br><span class="line">                                                   <span class="type">bool</span> all_memory_pools_affected) :</span><br><span class="line">  <span class="built_in">G1MonitoringScope</span>(monitoring_support,</span><br><span class="line">                    monitoring_support-&gt;_young_collection_counters,</span><br><span class="line">                    &amp;monitoring_support-&gt;_young_gc_memory_manager,</span><br><span class="line">                    <span class="string">&quot;end of minor GC&quot;</span>,</span><br><span class="line">                    all_memory_pools_affected) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">G1FullGCMonitoringScope::<span class="built_in">G1FullGCMonitoringScope</span>(G1MonitoringSupport* monitoring_support) :</span><br><span class="line">  <span class="built_in">G1MonitoringScope</span>(monitoring_support,</span><br><span class="line">                    monitoring_support-&gt;_full_collection_counters,</span><br><span class="line">                    &amp;monitoring_support-&gt;_full_gc_memory_manager,</span><br><span class="line">                    <span class="string">&quot;end of major GC&quot;</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">G1ConcGCMonitoringScope::<span class="built_in">G1ConcGCMonitoringScope</span>(G1MonitoringSupport* monitoring_support) :</span><br><span class="line">  <span class="built_in">G1MonitoringScope</span>(monitoring_support,</span><br><span class="line">                    monitoring_support-&gt;_conc_collection_counters,</span><br><span class="line">                    &amp;monitoring_support-&gt;_conc_gc_memory_manager,</span><br><span class="line">                    <span class="string">&quot;end of concurrent GC pause&quot;</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们重点关注一下 G1ConcGCMonitoringScope，顾名思义，该类主要用于 concurrent G1。继续跟进，发现<strong>只有</strong>在 VM_G1PauseConcurrent::doit() 该类被声明。也就是说，对于 concurrent G1，JVM 只统计了 VM_G1PauseConcurrent::doit() 的耗时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VM_G1PauseConcurrent::doit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">GCIdMark <span class="title">gc_id_mark</span><span class="params">(_gc_id)</span></span>;</span><br><span class="line">  G1CollectedHeap* g1h = G1CollectedHeap::<span class="built_in">heap</span>();</span><br><span class="line">  <span class="function">GCTraceCPUTime <span class="title">tcpu</span><span class="params">(g1h-&gt;concurrent_mark()-&gt;gc_tracer_cm())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GCTraceTime(...) only supports sub-phases, so a more verbose version</span></span><br><span class="line">  <span class="comment">// is needed when we report the top-level pause phase.</span></span><br><span class="line">  <span class="built_in">GCTraceTimeLogger</span>(Info, gc) <span class="built_in">logger</span>(_message, GCCause::_no_gc, <span class="literal">true</span>);</span><br><span class="line">  <span class="function">GCTraceTimePauseTimer       <span class="title">timer</span><span class="params">(_message, g1h-&gt;concurrent_mark()-&gt;gc_timer_cm())</span></span>;</span><br><span class="line">  <span class="function">GCTraceTimeDriver           <span class="title">t</span><span class="params">(&amp;logger, &amp;timer)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">G1ConcGCMonitoringScope <span class="title">monitoring_scope</span><span class="params">(g1h-&gt;monitoring_support())</span></span>;</span><br><span class="line">  <span class="function">SvcGCMarker <span class="title">sgcm</span><span class="params">(SvcGCMarker::CONCURRENT)</span></span>;</span><br><span class="line">  IsGCActiveMark x;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">work</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一下 VM_G1PauseConcurrent::doit() 干了什么。doit() 是 VM_G1PauseConcurrent 的入口方法，而 VM_G1PauseConcurrent 是 concurrent G1 stw 的 operations。这点源码也通过注释解释的很清楚了。</p>
<p><img src="https://peng-img.oss-cn-shanghai.aliyuncs.com/markdown-img/image-20231115175033983-20231115175047189.png"></p>
<p>综上，可以看出：JMX 对于 getCollectionTime() 方法只记录了 concurrent G1 的 stw 部分的耗时，因此 getCollectionTime() 的统计耗时是 accumulated stw GC time，更为精确。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《深入理解Java虚拟机（第3版）》 周志明 </p>
<p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/15/">https://openjdk.java.net/projects/jdk/15/</a></p>
<p><a target="_blank" rel="noopener" href="https://aijishu.com/a/1060000000083459">https://aijishu.com/a/1060000000083459</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/aef0f4765098">https://www.jianshu.com/p/aef0f4765098</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lbh_paopao/article/details/120269135">https://blog.csdn.net/lbh_paopao/article/details/120269135</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/546651403">https://zhuanlan.zhihu.com/p/546651403</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/431406707">https://zhuanlan.zhihu.com/p/431406707</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903970142421005">https://juejin.cn/post/6844903970142421005</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/19154607/how-actually-card-table-and-writer-barrier-work">https://stackoverflow.com/questions/19154607/how-actually-card-table-and-writer-barrier-work</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">https://tech.meituan.com/2020/11/12/java-9-cms-gc.html</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/09/23/g1.html">https://tech.meituan.com/2016/09/23/g1.html</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">https://tech.meituan.com/2020/11/12/java-9-cms-gc.html</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wisgood/article/details/79850093">https://blog.csdn.net/wisgood/article/details/79850093</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7095643412082196511#heading-7">https://juejin.cn/post/7095643412082196511#heading-7</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42596455/article/details/81228611">https://blog.csdn.net/weixin_42596455/article/details/81228611</a></p>

  </div>
  
    
      <a id="older" class="blog-nav" href="/article/Zero-Change/">OLDER&nbsp;&gt;</a>
      
        
          <a id="newer" class="blog-nav" href="/article/Metric-System/">&lt;&nbsp;NEWER</a>
          
            
</div>
        <div class="footer">
  
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/Pengzna">Copyright © Pengzna 2021-present</a>
        
    </div>
  
</div>

      </div>

      <div class="back-to-top hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



      
  <div class="search-icon" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-box">
        <div class="search-title">
          <!-- <span class="search-icon-input">
            <a href="javascript: void(0)">
              <i class="iconfont icon-search"></i>
            </a>
          </span> -->
          
            <input type="text" class="search-input" id="search-input" placeholder="搜索">
          
          <span class="search-close-icon" id="search-close-icon">
            <a href="javascript: void(0)">
              <i class="iconfont icon-close"></i>
            </a>
          </span>
        </div>
        <div class="search-result" id="search-result"></div>
      </div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    // inputArea.onclick = function() {
    //   getSearchFile()
    //   this.onclick = null
    // }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        inputArea.focus()
        getSearchFile()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'><span></ul>";
      // $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'><h2>" + orig_data_title + "</h2></a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<h3 class=\"search-result-abstract\">" + match_content + "...</h3>"
                }
                str += "<hr></li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/leedom92/hexo-theme-leedom#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </body>
</html>
